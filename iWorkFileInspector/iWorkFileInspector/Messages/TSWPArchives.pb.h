// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSWPArchives.proto

#ifndef PROTOBUF_TSWPArchives_2eproto__INCLUDED
#define PROTOBUF_TSWPArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSKArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TSWP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSWPArchives_2eproto();
void protobuf_AssignDesc_TSWPArchives_2eproto();
void protobuf_ShutdownFile_TSWPArchives_2eproto();

class SelectionArchive;
class ObjectAttributeTable;
class ObjectAttributeTable_ObjectAttribute;
class StringAttributeTable;
class StringAttributeTable_StringAttribute;
class ParaDataAttributeTable;
class ParaDataAttributeTable_ParaDataAttribute;
class SparseObjectAttributeTable;
class SparseObjectAttributeTable_SparseObjectAttribute;
class StorageArchive;
class HighlightArchive;
class FontFeatureArchive;
class CharacterStylePropertiesArchive;
class CharacterStyleArchive;
class TabArchive;
class TabsArchive;
class LineSpacingArchive;
class ParagraphStylePropertiesArchive;
class ParagraphStyleArchive;
class ListStyleArchive;
class ListStyleArchive_LabelGeometry;
class ListStyleArchive_LabelImage;
class TextStylePresetArchive;
class ColumnsArchive;
class ColumnsArchive_EqualColumnsArchive;
class ColumnsArchive_NonEqualColumnsArchive;
class ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive;
class PaddingArchive;
class ColumnStylePropertiesArchive;
class ColumnStyleArchive;
class ShapeStylePropertiesArchive;
class ShapeStyleArchive;
class ThemePresetsArchive;
class TextPresetDisplayItemArchive;
class TOCEntryStylePropertiesArchive;
class TOCEntryStyleArchive;
class TOCSettingsArchive;
class TOCSettingsArchive_TOCEntryData;
class TOCEntryInstanceArchive;
class UndoTransaction;
class UndoTransaction_GenericTransaction;
class UndoTransaction_TextTransaction;
class UndoTransaction_CharIndexTransaction;
class UndoTransaction_ReplaceCharIndexTransaction;
class UndoTransaction_AttributeIndexTransaction;
class UndoTransaction_InsertAttributeTransaction;
class UndoTransaction_InsertNilTransaction;
class UndoTransaction_CharDeltaTransaction;
class UndoTransaction_ParagraphDataTransaction;
class UndoTransaction_ObjectDOLCTransaction;
class UndoTransaction_CTDateTransaction;
class UndoTransaction_UnionTransaction;
class UndoTransactionWrapperArchive;
class ShapeInfoArchive;
class CommentInfoArchive;
class TOCInfoArchive;
class TOCLayoutHintArchive;
class TextualAttachmentArchive;
class TSWPTOCPageNumberAttachmentArchive;
class UIGraphicalAttachment;
class DrawableAttachmentArchive;
class TOCAttachmentArchive;
class FootnoteReferenceAttachmentArchive;
class NumberAttachmentArchive;
class SmartFieldArchive;
class HyperlinkFieldArchive;
class PlaceholderSmartFieldArchive;
class UnsupportedHyperlinkFieldArchive;
class BibliographySmartFieldArchive;
class CitationRecordArchive;
class CitationSmartFieldArchive;
class DateTimeSmartFieldArchive;
class BookmarkFieldArchive;
class FilenameSmartFieldArchive;
class MergeSmartFieldArchive;
class TOCSmartFieldArchive;
class TOCSmartFieldArchive_TOCEntry;
class RubyFieldArchive;
class ChangeArchive;
class ChangeSessionArchive;
class SectionPlaceholderArchive;

enum StorageArchive_KindType {
  StorageArchive_KindType_BODY = 0,
  StorageArchive_KindType_HEADER = 1,
  StorageArchive_KindType_FOOTNOTE = 2,
  StorageArchive_KindType_TEXTBOX = 3,
  StorageArchive_KindType_NOTE = 4,
  StorageArchive_KindType_CELL = 5,
  StorageArchive_KindType_UNCLASSIFIED = 6,
  StorageArchive_KindType_TABLEOFCONTENTS = 7
};
bool StorageArchive_KindType_IsValid(int value);
const StorageArchive_KindType StorageArchive_KindType_KindType_MIN = StorageArchive_KindType_BODY;
const StorageArchive_KindType StorageArchive_KindType_KindType_MAX = StorageArchive_KindType_TABLEOFCONTENTS;
const int StorageArchive_KindType_KindType_ARRAYSIZE = StorageArchive_KindType_KindType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StorageArchive_KindType_descriptor();
inline const ::std::string& StorageArchive_KindType_Name(StorageArchive_KindType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StorageArchive_KindType_descriptor(), value);
}
inline bool StorageArchive_KindType_Parse(
    const ::std::string& name, StorageArchive_KindType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StorageArchive_KindType>(
    StorageArchive_KindType_descriptor(), name, value);
}
enum CharacterStylePropertiesArchive_CapitalizationType {
  CharacterStylePropertiesArchive_CapitalizationType_kNoCaps = 0,
  CharacterStylePropertiesArchive_CapitalizationType_kAllCaps = 1,
  CharacterStylePropertiesArchive_CapitalizationType_kSmallCaps = 2,
  CharacterStylePropertiesArchive_CapitalizationType_kTitled = 3
};
bool CharacterStylePropertiesArchive_CapitalizationType_IsValid(int value);
const CharacterStylePropertiesArchive_CapitalizationType CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_MIN = CharacterStylePropertiesArchive_CapitalizationType_kNoCaps;
const CharacterStylePropertiesArchive_CapitalizationType CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_MAX = CharacterStylePropertiesArchive_CapitalizationType_kTitled;
const int CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_ARRAYSIZE = CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterStylePropertiesArchive_CapitalizationType_descriptor();
inline const ::std::string& CharacterStylePropertiesArchive_CapitalizationType_Name(CharacterStylePropertiesArchive_CapitalizationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterStylePropertiesArchive_CapitalizationType_descriptor(), value);
}
inline bool CharacterStylePropertiesArchive_CapitalizationType_Parse(
    const ::std::string& name, CharacterStylePropertiesArchive_CapitalizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterStylePropertiesArchive_CapitalizationType>(
    CharacterStylePropertiesArchive_CapitalizationType_descriptor(), name, value);
}
enum CharacterStylePropertiesArchive_UnderlineType {
  CharacterStylePropertiesArchive_UnderlineType_kNoUnderline = 0,
  CharacterStylePropertiesArchive_UnderlineType_kSingleUnderline = 1,
  CharacterStylePropertiesArchive_UnderlineType_kDoubleUnderline = 2,
  CharacterStylePropertiesArchive_UnderlineType_kWavyUnderline = 3
};
bool CharacterStylePropertiesArchive_UnderlineType_IsValid(int value);
const CharacterStylePropertiesArchive_UnderlineType CharacterStylePropertiesArchive_UnderlineType_UnderlineType_MIN = CharacterStylePropertiesArchive_UnderlineType_kNoUnderline;
const CharacterStylePropertiesArchive_UnderlineType CharacterStylePropertiesArchive_UnderlineType_UnderlineType_MAX = CharacterStylePropertiesArchive_UnderlineType_kWavyUnderline;
const int CharacterStylePropertiesArchive_UnderlineType_UnderlineType_ARRAYSIZE = CharacterStylePropertiesArchive_UnderlineType_UnderlineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterStylePropertiesArchive_UnderlineType_descriptor();
inline const ::std::string& CharacterStylePropertiesArchive_UnderlineType_Name(CharacterStylePropertiesArchive_UnderlineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterStylePropertiesArchive_UnderlineType_descriptor(), value);
}
inline bool CharacterStylePropertiesArchive_UnderlineType_Parse(
    const ::std::string& name, CharacterStylePropertiesArchive_UnderlineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterStylePropertiesArchive_UnderlineType>(
    CharacterStylePropertiesArchive_UnderlineType_descriptor(), name, value);
}
enum CharacterStylePropertiesArchive_LigaturesType {
  CharacterStylePropertiesArchive_LigaturesType_kRequiredLigatures = 0,
  CharacterStylePropertiesArchive_LigaturesType_kStandardLigatures = 1,
  CharacterStylePropertiesArchive_LigaturesType_kAllLigatures = 2
};
bool CharacterStylePropertiesArchive_LigaturesType_IsValid(int value);
const CharacterStylePropertiesArchive_LigaturesType CharacterStylePropertiesArchive_LigaturesType_LigaturesType_MIN = CharacterStylePropertiesArchive_LigaturesType_kRequiredLigatures;
const CharacterStylePropertiesArchive_LigaturesType CharacterStylePropertiesArchive_LigaturesType_LigaturesType_MAX = CharacterStylePropertiesArchive_LigaturesType_kAllLigatures;
const int CharacterStylePropertiesArchive_LigaturesType_LigaturesType_ARRAYSIZE = CharacterStylePropertiesArchive_LigaturesType_LigaturesType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterStylePropertiesArchive_LigaturesType_descriptor();
inline const ::std::string& CharacterStylePropertiesArchive_LigaturesType_Name(CharacterStylePropertiesArchive_LigaturesType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterStylePropertiesArchive_LigaturesType_descriptor(), value);
}
inline bool CharacterStylePropertiesArchive_LigaturesType_Parse(
    const ::std::string& name, CharacterStylePropertiesArchive_LigaturesType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterStylePropertiesArchive_LigaturesType>(
    CharacterStylePropertiesArchive_LigaturesType_descriptor(), name, value);
}
enum CharacterStylePropertiesArchive_StrikethruType {
  CharacterStylePropertiesArchive_StrikethruType_kNoStrikethru = 0,
  CharacterStylePropertiesArchive_StrikethruType_kSingleStrikethru = 1,
  CharacterStylePropertiesArchive_StrikethruType_kDoubleStrikethru = 2,
  CharacterStylePropertiesArchive_StrikethruType_kTripleStrikethru = 3
};
bool CharacterStylePropertiesArchive_StrikethruType_IsValid(int value);
const CharacterStylePropertiesArchive_StrikethruType CharacterStylePropertiesArchive_StrikethruType_StrikethruType_MIN = CharacterStylePropertiesArchive_StrikethruType_kNoStrikethru;
const CharacterStylePropertiesArchive_StrikethruType CharacterStylePropertiesArchive_StrikethruType_StrikethruType_MAX = CharacterStylePropertiesArchive_StrikethruType_kTripleStrikethru;
const int CharacterStylePropertiesArchive_StrikethruType_StrikethruType_ARRAYSIZE = CharacterStylePropertiesArchive_StrikethruType_StrikethruType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterStylePropertiesArchive_StrikethruType_descriptor();
inline const ::std::string& CharacterStylePropertiesArchive_StrikethruType_Name(CharacterStylePropertiesArchive_StrikethruType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterStylePropertiesArchive_StrikethruType_descriptor(), value);
}
inline bool CharacterStylePropertiesArchive_StrikethruType_Parse(
    const ::std::string& name, CharacterStylePropertiesArchive_StrikethruType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterStylePropertiesArchive_StrikethruType>(
    CharacterStylePropertiesArchive_StrikethruType_descriptor(), name, value);
}
enum CharacterStylePropertiesArchive_SuperscriptType {
  CharacterStylePropertiesArchive_SuperscriptType_kNoScript = 0,
  CharacterStylePropertiesArchive_SuperscriptType_kSuperscript = 1,
  CharacterStylePropertiesArchive_SuperscriptType_kSubscript = 2
};
bool CharacterStylePropertiesArchive_SuperscriptType_IsValid(int value);
const CharacterStylePropertiesArchive_SuperscriptType CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_MIN = CharacterStylePropertiesArchive_SuperscriptType_kNoScript;
const CharacterStylePropertiesArchive_SuperscriptType CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_MAX = CharacterStylePropertiesArchive_SuperscriptType_kSubscript;
const int CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_ARRAYSIZE = CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterStylePropertiesArchive_SuperscriptType_descriptor();
inline const ::std::string& CharacterStylePropertiesArchive_SuperscriptType_Name(CharacterStylePropertiesArchive_SuperscriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterStylePropertiesArchive_SuperscriptType_descriptor(), value);
}
inline bool CharacterStylePropertiesArchive_SuperscriptType_Parse(
    const ::std::string& name, CharacterStylePropertiesArchive_SuperscriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterStylePropertiesArchive_SuperscriptType>(
    CharacterStylePropertiesArchive_SuperscriptType_descriptor(), name, value);
}
enum TabArchive_TabAlignmentType {
  TabArchive_TabAlignmentType_kTabAlignmentLeft = 0,
  TabArchive_TabAlignmentType_kTabAlignmentCenter = 1,
  TabArchive_TabAlignmentType_kTabAlignmentRight = 2,
  TabArchive_TabAlignmentType_kTabAlignmentDecimal = 3
};
bool TabArchive_TabAlignmentType_IsValid(int value);
const TabArchive_TabAlignmentType TabArchive_TabAlignmentType_TabAlignmentType_MIN = TabArchive_TabAlignmentType_kTabAlignmentLeft;
const TabArchive_TabAlignmentType TabArchive_TabAlignmentType_TabAlignmentType_MAX = TabArchive_TabAlignmentType_kTabAlignmentDecimal;
const int TabArchive_TabAlignmentType_TabAlignmentType_ARRAYSIZE = TabArchive_TabAlignmentType_TabAlignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TabArchive_TabAlignmentType_descriptor();
inline const ::std::string& TabArchive_TabAlignmentType_Name(TabArchive_TabAlignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TabArchive_TabAlignmentType_descriptor(), value);
}
inline bool TabArchive_TabAlignmentType_Parse(
    const ::std::string& name, TabArchive_TabAlignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TabArchive_TabAlignmentType>(
    TabArchive_TabAlignmentType_descriptor(), name, value);
}
enum LineSpacingArchive_LineSpacingModeType {
  LineSpacingArchive_LineSpacingModeType_kRelativeLineSpacing = 0,
  LineSpacingArchive_LineSpacingModeType_kMinimumLineSpacing = 1,
  LineSpacingArchive_LineSpacingModeType_kExactLineSpacing = 2,
  LineSpacingArchive_LineSpacingModeType_kMaximumLineSpacing = 3,
  LineSpacingArchive_LineSpacingModeType_kSpaceBetweenLineSpacing = 4
};
bool LineSpacingArchive_LineSpacingModeType_IsValid(int value);
const LineSpacingArchive_LineSpacingModeType LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_MIN = LineSpacingArchive_LineSpacingModeType_kRelativeLineSpacing;
const LineSpacingArchive_LineSpacingModeType LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_MAX = LineSpacingArchive_LineSpacingModeType_kSpaceBetweenLineSpacing;
const int LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_ARRAYSIZE = LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineSpacingArchive_LineSpacingModeType_descriptor();
inline const ::std::string& LineSpacingArchive_LineSpacingModeType_Name(LineSpacingArchive_LineSpacingModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineSpacingArchive_LineSpacingModeType_descriptor(), value);
}
inline bool LineSpacingArchive_LineSpacingModeType_Parse(
    const ::std::string& name, LineSpacingArchive_LineSpacingModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineSpacingArchive_LineSpacingModeType>(
    LineSpacingArchive_LineSpacingModeType_descriptor(), name, value);
}
enum ParagraphStylePropertiesArchive_TextAlignmentType {
  ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue0 = 0,
  ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue1 = 1,
  ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue2 = 2,
  ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue3 = 3,
  ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue4 = 4
};
bool ParagraphStylePropertiesArchive_TextAlignmentType_IsValid(int value);
const ParagraphStylePropertiesArchive_TextAlignmentType ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_MIN = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue0;
const ParagraphStylePropertiesArchive_TextAlignmentType ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_MAX = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue4;
const int ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_ARRAYSIZE = ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParagraphStylePropertiesArchive_TextAlignmentType_descriptor();
inline const ::std::string& ParagraphStylePropertiesArchive_TextAlignmentType_Name(ParagraphStylePropertiesArchive_TextAlignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParagraphStylePropertiesArchive_TextAlignmentType_descriptor(), value);
}
inline bool ParagraphStylePropertiesArchive_TextAlignmentType_Parse(
    const ::std::string& name, ParagraphStylePropertiesArchive_TextAlignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParagraphStylePropertiesArchive_TextAlignmentType>(
    ParagraphStylePropertiesArchive_TextAlignmentType_descriptor(), name, value);
}
enum ParagraphStylePropertiesArchive_ParagraphBorderType {
  ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue0 = 0,
  ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue1 = 1,
  ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue2 = 2,
  ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue3 = 3,
  ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue4 = 4
};
bool ParagraphStylePropertiesArchive_ParagraphBorderType_IsValid(int value);
const ParagraphStylePropertiesArchive_ParagraphBorderType ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_MIN = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue0;
const ParagraphStylePropertiesArchive_ParagraphBorderType ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_MAX = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue4;
const int ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_ARRAYSIZE = ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParagraphStylePropertiesArchive_ParagraphBorderType_descriptor();
inline const ::std::string& ParagraphStylePropertiesArchive_ParagraphBorderType_Name(ParagraphStylePropertiesArchive_ParagraphBorderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParagraphStylePropertiesArchive_ParagraphBorderType_descriptor(), value);
}
inline bool ParagraphStylePropertiesArchive_ParagraphBorderType_Parse(
    const ::std::string& name, ParagraphStylePropertiesArchive_ParagraphBorderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParagraphStylePropertiesArchive_ParagraphBorderType>(
    ParagraphStylePropertiesArchive_ParagraphBorderType_descriptor(), name, value);
}
enum ParagraphStylePropertiesArchive_OutlineStyleType {
  ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue0 = 0,
  ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue1 = 1,
  ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue2 = 2
};
bool ParagraphStylePropertiesArchive_OutlineStyleType_IsValid(int value);
const ParagraphStylePropertiesArchive_OutlineStyleType ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_MIN = ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue0;
const ParagraphStylePropertiesArchive_OutlineStyleType ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_MAX = ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue2;
const int ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_ARRAYSIZE = ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParagraphStylePropertiesArchive_OutlineStyleType_descriptor();
inline const ::std::string& ParagraphStylePropertiesArchive_OutlineStyleType_Name(ParagraphStylePropertiesArchive_OutlineStyleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParagraphStylePropertiesArchive_OutlineStyleType_descriptor(), value);
}
inline bool ParagraphStylePropertiesArchive_OutlineStyleType_Parse(
    const ::std::string& name, ParagraphStylePropertiesArchive_OutlineStyleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParagraphStylePropertiesArchive_OutlineStyleType>(
    ParagraphStylePropertiesArchive_OutlineStyleType_descriptor(), name, value);
}
enum ListStyleArchive_LabelType {
  ListStyleArchive_LabelType_kNone = 0,
  ListStyleArchive_LabelType_kImage = 1,
  ListStyleArchive_LabelType_kString = 2,
  ListStyleArchive_LabelType_kNumber = 3
};
bool ListStyleArchive_LabelType_IsValid(int value);
const ListStyleArchive_LabelType ListStyleArchive_LabelType_LabelType_MIN = ListStyleArchive_LabelType_kNone;
const ListStyleArchive_LabelType ListStyleArchive_LabelType_LabelType_MAX = ListStyleArchive_LabelType_kNumber;
const int ListStyleArchive_LabelType_LabelType_ARRAYSIZE = ListStyleArchive_LabelType_LabelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListStyleArchive_LabelType_descriptor();
inline const ::std::string& ListStyleArchive_LabelType_Name(ListStyleArchive_LabelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListStyleArchive_LabelType_descriptor(), value);
}
inline bool ListStyleArchive_LabelType_Parse(
    const ::std::string& name, ListStyleArchive_LabelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListStyleArchive_LabelType>(
    ListStyleArchive_LabelType_descriptor(), name, value);
}
enum ListStyleArchive_NumberType {
  ListStyleArchive_NumberType_kNumericDecimal = 0,
  ListStyleArchive_NumberType_kNumericDoubleParen = 1,
  ListStyleArchive_NumberType_kNumericRightParen = 2,
  ListStyleArchive_NumberType_kRomanUpperDecimal = 3,
  ListStyleArchive_NumberType_kRomanUpperDoubleParen = 4,
  ListStyleArchive_NumberType_kRomanUpperRightParen = 5,
  ListStyleArchive_NumberType_kRomanLowerDecimal = 6,
  ListStyleArchive_NumberType_kRomanLowerDoubleParen = 7,
  ListStyleArchive_NumberType_kRomanLowerRightParen = 8,
  ListStyleArchive_NumberType_kAlphaUpperDecimal = 9,
  ListStyleArchive_NumberType_kAlphaUpperDoubleParen = 10,
  ListStyleArchive_NumberType_kAlphaUpperRightParen = 11,
  ListStyleArchive_NumberType_kAlphaLowerDecimal = 12,
  ListStyleArchive_NumberType_kAlphaLowerDoubleParen = 13,
  ListStyleArchive_NumberType_kAlphaLowerRightParen = 14,
  ListStyleArchive_NumberType_kIdeographicJapaneseDecimalKind = 15,
  ListStyleArchive_NumberType_kIdeographicJapaneseDoubleParenKind = 16,
  ListStyleArchive_NumberType_kIdeographicJapaneseRightParenKind = 17,
  ListStyleArchive_NumberType_kHiraganaDecimalKind = 18,
  ListStyleArchive_NumberType_kHiraganaDoubleParenKind = 19,
  ListStyleArchive_NumberType_kHiraganaRightParenKind = 20,
  ListStyleArchive_NumberType_kKatakanaDecimalKind = 21,
  ListStyleArchive_NumberType_kKatakanaDoubleParenKind = 22,
  ListStyleArchive_NumberType_kKatakanaRightParenKind = 23,
  ListStyleArchive_NumberType_kHiraganaIrohaDecimalKind = 24,
  ListStyleArchive_NumberType_kHiraganaIrohaDoubleParenKind = 25,
  ListStyleArchive_NumberType_kHiraganaIrohaRightParenKind = 26,
  ListStyleArchive_NumberType_kKatakanaIrohaDecimalKind = 27,
  ListStyleArchive_NumberType_kKatakanaIrohaDoubleParenKind = 28,
  ListStyleArchive_NumberType_kKatakanaIrohaRightParenKind = 29,
  ListStyleArchive_NumberType_kIdeographicSimplifiedChineseDecimalKind = 30,
  ListStyleArchive_NumberType_kIdeographicSimplifiedChineseDoubleParenKind = 31,
  ListStyleArchive_NumberType_kIdeographicSimplifiedChineseRightParenKind = 32,
  ListStyleArchive_NumberType_kIdeographicTraditionalChineseDecimalKind = 33,
  ListStyleArchive_NumberType_kIdeographicTraditionalChineseDoubleParenKind = 34,
  ListStyleArchive_NumberType_kIdeographicTraditionalChineseRightParenKind = 35,
  ListStyleArchive_NumberType_kIdeographicFormalJapaneseDecimalKind = 36,
  ListStyleArchive_NumberType_kIdeographicFormalJapaneseDoubleParenKind = 37,
  ListStyleArchive_NumberType_kIdeographicFormalJapaneseRightParenKind = 38,
  ListStyleArchive_NumberType_kIdeographicFormalSimplifiedChineseDecimalKind = 39,
  ListStyleArchive_NumberType_kIdeographicFormalSimplifiedChineseDoubleParenKind = 40,
  ListStyleArchive_NumberType_kIdeographicFormalSimplifiedChineseRightParenKind = 41,
  ListStyleArchive_NumberType_kIdeographicFormalTraditionalChineseDecimalKind = 42,
  ListStyleArchive_NumberType_kIdeographicFormalTraditionalChineseDoubleParenKind = 43,
  ListStyleArchive_NumberType_kIdeographicFormalTraditionalChineseRightParenKind = 44,
  ListStyleArchive_NumberType_kKoreanAlphabetDecimalKind = 45,
  ListStyleArchive_NumberType_kKoreanAlphabetDoubleParenKind = 46,
  ListStyleArchive_NumberType_kKoreanAlphabetRightParenKind = 47,
  ListStyleArchive_NumberType_kCircledNumberKind = 48,
  ListStyleArchive_NumberType_kArabianNumericDecimalKind = 49,
  ListStyleArchive_NumberType_kArabianNumericDoubleParenKind = 50,
  ListStyleArchive_NumberType_kArabianNumericRightParenKind = 51,
  ListStyleArchive_NumberType_kArabianAlphaDecimalKind = 52,
  ListStyleArchive_NumberType_kArabianAlphaDoubleParenKind = 53,
  ListStyleArchive_NumberType_kArabianAlphaRightParenKind = 54,
  ListStyleArchive_NumberType_kArabianAbjadDecimalKind = 55,
  ListStyleArchive_NumberType_kArabianAbjadDoubleParenKind = 56,
  ListStyleArchive_NumberType_kArabianAbjadRightParenKind = 57,
  ListStyleArchive_NumberType_kHebrewAlphaDecimalKind = 58,
  ListStyleArchive_NumberType_kHebrewAlphaDoubleParenKind = 59,
  ListStyleArchive_NumberType_kHebrewAlphaRightParenKind = 60,
  ListStyleArchive_NumberType_kHebrewBiblicalStandardKind = 61
};
bool ListStyleArchive_NumberType_IsValid(int value);
const ListStyleArchive_NumberType ListStyleArchive_NumberType_NumberType_MIN = ListStyleArchive_NumberType_kNumericDecimal;
const ListStyleArchive_NumberType ListStyleArchive_NumberType_NumberType_MAX = ListStyleArchive_NumberType_kHebrewBiblicalStandardKind;
const int ListStyleArchive_NumberType_NumberType_ARRAYSIZE = ListStyleArchive_NumberType_NumberType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListStyleArchive_NumberType_descriptor();
inline const ::std::string& ListStyleArchive_NumberType_Name(ListStyleArchive_NumberType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListStyleArchive_NumberType_descriptor(), value);
}
inline bool ListStyleArchive_NumberType_Parse(
    const ::std::string& name, ListStyleArchive_NumberType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListStyleArchive_NumberType>(
    ListStyleArchive_NumberType_descriptor(), name, value);
}
enum ColumnStylePropertiesArchive_VerticalAlignmentType {
  ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignTop = 0,
  ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignMiddle = 1,
  ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignBottom = 2,
  ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignJustify = 3
};
bool ColumnStylePropertiesArchive_VerticalAlignmentType_IsValid(int value);
const ColumnStylePropertiesArchive_VerticalAlignmentType ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MIN = ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignTop;
const ColumnStylePropertiesArchive_VerticalAlignmentType ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MAX = ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignJustify;
const int ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_ARRAYSIZE = ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ColumnStylePropertiesArchive_VerticalAlignmentType_descriptor();
inline const ::std::string& ColumnStylePropertiesArchive_VerticalAlignmentType_Name(ColumnStylePropertiesArchive_VerticalAlignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ColumnStylePropertiesArchive_VerticalAlignmentType_descriptor(), value);
}
inline bool ColumnStylePropertiesArchive_VerticalAlignmentType_Parse(
    const ::std::string& name, ColumnStylePropertiesArchive_VerticalAlignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColumnStylePropertiesArchive_VerticalAlignmentType>(
    ColumnStylePropertiesArchive_VerticalAlignmentType_descriptor(), name, value);
}
enum ShapeStylePropertiesArchive_VerticalAlignmentType {
  ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignTop = 0,
  ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignMiddle = 1,
  ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignBottom = 2,
  ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignJustify = 3
};
bool ShapeStylePropertiesArchive_VerticalAlignmentType_IsValid(int value);
const ShapeStylePropertiesArchive_VerticalAlignmentType ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MIN = ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignTop;
const ShapeStylePropertiesArchive_VerticalAlignmentType ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MAX = ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignJustify;
const int ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_ARRAYSIZE = ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeStylePropertiesArchive_VerticalAlignmentType_descriptor();
inline const ::std::string& ShapeStylePropertiesArchive_VerticalAlignmentType_Name(ShapeStylePropertiesArchive_VerticalAlignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeStylePropertiesArchive_VerticalAlignmentType_descriptor(), value);
}
inline bool ShapeStylePropertiesArchive_VerticalAlignmentType_Parse(
    const ::std::string& name, ShapeStylePropertiesArchive_VerticalAlignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeStylePropertiesArchive_VerticalAlignmentType>(
    ShapeStylePropertiesArchive_VerticalAlignmentType_descriptor(), name, value);
}
enum UndoTransaction_UndoKind {
  UndoTransaction_UndoKind_REPLACE_TEXT = 1,
  UndoTransaction_UndoKind_INSERT_ATTRIBUTE = 2,
  UndoTransaction_UndoKind_DELETE_ATTRIBUTE = 3,
  UndoTransaction_UndoKind_ADJUST_CHAR_INDEXES = 4,
  UndoTransaction_UndoKind_COMPR_ADJUST_CHAR_INDEXES = 5,
  UndoTransaction_UndoKind_REPLACE_CHAR_INDEX = 6,
  UndoTransaction_UndoKind_REPLACE_OBJECT = 7,
  UndoTransaction_UndoKind_REPLACE_PARAGRAPH_DATA = 8,
  UndoTransaction_UndoKind_OBJECT_DOLC = 9,
  UndoTransaction_UndoKind_CT_DATE = 10
};
bool UndoTransaction_UndoKind_IsValid(int value);
const UndoTransaction_UndoKind UndoTransaction_UndoKind_UndoKind_MIN = UndoTransaction_UndoKind_REPLACE_TEXT;
const UndoTransaction_UndoKind UndoTransaction_UndoKind_UndoKind_MAX = UndoTransaction_UndoKind_CT_DATE;
const int UndoTransaction_UndoKind_UndoKind_ARRAYSIZE = UndoTransaction_UndoKind_UndoKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* UndoTransaction_UndoKind_descriptor();
inline const ::std::string& UndoTransaction_UndoKind_Name(UndoTransaction_UndoKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    UndoTransaction_UndoKind_descriptor(), value);
}
inline bool UndoTransaction_UndoKind_Parse(
    const ::std::string& name, UndoTransaction_UndoKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UndoTransaction_UndoKind>(
    UndoTransaction_UndoKind_descriptor(), name, value);
}
enum TextualAttachmentArchive_Kind {
  TextualAttachmentArchive_Kind_kKindPageNumber = 0,
  TextualAttachmentArchive_Kind_kKindPageCount = 1,
  TextualAttachmentArchive_Kind_kKindFootnoteMark = 2
};
bool TextualAttachmentArchive_Kind_IsValid(int value);
const TextualAttachmentArchive_Kind TextualAttachmentArchive_Kind_Kind_MIN = TextualAttachmentArchive_Kind_kKindPageNumber;
const TextualAttachmentArchive_Kind TextualAttachmentArchive_Kind_Kind_MAX = TextualAttachmentArchive_Kind_kKindFootnoteMark;
const int TextualAttachmentArchive_Kind_Kind_ARRAYSIZE = TextualAttachmentArchive_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TextualAttachmentArchive_Kind_descriptor();
inline const ::std::string& TextualAttachmentArchive_Kind_Name(TextualAttachmentArchive_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TextualAttachmentArchive_Kind_descriptor(), value);
}
inline bool TextualAttachmentArchive_Kind_Parse(
    const ::std::string& name, TextualAttachmentArchive_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextualAttachmentArchive_Kind>(
    TextualAttachmentArchive_Kind_descriptor(), name, value);
}
enum DateTimeSmartFieldArchive_DateTimeUpdatePlan {
  DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanNever = 0,
  DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanAuto = 1,
  DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanOnce = 2
};
bool DateTimeSmartFieldArchive_DateTimeUpdatePlan_IsValid(int value);
const DateTimeSmartFieldArchive_DateTimeUpdatePlan DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_MIN = DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanNever;
const DateTimeSmartFieldArchive_DateTimeUpdatePlan DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_MAX = DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanOnce;
const int DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_ARRAYSIZE = DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_MAX + 1;

const ::google::protobuf::EnumDescriptor* DateTimeSmartFieldArchive_DateTimeUpdatePlan_descriptor();
inline const ::std::string& DateTimeSmartFieldArchive_DateTimeUpdatePlan_Name(DateTimeSmartFieldArchive_DateTimeUpdatePlan value) {
  return ::google::protobuf::internal::NameOfEnum(
    DateTimeSmartFieldArchive_DateTimeUpdatePlan_descriptor(), value);
}
inline bool DateTimeSmartFieldArchive_DateTimeUpdatePlan_Parse(
    const ::std::string& name, DateTimeSmartFieldArchive_DateTimeUpdatePlan* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DateTimeSmartFieldArchive_DateTimeUpdatePlan>(
    DateTimeSmartFieldArchive_DateTimeUpdatePlan_descriptor(), name, value);
}
enum DateTimeSmartFieldArchive_DateTimeFormatterStyle {
  DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleNone = 0,
  DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleShort = 1,
  DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleMedium = 2,
  DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleLong = 3,
  DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleFull = 4
};
bool DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(int value);
const DateTimeSmartFieldArchive_DateTimeFormatterStyle DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_MIN = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleNone;
const DateTimeSmartFieldArchive_DateTimeFormatterStyle DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_MAX = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleFull;
const int DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_ARRAYSIZE = DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* DateTimeSmartFieldArchive_DateTimeFormatterStyle_descriptor();
inline const ::std::string& DateTimeSmartFieldArchive_DateTimeFormatterStyle_Name(DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    DateTimeSmartFieldArchive_DateTimeFormatterStyle_descriptor(), value);
}
inline bool DateTimeSmartFieldArchive_DateTimeFormatterStyle_Parse(
    const ::std::string& name, DateTimeSmartFieldArchive_DateTimeFormatterStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DateTimeSmartFieldArchive_DateTimeFormatterStyle>(
    DateTimeSmartFieldArchive_DateTimeFormatterStyle_descriptor(), name, value);
}
enum MergeSmartFieldArchive_MergeCategory {
  MergeSmartFieldArchive_MergeCategory_kMergeCategoryTo = 0,
  MergeSmartFieldArchive_MergeCategory_kMergeCategoryFrom = 1
};
bool MergeSmartFieldArchive_MergeCategory_IsValid(int value);
const MergeSmartFieldArchive_MergeCategory MergeSmartFieldArchive_MergeCategory_MergeCategory_MIN = MergeSmartFieldArchive_MergeCategory_kMergeCategoryTo;
const MergeSmartFieldArchive_MergeCategory MergeSmartFieldArchive_MergeCategory_MergeCategory_MAX = MergeSmartFieldArchive_MergeCategory_kMergeCategoryFrom;
const int MergeSmartFieldArchive_MergeCategory_MergeCategory_ARRAYSIZE = MergeSmartFieldArchive_MergeCategory_MergeCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* MergeSmartFieldArchive_MergeCategory_descriptor();
inline const ::std::string& MergeSmartFieldArchive_MergeCategory_Name(MergeSmartFieldArchive_MergeCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    MergeSmartFieldArchive_MergeCategory_descriptor(), value);
}
inline bool MergeSmartFieldArchive_MergeCategory_Parse(
    const ::std::string& name, MergeSmartFieldArchive_MergeCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MergeSmartFieldArchive_MergeCategory>(
    MergeSmartFieldArchive_MergeCategory_descriptor(), name, value);
}
enum ChangeArchive_ChangeKind {
  ChangeArchive_ChangeKind_kChangeKindInsertion = 1,
  ChangeArchive_ChangeKind_kChangeKindDeletion = 2
};
bool ChangeArchive_ChangeKind_IsValid(int value);
const ChangeArchive_ChangeKind ChangeArchive_ChangeKind_ChangeKind_MIN = ChangeArchive_ChangeKind_kChangeKindInsertion;
const ChangeArchive_ChangeKind ChangeArchive_ChangeKind_ChangeKind_MAX = ChangeArchive_ChangeKind_kChangeKindDeletion;
const int ChangeArchive_ChangeKind_ChangeKind_ARRAYSIZE = ChangeArchive_ChangeKind_ChangeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeArchive_ChangeKind_descriptor();
inline const ::std::string& ChangeArchive_ChangeKind_Name(ChangeArchive_ChangeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeArchive_ChangeKind_descriptor(), value);
}
inline bool ChangeArchive_ChangeKind_Parse(
    const ::std::string& name, ChangeArchive_ChangeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeArchive_ChangeKind>(
    ChangeArchive_ChangeKind_descriptor(), name, value);
}
enum SelectionType {
  SelectionType_Normal = 0,
  SelectionType_ListLabel = 1,
  SelectionType_ListTopic = 2,
  SelectionType_Replace = 3,
  SelectionType_CopyPasteStyle = 4,
  SelectionType_Replace2 = 5,
  SelectionType_SmartField = 6,
  SelectionType_Visual = 7
};
bool SelectionType_IsValid(int value);
const SelectionType SelectionType_MIN = SelectionType_Normal;
const SelectionType SelectionType_MAX = SelectionType_Visual;
const int SelectionType_ARRAYSIZE = SelectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectionType_descriptor();
inline const ::std::string& SelectionType_Name(SelectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectionType_descriptor(), value);
}
inline bool SelectionType_Parse(
    const ::std::string& name, SelectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectionType>(
    SelectionType_descriptor(), name, value);
}
enum StyleInsertionBehavior {
  StyleInsertionBehavior_NoGrow = 0,
  StyleInsertionBehavior_GrowLeft = 1,
  StyleInsertionBehavior_GrowRight = 2
};
bool StyleInsertionBehavior_IsValid(int value);
const StyleInsertionBehavior StyleInsertionBehavior_MIN = StyleInsertionBehavior_NoGrow;
const StyleInsertionBehavior StyleInsertionBehavior_MAX = StyleInsertionBehavior_GrowRight;
const int StyleInsertionBehavior_ARRAYSIZE = StyleInsertionBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* StyleInsertionBehavior_descriptor();
inline const ::std::string& StyleInsertionBehavior_Name(StyleInsertionBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    StyleInsertionBehavior_descriptor(), value);
}
inline bool StyleInsertionBehavior_Parse(
    const ::std::string& name, StyleInsertionBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StyleInsertionBehavior>(
    StyleInsertionBehavior_descriptor(), name, value);
}
enum CaretAffinity {
  CaretAffinity_Start = 0,
  CaretAffinity_End = 1
};
bool CaretAffinity_IsValid(int value);
const CaretAffinity CaretAffinity_MIN = CaretAffinity_Start;
const CaretAffinity CaretAffinity_MAX = CaretAffinity_End;
const int CaretAffinity_ARRAYSIZE = CaretAffinity_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaretAffinity_descriptor();
inline const ::std::string& CaretAffinity_Name(CaretAffinity value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaretAffinity_descriptor(), value);
}
inline bool CaretAffinity_Parse(
    const ::std::string& name, CaretAffinity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaretAffinity>(
    CaretAffinity_descriptor(), name, value);
}
enum WritingDirectionType {
  kWritingDirectionNatural = -1,
  kWritingDirectionLeftToRight = 0,
  kWritingDirectionRightToLeft = 1
};
bool WritingDirectionType_IsValid(int value);
const WritingDirectionType WritingDirectionType_MIN = kWritingDirectionNatural;
const WritingDirectionType WritingDirectionType_MAX = kWritingDirectionRightToLeft;
const int WritingDirectionType_ARRAYSIZE = WritingDirectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WritingDirectionType_descriptor();
inline const ::std::string& WritingDirectionType_Name(WritingDirectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WritingDirectionType_descriptor(), value);
}
inline bool WritingDirectionType_Parse(
    const ::std::string& name, WritingDirectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WritingDirectionType>(
    WritingDirectionType_descriptor(), name, value);
}
// ===================================================================

class SelectionArchive : public ::google::protobuf::Message {
 public:
  SelectionArchive();
  virtual ~SelectionArchive();

  SelectionArchive(const SelectionArchive& from);

  inline SelectionArchive& operator=(const SelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectionArchive& default_instance();

  void Swap(SelectionArchive* other);

  // implements Message ----------------------------------------------

  SelectionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelectionArchive& from);
  void MergeFrom(const SelectionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.SelectionType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSWP::SelectionType type() const;
  inline void set_type(::TSWP::SelectionType value);

  // required .TSP.Range range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline const ::TSP::Range& range() const;
  inline ::TSP::Range* mutable_range();
  inline ::TSP::Range* release_range();
  inline void set_allocated_range(::TSP::Range* range);

  // required .TSWP.StyleInsertionBehavior styleInsertionBehavior = 3;
  inline bool has_styleinsertionbehavior() const;
  inline void clear_styleinsertionbehavior();
  static const int kStyleInsertionBehaviorFieldNumber = 3;
  inline ::TSWP::StyleInsertionBehavior styleinsertionbehavior() const;
  inline void set_styleinsertionbehavior(::TSWP::StyleInsertionBehavior value);

  // required .TSWP.CaretAffinity caretAffinity = 4;
  inline bool has_caretaffinity() const;
  inline void clear_caretaffinity();
  static const int kCaretAffinityFieldNumber = 4;
  inline ::TSWP::CaretAffinity caretaffinity() const;
  inline void set_caretaffinity(::TSWP::CaretAffinity value);

  // required .TSP.Range smart_field_range = 5;
  inline bool has_smart_field_range() const;
  inline void clear_smart_field_range();
  static const int kSmartFieldRangeFieldNumber = 5;
  inline const ::TSP::Range& smart_field_range() const;
  inline ::TSP::Range* mutable_smart_field_range();
  inline ::TSP::Range* release_smart_field_range();
  inline void set_allocated_smart_field_range(::TSP::Range* smart_field_range);

  // @@protoc_insertion_point(class_scope:TSWP.SelectionArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_styleinsertionbehavior();
  inline void clear_has_styleinsertionbehavior();
  inline void set_has_caretaffinity();
  inline void clear_has_caretaffinity();
  inline void set_has_smart_field_range();
  inline void clear_has_smart_field_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Range* range_;
  int type_;
  int styleinsertionbehavior_;
  ::TSP::Range* smart_field_range_;
  int caretaffinity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static SelectionArchive* default_instance_;
};
// -------------------------------------------------------------------

class ObjectAttributeTable_ObjectAttribute : public ::google::protobuf::Message {
 public:
  ObjectAttributeTable_ObjectAttribute();
  virtual ~ObjectAttributeTable_ObjectAttribute();

  ObjectAttributeTable_ObjectAttribute(const ObjectAttributeTable_ObjectAttribute& from);

  inline ObjectAttributeTable_ObjectAttribute& operator=(const ObjectAttributeTable_ObjectAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectAttributeTable_ObjectAttribute& default_instance();

  void Swap(ObjectAttributeTable_ObjectAttribute* other);

  // implements Message ----------------------------------------------

  ObjectAttributeTable_ObjectAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectAttributeTable_ObjectAttribute& from);
  void MergeFrom(const ObjectAttributeTable_ObjectAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_index = 1;
  inline bool has_character_index() const;
  inline void clear_character_index();
  static const int kCharacterIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 character_index() const;
  inline void set_character_index(::google::protobuf::uint32 value);

  // optional .TSP.Reference object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // @@protoc_insertion_point(class_scope:TSWP.ObjectAttributeTable.ObjectAttribute)
 private:
  inline void set_has_character_index();
  inline void clear_has_character_index();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* object_;
  ::google::protobuf::uint32 character_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ObjectAttributeTable_ObjectAttribute* default_instance_;
};
// -------------------------------------------------------------------

class ObjectAttributeTable : public ::google::protobuf::Message {
 public:
  ObjectAttributeTable();
  virtual ~ObjectAttributeTable();

  ObjectAttributeTable(const ObjectAttributeTable& from);

  inline ObjectAttributeTable& operator=(const ObjectAttributeTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectAttributeTable& default_instance();

  void Swap(ObjectAttributeTable* other);

  // implements Message ----------------------------------------------

  ObjectAttributeTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectAttributeTable& from);
  void MergeFrom(const ObjectAttributeTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ObjectAttributeTable_ObjectAttribute ObjectAttribute;

  // accessors -------------------------------------------------------

  // repeated .TSWP.ObjectAttributeTable.ObjectAttribute entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TSWP::ObjectAttributeTable_ObjectAttribute& entries(int index) const;
  inline ::TSWP::ObjectAttributeTable_ObjectAttribute* mutable_entries(int index);
  inline ::TSWP::ObjectAttributeTable_ObjectAttribute* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ObjectAttributeTable_ObjectAttribute >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::ObjectAttributeTable_ObjectAttribute >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSWP.ObjectAttributeTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::ObjectAttributeTable_ObjectAttribute > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ObjectAttributeTable* default_instance_;
};
// -------------------------------------------------------------------

class StringAttributeTable_StringAttribute : public ::google::protobuf::Message {
 public:
  StringAttributeTable_StringAttribute();
  virtual ~StringAttributeTable_StringAttribute();

  StringAttributeTable_StringAttribute(const StringAttributeTable_StringAttribute& from);

  inline StringAttributeTable_StringAttribute& operator=(const StringAttributeTable_StringAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringAttributeTable_StringAttribute& default_instance();

  void Swap(StringAttributeTable_StringAttribute* other);

  // implements Message ----------------------------------------------

  StringAttributeTable_StringAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringAttributeTable_StringAttribute& from);
  void MergeFrom(const StringAttributeTable_StringAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_index = 1;
  inline bool has_character_index() const;
  inline void clear_character_index();
  static const int kCharacterIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 character_index() const;
  inline void set_character_index(::google::protobuf::uint32 value);

  // optional string object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::std::string& object() const;
  inline void set_object(const ::std::string& value);
  inline void set_object(const char* value);
  inline void set_object(const char* value, size_t size);
  inline ::std::string* mutable_object();
  inline ::std::string* release_object();
  inline void set_allocated_object(::std::string* object);

  // @@protoc_insertion_point(class_scope:TSWP.StringAttributeTable.StringAttribute)
 private:
  inline void set_has_character_index();
  inline void clear_has_character_index();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_;
  ::google::protobuf::uint32 character_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static StringAttributeTable_StringAttribute* default_instance_;
};
// -------------------------------------------------------------------

class StringAttributeTable : public ::google::protobuf::Message {
 public:
  StringAttributeTable();
  virtual ~StringAttributeTable();

  StringAttributeTable(const StringAttributeTable& from);

  inline StringAttributeTable& operator=(const StringAttributeTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringAttributeTable& default_instance();

  void Swap(StringAttributeTable* other);

  // implements Message ----------------------------------------------

  StringAttributeTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringAttributeTable& from);
  void MergeFrom(const StringAttributeTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StringAttributeTable_StringAttribute StringAttribute;

  // accessors -------------------------------------------------------

  // repeated .TSWP.StringAttributeTable.StringAttribute entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TSWP::StringAttributeTable_StringAttribute& entries(int index) const;
  inline ::TSWP::StringAttributeTable_StringAttribute* mutable_entries(int index);
  inline ::TSWP::StringAttributeTable_StringAttribute* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::StringAttributeTable_StringAttribute >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::StringAttributeTable_StringAttribute >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSWP.StringAttributeTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::StringAttributeTable_StringAttribute > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static StringAttributeTable* default_instance_;
};
// -------------------------------------------------------------------

class ParaDataAttributeTable_ParaDataAttribute : public ::google::protobuf::Message {
 public:
  ParaDataAttributeTable_ParaDataAttribute();
  virtual ~ParaDataAttributeTable_ParaDataAttribute();

  ParaDataAttributeTable_ParaDataAttribute(const ParaDataAttributeTable_ParaDataAttribute& from);

  inline ParaDataAttributeTable_ParaDataAttribute& operator=(const ParaDataAttributeTable_ParaDataAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParaDataAttributeTable_ParaDataAttribute& default_instance();

  void Swap(ParaDataAttributeTable_ParaDataAttribute* other);

  // implements Message ----------------------------------------------

  ParaDataAttributeTable_ParaDataAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParaDataAttributeTable_ParaDataAttribute& from);
  void MergeFrom(const ParaDataAttributeTable_ParaDataAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_index = 1;
  inline bool has_character_index() const;
  inline void clear_character_index();
  static const int kCharacterIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 character_index() const;
  inline void set_character_index(::google::protobuf::uint32 value);

  // required uint32 first = 2;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 2;
  inline ::google::protobuf::uint32 first() const;
  inline void set_first(::google::protobuf::uint32 value);

  // required uint32 second = 3;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 3;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.ParaDataAttributeTable.ParaDataAttribute)
 private:
  inline void set_has_character_index();
  inline void clear_has_character_index();
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_second();
  inline void clear_has_second();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 character_index_;
  ::google::protobuf::uint32 first_;
  ::google::protobuf::uint32 second_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ParaDataAttributeTable_ParaDataAttribute* default_instance_;
};
// -------------------------------------------------------------------

class ParaDataAttributeTable : public ::google::protobuf::Message {
 public:
  ParaDataAttributeTable();
  virtual ~ParaDataAttributeTable();

  ParaDataAttributeTable(const ParaDataAttributeTable& from);

  inline ParaDataAttributeTable& operator=(const ParaDataAttributeTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParaDataAttributeTable& default_instance();

  void Swap(ParaDataAttributeTable* other);

  // implements Message ----------------------------------------------

  ParaDataAttributeTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParaDataAttributeTable& from);
  void MergeFrom(const ParaDataAttributeTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ParaDataAttributeTable_ParaDataAttribute ParaDataAttribute;

  // accessors -------------------------------------------------------

  // repeated .TSWP.ParaDataAttributeTable.ParaDataAttribute entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TSWP::ParaDataAttributeTable_ParaDataAttribute& entries(int index) const;
  inline ::TSWP::ParaDataAttributeTable_ParaDataAttribute* mutable_entries(int index);
  inline ::TSWP::ParaDataAttributeTable_ParaDataAttribute* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ParaDataAttributeTable_ParaDataAttribute >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::ParaDataAttributeTable_ParaDataAttribute >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSWP.ParaDataAttributeTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::ParaDataAttributeTable_ParaDataAttribute > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ParaDataAttributeTable* default_instance_;
};
// -------------------------------------------------------------------

class SparseObjectAttributeTable_SparseObjectAttribute : public ::google::protobuf::Message {
 public:
  SparseObjectAttributeTable_SparseObjectAttribute();
  virtual ~SparseObjectAttributeTable_SparseObjectAttribute();

  SparseObjectAttributeTable_SparseObjectAttribute(const SparseObjectAttributeTable_SparseObjectAttribute& from);

  inline SparseObjectAttributeTable_SparseObjectAttribute& operator=(const SparseObjectAttributeTable_SparseObjectAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseObjectAttributeTable_SparseObjectAttribute& default_instance();

  void Swap(SparseObjectAttributeTable_SparseObjectAttribute* other);

  // implements Message ----------------------------------------------

  SparseObjectAttributeTable_SparseObjectAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparseObjectAttributeTable_SparseObjectAttribute& from);
  void MergeFrom(const SparseObjectAttributeTable_SparseObjectAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_index = 1;
  inline bool has_character_index() const;
  inline void clear_character_index();
  static const int kCharacterIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 character_index() const;
  inline void set_character_index(::google::protobuf::uint32 value);

  // optional .TSP.Reference object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // required uint32 run_length = 3;
  inline bool has_run_length() const;
  inline void clear_run_length();
  static const int kRunLengthFieldNumber = 3;
  inline ::google::protobuf::uint32 run_length() const;
  inline void set_run_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.SparseObjectAttributeTable.SparseObjectAttribute)
 private:
  inline void set_has_character_index();
  inline void clear_has_character_index();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_run_length();
  inline void clear_has_run_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* object_;
  ::google::protobuf::uint32 character_index_;
  ::google::protobuf::uint32 run_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static SparseObjectAttributeTable_SparseObjectAttribute* default_instance_;
};
// -------------------------------------------------------------------

class SparseObjectAttributeTable : public ::google::protobuf::Message {
 public:
  SparseObjectAttributeTable();
  virtual ~SparseObjectAttributeTable();

  SparseObjectAttributeTable(const SparseObjectAttributeTable& from);

  inline SparseObjectAttributeTable& operator=(const SparseObjectAttributeTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseObjectAttributeTable& default_instance();

  void Swap(SparseObjectAttributeTable* other);

  // implements Message ----------------------------------------------

  SparseObjectAttributeTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparseObjectAttributeTable& from);
  void MergeFrom(const SparseObjectAttributeTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SparseObjectAttributeTable_SparseObjectAttribute SparseObjectAttribute;

  // accessors -------------------------------------------------------

  // required uint32 total_count = 1;
  inline bool has_total_count() const;
  inline void clear_total_count();
  static const int kTotalCountFieldNumber = 1;
  inline ::google::protobuf::uint32 total_count() const;
  inline void set_total_count(::google::protobuf::uint32 value);

  // repeated .TSWP.SparseObjectAttributeTable.SparseObjectAttribute entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute& entries(int index) const;
  inline ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute* mutable_entries(int index);
  inline ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSWP.SparseObjectAttributeTable)
 private:
  inline void set_has_total_count();
  inline void clear_has_total_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute > entries_;
  ::google::protobuf::uint32 total_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static SparseObjectAttributeTable* default_instance_;
};
// -------------------------------------------------------------------

class StorageArchive : public ::google::protobuf::Message {
 public:
  StorageArchive();
  virtual ~StorageArchive();

  StorageArchive(const StorageArchive& from);

  inline StorageArchive& operator=(const StorageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageArchive& default_instance();

  void Swap(StorageArchive* other);

  // implements Message ----------------------------------------------

  StorageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageArchive& from);
  void MergeFrom(const StorageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StorageArchive_KindType KindType;
  static const KindType BODY = StorageArchive_KindType_BODY;
  static const KindType HEADER = StorageArchive_KindType_HEADER;
  static const KindType FOOTNOTE = StorageArchive_KindType_FOOTNOTE;
  static const KindType TEXTBOX = StorageArchive_KindType_TEXTBOX;
  static const KindType NOTE = StorageArchive_KindType_NOTE;
  static const KindType CELL = StorageArchive_KindType_CELL;
  static const KindType UNCLASSIFIED = StorageArchive_KindType_UNCLASSIFIED;
  static const KindType TABLEOFCONTENTS = StorageArchive_KindType_TABLEOFCONTENTS;
  static inline bool KindType_IsValid(int value) {
    return StorageArchive_KindType_IsValid(value);
  }
  static const KindType KindType_MIN =
    StorageArchive_KindType_KindType_MIN;
  static const KindType KindType_MAX =
    StorageArchive_KindType_KindType_MAX;
  static const int KindType_ARRAYSIZE =
    StorageArchive_KindType_KindType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KindType_descriptor() {
    return StorageArchive_KindType_descriptor();
  }
  static inline const ::std::string& KindType_Name(KindType value) {
    return StorageArchive_KindType_Name(value);
  }
  static inline bool KindType_Parse(const ::std::string& name,
      KindType* value) {
    return StorageArchive_KindType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSWP.StorageArchive.KindType kind = 1 [default = TEXTBOX];
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::TSWP::StorageArchive_KindType kind() const;
  inline void set_kind(::TSWP::StorageArchive_KindType value);

  // optional .TSP.Reference style_sheet = 2;
  inline bool has_style_sheet() const;
  inline void clear_style_sheet();
  static const int kStyleSheetFieldNumber = 2;
  inline const ::TSP::Reference& style_sheet() const;
  inline ::TSP::Reference* mutable_style_sheet();
  inline ::TSP::Reference* release_style_sheet();
  inline void set_allocated_style_sheet(::TSP::Reference* style_sheet);

  // repeated string text = 3;
  inline int text_size() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text(int index) const;
  inline ::std::string* mutable_text(int index);
  inline void set_text(int index, const ::std::string& value);
  inline void set_text(int index, const char* value);
  inline void set_text(int index, const char* value, size_t size);
  inline ::std::string* add_text();
  inline void add_text(const ::std::string& value);
  inline void add_text(const char* value);
  inline void add_text(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();

  // optional bool has_itext = 4 [default = false];
  inline bool has_has_itext() const;
  inline void clear_has_itext();
  static const int kHasItextFieldNumber = 4;
  inline bool has_itext() const;
  inline void set_has_itext(bool value);

  // optional bool in_document = 10 [default = false];
  inline bool has_in_document() const;
  inline void clear_in_document();
  static const int kInDocumentFieldNumber = 10;
  inline bool in_document() const;
  inline void set_in_document(bool value);

  // optional .TSWP.ObjectAttributeTable table_para_style = 5;
  inline bool has_table_para_style() const;
  inline void clear_table_para_style();
  static const int kTableParaStyleFieldNumber = 5;
  inline const ::TSWP::ObjectAttributeTable& table_para_style() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_para_style();
  inline ::TSWP::ObjectAttributeTable* release_table_para_style();
  inline void set_allocated_table_para_style(::TSWP::ObjectAttributeTable* table_para_style);

  // optional .TSWP.ParaDataAttributeTable table_para_data = 6;
  inline bool has_table_para_data() const;
  inline void clear_table_para_data();
  static const int kTableParaDataFieldNumber = 6;
  inline const ::TSWP::ParaDataAttributeTable& table_para_data() const;
  inline ::TSWP::ParaDataAttributeTable* mutable_table_para_data();
  inline ::TSWP::ParaDataAttributeTable* release_table_para_data();
  inline void set_allocated_table_para_data(::TSWP::ParaDataAttributeTable* table_para_data);

  // optional .TSWP.ObjectAttributeTable table_list_style = 7;
  inline bool has_table_list_style() const;
  inline void clear_table_list_style();
  static const int kTableListStyleFieldNumber = 7;
  inline const ::TSWP::ObjectAttributeTable& table_list_style() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_list_style();
  inline ::TSWP::ObjectAttributeTable* release_table_list_style();
  inline void set_allocated_table_list_style(::TSWP::ObjectAttributeTable* table_list_style);

  // optional .TSWP.ObjectAttributeTable table_char_style = 8;
  inline bool has_table_char_style() const;
  inline void clear_table_char_style();
  static const int kTableCharStyleFieldNumber = 8;
  inline const ::TSWP::ObjectAttributeTable& table_char_style() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_char_style();
  inline ::TSWP::ObjectAttributeTable* release_table_char_style();
  inline void set_allocated_table_char_style(::TSWP::ObjectAttributeTable* table_char_style);

  // optional .TSWP.ObjectAttributeTable table_attachment = 9;
  inline bool has_table_attachment() const;
  inline void clear_table_attachment();
  static const int kTableAttachmentFieldNumber = 9;
  inline const ::TSWP::ObjectAttributeTable& table_attachment() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_attachment();
  inline ::TSWP::ObjectAttributeTable* release_table_attachment();
  inline void set_allocated_table_attachment(::TSWP::ObjectAttributeTable* table_attachment);

  // optional .TSWP.ObjectAttributeTable table_smartfield = 11;
  inline bool has_table_smartfield() const;
  inline void clear_table_smartfield();
  static const int kTableSmartfieldFieldNumber = 11;
  inline const ::TSWP::ObjectAttributeTable& table_smartfield() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_smartfield();
  inline ::TSWP::ObjectAttributeTable* release_table_smartfield();
  inline void set_allocated_table_smartfield(::TSWP::ObjectAttributeTable* table_smartfield);

  // optional .TSWP.ObjectAttributeTable table_layout_style = 12;
  inline bool has_table_layout_style() const;
  inline void clear_table_layout_style();
  static const int kTableLayoutStyleFieldNumber = 12;
  inline const ::TSWP::ObjectAttributeTable& table_layout_style() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_layout_style();
  inline ::TSWP::ObjectAttributeTable* release_table_layout_style();
  inline void set_allocated_table_layout_style(::TSWP::ObjectAttributeTable* table_layout_style);

  // optional .TSWP.ParaDataAttributeTable table_para_starts = 14;
  inline bool has_table_para_starts() const;
  inline void clear_table_para_starts();
  static const int kTableParaStartsFieldNumber = 14;
  inline const ::TSWP::ParaDataAttributeTable& table_para_starts() const;
  inline ::TSWP::ParaDataAttributeTable* mutable_table_para_starts();
  inline ::TSWP::ParaDataAttributeTable* release_table_para_starts();
  inline void set_allocated_table_para_starts(::TSWP::ParaDataAttributeTable* table_para_starts);

  // optional .TSWP.ObjectAttributeTable table_bookmark = 15;
  inline bool has_table_bookmark() const;
  inline void clear_table_bookmark();
  static const int kTableBookmarkFieldNumber = 15;
  inline const ::TSWP::ObjectAttributeTable& table_bookmark() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_bookmark();
  inline ::TSWP::ObjectAttributeTable* release_table_bookmark();
  inline void set_allocated_table_bookmark(::TSWP::ObjectAttributeTable* table_bookmark);

  // optional .TSWP.ObjectAttributeTable table_footnote = 16;
  inline bool has_table_footnote() const;
  inline void clear_table_footnote();
  static const int kTableFootnoteFieldNumber = 16;
  inline const ::TSWP::ObjectAttributeTable& table_footnote() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_footnote();
  inline ::TSWP::ObjectAttributeTable* release_table_footnote();
  inline void set_allocated_table_footnote(::TSWP::ObjectAttributeTable* table_footnote);

  // optional .TSWP.ObjectAttributeTable table_section = 17;
  inline bool has_table_section() const;
  inline void clear_table_section();
  static const int kTableSectionFieldNumber = 17;
  inline const ::TSWP::ObjectAttributeTable& table_section() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_section();
  inline ::TSWP::ObjectAttributeTable* release_table_section();
  inline void set_allocated_table_section(::TSWP::ObjectAttributeTable* table_section);

  // optional .TSWP.ObjectAttributeTable table_rubyfield = 18;
  inline bool has_table_rubyfield() const;
  inline void clear_table_rubyfield();
  static const int kTableRubyfieldFieldNumber = 18;
  inline const ::TSWP::ObjectAttributeTable& table_rubyfield() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_rubyfield();
  inline ::TSWP::ObjectAttributeTable* release_table_rubyfield();
  inline void set_allocated_table_rubyfield(::TSWP::ObjectAttributeTable* table_rubyfield);

  // optional .TSWP.StringAttributeTable table_language = 19;
  inline bool has_table_language() const;
  inline void clear_table_language();
  static const int kTableLanguageFieldNumber = 19;
  inline const ::TSWP::StringAttributeTable& table_language() const;
  inline ::TSWP::StringAttributeTable* mutable_table_language();
  inline ::TSWP::StringAttributeTable* release_table_language();
  inline void set_allocated_table_language(::TSWP::StringAttributeTable* table_language);

  // optional .TSWP.StringAttributeTable table_dictation = 20;
  inline bool has_table_dictation() const;
  inline void clear_table_dictation();
  static const int kTableDictationFieldNumber = 20;
  inline const ::TSWP::StringAttributeTable& table_dictation() const;
  inline ::TSWP::StringAttributeTable* mutable_table_dictation();
  inline ::TSWP::StringAttributeTable* release_table_dictation();
  inline void set_allocated_table_dictation(::TSWP::StringAttributeTable* table_dictation);

  // optional .TSWP.ObjectAttributeTable table_insertion = 21;
  inline bool has_table_insertion() const;
  inline void clear_table_insertion();
  static const int kTableInsertionFieldNumber = 21;
  inline const ::TSWP::ObjectAttributeTable& table_insertion() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_insertion();
  inline ::TSWP::ObjectAttributeTable* release_table_insertion();
  inline void set_allocated_table_insertion(::TSWP::ObjectAttributeTable* table_insertion);

  // optional .TSWP.ObjectAttributeTable table_deletion = 22;
  inline bool has_table_deletion() const;
  inline void clear_table_deletion();
  static const int kTableDeletionFieldNumber = 22;
  inline const ::TSWP::ObjectAttributeTable& table_deletion() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_deletion();
  inline ::TSWP::ObjectAttributeTable* release_table_deletion();
  inline void set_allocated_table_deletion(::TSWP::ObjectAttributeTable* table_deletion);

  // optional .TSWP.ObjectAttributeTable table_highlight = 23;
  inline bool has_table_highlight() const;
  inline void clear_table_highlight();
  static const int kTableHighlightFieldNumber = 23;
  inline const ::TSWP::ObjectAttributeTable& table_highlight() const;
  inline ::TSWP::ObjectAttributeTable* mutable_table_highlight();
  inline ::TSWP::ObjectAttributeTable* release_table_highlight();
  inline void set_allocated_table_highlight(::TSWP::ObjectAttributeTable* table_highlight);

  // optional .TSWP.ParaDataAttributeTable table_para_bidi = 24;
  inline bool has_table_para_bidi() const;
  inline void clear_table_para_bidi();
  static const int kTableParaBidiFieldNumber = 24;
  inline const ::TSWP::ParaDataAttributeTable& table_para_bidi() const;
  inline ::TSWP::ParaDataAttributeTable* mutable_table_para_bidi();
  inline ::TSWP::ParaDataAttributeTable* release_table_para_bidi();
  inline void set_allocated_table_para_bidi(::TSWP::ParaDataAttributeTable* table_para_bidi);

  // @@protoc_insertion_point(class_scope:TSWP.StorageArchive)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_style_sheet();
  inline void clear_has_style_sheet();
  inline void set_has_has_itext();
  inline void clear_has_has_itext();
  inline void set_has_in_document();
  inline void clear_has_in_document();
  inline void set_has_table_para_style();
  inline void clear_has_table_para_style();
  inline void set_has_table_para_data();
  inline void clear_has_table_para_data();
  inline void set_has_table_list_style();
  inline void clear_has_table_list_style();
  inline void set_has_table_char_style();
  inline void clear_has_table_char_style();
  inline void set_has_table_attachment();
  inline void clear_has_table_attachment();
  inline void set_has_table_smartfield();
  inline void clear_has_table_smartfield();
  inline void set_has_table_layout_style();
  inline void clear_has_table_layout_style();
  inline void set_has_table_para_starts();
  inline void clear_has_table_para_starts();
  inline void set_has_table_bookmark();
  inline void clear_has_table_bookmark();
  inline void set_has_table_footnote();
  inline void clear_has_table_footnote();
  inline void set_has_table_section();
  inline void clear_has_table_section();
  inline void set_has_table_rubyfield();
  inline void clear_has_table_rubyfield();
  inline void set_has_table_language();
  inline void clear_has_table_language();
  inline void set_has_table_dictation();
  inline void clear_has_table_dictation();
  inline void set_has_table_insertion();
  inline void clear_has_table_insertion();
  inline void set_has_table_deletion();
  inline void clear_has_table_deletion();
  inline void set_has_table_highlight();
  inline void clear_has_table_highlight();
  inline void set_has_table_para_bidi();
  inline void clear_has_table_para_bidi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* style_sheet_;
  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  int kind_;
  bool has_itext_;
  bool in_document_;
  ::TSWP::ObjectAttributeTable* table_para_style_;
  ::TSWP::ParaDataAttributeTable* table_para_data_;
  ::TSWP::ObjectAttributeTable* table_list_style_;
  ::TSWP::ObjectAttributeTable* table_char_style_;
  ::TSWP::ObjectAttributeTable* table_attachment_;
  ::TSWP::ObjectAttributeTable* table_smartfield_;
  ::TSWP::ObjectAttributeTable* table_layout_style_;
  ::TSWP::ParaDataAttributeTable* table_para_starts_;
  ::TSWP::ObjectAttributeTable* table_bookmark_;
  ::TSWP::ObjectAttributeTable* table_footnote_;
  ::TSWP::ObjectAttributeTable* table_section_;
  ::TSWP::ObjectAttributeTable* table_rubyfield_;
  ::TSWP::StringAttributeTable* table_language_;
  ::TSWP::StringAttributeTable* table_dictation_;
  ::TSWP::ObjectAttributeTable* table_insertion_;
  ::TSWP::ObjectAttributeTable* table_deletion_;
  ::TSWP::ObjectAttributeTable* table_highlight_;
  ::TSWP::ParaDataAttributeTable* table_para_bidi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static StorageArchive* default_instance_;
};
// -------------------------------------------------------------------

class HighlightArchive : public ::google::protobuf::Message {
 public:
  HighlightArchive();
  virtual ~HighlightArchive();

  HighlightArchive(const HighlightArchive& from);

  inline HighlightArchive& operator=(const HighlightArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HighlightArchive& default_instance();

  void Swap(HighlightArchive* other);

  // implements Message ----------------------------------------------

  HighlightArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HighlightArchive& from);
  void MergeFrom(const HighlightArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference commentStorage = 1;
  inline bool has_commentstorage() const;
  inline void clear_commentstorage();
  static const int kCommentStorageFieldNumber = 1;
  inline const ::TSP::Reference& commentstorage() const;
  inline ::TSP::Reference* mutable_commentstorage();
  inline ::TSP::Reference* release_commentstorage();
  inline void set_allocated_commentstorage(::TSP::Reference* commentstorage);

  // @@protoc_insertion_point(class_scope:TSWP.HighlightArchive)
 private:
  inline void set_has_commentstorage();
  inline void clear_has_commentstorage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* commentstorage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static HighlightArchive* default_instance_;
};
// -------------------------------------------------------------------

class FontFeatureArchive : public ::google::protobuf::Message {
 public:
  FontFeatureArchive();
  virtual ~FontFeatureArchive();

  FontFeatureArchive(const FontFeatureArchive& from);

  inline FontFeatureArchive& operator=(const FontFeatureArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FontFeatureArchive& default_instance();

  void Swap(FontFeatureArchive* other);

  // implements Message ----------------------------------------------

  FontFeatureArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FontFeatureArchive& from);
  void MergeFrom(const FontFeatureArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 feature_type = 1;
  inline bool has_feature_type() const;
  inline void clear_feature_type();
  static const int kFeatureTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 feature_type() const;
  inline void set_feature_type(::google::protobuf::uint32 value);

  // required uint32 feature_selector = 2;
  inline bool has_feature_selector() const;
  inline void clear_feature_selector();
  static const int kFeatureSelectorFieldNumber = 2;
  inline ::google::protobuf::uint32 feature_selector() const;
  inline void set_feature_selector(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.FontFeatureArchive)
 private:
  inline void set_has_feature_type();
  inline void clear_has_feature_type();
  inline void set_has_feature_selector();
  inline void clear_has_feature_selector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 feature_type_;
  ::google::protobuf::uint32 feature_selector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static FontFeatureArchive* default_instance_;
};
// -------------------------------------------------------------------

class CharacterStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  CharacterStylePropertiesArchive();
  virtual ~CharacterStylePropertiesArchive();

  CharacterStylePropertiesArchive(const CharacterStylePropertiesArchive& from);

  inline CharacterStylePropertiesArchive& operator=(const CharacterStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterStylePropertiesArchive& default_instance();

  void Swap(CharacterStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  CharacterStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterStylePropertiesArchive& from);
  void MergeFrom(const CharacterStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CharacterStylePropertiesArchive_CapitalizationType CapitalizationType;
  static const CapitalizationType kNoCaps = CharacterStylePropertiesArchive_CapitalizationType_kNoCaps;
  static const CapitalizationType kAllCaps = CharacterStylePropertiesArchive_CapitalizationType_kAllCaps;
  static const CapitalizationType kSmallCaps = CharacterStylePropertiesArchive_CapitalizationType_kSmallCaps;
  static const CapitalizationType kTitled = CharacterStylePropertiesArchive_CapitalizationType_kTitled;
  static inline bool CapitalizationType_IsValid(int value) {
    return CharacterStylePropertiesArchive_CapitalizationType_IsValid(value);
  }
  static const CapitalizationType CapitalizationType_MIN =
    CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_MIN;
  static const CapitalizationType CapitalizationType_MAX =
    CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_MAX;
  static const int CapitalizationType_ARRAYSIZE =
    CharacterStylePropertiesArchive_CapitalizationType_CapitalizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CapitalizationType_descriptor() {
    return CharacterStylePropertiesArchive_CapitalizationType_descriptor();
  }
  static inline const ::std::string& CapitalizationType_Name(CapitalizationType value) {
    return CharacterStylePropertiesArchive_CapitalizationType_Name(value);
  }
  static inline bool CapitalizationType_Parse(const ::std::string& name,
      CapitalizationType* value) {
    return CharacterStylePropertiesArchive_CapitalizationType_Parse(name, value);
  }

  typedef CharacterStylePropertiesArchive_UnderlineType UnderlineType;
  static const UnderlineType kNoUnderline = CharacterStylePropertiesArchive_UnderlineType_kNoUnderline;
  static const UnderlineType kSingleUnderline = CharacterStylePropertiesArchive_UnderlineType_kSingleUnderline;
  static const UnderlineType kDoubleUnderline = CharacterStylePropertiesArchive_UnderlineType_kDoubleUnderline;
  static const UnderlineType kWavyUnderline = CharacterStylePropertiesArchive_UnderlineType_kWavyUnderline;
  static inline bool UnderlineType_IsValid(int value) {
    return CharacterStylePropertiesArchive_UnderlineType_IsValid(value);
  }
  static const UnderlineType UnderlineType_MIN =
    CharacterStylePropertiesArchive_UnderlineType_UnderlineType_MIN;
  static const UnderlineType UnderlineType_MAX =
    CharacterStylePropertiesArchive_UnderlineType_UnderlineType_MAX;
  static const int UnderlineType_ARRAYSIZE =
    CharacterStylePropertiesArchive_UnderlineType_UnderlineType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UnderlineType_descriptor() {
    return CharacterStylePropertiesArchive_UnderlineType_descriptor();
  }
  static inline const ::std::string& UnderlineType_Name(UnderlineType value) {
    return CharacterStylePropertiesArchive_UnderlineType_Name(value);
  }
  static inline bool UnderlineType_Parse(const ::std::string& name,
      UnderlineType* value) {
    return CharacterStylePropertiesArchive_UnderlineType_Parse(name, value);
  }

  typedef CharacterStylePropertiesArchive_LigaturesType LigaturesType;
  static const LigaturesType kRequiredLigatures = CharacterStylePropertiesArchive_LigaturesType_kRequiredLigatures;
  static const LigaturesType kStandardLigatures = CharacterStylePropertiesArchive_LigaturesType_kStandardLigatures;
  static const LigaturesType kAllLigatures = CharacterStylePropertiesArchive_LigaturesType_kAllLigatures;
  static inline bool LigaturesType_IsValid(int value) {
    return CharacterStylePropertiesArchive_LigaturesType_IsValid(value);
  }
  static const LigaturesType LigaturesType_MIN =
    CharacterStylePropertiesArchive_LigaturesType_LigaturesType_MIN;
  static const LigaturesType LigaturesType_MAX =
    CharacterStylePropertiesArchive_LigaturesType_LigaturesType_MAX;
  static const int LigaturesType_ARRAYSIZE =
    CharacterStylePropertiesArchive_LigaturesType_LigaturesType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LigaturesType_descriptor() {
    return CharacterStylePropertiesArchive_LigaturesType_descriptor();
  }
  static inline const ::std::string& LigaturesType_Name(LigaturesType value) {
    return CharacterStylePropertiesArchive_LigaturesType_Name(value);
  }
  static inline bool LigaturesType_Parse(const ::std::string& name,
      LigaturesType* value) {
    return CharacterStylePropertiesArchive_LigaturesType_Parse(name, value);
  }

  typedef CharacterStylePropertiesArchive_StrikethruType StrikethruType;
  static const StrikethruType kNoStrikethru = CharacterStylePropertiesArchive_StrikethruType_kNoStrikethru;
  static const StrikethruType kSingleStrikethru = CharacterStylePropertiesArchive_StrikethruType_kSingleStrikethru;
  static const StrikethruType kDoubleStrikethru = CharacterStylePropertiesArchive_StrikethruType_kDoubleStrikethru;
  static const StrikethruType kTripleStrikethru = CharacterStylePropertiesArchive_StrikethruType_kTripleStrikethru;
  static inline bool StrikethruType_IsValid(int value) {
    return CharacterStylePropertiesArchive_StrikethruType_IsValid(value);
  }
  static const StrikethruType StrikethruType_MIN =
    CharacterStylePropertiesArchive_StrikethruType_StrikethruType_MIN;
  static const StrikethruType StrikethruType_MAX =
    CharacterStylePropertiesArchive_StrikethruType_StrikethruType_MAX;
  static const int StrikethruType_ARRAYSIZE =
    CharacterStylePropertiesArchive_StrikethruType_StrikethruType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StrikethruType_descriptor() {
    return CharacterStylePropertiesArchive_StrikethruType_descriptor();
  }
  static inline const ::std::string& StrikethruType_Name(StrikethruType value) {
    return CharacterStylePropertiesArchive_StrikethruType_Name(value);
  }
  static inline bool StrikethruType_Parse(const ::std::string& name,
      StrikethruType* value) {
    return CharacterStylePropertiesArchive_StrikethruType_Parse(name, value);
  }

  typedef CharacterStylePropertiesArchive_SuperscriptType SuperscriptType;
  static const SuperscriptType kNoScript = CharacterStylePropertiesArchive_SuperscriptType_kNoScript;
  static const SuperscriptType kSuperscript = CharacterStylePropertiesArchive_SuperscriptType_kSuperscript;
  static const SuperscriptType kSubscript = CharacterStylePropertiesArchive_SuperscriptType_kSubscript;
  static inline bool SuperscriptType_IsValid(int value) {
    return CharacterStylePropertiesArchive_SuperscriptType_IsValid(value);
  }
  static const SuperscriptType SuperscriptType_MIN =
    CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_MIN;
  static const SuperscriptType SuperscriptType_MAX =
    CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_MAX;
  static const int SuperscriptType_ARRAYSIZE =
    CharacterStylePropertiesArchive_SuperscriptType_SuperscriptType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SuperscriptType_descriptor() {
    return CharacterStylePropertiesArchive_SuperscriptType_descriptor();
  }
  static inline const ::std::string& SuperscriptType_Name(SuperscriptType value) {
    return CharacterStylePropertiesArchive_SuperscriptType_Name(value);
  }
  static inline bool SuperscriptType_Parse(const ::std::string& name,
      SuperscriptType* value) {
    return CharacterStylePropertiesArchive_SuperscriptType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool bold = 1;
  inline bool has_bold() const;
  inline void clear_bold();
  static const int kBoldFieldNumber = 1;
  inline bool bold() const;
  inline void set_bold(bool value);

  // optional bool italic = 2;
  inline bool has_italic() const;
  inline void clear_italic();
  static const int kItalicFieldNumber = 2;
  inline bool italic() const;
  inline void set_italic(bool value);

  // optional float font_size = 3;
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 3;
  inline float font_size() const;
  inline void set_font_size(float value);

  // optional bool font_name_null = 4;
  inline bool has_font_name_null() const;
  inline void clear_font_name_null();
  static const int kFontNameNullFieldNumber = 4;
  inline bool font_name_null() const;
  inline void set_font_name_null(bool value);

  // optional string font_name = 5;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 5;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  inline ::std::string* release_font_name();
  inline void set_allocated_font_name(::std::string* font_name);

  // optional bool font_color_null = 6;
  inline bool has_font_color_null() const;
  inline void clear_font_color_null();
  static const int kFontColorNullFieldNumber = 6;
  inline bool font_color_null() const;
  inline void set_font_color_null(bool value);

  // optional .TSP.Color font_color = 7;
  inline bool has_font_color() const;
  inline void clear_font_color();
  static const int kFontColorFieldNumber = 7;
  inline const ::TSP::Color& font_color() const;
  inline ::TSP::Color* mutable_font_color();
  inline ::TSP::Color* release_font_color();
  inline void set_allocated_font_color(::TSP::Color* font_color);

  // optional bool language_null = 8;
  inline bool has_language_null() const;
  inline void clear_language_null();
  static const int kLanguageNullFieldNumber = 8;
  inline bool language_null() const;
  inline void set_language_null(bool value);

  // optional string language = 9;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 9;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional .TSWP.CharacterStylePropertiesArchive.SuperscriptType superscript = 10;
  inline bool has_superscript() const;
  inline void clear_superscript();
  static const int kSuperscriptFieldNumber = 10;
  inline ::TSWP::CharacterStylePropertiesArchive_SuperscriptType superscript() const;
  inline void set_superscript(::TSWP::CharacterStylePropertiesArchive_SuperscriptType value);

  // optional .TSWP.CharacterStylePropertiesArchive.UnderlineType underline = 11;
  inline bool has_underline() const;
  inline void clear_underline();
  static const int kUnderlineFieldNumber = 11;
  inline ::TSWP::CharacterStylePropertiesArchive_UnderlineType underline() const;
  inline void set_underline(::TSWP::CharacterStylePropertiesArchive_UnderlineType value);

  // optional .TSWP.CharacterStylePropertiesArchive.StrikethruType strikethru = 12;
  inline bool has_strikethru() const;
  inline void clear_strikethru();
  static const int kStrikethruFieldNumber = 12;
  inline ::TSWP::CharacterStylePropertiesArchive_StrikethruType strikethru() const;
  inline void set_strikethru(::TSWP::CharacterStylePropertiesArchive_StrikethruType value);

  // optional .TSWP.CharacterStylePropertiesArchive.CapitalizationType capitalization = 13;
  inline bool has_capitalization() const;
  inline void clear_capitalization();
  static const int kCapitalizationFieldNumber = 13;
  inline ::TSWP::CharacterStylePropertiesArchive_CapitalizationType capitalization() const;
  inline void set_capitalization(::TSWP::CharacterStylePropertiesArchive_CapitalizationType value);

  // optional float baseline_shift = 14;
  inline bool has_baseline_shift() const;
  inline void clear_baseline_shift();
  static const int kBaselineShiftFieldNumber = 14;
  inline float baseline_shift() const;
  inline void set_baseline_shift(float value);

  // optional float kerning = 15;
  inline bool has_kerning() const;
  inline void clear_kerning();
  static const int kKerningFieldNumber = 15;
  inline float kerning() const;
  inline void set_kerning(float value);

  // optional .TSWP.CharacterStylePropertiesArchive.LigaturesType ligatures = 16;
  inline bool has_ligatures() const;
  inline void clear_ligatures();
  static const int kLigaturesFieldNumber = 16;
  inline ::TSWP::CharacterStylePropertiesArchive_LigaturesType ligatures() const;
  inline void set_ligatures(::TSWP::CharacterStylePropertiesArchive_LigaturesType value);

  // optional bool outline_color_null = 17;
  inline bool has_outline_color_null() const;
  inline void clear_outline_color_null();
  static const int kOutlineColorNullFieldNumber = 17;
  inline bool outline_color_null() const;
  inline void set_outline_color_null(bool value);

  // optional .TSP.Color outline_color = 18;
  inline bool has_outline_color() const;
  inline void clear_outline_color();
  static const int kOutlineColorFieldNumber = 18;
  inline const ::TSP::Color& outline_color() const;
  inline ::TSP::Color* mutable_outline_color();
  inline ::TSP::Color* release_outline_color();
  inline void set_allocated_outline_color(::TSP::Color* outline_color);

  // optional float outline = 19;
  inline bool has_outline() const;
  inline void clear_outline();
  static const int kOutlineFieldNumber = 19;
  inline float outline() const;
  inline void set_outline(float value);

  // optional bool shadow_null = 20;
  inline bool has_shadow_null() const;
  inline void clear_shadow_null();
  static const int kShadowNullFieldNumber = 20;
  inline bool shadow_null() const;
  inline void set_shadow_null(bool value);

  // optional .TSD.ShadowArchive shadow = 21;
  inline bool has_shadow() const;
  inline void clear_shadow();
  static const int kShadowFieldNumber = 21;
  inline const ::TSD::ShadowArchive& shadow() const;
  inline ::TSD::ShadowArchive* mutable_shadow();
  inline ::TSD::ShadowArchive* release_shadow();
  inline void set_allocated_shadow(::TSD::ShadowArchive* shadow);

  // optional bool strikethru_color_null = 22;
  inline bool has_strikethru_color_null() const;
  inline void clear_strikethru_color_null();
  static const int kStrikethruColorNullFieldNumber = 22;
  inline bool strikethru_color_null() const;
  inline void set_strikethru_color_null(bool value);

  // optional .TSP.Color strikethru_color = 23;
  inline bool has_strikethru_color() const;
  inline void clear_strikethru_color();
  static const int kStrikethruColorFieldNumber = 23;
  inline const ::TSP::Color& strikethru_color() const;
  inline ::TSP::Color* mutable_strikethru_color();
  inline ::TSP::Color* release_strikethru_color();
  inline void set_allocated_strikethru_color(::TSP::Color* strikethru_color);

  // optional float strikethru_width = 24;
  inline bool has_strikethru_width() const;
  inline void clear_strikethru_width();
  static const int kStrikethruWidthFieldNumber = 24;
  inline float strikethru_width() const;
  inline void set_strikethru_width(float value);

  // optional bool background_color_null = 25;
  inline bool has_background_color_null() const;
  inline void clear_background_color_null();
  static const int kBackgroundColorNullFieldNumber = 25;
  inline bool background_color_null() const;
  inline void set_background_color_null(bool value);

  // optional .TSP.Color background_color = 26;
  inline bool has_background_color() const;
  inline void clear_background_color();
  static const int kBackgroundColorFieldNumber = 26;
  inline const ::TSP::Color& background_color() const;
  inline ::TSP::Color* mutable_background_color();
  inline ::TSP::Color* release_background_color();
  inline void set_allocated_background_color(::TSP::Color* background_color);

  // optional float tracking = 27;
  inline bool has_tracking() const;
  inline void clear_tracking();
  static const int kTrackingFieldNumber = 27;
  inline float tracking() const;
  inline void set_tracking(float value);

  // optional bool underline_color_null = 28;
  inline bool has_underline_color_null() const;
  inline void clear_underline_color_null();
  static const int kUnderlineColorNullFieldNumber = 28;
  inline bool underline_color_null() const;
  inline void set_underline_color_null(bool value);

  // optional .TSP.Color underline_color = 29;
  inline bool has_underline_color() const;
  inline void clear_underline_color();
  static const int kUnderlineColorFieldNumber = 29;
  inline const ::TSP::Color& underline_color() const;
  inline ::TSP::Color* mutable_underline_color();
  inline ::TSP::Color* release_underline_color();
  inline void set_allocated_underline_color(::TSP::Color* underline_color);

  // optional float underline_width = 30;
  inline bool has_underline_width() const;
  inline void clear_underline_width();
  static const int kUnderlineWidthFieldNumber = 30;
  inline float underline_width() const;
  inline void set_underline_width(float value);

  // optional bool word_strikethru = 31;
  inline bool has_word_strikethru() const;
  inline void clear_word_strikethru();
  static const int kWordStrikethruFieldNumber = 31;
  inline bool word_strikethru() const;
  inline void set_word_strikethru(bool value);

  // optional bool word_underline = 32;
  inline bool has_word_underline() const;
  inline void clear_word_underline();
  static const int kWordUnderlineFieldNumber = 32;
  inline bool word_underline() const;
  inline void set_word_underline(bool value);

  // optional bool font_features_null = 33;
  inline bool has_font_features_null() const;
  inline void clear_font_features_null();
  static const int kFontFeaturesNullFieldNumber = 33;
  inline bool font_features_null() const;
  inline void set_font_features_null(bool value);

  // repeated .TSWP.FontFeatureArchive font_features = 34;
  inline int font_features_size() const;
  inline void clear_font_features();
  static const int kFontFeaturesFieldNumber = 34;
  inline const ::TSWP::FontFeatureArchive& font_features(int index) const;
  inline ::TSWP::FontFeatureArchive* mutable_font_features(int index);
  inline ::TSWP::FontFeatureArchive* add_font_features();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::FontFeatureArchive >&
      font_features() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::FontFeatureArchive >*
      mutable_font_features();

  // optional .TSWP.WritingDirectionType writing_direction = 35 [default = kWritingDirectionNatural];
  inline bool has_writing_direction() const;
  inline void clear_writing_direction();
  static const int kWritingDirectionFieldNumber = 35;
  inline ::TSWP::WritingDirectionType writing_direction() const;
  inline void set_writing_direction(::TSWP::WritingDirectionType value);

  // optional bool emphasis_marks_null = 36;
  inline bool has_emphasis_marks_null() const;
  inline void clear_emphasis_marks_null();
  static const int kEmphasisMarksNullFieldNumber = 36;
  inline bool emphasis_marks_null() const;
  inline void set_emphasis_marks_null(bool value);

  // optional string emphasis_marks = 37;
  inline bool has_emphasis_marks() const;
  inline void clear_emphasis_marks();
  static const int kEmphasisMarksFieldNumber = 37;
  inline const ::std::string& emphasis_marks() const;
  inline void set_emphasis_marks(const ::std::string& value);
  inline void set_emphasis_marks(const char* value);
  inline void set_emphasis_marks(const char* value, size_t size);
  inline ::std::string* mutable_emphasis_marks();
  inline ::std::string* release_emphasis_marks();
  inline void set_allocated_emphasis_marks(::std::string* emphasis_marks);

  // optional bool compatibility_font_name_null = 38;
  inline bool has_compatibility_font_name_null() const;
  inline void clear_compatibility_font_name_null();
  static const int kCompatibilityFontNameNullFieldNumber = 38;
  inline bool compatibility_font_name_null() const;
  inline void set_compatibility_font_name_null(bool value);

  // optional string compatibility_font_name = 39;
  inline bool has_compatibility_font_name() const;
  inline void clear_compatibility_font_name();
  static const int kCompatibilityFontNameFieldNumber = 39;
  inline const ::std::string& compatibility_font_name() const;
  inline void set_compatibility_font_name(const ::std::string& value);
  inline void set_compatibility_font_name(const char* value);
  inline void set_compatibility_font_name(const char* value, size_t size);
  inline ::std::string* mutable_compatibility_font_name();
  inline ::std::string* release_compatibility_font_name();
  inline void set_allocated_compatibility_font_name(::std::string* compatibility_font_name);

  // @@protoc_insertion_point(class_scope:TSWP.CharacterStylePropertiesArchive)
 private:
  inline void set_has_bold();
  inline void clear_has_bold();
  inline void set_has_italic();
  inline void clear_has_italic();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_font_name_null();
  inline void clear_has_font_name_null();
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_color_null();
  inline void clear_has_font_color_null();
  inline void set_has_font_color();
  inline void clear_has_font_color();
  inline void set_has_language_null();
  inline void clear_has_language_null();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_superscript();
  inline void clear_has_superscript();
  inline void set_has_underline();
  inline void clear_has_underline();
  inline void set_has_strikethru();
  inline void clear_has_strikethru();
  inline void set_has_capitalization();
  inline void clear_has_capitalization();
  inline void set_has_baseline_shift();
  inline void clear_has_baseline_shift();
  inline void set_has_kerning();
  inline void clear_has_kerning();
  inline void set_has_ligatures();
  inline void clear_has_ligatures();
  inline void set_has_outline_color_null();
  inline void clear_has_outline_color_null();
  inline void set_has_outline_color();
  inline void clear_has_outline_color();
  inline void set_has_outline();
  inline void clear_has_outline();
  inline void set_has_shadow_null();
  inline void clear_has_shadow_null();
  inline void set_has_shadow();
  inline void clear_has_shadow();
  inline void set_has_strikethru_color_null();
  inline void clear_has_strikethru_color_null();
  inline void set_has_strikethru_color();
  inline void clear_has_strikethru_color();
  inline void set_has_strikethru_width();
  inline void clear_has_strikethru_width();
  inline void set_has_background_color_null();
  inline void clear_has_background_color_null();
  inline void set_has_background_color();
  inline void clear_has_background_color();
  inline void set_has_tracking();
  inline void clear_has_tracking();
  inline void set_has_underline_color_null();
  inline void clear_has_underline_color_null();
  inline void set_has_underline_color();
  inline void clear_has_underline_color();
  inline void set_has_underline_width();
  inline void clear_has_underline_width();
  inline void set_has_word_strikethru();
  inline void clear_has_word_strikethru();
  inline void set_has_word_underline();
  inline void clear_has_word_underline();
  inline void set_has_font_features_null();
  inline void clear_has_font_features_null();
  inline void set_has_writing_direction();
  inline void clear_has_writing_direction();
  inline void set_has_emphasis_marks_null();
  inline void clear_has_emphasis_marks_null();
  inline void set_has_emphasis_marks();
  inline void clear_has_emphasis_marks();
  inline void set_has_compatibility_font_name_null();
  inline void clear_has_compatibility_font_name_null();
  inline void set_has_compatibility_font_name();
  inline void clear_has_compatibility_font_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float font_size_;
  bool bold_;
  bool italic_;
  bool font_name_null_;
  bool font_color_null_;
  ::std::string* font_name_;
  ::TSP::Color* font_color_;
  ::std::string* language_;
  int superscript_;
  int underline_;
  int strikethru_;
  int capitalization_;
  float baseline_shift_;
  float kerning_;
  int ligatures_;
  bool language_null_;
  bool outline_color_null_;
  bool shadow_null_;
  bool strikethru_color_null_;
  ::TSP::Color* outline_color_;
  ::TSD::ShadowArchive* shadow_;
  float outline_;
  float strikethru_width_;
  ::TSP::Color* strikethru_color_;
  ::TSP::Color* background_color_;
  float tracking_;
  bool background_color_null_;
  bool underline_color_null_;
  bool word_strikethru_;
  bool word_underline_;
  ::TSP::Color* underline_color_;
  float underline_width_;
  int writing_direction_;
  ::google::protobuf::RepeatedPtrField< ::TSWP::FontFeatureArchive > font_features_;
  ::std::string* emphasis_marks_;
  ::std::string* compatibility_font_name_;
  bool font_features_null_;
  bool emphasis_marks_null_;
  bool compatibility_font_name_null_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static CharacterStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CharacterStyleArchive : public ::google::protobuf::Message {
 public:
  CharacterStyleArchive();
  virtual ~CharacterStyleArchive();

  CharacterStyleArchive(const CharacterStyleArchive& from);

  inline CharacterStyleArchive& operator=(const CharacterStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterStyleArchive& default_instance();

  void Swap(CharacterStyleArchive* other);

  // implements Message ----------------------------------------------

  CharacterStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterStyleArchive& from);
  void MergeFrom(const CharacterStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TSWP.CharacterStylePropertiesArchive char_properties = 11;
  inline bool has_char_properties() const;
  inline void clear_char_properties();
  static const int kCharPropertiesFieldNumber = 11;
  inline const ::TSWP::CharacterStylePropertiesArchive& char_properties() const;
  inline ::TSWP::CharacterStylePropertiesArchive* mutable_char_properties();
  inline ::TSWP::CharacterStylePropertiesArchive* release_char_properties();
  inline void set_allocated_char_properties(::TSWP::CharacterStylePropertiesArchive* char_properties);

  // @@protoc_insertion_point(class_scope:TSWP.CharacterStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_char_properties();
  inline void clear_has_char_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TSWP::CharacterStylePropertiesArchive* char_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static CharacterStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class TabArchive : public ::google::protobuf::Message {
 public:
  TabArchive();
  virtual ~TabArchive();

  TabArchive(const TabArchive& from);

  inline TabArchive& operator=(const TabArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TabArchive& default_instance();

  void Swap(TabArchive* other);

  // implements Message ----------------------------------------------

  TabArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TabArchive& from);
  void MergeFrom(const TabArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TabArchive_TabAlignmentType TabAlignmentType;
  static const TabAlignmentType kTabAlignmentLeft = TabArchive_TabAlignmentType_kTabAlignmentLeft;
  static const TabAlignmentType kTabAlignmentCenter = TabArchive_TabAlignmentType_kTabAlignmentCenter;
  static const TabAlignmentType kTabAlignmentRight = TabArchive_TabAlignmentType_kTabAlignmentRight;
  static const TabAlignmentType kTabAlignmentDecimal = TabArchive_TabAlignmentType_kTabAlignmentDecimal;
  static inline bool TabAlignmentType_IsValid(int value) {
    return TabArchive_TabAlignmentType_IsValid(value);
  }
  static const TabAlignmentType TabAlignmentType_MIN =
    TabArchive_TabAlignmentType_TabAlignmentType_MIN;
  static const TabAlignmentType TabAlignmentType_MAX =
    TabArchive_TabAlignmentType_TabAlignmentType_MAX;
  static const int TabAlignmentType_ARRAYSIZE =
    TabArchive_TabAlignmentType_TabAlignmentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TabAlignmentType_descriptor() {
    return TabArchive_TabAlignmentType_descriptor();
  }
  static inline const ::std::string& TabAlignmentType_Name(TabAlignmentType value) {
    return TabArchive_TabAlignmentType_Name(value);
  }
  static inline bool TabAlignmentType_Parse(const ::std::string& name,
      TabAlignmentType* value) {
    return TabArchive_TabAlignmentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline float position() const;
  inline void set_position(float value);

  // optional .TSWP.TabArchive.TabAlignmentType alignment = 2;
  inline bool has_alignment() const;
  inline void clear_alignment();
  static const int kAlignmentFieldNumber = 2;
  inline ::TSWP::TabArchive_TabAlignmentType alignment() const;
  inline void set_alignment(::TSWP::TabArchive_TabAlignmentType value);

  // optional string leader = 3;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 3;
  inline const ::std::string& leader() const;
  inline void set_leader(const ::std::string& value);
  inline void set_leader(const char* value);
  inline void set_leader(const char* value, size_t size);
  inline ::std::string* mutable_leader();
  inline ::std::string* release_leader();
  inline void set_allocated_leader(::std::string* leader);

  // @@protoc_insertion_point(class_scope:TSWP.TabArchive)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_alignment();
  inline void clear_has_alignment();
  inline void set_has_leader();
  inline void clear_has_leader();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float position_;
  int alignment_;
  ::std::string* leader_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TabArchive* default_instance_;
};
// -------------------------------------------------------------------

class TabsArchive : public ::google::protobuf::Message {
 public:
  TabsArchive();
  virtual ~TabsArchive();

  TabsArchive(const TabsArchive& from);

  inline TabsArchive& operator=(const TabsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TabsArchive& default_instance();

  void Swap(TabsArchive* other);

  // implements Message ----------------------------------------------

  TabsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TabsArchive& from);
  void MergeFrom(const TabsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSWP.TabArchive tabs = 1;
  inline int tabs_size() const;
  inline void clear_tabs();
  static const int kTabsFieldNumber = 1;
  inline const ::TSWP::TabArchive& tabs(int index) const;
  inline ::TSWP::TabArchive* mutable_tabs(int index);
  inline ::TSWP::TabArchive* add_tabs();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::TabArchive >&
      tabs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::TabArchive >*
      mutable_tabs();

  // @@protoc_insertion_point(class_scope:TSWP.TabsArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::TabArchive > tabs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TabsArchive* default_instance_;
};
// -------------------------------------------------------------------

class LineSpacingArchive : public ::google::protobuf::Message {
 public:
  LineSpacingArchive();
  virtual ~LineSpacingArchive();

  LineSpacingArchive(const LineSpacingArchive& from);

  inline LineSpacingArchive& operator=(const LineSpacingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineSpacingArchive& default_instance();

  void Swap(LineSpacingArchive* other);

  // implements Message ----------------------------------------------

  LineSpacingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineSpacingArchive& from);
  void MergeFrom(const LineSpacingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LineSpacingArchive_LineSpacingModeType LineSpacingModeType;
  static const LineSpacingModeType kRelativeLineSpacing = LineSpacingArchive_LineSpacingModeType_kRelativeLineSpacing;
  static const LineSpacingModeType kMinimumLineSpacing = LineSpacingArchive_LineSpacingModeType_kMinimumLineSpacing;
  static const LineSpacingModeType kExactLineSpacing = LineSpacingArchive_LineSpacingModeType_kExactLineSpacing;
  static const LineSpacingModeType kMaximumLineSpacing = LineSpacingArchive_LineSpacingModeType_kMaximumLineSpacing;
  static const LineSpacingModeType kSpaceBetweenLineSpacing = LineSpacingArchive_LineSpacingModeType_kSpaceBetweenLineSpacing;
  static inline bool LineSpacingModeType_IsValid(int value) {
    return LineSpacingArchive_LineSpacingModeType_IsValid(value);
  }
  static const LineSpacingModeType LineSpacingModeType_MIN =
    LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_MIN;
  static const LineSpacingModeType LineSpacingModeType_MAX =
    LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_MAX;
  static const int LineSpacingModeType_ARRAYSIZE =
    LineSpacingArchive_LineSpacingModeType_LineSpacingModeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LineSpacingModeType_descriptor() {
    return LineSpacingArchive_LineSpacingModeType_descriptor();
  }
  static inline const ::std::string& LineSpacingModeType_Name(LineSpacingModeType value) {
    return LineSpacingArchive_LineSpacingModeType_Name(value);
  }
  static inline bool LineSpacingModeType_Parse(const ::std::string& name,
      LineSpacingModeType* value) {
    return LineSpacingArchive_LineSpacingModeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSWP.LineSpacingArchive.LineSpacingModeType mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::TSWP::LineSpacingArchive_LineSpacingModeType mode() const;
  inline void set_mode(::TSWP::LineSpacingArchive_LineSpacingModeType value);

  // optional float amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline float amount() const;
  inline void set_amount(float value);

  // optional float baselineRule = 3;
  inline bool has_baselinerule() const;
  inline void clear_baselinerule();
  static const int kBaselineRuleFieldNumber = 3;
  inline float baselinerule() const;
  inline void set_baselinerule(float value);

  // @@protoc_insertion_point(class_scope:TSWP.LineSpacingArchive)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_baselinerule();
  inline void clear_has_baselinerule();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mode_;
  float amount_;
  float baselinerule_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static LineSpacingArchive* default_instance_;
};
// -------------------------------------------------------------------

class ParagraphStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  ParagraphStylePropertiesArchive();
  virtual ~ParagraphStylePropertiesArchive();

  ParagraphStylePropertiesArchive(const ParagraphStylePropertiesArchive& from);

  inline ParagraphStylePropertiesArchive& operator=(const ParagraphStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParagraphStylePropertiesArchive& default_instance();

  void Swap(ParagraphStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  ParagraphStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParagraphStylePropertiesArchive& from);
  void MergeFrom(const ParagraphStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ParagraphStylePropertiesArchive_TextAlignmentType TextAlignmentType;
  static const TextAlignmentType TATvalue0 = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue0;
  static const TextAlignmentType TATvalue1 = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue1;
  static const TextAlignmentType TATvalue2 = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue2;
  static const TextAlignmentType TATvalue3 = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue3;
  static const TextAlignmentType TATvalue4 = ParagraphStylePropertiesArchive_TextAlignmentType_TATvalue4;
  static inline bool TextAlignmentType_IsValid(int value) {
    return ParagraphStylePropertiesArchive_TextAlignmentType_IsValid(value);
  }
  static const TextAlignmentType TextAlignmentType_MIN =
    ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_MIN;
  static const TextAlignmentType TextAlignmentType_MAX =
    ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_MAX;
  static const int TextAlignmentType_ARRAYSIZE =
    ParagraphStylePropertiesArchive_TextAlignmentType_TextAlignmentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextAlignmentType_descriptor() {
    return ParagraphStylePropertiesArchive_TextAlignmentType_descriptor();
  }
  static inline const ::std::string& TextAlignmentType_Name(TextAlignmentType value) {
    return ParagraphStylePropertiesArchive_TextAlignmentType_Name(value);
  }
  static inline bool TextAlignmentType_Parse(const ::std::string& name,
      TextAlignmentType* value) {
    return ParagraphStylePropertiesArchive_TextAlignmentType_Parse(name, value);
  }

  typedef ParagraphStylePropertiesArchive_ParagraphBorderType ParagraphBorderType;
  static const ParagraphBorderType PBTvalue0 = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue0;
  static const ParagraphBorderType PBTvalue1 = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue1;
  static const ParagraphBorderType PBTvalue2 = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue2;
  static const ParagraphBorderType PBTvalue3 = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue3;
  static const ParagraphBorderType PBTvalue4 = ParagraphStylePropertiesArchive_ParagraphBorderType_PBTvalue4;
  static inline bool ParagraphBorderType_IsValid(int value) {
    return ParagraphStylePropertiesArchive_ParagraphBorderType_IsValid(value);
  }
  static const ParagraphBorderType ParagraphBorderType_MIN =
    ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_MIN;
  static const ParagraphBorderType ParagraphBorderType_MAX =
    ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_MAX;
  static const int ParagraphBorderType_ARRAYSIZE =
    ParagraphStylePropertiesArchive_ParagraphBorderType_ParagraphBorderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ParagraphBorderType_descriptor() {
    return ParagraphStylePropertiesArchive_ParagraphBorderType_descriptor();
  }
  static inline const ::std::string& ParagraphBorderType_Name(ParagraphBorderType value) {
    return ParagraphStylePropertiesArchive_ParagraphBorderType_Name(value);
  }
  static inline bool ParagraphBorderType_Parse(const ::std::string& name,
      ParagraphBorderType* value) {
    return ParagraphStylePropertiesArchive_ParagraphBorderType_Parse(name, value);
  }

  typedef ParagraphStylePropertiesArchive_OutlineStyleType OutlineStyleType;
  static const OutlineStyleType OSTvalue0 = ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue0;
  static const OutlineStyleType OSTvalue1 = ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue1;
  static const OutlineStyleType OSTvalue2 = ParagraphStylePropertiesArchive_OutlineStyleType_OSTvalue2;
  static inline bool OutlineStyleType_IsValid(int value) {
    return ParagraphStylePropertiesArchive_OutlineStyleType_IsValid(value);
  }
  static const OutlineStyleType OutlineStyleType_MIN =
    ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_MIN;
  static const OutlineStyleType OutlineStyleType_MAX =
    ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_MAX;
  static const int OutlineStyleType_ARRAYSIZE =
    ParagraphStylePropertiesArchive_OutlineStyleType_OutlineStyleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OutlineStyleType_descriptor() {
    return ParagraphStylePropertiesArchive_OutlineStyleType_descriptor();
  }
  static inline const ::std::string& OutlineStyleType_Name(OutlineStyleType value) {
    return ParagraphStylePropertiesArchive_OutlineStyleType_Name(value);
  }
  static inline bool OutlineStyleType_Parse(const ::std::string& name,
      OutlineStyleType* value) {
    return ParagraphStylePropertiesArchive_OutlineStyleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSWP.ParagraphStylePropertiesArchive.TextAlignmentType alignment = 1;
  inline bool has_alignment() const;
  inline void clear_alignment();
  static const int kAlignmentFieldNumber = 1;
  inline ::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType alignment() const;
  inline void set_alignment(::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType value);

  // optional bool decimal_tab_null = 2;
  inline bool has_decimal_tab_null() const;
  inline void clear_decimal_tab_null();
  static const int kDecimalTabNullFieldNumber = 2;
  inline bool decimal_tab_null() const;
  inline void set_decimal_tab_null(bool value);

  // optional string decimal_tab = 3;
  inline bool has_decimal_tab() const;
  inline void clear_decimal_tab();
  static const int kDecimalTabFieldNumber = 3;
  inline const ::std::string& decimal_tab() const;
  inline void set_decimal_tab(const ::std::string& value);
  inline void set_decimal_tab(const char* value);
  inline void set_decimal_tab(const char* value, size_t size);
  inline ::std::string* mutable_decimal_tab();
  inline ::std::string* release_decimal_tab();
  inline void set_allocated_decimal_tab(::std::string* decimal_tab);

  // optional float default_tab_stops = 4;
  inline bool has_default_tab_stops() const;
  inline void clear_default_tab_stops();
  static const int kDefaultTabStopsFieldNumber = 4;
  inline float default_tab_stops() const;
  inline void set_default_tab_stops(float value);

  // optional bool fill_null = 5;
  inline bool has_fill_null() const;
  inline void clear_fill_null();
  static const int kFillNullFieldNumber = 5;
  inline bool fill_null() const;
  inline void set_fill_null(bool value);

  // optional .TSP.Color fill = 6;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 6;
  inline const ::TSP::Color& fill() const;
  inline ::TSP::Color* mutable_fill();
  inline ::TSP::Color* release_fill();
  inline void set_allocated_fill(::TSP::Color* fill);

  // optional float first_line_indent = 7;
  inline bool has_first_line_indent() const;
  inline void clear_first_line_indent();
  static const int kFirstLineIndentFieldNumber = 7;
  inline float first_line_indent() const;
  inline void set_first_line_indent(float value);

  // optional bool hyphenate = 8;
  inline bool has_hyphenate() const;
  inline void clear_hyphenate();
  static const int kHyphenateFieldNumber = 8;
  inline bool hyphenate() const;
  inline void set_hyphenate(bool value);

  // optional bool keep_lines_together = 9;
  inline bool has_keep_lines_together() const;
  inline void clear_keep_lines_together();
  static const int kKeepLinesTogetherFieldNumber = 9;
  inline bool keep_lines_together() const;
  inline void set_keep_lines_together(bool value);

  // optional bool keep_with_next = 10;
  inline bool has_keep_with_next() const;
  inline void clear_keep_with_next();
  static const int kKeepWithNextFieldNumber = 10;
  inline bool keep_with_next() const;
  inline void set_keep_with_next(bool value);

  // optional float left_indent = 11;
  inline bool has_left_indent() const;
  inline void clear_left_indent();
  static const int kLeftIndentFieldNumber = 11;
  inline float left_indent() const;
  inline void set_left_indent(float value);

  // optional bool line_spacing_null = 12;
  inline bool has_line_spacing_null() const;
  inline void clear_line_spacing_null();
  static const int kLineSpacingNullFieldNumber = 12;
  inline bool line_spacing_null() const;
  inline void set_line_spacing_null(bool value);

  // optional .TSWP.LineSpacingArchive line_spacing = 13;
  inline bool has_line_spacing() const;
  inline void clear_line_spacing();
  static const int kLineSpacingFieldNumber = 13;
  inline const ::TSWP::LineSpacingArchive& line_spacing() const;
  inline ::TSWP::LineSpacingArchive* mutable_line_spacing();
  inline ::TSWP::LineSpacingArchive* release_line_spacing();
  inline void set_allocated_line_spacing(::TSWP::LineSpacingArchive* line_spacing);

  // optional bool page_break_before = 14;
  inline bool has_page_break_before() const;
  inline void clear_page_break_before();
  static const int kPageBreakBeforeFieldNumber = 14;
  inline bool page_break_before() const;
  inline void set_page_break_before(bool value);

  // optional .TSWP.ParagraphStylePropertiesArchive.ParagraphBorderType borders = 15;
  inline bool has_borders() const;
  inline void clear_borders();
  static const int kBordersFieldNumber = 15;
  inline ::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType borders() const;
  inline void set_borders(::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType value);

  // optional bool rule_offset_null = 16;
  inline bool has_rule_offset_null() const;
  inline void clear_rule_offset_null();
  static const int kRuleOffsetNullFieldNumber = 16;
  inline bool rule_offset_null() const;
  inline void set_rule_offset_null(bool value);

  // optional .TSP.Point rule_offset = 17;
  inline bool has_rule_offset() const;
  inline void clear_rule_offset();
  static const int kRuleOffsetFieldNumber = 17;
  inline const ::TSP::Point& rule_offset() const;
  inline ::TSP::Point* mutable_rule_offset();
  inline ::TSP::Point* release_rule_offset();
  inline void set_allocated_rule_offset(::TSP::Point* rule_offset);

  // optional float rule_width = 18;
  inline bool has_rule_width() const;
  inline void clear_rule_width();
  static const int kRuleWidthFieldNumber = 18;
  inline float rule_width() const;
  inline void set_rule_width(float value);

  // optional float right_indent = 19;
  inline bool has_right_indent() const;
  inline void clear_right_indent();
  static const int kRightIndentFieldNumber = 19;
  inline float right_indent() const;
  inline void set_right_indent(float value);

  // optional float space_after = 20;
  inline bool has_space_after() const;
  inline void clear_space_after();
  static const int kSpaceAfterFieldNumber = 20;
  inline float space_after() const;
  inline void set_space_after(float value);

  // optional float space_before = 21;
  inline bool has_space_before() const;
  inline void clear_space_before();
  static const int kSpaceBeforeFieldNumber = 21;
  inline float space_before() const;
  inline void set_space_before(float value);

  // optional bool tabs_null = 24;
  inline bool has_tabs_null() const;
  inline void clear_tabs_null();
  static const int kTabsNullFieldNumber = 24;
  inline bool tabs_null() const;
  inline void set_tabs_null(bool value);

  // optional .TSWP.TabsArchive tabs = 25;
  inline bool has_tabs() const;
  inline void clear_tabs();
  static const int kTabsFieldNumber = 25;
  inline const ::TSWP::TabsArchive& tabs() const;
  inline ::TSWP::TabsArchive* mutable_tabs();
  inline ::TSWP::TabsArchive* release_tabs();
  inline void set_allocated_tabs(::TSWP::TabsArchive* tabs);

  // optional bool widow_control = 26;
  inline bool has_widow_control() const;
  inline void clear_widow_control();
  static const int kWidowControlFieldNumber = 26;
  inline bool widow_control() const;
  inline void set_widow_control(bool value);

  // optional uint32 outline_level = 27;
  inline bool has_outline_level() const;
  inline void clear_outline_level();
  static const int kOutlineLevelFieldNumber = 27;
  inline ::google::protobuf::uint32 outline_level() const;
  inline void set_outline_level(::google::protobuf::uint32 value);

  // optional .TSWP.ParagraphStylePropertiesArchive.OutlineStyleType outline_style = 28;
  inline bool has_outline_style() const;
  inline void clear_outline_style();
  static const int kOutlineStyleFieldNumber = 28;
  inline ::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType outline_style() const;
  inline void set_outline_style(::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType value);

  // optional bool following_style_id_null = 29;
  inline bool has_following_style_id_null() const;
  inline void clear_following_style_id_null();
  static const int kFollowingStyleIdNullFieldNumber = 29;
  inline bool following_style_id_null() const;
  inline void set_following_style_id_null(bool value);

  // optional string following_style_id = 30;
  inline bool has_following_style_id() const;
  inline void clear_following_style_id();
  static const int kFollowingStyleIdFieldNumber = 30;
  inline const ::std::string& following_style_id() const;
  inline void set_following_style_id(const ::std::string& value);
  inline void set_following_style_id(const char* value);
  inline void set_following_style_id(const char* value, size_t size);
  inline ::std::string* mutable_following_style_id();
  inline ::std::string* release_following_style_id();
  inline void set_allocated_following_style_id(::std::string* following_style_id);

  // optional bool stroke_null = 31;
  inline bool has_stroke_null() const;
  inline void clear_stroke_null();
  static const int kStrokeNullFieldNumber = 31;
  inline bool stroke_null() const;
  inline void set_stroke_null(bool value);

  // optional .TSD.StrokeArchive stroke = 32;
  inline bool has_stroke() const;
  inline void clear_stroke();
  static const int kStrokeFieldNumber = 32;
  inline const ::TSD::StrokeArchive& stroke() const;
  inline ::TSD::StrokeArchive* mutable_stroke();
  inline ::TSD::StrokeArchive* release_stroke();
  inline void set_allocated_stroke(::TSD::StrokeArchive* stroke);

  // optional bool show_in_toc = 33;
  inline bool has_show_in_toc() const;
  inline void clear_show_in_toc();
  static const int kShowInTocFieldNumber = 33;
  inline bool show_in_toc() const;
  inline void set_show_in_toc(bool value);

  // optional bool toc_style_id_null = 34;
  inline bool has_toc_style_id_null() const;
  inline void clear_toc_style_id_null();
  static const int kTocStyleIdNullFieldNumber = 34;
  inline bool toc_style_id_null() const;
  inline void set_toc_style_id_null(bool value);

  // optional string toc_style_id = 35;
  inline bool has_toc_style_id() const;
  inline void clear_toc_style_id();
  static const int kTocStyleIdFieldNumber = 35;
  inline const ::std::string& toc_style_id() const;
  inline void set_toc_style_id(const ::std::string& value);
  inline void set_toc_style_id(const char* value);
  inline void set_toc_style_id(const char* value, size_t size);
  inline ::std::string* mutable_toc_style_id();
  inline ::std::string* release_toc_style_id();
  inline void set_allocated_toc_style_id(::std::string* toc_style_id);

  // optional .TSWP.WritingDirectionType writing_direction = 38 [default = kWritingDirectionNatural];
  inline bool has_writing_direction() const;
  inline void clear_writing_direction();
  static const int kWritingDirectionFieldNumber = 38;
  inline ::TSWP::WritingDirectionType writing_direction() const;
  inline void set_writing_direction(::TSWP::WritingDirectionType value);

  // optional bool list_style_null = 39;
  inline bool has_list_style_null() const;
  inline void clear_list_style_null();
  static const int kListStyleNullFieldNumber = 39;
  inline bool list_style_null() const;
  inline void set_list_style_null(bool value);

  // optional .TSP.Reference list_style = 40;
  inline bool has_list_style() const;
  inline void clear_list_style();
  static const int kListStyleFieldNumber = 40;
  inline const ::TSP::Reference& list_style() const;
  inline ::TSP::Reference* mutable_list_style();
  inline ::TSP::Reference* release_list_style();
  inline void set_allocated_list_style(::TSP::Reference* list_style);

  // optional bool following_style_null = 41;
  inline bool has_following_style_null() const;
  inline void clear_following_style_null();
  static const int kFollowingStyleNullFieldNumber = 41;
  inline bool following_style_null() const;
  inline void set_following_style_null(bool value);

  // optional .TSP.Reference following_style = 42;
  inline bool has_following_style() const;
  inline void clear_following_style();
  static const int kFollowingStyleFieldNumber = 42;
  inline const ::TSP::Reference& following_style() const;
  inline ::TSP::Reference* mutable_following_style();
  inline ::TSP::Reference* release_following_style();
  inline void set_allocated_following_style(::TSP::Reference* following_style);

  // @@protoc_insertion_point(class_scope:TSWP.ParagraphStylePropertiesArchive)
 private:
  inline void set_has_alignment();
  inline void clear_has_alignment();
  inline void set_has_decimal_tab_null();
  inline void clear_has_decimal_tab_null();
  inline void set_has_decimal_tab();
  inline void clear_has_decimal_tab();
  inline void set_has_default_tab_stops();
  inline void clear_has_default_tab_stops();
  inline void set_has_fill_null();
  inline void clear_has_fill_null();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_first_line_indent();
  inline void clear_has_first_line_indent();
  inline void set_has_hyphenate();
  inline void clear_has_hyphenate();
  inline void set_has_keep_lines_together();
  inline void clear_has_keep_lines_together();
  inline void set_has_keep_with_next();
  inline void clear_has_keep_with_next();
  inline void set_has_left_indent();
  inline void clear_has_left_indent();
  inline void set_has_line_spacing_null();
  inline void clear_has_line_spacing_null();
  inline void set_has_line_spacing();
  inline void clear_has_line_spacing();
  inline void set_has_page_break_before();
  inline void clear_has_page_break_before();
  inline void set_has_borders();
  inline void clear_has_borders();
  inline void set_has_rule_offset_null();
  inline void clear_has_rule_offset_null();
  inline void set_has_rule_offset();
  inline void clear_has_rule_offset();
  inline void set_has_rule_width();
  inline void clear_has_rule_width();
  inline void set_has_right_indent();
  inline void clear_has_right_indent();
  inline void set_has_space_after();
  inline void clear_has_space_after();
  inline void set_has_space_before();
  inline void clear_has_space_before();
  inline void set_has_tabs_null();
  inline void clear_has_tabs_null();
  inline void set_has_tabs();
  inline void clear_has_tabs();
  inline void set_has_widow_control();
  inline void clear_has_widow_control();
  inline void set_has_outline_level();
  inline void clear_has_outline_level();
  inline void set_has_outline_style();
  inline void clear_has_outline_style();
  inline void set_has_following_style_id_null();
  inline void clear_has_following_style_id_null();
  inline void set_has_following_style_id();
  inline void clear_has_following_style_id();
  inline void set_has_stroke_null();
  inline void clear_has_stroke_null();
  inline void set_has_stroke();
  inline void clear_has_stroke();
  inline void set_has_show_in_toc();
  inline void clear_has_show_in_toc();
  inline void set_has_toc_style_id_null();
  inline void clear_has_toc_style_id_null();
  inline void set_has_toc_style_id();
  inline void clear_has_toc_style_id();
  inline void set_has_writing_direction();
  inline void clear_has_writing_direction();
  inline void set_has_list_style_null();
  inline void clear_has_list_style_null();
  inline void set_has_list_style();
  inline void clear_has_list_style();
  inline void set_has_following_style_null();
  inline void clear_has_following_style_null();
  inline void set_has_following_style();
  inline void clear_has_following_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int alignment_;
  float default_tab_stops_;
  ::std::string* decimal_tab_;
  ::TSP::Color* fill_;
  bool decimal_tab_null_;
  bool fill_null_;
  bool hyphenate_;
  bool keep_lines_together_;
  float first_line_indent_;
  float left_indent_;
  bool keep_with_next_;
  bool line_spacing_null_;
  bool page_break_before_;
  bool rule_offset_null_;
  ::TSWP::LineSpacingArchive* line_spacing_;
  int borders_;
  float rule_width_;
  ::TSP::Point* rule_offset_;
  float right_indent_;
  float space_after_;
  float space_before_;
  ::google::protobuf::uint32 outline_level_;
  ::TSWP::TabsArchive* tabs_;
  bool tabs_null_;
  bool widow_control_;
  bool following_style_id_null_;
  bool stroke_null_;
  int outline_style_;
  ::std::string* following_style_id_;
  ::TSD::StrokeArchive* stroke_;
  ::std::string* toc_style_id_;
  bool show_in_toc_;
  bool toc_style_id_null_;
  bool list_style_null_;
  bool following_style_null_;
  int writing_direction_;
  ::TSP::Reference* list_style_;
  ::TSP::Reference* following_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ParagraphStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class ParagraphStyleArchive : public ::google::protobuf::Message {
 public:
  ParagraphStyleArchive();
  virtual ~ParagraphStyleArchive();

  ParagraphStyleArchive(const ParagraphStyleArchive& from);

  inline ParagraphStyleArchive& operator=(const ParagraphStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParagraphStyleArchive& default_instance();

  void Swap(ParagraphStyleArchive* other);

  // implements Message ----------------------------------------------

  ParagraphStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParagraphStyleArchive& from);
  void MergeFrom(const ParagraphStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TSWP.CharacterStylePropertiesArchive char_properties = 11;
  inline bool has_char_properties() const;
  inline void clear_char_properties();
  static const int kCharPropertiesFieldNumber = 11;
  inline const ::TSWP::CharacterStylePropertiesArchive& char_properties() const;
  inline ::TSWP::CharacterStylePropertiesArchive* mutable_char_properties();
  inline ::TSWP::CharacterStylePropertiesArchive* release_char_properties();
  inline void set_allocated_char_properties(::TSWP::CharacterStylePropertiesArchive* char_properties);

  // optional .TSWP.ParagraphStylePropertiesArchive para_properties = 12;
  inline bool has_para_properties() const;
  inline void clear_para_properties();
  static const int kParaPropertiesFieldNumber = 12;
  inline const ::TSWP::ParagraphStylePropertiesArchive& para_properties() const;
  inline ::TSWP::ParagraphStylePropertiesArchive* mutable_para_properties();
  inline ::TSWP::ParagraphStylePropertiesArchive* release_para_properties();
  inline void set_allocated_para_properties(::TSWP::ParagraphStylePropertiesArchive* para_properties);

  // @@protoc_insertion_point(class_scope:TSWP.ParagraphStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_char_properties();
  inline void clear_has_char_properties();
  inline void set_has_para_properties();
  inline void clear_has_para_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TSWP::CharacterStylePropertiesArchive* char_properties_;
  ::TSWP::ParagraphStylePropertiesArchive* para_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ParagraphStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ListStyleArchive_LabelGeometry : public ::google::protobuf::Message {
 public:
  ListStyleArchive_LabelGeometry();
  virtual ~ListStyleArchive_LabelGeometry();

  ListStyleArchive_LabelGeometry(const ListStyleArchive_LabelGeometry& from);

  inline ListStyleArchive_LabelGeometry& operator=(const ListStyleArchive_LabelGeometry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListStyleArchive_LabelGeometry& default_instance();

  void Swap(ListStyleArchive_LabelGeometry* other);

  // implements Message ----------------------------------------------

  ListStyleArchive_LabelGeometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListStyleArchive_LabelGeometry& from);
  void MergeFrom(const ListStyleArchive_LabelGeometry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float scale = 1 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 1;
  inline float scale() const;
  inline void set_scale(float value);

  // optional float baseline_offset = 2 [default = 0];
  inline bool has_baseline_offset() const;
  inline void clear_baseline_offset();
  static const int kBaselineOffsetFieldNumber = 2;
  inline float baseline_offset() const;
  inline void set_baseline_offset(float value);

  // optional bool scale_with_text = 3 [default = true];
  inline bool has_scale_with_text() const;
  inline void clear_scale_with_text();
  static const int kScaleWithTextFieldNumber = 3;
  inline bool scale_with_text() const;
  inline void set_scale_with_text(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.ListStyleArchive.LabelGeometry)
 private:
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_baseline_offset();
  inline void clear_has_baseline_offset();
  inline void set_has_scale_with_text();
  inline void clear_has_scale_with_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float scale_;
  float baseline_offset_;
  bool scale_with_text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ListStyleArchive_LabelGeometry* default_instance_;
};
// -------------------------------------------------------------------

class ListStyleArchive_LabelImage : public ::google::protobuf::Message {
 public:
  ListStyleArchive_LabelImage();
  virtual ~ListStyleArchive_LabelImage();

  ListStyleArchive_LabelImage(const ListStyleArchive_LabelImage& from);

  inline ListStyleArchive_LabelImage& operator=(const ListStyleArchive_LabelImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListStyleArchive_LabelImage& default_instance();

  void Swap(ListStyleArchive_LabelImage* other);

  // implements Message ----------------------------------------------

  ListStyleArchive_LabelImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListStyleArchive_LabelImage& from);
  void MergeFrom(const ListStyleArchive_LabelImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.DataReference image = 3;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 3;
  inline const ::TSP::DataReference& image() const;
  inline ::TSP::DataReference* mutable_image();
  inline ::TSP::DataReference* release_image();
  inline void set_allocated_image(::TSP::DataReference* image);

  // optional bool image_null = 2;
  inline bool has_image_null() const;
  inline void clear_image_null();
  static const int kImageNullFieldNumber = 2;
  inline bool image_null() const;
  inline void set_image_null(bool value);

  // optional .TSP.Reference database_image = 1;
  inline bool has_database_image() const;
  inline void clear_database_image();
  static const int kDatabaseImageFieldNumber = 1;
  inline const ::TSP::Reference& database_image() const;
  inline ::TSP::Reference* mutable_database_image();
  inline ::TSP::Reference* release_database_image();
  inline void set_allocated_database_image(::TSP::Reference* database_image);

  // @@protoc_insertion_point(class_scope:TSWP.ListStyleArchive.LabelImage)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_null();
  inline void clear_has_image_null();
  inline void set_has_database_image();
  inline void clear_has_database_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::DataReference* image_;
  ::TSP::Reference* database_image_;
  bool image_null_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ListStyleArchive_LabelImage* default_instance_;
};
// -------------------------------------------------------------------

class ListStyleArchive : public ::google::protobuf::Message {
 public:
  ListStyleArchive();
  virtual ~ListStyleArchive();

  ListStyleArchive(const ListStyleArchive& from);

  inline ListStyleArchive& operator=(const ListStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListStyleArchive& default_instance();

  void Swap(ListStyleArchive* other);

  // implements Message ----------------------------------------------

  ListStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListStyleArchive& from);
  void MergeFrom(const ListStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ListStyleArchive_LabelGeometry LabelGeometry;
  typedef ListStyleArchive_LabelImage LabelImage;

  typedef ListStyleArchive_LabelType LabelType;
  static const LabelType kNone = ListStyleArchive_LabelType_kNone;
  static const LabelType kImage = ListStyleArchive_LabelType_kImage;
  static const LabelType kString = ListStyleArchive_LabelType_kString;
  static const LabelType kNumber = ListStyleArchive_LabelType_kNumber;
  static inline bool LabelType_IsValid(int value) {
    return ListStyleArchive_LabelType_IsValid(value);
  }
  static const LabelType LabelType_MIN =
    ListStyleArchive_LabelType_LabelType_MIN;
  static const LabelType LabelType_MAX =
    ListStyleArchive_LabelType_LabelType_MAX;
  static const int LabelType_ARRAYSIZE =
    ListStyleArchive_LabelType_LabelType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LabelType_descriptor() {
    return ListStyleArchive_LabelType_descriptor();
  }
  static inline const ::std::string& LabelType_Name(LabelType value) {
    return ListStyleArchive_LabelType_Name(value);
  }
  static inline bool LabelType_Parse(const ::std::string& name,
      LabelType* value) {
    return ListStyleArchive_LabelType_Parse(name, value);
  }

  typedef ListStyleArchive_NumberType NumberType;
  static const NumberType kNumericDecimal = ListStyleArchive_NumberType_kNumericDecimal;
  static const NumberType kNumericDoubleParen = ListStyleArchive_NumberType_kNumericDoubleParen;
  static const NumberType kNumericRightParen = ListStyleArchive_NumberType_kNumericRightParen;
  static const NumberType kRomanUpperDecimal = ListStyleArchive_NumberType_kRomanUpperDecimal;
  static const NumberType kRomanUpperDoubleParen = ListStyleArchive_NumberType_kRomanUpperDoubleParen;
  static const NumberType kRomanUpperRightParen = ListStyleArchive_NumberType_kRomanUpperRightParen;
  static const NumberType kRomanLowerDecimal = ListStyleArchive_NumberType_kRomanLowerDecimal;
  static const NumberType kRomanLowerDoubleParen = ListStyleArchive_NumberType_kRomanLowerDoubleParen;
  static const NumberType kRomanLowerRightParen = ListStyleArchive_NumberType_kRomanLowerRightParen;
  static const NumberType kAlphaUpperDecimal = ListStyleArchive_NumberType_kAlphaUpperDecimal;
  static const NumberType kAlphaUpperDoubleParen = ListStyleArchive_NumberType_kAlphaUpperDoubleParen;
  static const NumberType kAlphaUpperRightParen = ListStyleArchive_NumberType_kAlphaUpperRightParen;
  static const NumberType kAlphaLowerDecimal = ListStyleArchive_NumberType_kAlphaLowerDecimal;
  static const NumberType kAlphaLowerDoubleParen = ListStyleArchive_NumberType_kAlphaLowerDoubleParen;
  static const NumberType kAlphaLowerRightParen = ListStyleArchive_NumberType_kAlphaLowerRightParen;
  static const NumberType kIdeographicJapaneseDecimalKind = ListStyleArchive_NumberType_kIdeographicJapaneseDecimalKind;
  static const NumberType kIdeographicJapaneseDoubleParenKind = ListStyleArchive_NumberType_kIdeographicJapaneseDoubleParenKind;
  static const NumberType kIdeographicJapaneseRightParenKind = ListStyleArchive_NumberType_kIdeographicJapaneseRightParenKind;
  static const NumberType kHiraganaDecimalKind = ListStyleArchive_NumberType_kHiraganaDecimalKind;
  static const NumberType kHiraganaDoubleParenKind = ListStyleArchive_NumberType_kHiraganaDoubleParenKind;
  static const NumberType kHiraganaRightParenKind = ListStyleArchive_NumberType_kHiraganaRightParenKind;
  static const NumberType kKatakanaDecimalKind = ListStyleArchive_NumberType_kKatakanaDecimalKind;
  static const NumberType kKatakanaDoubleParenKind = ListStyleArchive_NumberType_kKatakanaDoubleParenKind;
  static const NumberType kKatakanaRightParenKind = ListStyleArchive_NumberType_kKatakanaRightParenKind;
  static const NumberType kHiraganaIrohaDecimalKind = ListStyleArchive_NumberType_kHiraganaIrohaDecimalKind;
  static const NumberType kHiraganaIrohaDoubleParenKind = ListStyleArchive_NumberType_kHiraganaIrohaDoubleParenKind;
  static const NumberType kHiraganaIrohaRightParenKind = ListStyleArchive_NumberType_kHiraganaIrohaRightParenKind;
  static const NumberType kKatakanaIrohaDecimalKind = ListStyleArchive_NumberType_kKatakanaIrohaDecimalKind;
  static const NumberType kKatakanaIrohaDoubleParenKind = ListStyleArchive_NumberType_kKatakanaIrohaDoubleParenKind;
  static const NumberType kKatakanaIrohaRightParenKind = ListStyleArchive_NumberType_kKatakanaIrohaRightParenKind;
  static const NumberType kIdeographicSimplifiedChineseDecimalKind = ListStyleArchive_NumberType_kIdeographicSimplifiedChineseDecimalKind;
  static const NumberType kIdeographicSimplifiedChineseDoubleParenKind = ListStyleArchive_NumberType_kIdeographicSimplifiedChineseDoubleParenKind;
  static const NumberType kIdeographicSimplifiedChineseRightParenKind = ListStyleArchive_NumberType_kIdeographicSimplifiedChineseRightParenKind;
  static const NumberType kIdeographicTraditionalChineseDecimalKind = ListStyleArchive_NumberType_kIdeographicTraditionalChineseDecimalKind;
  static const NumberType kIdeographicTraditionalChineseDoubleParenKind = ListStyleArchive_NumberType_kIdeographicTraditionalChineseDoubleParenKind;
  static const NumberType kIdeographicTraditionalChineseRightParenKind = ListStyleArchive_NumberType_kIdeographicTraditionalChineseRightParenKind;
  static const NumberType kIdeographicFormalJapaneseDecimalKind = ListStyleArchive_NumberType_kIdeographicFormalJapaneseDecimalKind;
  static const NumberType kIdeographicFormalJapaneseDoubleParenKind = ListStyleArchive_NumberType_kIdeographicFormalJapaneseDoubleParenKind;
  static const NumberType kIdeographicFormalJapaneseRightParenKind = ListStyleArchive_NumberType_kIdeographicFormalJapaneseRightParenKind;
  static const NumberType kIdeographicFormalSimplifiedChineseDecimalKind = ListStyleArchive_NumberType_kIdeographicFormalSimplifiedChineseDecimalKind;
  static const NumberType kIdeographicFormalSimplifiedChineseDoubleParenKind = ListStyleArchive_NumberType_kIdeographicFormalSimplifiedChineseDoubleParenKind;
  static const NumberType kIdeographicFormalSimplifiedChineseRightParenKind = ListStyleArchive_NumberType_kIdeographicFormalSimplifiedChineseRightParenKind;
  static const NumberType kIdeographicFormalTraditionalChineseDecimalKind = ListStyleArchive_NumberType_kIdeographicFormalTraditionalChineseDecimalKind;
  static const NumberType kIdeographicFormalTraditionalChineseDoubleParenKind = ListStyleArchive_NumberType_kIdeographicFormalTraditionalChineseDoubleParenKind;
  static const NumberType kIdeographicFormalTraditionalChineseRightParenKind = ListStyleArchive_NumberType_kIdeographicFormalTraditionalChineseRightParenKind;
  static const NumberType kKoreanAlphabetDecimalKind = ListStyleArchive_NumberType_kKoreanAlphabetDecimalKind;
  static const NumberType kKoreanAlphabetDoubleParenKind = ListStyleArchive_NumberType_kKoreanAlphabetDoubleParenKind;
  static const NumberType kKoreanAlphabetRightParenKind = ListStyleArchive_NumberType_kKoreanAlphabetRightParenKind;
  static const NumberType kCircledNumberKind = ListStyleArchive_NumberType_kCircledNumberKind;
  static const NumberType kArabianNumericDecimalKind = ListStyleArchive_NumberType_kArabianNumericDecimalKind;
  static const NumberType kArabianNumericDoubleParenKind = ListStyleArchive_NumberType_kArabianNumericDoubleParenKind;
  static const NumberType kArabianNumericRightParenKind = ListStyleArchive_NumberType_kArabianNumericRightParenKind;
  static const NumberType kArabianAlphaDecimalKind = ListStyleArchive_NumberType_kArabianAlphaDecimalKind;
  static const NumberType kArabianAlphaDoubleParenKind = ListStyleArchive_NumberType_kArabianAlphaDoubleParenKind;
  static const NumberType kArabianAlphaRightParenKind = ListStyleArchive_NumberType_kArabianAlphaRightParenKind;
  static const NumberType kArabianAbjadDecimalKind = ListStyleArchive_NumberType_kArabianAbjadDecimalKind;
  static const NumberType kArabianAbjadDoubleParenKind = ListStyleArchive_NumberType_kArabianAbjadDoubleParenKind;
  static const NumberType kArabianAbjadRightParenKind = ListStyleArchive_NumberType_kArabianAbjadRightParenKind;
  static const NumberType kHebrewAlphaDecimalKind = ListStyleArchive_NumberType_kHebrewAlphaDecimalKind;
  static const NumberType kHebrewAlphaDoubleParenKind = ListStyleArchive_NumberType_kHebrewAlphaDoubleParenKind;
  static const NumberType kHebrewAlphaRightParenKind = ListStyleArchive_NumberType_kHebrewAlphaRightParenKind;
  static const NumberType kHebrewBiblicalStandardKind = ListStyleArchive_NumberType_kHebrewBiblicalStandardKind;
  static inline bool NumberType_IsValid(int value) {
    return ListStyleArchive_NumberType_IsValid(value);
  }
  static const NumberType NumberType_MIN =
    ListStyleArchive_NumberType_NumberType_MIN;
  static const NumberType NumberType_MAX =
    ListStyleArchive_NumberType_NumberType_MAX;
  static const int NumberType_ARRAYSIZE =
    ListStyleArchive_NumberType_NumberType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NumberType_descriptor() {
    return ListStyleArchive_NumberType_descriptor();
  }
  static inline const ::std::string& NumberType_Name(NumberType value) {
    return ListStyleArchive_NumberType_Name(value);
  }
  static inline bool NumberType_Parse(const ::std::string& name,
      NumberType* value) {
    return ListStyleArchive_NumberType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // repeated .TSWP.ListStyleArchive.LabelType label_types = 11;
  inline int label_types_size() const;
  inline void clear_label_types();
  static const int kLabelTypesFieldNumber = 11;
  inline ::TSWP::ListStyleArchive_LabelType label_types(int index) const;
  inline void set_label_types(int index, ::TSWP::ListStyleArchive_LabelType value);
  inline void add_label_types(::TSWP::ListStyleArchive_LabelType value);
  inline const ::google::protobuf::RepeatedField<int>& label_types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_label_types();

  // repeated float text_indents = 12;
  inline int text_indents_size() const;
  inline void clear_text_indents();
  static const int kTextIndentsFieldNumber = 12;
  inline float text_indents(int index) const;
  inline void set_text_indents(int index, float value);
  inline void add_text_indents(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      text_indents() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_text_indents();

  // repeated float indents = 13;
  inline int indents_size() const;
  inline void clear_indents();
  static const int kIndentsFieldNumber = 13;
  inline float indents(int index) const;
  inline void set_indents(int index, float value);
  inline void add_indents(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      indents() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_indents();

  // repeated .TSWP.ListStyleArchive.LabelGeometry geometries = 14;
  inline int geometries_size() const;
  inline void clear_geometries();
  static const int kGeometriesFieldNumber = 14;
  inline const ::TSWP::ListStyleArchive_LabelGeometry& geometries(int index) const;
  inline ::TSWP::ListStyleArchive_LabelGeometry* mutable_geometries(int index);
  inline ::TSWP::ListStyleArchive_LabelGeometry* add_geometries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelGeometry >&
      geometries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelGeometry >*
      mutable_geometries();

  // repeated .TSWP.ListStyleArchive.NumberType number_types = 15;
  inline int number_types_size() const;
  inline void clear_number_types();
  static const int kNumberTypesFieldNumber = 15;
  inline ::TSWP::ListStyleArchive_NumberType number_types(int index) const;
  inline void set_number_types(int index, ::TSWP::ListStyleArchive_NumberType value);
  inline void add_number_types(::TSWP::ListStyleArchive_NumberType value);
  inline const ::google::protobuf::RepeatedField<int>& number_types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_number_types();

  // repeated string strings = 16;
  inline int strings_size() const;
  inline void clear_strings();
  static const int kStringsFieldNumber = 16;
  inline const ::std::string& strings(int index) const;
  inline ::std::string* mutable_strings(int index);
  inline void set_strings(int index, const ::std::string& value);
  inline void set_strings(int index, const char* value);
  inline void set_strings(int index, const char* value, size_t size);
  inline ::std::string* add_strings();
  inline void add_strings(const ::std::string& value);
  inline void add_strings(const char* value);
  inline void add_strings(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& strings() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_strings();

  // repeated .TSWP.ListStyleArchive.LabelImage images = 17;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 17;
  inline const ::TSWP::ListStyleArchive_LabelImage& images(int index) const;
  inline ::TSWP::ListStyleArchive_LabelImage* mutable_images(int index);
  inline ::TSWP::ListStyleArchive_LabelImage* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelImage >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelImage >*
      mutable_images();

  // optional bool shadow_null = 18;
  inline bool has_shadow_null() const;
  inline void clear_shadow_null();
  static const int kShadowNullFieldNumber = 18;
  inline bool shadow_null() const;
  inline void set_shadow_null(bool value);

  // optional .TSD.ShadowArchive shadow = 19;
  inline bool has_shadow() const;
  inline void clear_shadow();
  static const int kShadowFieldNumber = 19;
  inline const ::TSD::ShadowArchive& shadow() const;
  inline ::TSD::ShadowArchive* mutable_shadow();
  inline ::TSD::ShadowArchive* release_shadow();
  inline void set_allocated_shadow(::TSD::ShadowArchive* shadow);

  // optional bool font_color_null = 20;
  inline bool has_font_color_null() const;
  inline void clear_font_color_null();
  static const int kFontColorNullFieldNumber = 20;
  inline bool font_color_null() const;
  inline void set_font_color_null(bool value);

  // optional .TSP.Color font_color = 21;
  inline bool has_font_color() const;
  inline void clear_font_color();
  static const int kFontColorFieldNumber = 21;
  inline const ::TSP::Color& font_color() const;
  inline ::TSP::Color* mutable_font_color();
  inline ::TSP::Color* release_font_color();
  inline void set_allocated_font_color(::TSP::Color* font_color);

  // optional bool font_name_null = 22;
  inline bool has_font_name_null() const;
  inline void clear_font_name_null();
  static const int kFontNameNullFieldNumber = 22;
  inline bool font_name_null() const;
  inline void set_font_name_null(bool value);

  // optional string font_name = 23;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 23;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  inline ::std::string* release_font_name();
  inline void set_allocated_font_name(::std::string* font_name);

  // optional .TSWP.WritingDirectionType writing_direction = 24 [default = kWritingDirectionNatural];
  inline bool has_writing_direction() const;
  inline void clear_writing_direction();
  static const int kWritingDirectionFieldNumber = 24;
  inline ::TSWP::WritingDirectionType writing_direction() const;
  inline void set_writing_direction(::TSWP::WritingDirectionType value);

  // repeated bool tiered_numbers = 25;
  inline int tiered_numbers_size() const;
  inline void clear_tiered_numbers();
  static const int kTieredNumbersFieldNumber = 25;
  inline bool tiered_numbers(int index) const;
  inline void set_tiered_numbers(int index, bool value);
  inline void add_tiered_numbers(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      tiered_numbers() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_tiered_numbers();

  // @@protoc_insertion_point(class_scope:TSWP.ListStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_shadow_null();
  inline void clear_has_shadow_null();
  inline void set_has_shadow();
  inline void clear_has_shadow();
  inline void set_has_font_color_null();
  inline void clear_has_font_color_null();
  inline void set_has_font_color();
  inline void clear_has_font_color();
  inline void set_has_font_name_null();
  inline void clear_has_font_name_null();
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_writing_direction();
  inline void clear_has_writing_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::google::protobuf::RepeatedField<int> label_types_;
  ::google::protobuf::RepeatedField< float > text_indents_;
  ::google::protobuf::RepeatedField< float > indents_;
  ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelGeometry > geometries_;
  ::google::protobuf::RepeatedField<int> number_types_;
  ::google::protobuf::RepeatedPtrField< ::std::string> strings_;
  ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelImage > images_;
  ::google::protobuf::uint32 override_count_;
  bool shadow_null_;
  bool font_color_null_;
  bool font_name_null_;
  ::TSD::ShadowArchive* shadow_;
  ::TSP::Color* font_color_;
  ::std::string* font_name_;
  ::google::protobuf::RepeatedField< bool > tiered_numbers_;
  int writing_direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ListStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class TextStylePresetArchive : public ::google::protobuf::Message {
 public:
  TextStylePresetArchive();
  virtual ~TextStylePresetArchive();

  TextStylePresetArchive(const TextStylePresetArchive& from);

  inline TextStylePresetArchive& operator=(const TextStylePresetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextStylePresetArchive& default_instance();

  void Swap(TextStylePresetArchive* other);

  // implements Message ----------------------------------------------

  TextStylePresetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextStylePresetArchive& from);
  void MergeFrom(const TextStylePresetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string preset_identifier = 1;
  inline bool has_preset_identifier() const;
  inline void clear_preset_identifier();
  static const int kPresetIdentifierFieldNumber = 1;
  inline const ::std::string& preset_identifier() const;
  inline void set_preset_identifier(const ::std::string& value);
  inline void set_preset_identifier(const char* value);
  inline void set_preset_identifier(const char* value, size_t size);
  inline ::std::string* mutable_preset_identifier();
  inline ::std::string* release_preset_identifier();
  inline void set_allocated_preset_identifier(::std::string* preset_identifier);

  // optional .TSP.Reference paragraph_style = 2;
  inline bool has_paragraph_style() const;
  inline void clear_paragraph_style();
  static const int kParagraphStyleFieldNumber = 2;
  inline const ::TSP::Reference& paragraph_style() const;
  inline ::TSP::Reference* mutable_paragraph_style();
  inline ::TSP::Reference* release_paragraph_style();
  inline void set_allocated_paragraph_style(::TSP::Reference* paragraph_style);

  // optional .TSP.Reference list_style = 3;
  inline bool has_list_style() const;
  inline void clear_list_style();
  static const int kListStyleFieldNumber = 3;
  inline const ::TSP::Reference& list_style() const;
  inline ::TSP::Reference* mutable_list_style();
  inline ::TSP::Reference* release_list_style();
  inline void set_allocated_list_style(::TSP::Reference* list_style);

  // @@protoc_insertion_point(class_scope:TSWP.TextStylePresetArchive)
 private:
  inline void set_has_preset_identifier();
  inline void clear_has_preset_identifier();
  inline void set_has_paragraph_style();
  inline void clear_has_paragraph_style();
  inline void set_has_list_style();
  inline void clear_has_list_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* preset_identifier_;
  ::TSP::Reference* paragraph_style_;
  ::TSP::Reference* list_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TextStylePresetArchive* default_instance_;
};
// -------------------------------------------------------------------

class ColumnsArchive_EqualColumnsArchive : public ::google::protobuf::Message {
 public:
  ColumnsArchive_EqualColumnsArchive();
  virtual ~ColumnsArchive_EqualColumnsArchive();

  ColumnsArchive_EqualColumnsArchive(const ColumnsArchive_EqualColumnsArchive& from);

  inline ColumnsArchive_EqualColumnsArchive& operator=(const ColumnsArchive_EqualColumnsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnsArchive_EqualColumnsArchive& default_instance();

  void Swap(ColumnsArchive_EqualColumnsArchive* other);

  // implements Message ----------------------------------------------

  ColumnsArchive_EqualColumnsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnsArchive_EqualColumnsArchive& from);
  void MergeFrom(const ColumnsArchive_EqualColumnsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional float gap = 2;
  inline bool has_gap() const;
  inline void clear_gap();
  static const int kGapFieldNumber = 2;
  inline float gap() const;
  inline void set_gap(float value);

  // @@protoc_insertion_point(class_scope:TSWP.ColumnsArchive.EqualColumnsArchive)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_gap();
  inline void clear_has_gap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;
  float gap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ColumnsArchive_EqualColumnsArchive* default_instance_;
};
// -------------------------------------------------------------------

class ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive : public ::google::protobuf::Message {
 public:
  ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive();
  virtual ~ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive();

  ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive(const ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& from);

  inline ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& operator=(const ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& default_instance();

  void Swap(ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* other);

  // implements Message ----------------------------------------------

  ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& from);
  void MergeFrom(const ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float gap = 1;
  inline bool has_gap() const;
  inline void clear_gap();
  static const int kGapFieldNumber = 1;
  inline float gap() const;
  inline void set_gap(float value);

  // required float width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline float width() const;
  inline void set_width(float value);

  // @@protoc_insertion_point(class_scope:TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive)
 private:
  inline void set_has_gap();
  inline void clear_has_gap();
  inline void set_has_width();
  inline void clear_has_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float gap_;
  float width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* default_instance_;
};
// -------------------------------------------------------------------

class ColumnsArchive_NonEqualColumnsArchive : public ::google::protobuf::Message {
 public:
  ColumnsArchive_NonEqualColumnsArchive();
  virtual ~ColumnsArchive_NonEqualColumnsArchive();

  ColumnsArchive_NonEqualColumnsArchive(const ColumnsArchive_NonEqualColumnsArchive& from);

  inline ColumnsArchive_NonEqualColumnsArchive& operator=(const ColumnsArchive_NonEqualColumnsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnsArchive_NonEqualColumnsArchive& default_instance();

  void Swap(ColumnsArchive_NonEqualColumnsArchive* other);

  // implements Message ----------------------------------------------

  ColumnsArchive_NonEqualColumnsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnsArchive_NonEqualColumnsArchive& from);
  void MergeFrom(const ColumnsArchive_NonEqualColumnsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive GapWidthArchive;

  // accessors -------------------------------------------------------

  // required float first = 1;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 1;
  inline float first() const;
  inline void set_first(float value);

  // repeated .TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive following = 2;
  inline int following_size() const;
  inline void clear_following();
  static const int kFollowingFieldNumber = 2;
  inline const ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& following(int index) const;
  inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* mutable_following(int index);
  inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* add_following();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive >&
      following() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive >*
      mutable_following();

  // @@protoc_insertion_point(class_scope:TSWP.ColumnsArchive.NonEqualColumnsArchive)
 private:
  inline void set_has_first();
  inline void clear_has_first();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive > following_;
  float first_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ColumnsArchive_NonEqualColumnsArchive* default_instance_;
};
// -------------------------------------------------------------------

class ColumnsArchive : public ::google::protobuf::Message {
 public:
  ColumnsArchive();
  virtual ~ColumnsArchive();

  ColumnsArchive(const ColumnsArchive& from);

  inline ColumnsArchive& operator=(const ColumnsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnsArchive& default_instance();

  void Swap(ColumnsArchive* other);

  // implements Message ----------------------------------------------

  ColumnsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnsArchive& from);
  void MergeFrom(const ColumnsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ColumnsArchive_EqualColumnsArchive EqualColumnsArchive;
  typedef ColumnsArchive_NonEqualColumnsArchive NonEqualColumnsArchive;

  // accessors -------------------------------------------------------

  // optional .TSWP.ColumnsArchive.EqualColumnsArchive equal_columns = 1;
  inline bool has_equal_columns() const;
  inline void clear_equal_columns();
  static const int kEqualColumnsFieldNumber = 1;
  inline const ::TSWP::ColumnsArchive_EqualColumnsArchive& equal_columns() const;
  inline ::TSWP::ColumnsArchive_EqualColumnsArchive* mutable_equal_columns();
  inline ::TSWP::ColumnsArchive_EqualColumnsArchive* release_equal_columns();
  inline void set_allocated_equal_columns(::TSWP::ColumnsArchive_EqualColumnsArchive* equal_columns);

  // optional .TSWP.ColumnsArchive.NonEqualColumnsArchive non_equal_columns = 2;
  inline bool has_non_equal_columns() const;
  inline void clear_non_equal_columns();
  static const int kNonEqualColumnsFieldNumber = 2;
  inline const ::TSWP::ColumnsArchive_NonEqualColumnsArchive& non_equal_columns() const;
  inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive* mutable_non_equal_columns();
  inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive* release_non_equal_columns();
  inline void set_allocated_non_equal_columns(::TSWP::ColumnsArchive_NonEqualColumnsArchive* non_equal_columns);

  // @@protoc_insertion_point(class_scope:TSWP.ColumnsArchive)
 private:
  inline void set_has_equal_columns();
  inline void clear_has_equal_columns();
  inline void set_has_non_equal_columns();
  inline void clear_has_non_equal_columns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ColumnsArchive_EqualColumnsArchive* equal_columns_;
  ::TSWP::ColumnsArchive_NonEqualColumnsArchive* non_equal_columns_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ColumnsArchive* default_instance_;
};
// -------------------------------------------------------------------

class PaddingArchive : public ::google::protobuf::Message {
 public:
  PaddingArchive();
  virtual ~PaddingArchive();

  PaddingArchive(const PaddingArchive& from);

  inline PaddingArchive& operator=(const PaddingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaddingArchive& default_instance();

  void Swap(PaddingArchive* other);

  // implements Message ----------------------------------------------

  PaddingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaddingArchive& from);
  void MergeFrom(const PaddingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline float left() const;
  inline void set_left(float value);

  // optional float top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline float top() const;
  inline void set_top(float value);

  // optional float right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline float right() const;
  inline void set_right(float value);

  // optional float bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline float bottom() const;
  inline void set_bottom(float value);

  // @@protoc_insertion_point(class_scope:TSWP.PaddingArchive)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float left_;
  float top_;
  float right_;
  float bottom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static PaddingArchive* default_instance_;
};
// -------------------------------------------------------------------

class ColumnStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  ColumnStylePropertiesArchive();
  virtual ~ColumnStylePropertiesArchive();

  ColumnStylePropertiesArchive(const ColumnStylePropertiesArchive& from);

  inline ColumnStylePropertiesArchive& operator=(const ColumnStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnStylePropertiesArchive& default_instance();

  void Swap(ColumnStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  ColumnStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnStylePropertiesArchive& from);
  void MergeFrom(const ColumnStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ColumnStylePropertiesArchive_VerticalAlignmentType VerticalAlignmentType;
  static const VerticalAlignmentType kFrameAlignTop = ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignTop;
  static const VerticalAlignmentType kFrameAlignMiddle = ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignMiddle;
  static const VerticalAlignmentType kFrameAlignBottom = ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignBottom;
  static const VerticalAlignmentType kFrameAlignJustify = ColumnStylePropertiesArchive_VerticalAlignmentType_kFrameAlignJustify;
  static inline bool VerticalAlignmentType_IsValid(int value) {
    return ColumnStylePropertiesArchive_VerticalAlignmentType_IsValid(value);
  }
  static const VerticalAlignmentType VerticalAlignmentType_MIN =
    ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MIN;
  static const VerticalAlignmentType VerticalAlignmentType_MAX =
    ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MAX;
  static const int VerticalAlignmentType_ARRAYSIZE =
    ColumnStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VerticalAlignmentType_descriptor() {
    return ColumnStylePropertiesArchive_VerticalAlignmentType_descriptor();
  }
  static inline const ::std::string& VerticalAlignmentType_Name(VerticalAlignmentType value) {
    return ColumnStylePropertiesArchive_VerticalAlignmentType_Name(value);
  }
  static inline bool VerticalAlignmentType_Parse(const ::std::string& name,
      VerticalAlignmentType* value) {
    return ColumnStylePropertiesArchive_VerticalAlignmentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool continuous = 1;
  inline bool has_continuous() const;
  inline void clear_continuous();
  static const int kContinuousFieldNumber = 1;
  inline bool continuous() const;
  inline void set_continuous(bool value);

  // optional bool shrink_to_fit = 2;
  inline bool has_shrink_to_fit() const;
  inline void clear_shrink_to_fit();
  static const int kShrinkToFitFieldNumber = 2;
  inline bool shrink_to_fit() const;
  inline void set_shrink_to_fit(bool value);

  // optional bool vertical_text = 3;
  inline bool has_vertical_text() const;
  inline void clear_vertical_text();
  static const int kVerticalTextFieldNumber = 3;
  inline bool vertical_text() const;
  inline void set_vertical_text(bool value);

  // optional float min_horizontal_inset = 4;
  inline bool has_min_horizontal_inset() const;
  inline void clear_min_horizontal_inset();
  static const int kMinHorizontalInsetFieldNumber = 4;
  inline float min_horizontal_inset() const;
  inline void set_min_horizontal_inset(float value);

  // optional .TSWP.ColumnStylePropertiesArchive.VerticalAlignmentType vertical_alignment = 5;
  inline bool has_vertical_alignment() const;
  inline void clear_vertical_alignment();
  static const int kVerticalAlignmentFieldNumber = 5;
  inline ::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType vertical_alignment() const;
  inline void set_vertical_alignment(::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType value);

  // optional bool columns_null = 6;
  inline bool has_columns_null() const;
  inline void clear_columns_null();
  static const int kColumnsNullFieldNumber = 6;
  inline bool columns_null() const;
  inline void set_columns_null(bool value);

  // optional .TSWP.ColumnsArchive columns = 7;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 7;
  inline const ::TSWP::ColumnsArchive& columns() const;
  inline ::TSWP::ColumnsArchive* mutable_columns();
  inline ::TSWP::ColumnsArchive* release_columns();
  inline void set_allocated_columns(::TSWP::ColumnsArchive* columns);

  // optional bool margins_null = 8;
  inline bool has_margins_null() const;
  inline void clear_margins_null();
  static const int kMarginsNullFieldNumber = 8;
  inline bool margins_null() const;
  inline void set_margins_null(bool value);

  // optional .TSWP.PaddingArchive margins = 9;
  inline bool has_margins() const;
  inline void clear_margins();
  static const int kMarginsFieldNumber = 9;
  inline const ::TSWP::PaddingArchive& margins() const;
  inline ::TSWP::PaddingArchive* mutable_margins();
  inline ::TSWP::PaddingArchive* release_margins();
  inline void set_allocated_margins(::TSWP::PaddingArchive* margins);

  // optional bool padding_null = 10;
  inline bool has_padding_null() const;
  inline void clear_padding_null();
  static const int kPaddingNullFieldNumber = 10;
  inline bool padding_null() const;
  inline void set_padding_null(bool value);

  // optional .TSWP.PaddingArchive padding = 11;
  inline bool has_padding() const;
  inline void clear_padding();
  static const int kPaddingFieldNumber = 11;
  inline const ::TSWP::PaddingArchive& padding() const;
  inline ::TSWP::PaddingArchive* mutable_padding();
  inline ::TSWP::PaddingArchive* release_padding();
  inline void set_allocated_padding(::TSWP::PaddingArchive* padding);

  // optional .TSWP.WritingDirectionType writing_direction = 12 [default = kWritingDirectionNatural];
  inline bool has_writing_direction() const;
  inline void clear_writing_direction();
  static const int kWritingDirectionFieldNumber = 12;
  inline ::TSWP::WritingDirectionType writing_direction() const;
  inline void set_writing_direction(::TSWP::WritingDirectionType value);

  // @@protoc_insertion_point(class_scope:TSWP.ColumnStylePropertiesArchive)
 private:
  inline void set_has_continuous();
  inline void clear_has_continuous();
  inline void set_has_shrink_to_fit();
  inline void clear_has_shrink_to_fit();
  inline void set_has_vertical_text();
  inline void clear_has_vertical_text();
  inline void set_has_min_horizontal_inset();
  inline void clear_has_min_horizontal_inset();
  inline void set_has_vertical_alignment();
  inline void clear_has_vertical_alignment();
  inline void set_has_columns_null();
  inline void clear_has_columns_null();
  inline void set_has_columns();
  inline void clear_has_columns();
  inline void set_has_margins_null();
  inline void clear_has_margins_null();
  inline void set_has_margins();
  inline void clear_has_margins();
  inline void set_has_padding_null();
  inline void clear_has_padding_null();
  inline void set_has_padding();
  inline void clear_has_padding();
  inline void set_has_writing_direction();
  inline void clear_has_writing_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool continuous_;
  bool shrink_to_fit_;
  bool vertical_text_;
  bool columns_null_;
  float min_horizontal_inset_;
  ::TSWP::ColumnsArchive* columns_;
  int vertical_alignment_;
  bool margins_null_;
  bool padding_null_;
  ::TSWP::PaddingArchive* margins_;
  ::TSWP::PaddingArchive* padding_;
  int writing_direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ColumnStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class ColumnStyleArchive : public ::google::protobuf::Message {
 public:
  ColumnStyleArchive();
  virtual ~ColumnStyleArchive();

  ColumnStyleArchive(const ColumnStyleArchive& from);

  inline ColumnStyleArchive& operator=(const ColumnStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnStyleArchive& default_instance();

  void Swap(ColumnStyleArchive* other);

  // implements Message ----------------------------------------------

  ColumnStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnStyleArchive& from);
  void MergeFrom(const ColumnStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TSWP.ColumnStylePropertiesArchive column_properties = 11;
  inline bool has_column_properties() const;
  inline void clear_column_properties();
  static const int kColumnPropertiesFieldNumber = 11;
  inline const ::TSWP::ColumnStylePropertiesArchive& column_properties() const;
  inline ::TSWP::ColumnStylePropertiesArchive* mutable_column_properties();
  inline ::TSWP::ColumnStylePropertiesArchive* release_column_properties();
  inline void set_allocated_column_properties(::TSWP::ColumnStylePropertiesArchive* column_properties);

  // @@protoc_insertion_point(class_scope:TSWP.ColumnStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_column_properties();
  inline void clear_has_column_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TSWP::ColumnStylePropertiesArchive* column_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ColumnStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  ShapeStylePropertiesArchive();
  virtual ~ShapeStylePropertiesArchive();

  ShapeStylePropertiesArchive(const ShapeStylePropertiesArchive& from);

  inline ShapeStylePropertiesArchive& operator=(const ShapeStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeStylePropertiesArchive& default_instance();

  void Swap(ShapeStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  ShapeStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeStylePropertiesArchive& from);
  void MergeFrom(const ShapeStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ShapeStylePropertiesArchive_VerticalAlignmentType VerticalAlignmentType;
  static const VerticalAlignmentType kFrameAlignTop = ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignTop;
  static const VerticalAlignmentType kFrameAlignMiddle = ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignMiddle;
  static const VerticalAlignmentType kFrameAlignBottom = ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignBottom;
  static const VerticalAlignmentType kFrameAlignJustify = ShapeStylePropertiesArchive_VerticalAlignmentType_kFrameAlignJustify;
  static inline bool VerticalAlignmentType_IsValid(int value) {
    return ShapeStylePropertiesArchive_VerticalAlignmentType_IsValid(value);
  }
  static const VerticalAlignmentType VerticalAlignmentType_MIN =
    ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MIN;
  static const VerticalAlignmentType VerticalAlignmentType_MAX =
    ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_MAX;
  static const int VerticalAlignmentType_ARRAYSIZE =
    ShapeStylePropertiesArchive_VerticalAlignmentType_VerticalAlignmentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VerticalAlignmentType_descriptor() {
    return ShapeStylePropertiesArchive_VerticalAlignmentType_descriptor();
  }
  static inline const ::std::string& VerticalAlignmentType_Name(VerticalAlignmentType value) {
    return ShapeStylePropertiesArchive_VerticalAlignmentType_Name(value);
  }
  static inline bool VerticalAlignmentType_Parse(const ::std::string& name,
      VerticalAlignmentType* value) {
    return ShapeStylePropertiesArchive_VerticalAlignmentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool shrink_to_fit = 1;
  inline bool has_shrink_to_fit() const;
  inline void clear_shrink_to_fit();
  static const int kShrinkToFitFieldNumber = 1;
  inline bool shrink_to_fit() const;
  inline void set_shrink_to_fit(bool value);

  // optional .TSWP.ShapeStylePropertiesArchive.VerticalAlignmentType vertical_alignment = 2;
  inline bool has_vertical_alignment() const;
  inline void clear_vertical_alignment();
  static const int kVerticalAlignmentFieldNumber = 2;
  inline ::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType vertical_alignment() const;
  inline void set_vertical_alignment(::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType value);

  // optional bool columns_null = 3;
  inline bool has_columns_null() const;
  inline void clear_columns_null();
  static const int kColumnsNullFieldNumber = 3;
  inline bool columns_null() const;
  inline void set_columns_null(bool value);

  // optional .TSWP.ColumnsArchive columns = 4;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 4;
  inline const ::TSWP::ColumnsArchive& columns() const;
  inline ::TSWP::ColumnsArchive* mutable_columns();
  inline ::TSWP::ColumnsArchive* release_columns();
  inline void set_allocated_columns(::TSWP::ColumnsArchive* columns);

  // optional bool padding_null = 5;
  inline bool has_padding_null() const;
  inline void clear_padding_null();
  static const int kPaddingNullFieldNumber = 5;
  inline bool padding_null() const;
  inline void set_padding_null(bool value);

  // optional .TSWP.PaddingArchive padding = 6;
  inline bool has_padding() const;
  inline void clear_padding();
  static const int kPaddingFieldNumber = 6;
  inline const ::TSWP::PaddingArchive& padding() const;
  inline ::TSWP::PaddingArchive* mutable_padding();
  inline ::TSWP::PaddingArchive* release_padding();
  inline void set_allocated_padding(::TSWP::PaddingArchive* padding);

  // optional uint32 default_text_preset_index = 7;
  inline bool has_default_text_preset_index() const;
  inline void clear_default_text_preset_index();
  static const int kDefaultTextPresetIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 default_text_preset_index() const;
  inline void set_default_text_preset_index(::google::protobuf::uint32 value);

  // optional bool vertical_text = 8;
  inline bool has_vertical_text() const;
  inline void clear_vertical_text();
  static const int kVerticalTextFieldNumber = 8;
  inline bool vertical_text() const;
  inline void set_vertical_text(bool value);

  // optional bool paragraph_style_null = 9;
  inline bool has_paragraph_style_null() const;
  inline void clear_paragraph_style_null();
  static const int kParagraphStyleNullFieldNumber = 9;
  inline bool paragraph_style_null() const;
  inline void set_paragraph_style_null(bool value);

  // optional .TSP.Reference paragraph_style = 10;
  inline bool has_paragraph_style() const;
  inline void clear_paragraph_style();
  static const int kParagraphStyleFieldNumber = 10;
  inline const ::TSP::Reference& paragraph_style() const;
  inline ::TSP::Reference* mutable_paragraph_style();
  inline ::TSP::Reference* release_paragraph_style();
  inline void set_allocated_paragraph_style(::TSP::Reference* paragraph_style);

  // @@protoc_insertion_point(class_scope:TSWP.ShapeStylePropertiesArchive)
 private:
  inline void set_has_shrink_to_fit();
  inline void clear_has_shrink_to_fit();
  inline void set_has_vertical_alignment();
  inline void clear_has_vertical_alignment();
  inline void set_has_columns_null();
  inline void clear_has_columns_null();
  inline void set_has_columns();
  inline void clear_has_columns();
  inline void set_has_padding_null();
  inline void clear_has_padding_null();
  inline void set_has_padding();
  inline void clear_has_padding();
  inline void set_has_default_text_preset_index();
  inline void clear_has_default_text_preset_index();
  inline void set_has_vertical_text();
  inline void clear_has_vertical_text();
  inline void set_has_paragraph_style_null();
  inline void clear_has_paragraph_style_null();
  inline void set_has_paragraph_style();
  inline void clear_has_paragraph_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int vertical_alignment_;
  bool shrink_to_fit_;
  bool columns_null_;
  bool padding_null_;
  bool vertical_text_;
  ::TSWP::ColumnsArchive* columns_;
  ::TSWP::PaddingArchive* padding_;
  ::google::protobuf::uint32 default_text_preset_index_;
  bool paragraph_style_null_;
  ::TSP::Reference* paragraph_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeStyleArchive : public ::google::protobuf::Message {
 public:
  ShapeStyleArchive();
  virtual ~ShapeStyleArchive();

  ShapeStyleArchive(const ShapeStyleArchive& from);

  inline ShapeStyleArchive& operator=(const ShapeStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeStyleArchive& default_instance();

  void Swap(ShapeStyleArchive* other);

  // implements Message ----------------------------------------------

  ShapeStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeStyleArchive& from);
  void MergeFrom(const ShapeStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.ShapeStyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::ShapeStyleArchive& super() const;
  inline ::TSD::ShapeStyleArchive* mutable_super();
  inline ::TSD::ShapeStyleArchive* release_super();
  inline void set_allocated_super(::TSD::ShapeStyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TSWP.ShapeStylePropertiesArchive shape_properties = 11;
  inline bool has_shape_properties() const;
  inline void clear_shape_properties();
  static const int kShapePropertiesFieldNumber = 11;
  inline const ::TSWP::ShapeStylePropertiesArchive& shape_properties() const;
  inline ::TSWP::ShapeStylePropertiesArchive* mutable_shape_properties();
  inline ::TSWP::ShapeStylePropertiesArchive* release_shape_properties();
  inline void set_allocated_shape_properties(::TSWP::ShapeStylePropertiesArchive* shape_properties);

  // @@protoc_insertion_point(class_scope:TSWP.ShapeStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_shape_properties();
  inline void clear_has_shape_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::ShapeStyleArchive* super_;
  ::TSWP::ShapeStylePropertiesArchive* shape_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ThemePresetsArchive : public ::google::protobuf::Message {
 public:
  ThemePresetsArchive();
  virtual ~ThemePresetsArchive();

  ThemePresetsArchive(const ThemePresetsArchive& from);

  inline ThemePresetsArchive& operator=(const ThemePresetsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThemePresetsArchive& default_instance();

  void Swap(ThemePresetsArchive* other);

  // implements Message ----------------------------------------------

  ThemePresetsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThemePresetsArchive& from);
  void MergeFrom(const ThemePresetsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference list_style_presets = 1;
  inline int list_style_presets_size() const;
  inline void clear_list_style_presets();
  static const int kListStylePresetsFieldNumber = 1;
  inline const ::TSP::Reference& list_style_presets(int index) const;
  inline ::TSP::Reference* mutable_list_style_presets(int index);
  inline ::TSP::Reference* add_list_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      list_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_list_style_presets();

  // repeated .TSP.Reference text_style_presets = 2;
  inline int text_style_presets_size() const;
  inline void clear_text_style_presets();
  static const int kTextStylePresetsFieldNumber = 2;
  inline const ::TSP::Reference& text_style_presets(int index) const;
  inline ::TSP::Reference* mutable_text_style_presets(int index);
  inline ::TSP::Reference* add_text_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      text_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_text_style_presets();

  // repeated .TSP.Reference imported_text_style_presets = 3;
  inline int imported_text_style_presets_size() const;
  inline void clear_imported_text_style_presets();
  static const int kImportedTextStylePresetsFieldNumber = 3;
  inline const ::TSP::Reference& imported_text_style_presets(int index) const;
  inline ::TSP::Reference* mutable_imported_text_style_presets(int index);
  inline ::TSP::Reference* add_imported_text_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      imported_text_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_imported_text_style_presets();

  // repeated .TSP.Reference toc_entry_style_presets = 4;
  inline int toc_entry_style_presets_size() const;
  inline void clear_toc_entry_style_presets();
  static const int kTocEntryStylePresetsFieldNumber = 4;
  inline const ::TSP::Reference& toc_entry_style_presets(int index) const;
  inline ::TSP::Reference* mutable_toc_entry_style_presets(int index);
  inline ::TSP::Reference* add_toc_entry_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      toc_entry_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_toc_entry_style_presets();

  // repeated .TSP.Reference toc_settings_presets = 5;
  inline int toc_settings_presets_size() const;
  inline void clear_toc_settings_presets();
  static const int kTocSettingsPresetsFieldNumber = 5;
  inline const ::TSP::Reference& toc_settings_presets(int index) const;
  inline ::TSP::Reference* mutable_toc_settings_presets(int index);
  inline ::TSP::Reference* add_toc_settings_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      toc_settings_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_toc_settings_presets();

  // repeated .TSP.Reference character_style_presets = 6;
  inline int character_style_presets_size() const;
  inline void clear_character_style_presets();
  static const int kCharacterStylePresetsFieldNumber = 6;
  inline const ::TSP::Reference& character_style_presets(int index) const;
  inline ::TSP::Reference* mutable_character_style_presets(int index);
  inline ::TSP::Reference* add_character_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      character_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_character_style_presets();

  // repeated .TSP.Reference paragraph_style_presets = 7;
  inline int paragraph_style_presets_size() const;
  inline void clear_paragraph_style_presets();
  static const int kParagraphStylePresetsFieldNumber = 7;
  inline const ::TSP::Reference& paragraph_style_presets(int index) const;
  inline ::TSP::Reference* mutable_paragraph_style_presets(int index);
  inline ::TSP::Reference* add_paragraph_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      paragraph_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_paragraph_style_presets();

  static const int kExtensionFieldNumber = 110;
  static ::google::protobuf::internal::ExtensionIdentifier< ::TSS::ThemeArchive,
      ::google::protobuf::internal::MessageTypeTraits< ::TSWP::ThemePresetsArchive >, 11, false >
    extension;
  // @@protoc_insertion_point(class_scope:TSWP.ThemePresetsArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > list_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > text_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > imported_text_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > toc_entry_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > toc_settings_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > character_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > paragraph_style_presets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ThemePresetsArchive* default_instance_;
};
// -------------------------------------------------------------------

class TextPresetDisplayItemArchive : public ::google::protobuf::Message {
 public:
  TextPresetDisplayItemArchive();
  virtual ~TextPresetDisplayItemArchive();

  TextPresetDisplayItemArchive(const TextPresetDisplayItemArchive& from);

  inline TextPresetDisplayItemArchive& operator=(const TextPresetDisplayItemArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextPresetDisplayItemArchive& default_instance();

  void Swap(TextPresetDisplayItemArchive* other);

  // implements Message ----------------------------------------------

  TextPresetDisplayItemArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextPresetDisplayItemArchive& from);
  void MergeFrom(const TextPresetDisplayItemArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference preset = 1;
  inline bool has_preset() const;
  inline void clear_preset();
  static const int kPresetFieldNumber = 1;
  inline const ::TSP::Reference& preset() const;
  inline ::TSP::Reference* mutable_preset();
  inline ::TSP::Reference* release_preset();
  inline void set_allocated_preset(::TSP::Reference* preset);

  // required string display_name = 2;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // @@protoc_insertion_point(class_scope:TSWP.TextPresetDisplayItemArchive)
 private:
  inline void set_has_preset();
  inline void clear_has_preset();
  inline void set_has_display_name();
  inline void clear_has_display_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* preset_;
  ::std::string* display_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TextPresetDisplayItemArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCEntryStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  TOCEntryStylePropertiesArchive();
  virtual ~TOCEntryStylePropertiesArchive();

  TOCEntryStylePropertiesArchive(const TOCEntryStylePropertiesArchive& from);

  inline TOCEntryStylePropertiesArchive& operator=(const TOCEntryStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCEntryStylePropertiesArchive& default_instance();

  void Swap(TOCEntryStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  TOCEntryStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCEntryStylePropertiesArchive& from);
  void MergeFrom(const TOCEntryStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool page_number_style_null = 1;
  inline bool has_page_number_style_null() const;
  inline void clear_page_number_style_null();
  static const int kPageNumberStyleNullFieldNumber = 1;
  inline bool page_number_style_null() const;
  inline void set_page_number_style_null(bool value);

  // optional .TSP.Reference page_number_style = 2;
  inline bool has_page_number_style() const;
  inline void clear_page_number_style();
  static const int kPageNumberStyleFieldNumber = 2;
  inline const ::TSP::Reference& page_number_style() const;
  inline ::TSP::Reference* mutable_page_number_style();
  inline ::TSP::Reference* release_page_number_style();
  inline void set_allocated_page_number_style(::TSP::Reference* page_number_style);

  // optional bool show_page_number = 3;
  inline bool has_show_page_number() const;
  inline void clear_show_page_number();
  static const int kShowPageNumberFieldNumber = 3;
  inline bool show_page_number() const;
  inline void set_show_page_number(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.TOCEntryStylePropertiesArchive)
 private:
  inline void set_has_page_number_style_null();
  inline void clear_has_page_number_style_null();
  inline void set_has_page_number_style();
  inline void clear_has_page_number_style();
  inline void set_has_show_page_number();
  inline void clear_has_show_page_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* page_number_style_;
  bool page_number_style_null_;
  bool show_page_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCEntryStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCEntryStyleArchive : public ::google::protobuf::Message {
 public:
  TOCEntryStyleArchive();
  virtual ~TOCEntryStyleArchive();

  TOCEntryStyleArchive(const TOCEntryStyleArchive& from);

  inline TOCEntryStyleArchive& operator=(const TOCEntryStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCEntryStyleArchive& default_instance();

  void Swap(TOCEntryStyleArchive* other);

  // implements Message ----------------------------------------------

  TOCEntryStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCEntryStyleArchive& from);
  void MergeFrom(const TOCEntryStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.ParagraphStyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::ParagraphStyleArchive& super() const;
  inline ::TSWP::ParagraphStyleArchive* mutable_super();
  inline ::TSWP::ParagraphStyleArchive* release_super();
  inline void set_allocated_super(::TSWP::ParagraphStyleArchive* super);

  // optional .TSWP.TOCEntryStylePropertiesArchive toc_properties = 2;
  inline bool has_toc_properties() const;
  inline void clear_toc_properties();
  static const int kTocPropertiesFieldNumber = 2;
  inline const ::TSWP::TOCEntryStylePropertiesArchive& toc_properties() const;
  inline ::TSWP::TOCEntryStylePropertiesArchive* mutable_toc_properties();
  inline ::TSWP::TOCEntryStylePropertiesArchive* release_toc_properties();
  inline void set_allocated_toc_properties(::TSWP::TOCEntryStylePropertiesArchive* toc_properties);

  // @@protoc_insertion_point(class_scope:TSWP.TOCEntryStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_toc_properties();
  inline void clear_has_toc_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ParagraphStyleArchive* super_;
  ::TSWP::TOCEntryStylePropertiesArchive* toc_properties_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCEntryStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCSettingsArchive_TOCEntryData : public ::google::protobuf::Message {
 public:
  TOCSettingsArchive_TOCEntryData();
  virtual ~TOCSettingsArchive_TOCEntryData();

  TOCSettingsArchive_TOCEntryData(const TOCSettingsArchive_TOCEntryData& from);

  inline TOCSettingsArchive_TOCEntryData& operator=(const TOCSettingsArchive_TOCEntryData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCSettingsArchive_TOCEntryData& default_instance();

  void Swap(TOCSettingsArchive_TOCEntryData* other);

  // implements Message ----------------------------------------------

  TOCSettingsArchive_TOCEntryData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCSettingsArchive_TOCEntryData& from);
  void MergeFrom(const TOCSettingsArchive_TOCEntryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference paragraph_style = 1;
  inline bool has_paragraph_style() const;
  inline void clear_paragraph_style();
  static const int kParagraphStyleFieldNumber = 1;
  inline const ::TSP::Reference& paragraph_style() const;
  inline ::TSP::Reference* mutable_paragraph_style();
  inline ::TSP::Reference* release_paragraph_style();
  inline void set_allocated_paragraph_style(::TSP::Reference* paragraph_style);

  // optional .TSP.Reference toc_entry_style = 2;
  inline bool has_toc_entry_style() const;
  inline void clear_toc_entry_style();
  static const int kTocEntryStyleFieldNumber = 2;
  inline const ::TSP::Reference& toc_entry_style() const;
  inline ::TSP::Reference* mutable_toc_entry_style();
  inline ::TSP::Reference* release_toc_entry_style();
  inline void set_allocated_toc_entry_style(::TSP::Reference* toc_entry_style);

  // optional bool show_in_toc = 3;
  inline bool has_show_in_toc() const;
  inline void clear_show_in_toc();
  static const int kShowInTocFieldNumber = 3;
  inline bool show_in_toc() const;
  inline void set_show_in_toc(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.TOCSettingsArchive.TOCEntryData)
 private:
  inline void set_has_paragraph_style();
  inline void clear_has_paragraph_style();
  inline void set_has_toc_entry_style();
  inline void clear_has_toc_entry_style();
  inline void set_has_show_in_toc();
  inline void clear_has_show_in_toc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* paragraph_style_;
  ::TSP::Reference* toc_entry_style_;
  bool show_in_toc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCSettingsArchive_TOCEntryData* default_instance_;
};
// -------------------------------------------------------------------

class TOCSettingsArchive : public ::google::protobuf::Message {
 public:
  TOCSettingsArchive();
  virtual ~TOCSettingsArchive();

  TOCSettingsArchive(const TOCSettingsArchive& from);

  inline TOCSettingsArchive& operator=(const TOCSettingsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCSettingsArchive& default_instance();

  void Swap(TOCSettingsArchive* other);

  // implements Message ----------------------------------------------

  TOCSettingsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCSettingsArchive& from);
  void MergeFrom(const TOCSettingsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TOCSettingsArchive_TOCEntryData TOCEntryData;

  // accessors -------------------------------------------------------

  // optional string toc_name = 1;
  inline bool has_toc_name() const;
  inline void clear_toc_name();
  static const int kTocNameFieldNumber = 1;
  inline const ::std::string& toc_name() const;
  inline void set_toc_name(const ::std::string& value);
  inline void set_toc_name(const char* value);
  inline void set_toc_name(const char* value, size_t size);
  inline ::std::string* mutable_toc_name();
  inline ::std::string* release_toc_name();
  inline void set_allocated_toc_name(::std::string* toc_name);

  // optional uint32 toc_scope = 2;
  inline bool has_toc_scope() const;
  inline void clear_toc_scope();
  static const int kTocScopeFieldNumber = 2;
  inline ::google::protobuf::uint32 toc_scope() const;
  inline void set_toc_scope(::google::protobuf::uint32 value);

  // repeated .TSWP.TOCSettingsArchive.TOCEntryData entries = 3;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline const ::TSWP::TOCSettingsArchive_TOCEntryData& entries(int index) const;
  inline ::TSWP::TOCSettingsArchive_TOCEntryData* mutable_entries(int index);
  inline ::TSWP::TOCSettingsArchive_TOCEntryData* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSettingsArchive_TOCEntryData >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSettingsArchive_TOCEntryData >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSWP.TOCSettingsArchive)
 private:
  inline void set_has_toc_name();
  inline void clear_has_toc_name();
  inline void set_has_toc_scope();
  inline void clear_has_toc_scope();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* toc_name_;
  ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSettingsArchive_TOCEntryData > entries_;
  ::google::protobuf::uint32 toc_scope_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCSettingsArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCEntryInstanceArchive : public ::google::protobuf::Message {
 public:
  TOCEntryInstanceArchive();
  virtual ~TOCEntryInstanceArchive();

  TOCEntryInstanceArchive(const TOCEntryInstanceArchive& from);

  inline TOCEntryInstanceArchive& operator=(const TOCEntryInstanceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCEntryInstanceArchive& default_instance();

  void Swap(TOCEntryInstanceArchive* other);

  // implements Message ----------------------------------------------

  TOCEntryInstanceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCEntryInstanceArchive& from);
  void MergeFrom(const TOCEntryInstanceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 paragraph_index = 1;
  inline bool has_paragraph_index() const;
  inline void clear_paragraph_index();
  static const int kParagraphIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 paragraph_index() const;
  inline void set_paragraph_index(::google::protobuf::uint32 value);

  // required uint32 page_number = 2;
  inline bool has_page_number() const;
  inline void clear_page_number();
  static const int kPageNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 page_number() const;
  inline void set_page_number(::google::protobuf::uint32 value);

  // required uint32 number_format = 3;
  inline bool has_number_format() const;
  inline void clear_number_format();
  static const int kNumberFormatFieldNumber = 3;
  inline ::google::protobuf::uint32 number_format() const;
  inline void set_number_format(::google::protobuf::uint32 value);

  // required string heading = 4;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 4;
  inline const ::std::string& heading() const;
  inline void set_heading(const ::std::string& value);
  inline void set_heading(const char* value);
  inline void set_heading(const char* value, size_t size);
  inline ::std::string* mutable_heading();
  inline ::std::string* release_heading();
  inline void set_allocated_heading(::std::string* heading);

  // required .TSP.Reference indexed_style = 5;
  inline bool has_indexed_style() const;
  inline void clear_indexed_style();
  static const int kIndexedStyleFieldNumber = 5;
  inline const ::TSP::Reference& indexed_style() const;
  inline ::TSP::Reference* mutable_indexed_style();
  inline ::TSP::Reference* release_indexed_style();
  inline void set_allocated_indexed_style(::TSP::Reference* indexed_style);

  // @@protoc_insertion_point(class_scope:TSWP.TOCEntryInstanceArchive)
 private:
  inline void set_has_paragraph_index();
  inline void clear_has_paragraph_index();
  inline void set_has_page_number();
  inline void clear_has_page_number();
  inline void set_has_number_format();
  inline void clear_has_number_format();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_indexed_style();
  inline void clear_has_indexed_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 paragraph_index_;
  ::google::protobuf::uint32 page_number_;
  ::std::string* heading_;
  ::TSP::Reference* indexed_style_;
  ::google::protobuf::uint32 number_format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCEntryInstanceArchive* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_GenericTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_GenericTransaction();
  virtual ~UndoTransaction_GenericTransaction();

  UndoTransaction_GenericTransaction(const UndoTransaction_GenericTransaction& from);

  inline UndoTransaction_GenericTransaction& operator=(const UndoTransaction_GenericTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_GenericTransaction& default_instance();

  void Swap(UndoTransaction_GenericTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_GenericTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_GenericTransaction& from);
  void MergeFrom(const UndoTransaction_GenericTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value1 = 1;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 1;
  inline ::google::protobuf::uint32 value1() const;
  inline void set_value1(::google::protobuf::uint32 value);

  // required uint32 value2 = 2;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 2;
  inline ::google::protobuf::uint32 value2() const;
  inline void set_value2(::google::protobuf::uint32 value);

  // required uint32 value3 = 3;
  inline bool has_value3() const;
  inline void clear_value3();
  static const int kValue3FieldNumber = 3;
  inline ::google::protobuf::uint32 value3() const;
  inline void set_value3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.GenericTransaction)
 private:
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_value3();
  inline void clear_has_value3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 value1_;
  ::google::protobuf::uint32 value2_;
  ::google::protobuf::uint32 value3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_GenericTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_TextTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_TextTransaction();
  virtual ~UndoTransaction_TextTransaction();

  UndoTransaction_TextTransaction(const UndoTransaction_TextTransaction& from);

  inline UndoTransaction_TextTransaction& operator=(const UndoTransaction_TextTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_TextTransaction& default_instance();

  void Swap(UndoTransaction_TextTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_TextTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_TextTransaction& from);
  void MergeFrom(const UndoTransaction_TextTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 insert_location = 1;
  inline bool has_insert_location() const;
  inline void clear_insert_location();
  static const int kInsertLocationFieldNumber = 1;
  inline ::google::protobuf::uint32 insert_location() const;
  inline void set_insert_location(::google::protobuf::uint32 value);

  // required uint32 insert_length = 2;
  inline bool has_insert_length() const;
  inline void clear_insert_length();
  static const int kInsertLengthFieldNumber = 2;
  inline ::google::protobuf::uint32 insert_length() const;
  inline void set_insert_length(::google::protobuf::uint32 value);

  // optional string string_to_delete = 3;
  inline bool has_string_to_delete() const;
  inline void clear_string_to_delete();
  static const int kStringToDeleteFieldNumber = 3;
  inline const ::std::string& string_to_delete() const;
  inline void set_string_to_delete(const ::std::string& value);
  inline void set_string_to_delete(const char* value);
  inline void set_string_to_delete(const char* value, size_t size);
  inline ::std::string* mutable_string_to_delete();
  inline ::std::string* release_string_to_delete();
  inline void set_allocated_string_to_delete(::std::string* string_to_delete);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.TextTransaction)
 private:
  inline void set_has_insert_location();
  inline void clear_has_insert_location();
  inline void set_has_insert_length();
  inline void clear_has_insert_length();
  inline void set_has_string_to_delete();
  inline void clear_has_string_to_delete();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 insert_location_;
  ::google::protobuf::uint32 insert_length_;
  ::std::string* string_to_delete_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_TextTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_CharIndexTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_CharIndexTransaction();
  virtual ~UndoTransaction_CharIndexTransaction();

  UndoTransaction_CharIndexTransaction(const UndoTransaction_CharIndexTransaction& from);

  inline UndoTransaction_CharIndexTransaction& operator=(const UndoTransaction_CharIndexTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_CharIndexTransaction& default_instance();

  void Swap(UndoTransaction_CharIndexTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_CharIndexTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_CharIndexTransaction& from);
  void MergeFrom(const UndoTransaction_CharIndexTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_index = 1;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 char_index() const;
  inline void set_char_index(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional .TSP.Reference object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.CharIndexTransaction)
 private:
  inline void set_has_char_index();
  inline void clear_has_char_index();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 char_index_;
  ::google::protobuf::uint32 count_;
  ::TSP::Reference* object_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_CharIndexTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_ReplaceCharIndexTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_ReplaceCharIndexTransaction();
  virtual ~UndoTransaction_ReplaceCharIndexTransaction();

  UndoTransaction_ReplaceCharIndexTransaction(const UndoTransaction_ReplaceCharIndexTransaction& from);

  inline UndoTransaction_ReplaceCharIndexTransaction& operator=(const UndoTransaction_ReplaceCharIndexTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_ReplaceCharIndexTransaction& default_instance();

  void Swap(UndoTransaction_ReplaceCharIndexTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_ReplaceCharIndexTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_ReplaceCharIndexTransaction& from);
  void MergeFrom(const UndoTransaction_ReplaceCharIndexTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attribute_index = 1;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // required uint32 char_index = 2;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 char_index() const;
  inline void set_char_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.ReplaceCharIndexTransaction)
 private:
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_char_index();
  inline void clear_has_char_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attribute_index_;
  ::google::protobuf::uint32 char_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_ReplaceCharIndexTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_AttributeIndexTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_AttributeIndexTransaction();
  virtual ~UndoTransaction_AttributeIndexTransaction();

  UndoTransaction_AttributeIndexTransaction(const UndoTransaction_AttributeIndexTransaction& from);

  inline UndoTransaction_AttributeIndexTransaction& operator=(const UndoTransaction_AttributeIndexTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_AttributeIndexTransaction& default_instance();

  void Swap(UndoTransaction_AttributeIndexTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_AttributeIndexTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_AttributeIndexTransaction& from);
  void MergeFrom(const UndoTransaction_AttributeIndexTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attribute_index = 1;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // required uint32 char_index = 2;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 char_index() const;
  inline void set_char_index(::google::protobuf::uint32 value);

  // optional .TSP.Reference object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // optional string string = 4;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 4;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  inline void set_allocated_string(::std::string* string);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.AttributeIndexTransaction)
 private:
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_char_index();
  inline void clear_has_char_index();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_string();
  inline void clear_has_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attribute_index_;
  ::google::protobuf::uint32 char_index_;
  ::TSP::Reference* object_;
  ::std::string* string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_AttributeIndexTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_InsertAttributeTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_InsertAttributeTransaction();
  virtual ~UndoTransaction_InsertAttributeTransaction();

  UndoTransaction_InsertAttributeTransaction(const UndoTransaction_InsertAttributeTransaction& from);

  inline UndoTransaction_InsertAttributeTransaction& operator=(const UndoTransaction_InsertAttributeTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_InsertAttributeTransaction& default_instance();

  void Swap(UndoTransaction_InsertAttributeTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_InsertAttributeTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_InsertAttributeTransaction& from);
  void MergeFrom(const UndoTransaction_InsertAttributeTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attribute_index = 1;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // required uint32 attribute_count = 2;
  inline bool has_attribute_count() const;
  inline void clear_attribute_count();
  static const int kAttributeCountFieldNumber = 2;
  inline ::google::protobuf::uint32 attribute_count() const;
  inline void set_attribute_count(::google::protobuf::uint32 value);

  // optional .TSP.Reference object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // optional string string = 4;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 4;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  inline void set_allocated_string(::std::string* string);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.InsertAttributeTransaction)
 private:
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_attribute_count();
  inline void clear_has_attribute_count();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_string();
  inline void clear_has_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attribute_index_;
  ::google::protobuf::uint32 attribute_count_;
  ::TSP::Reference* object_;
  ::std::string* string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_InsertAttributeTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_InsertNilTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_InsertNilTransaction();
  virtual ~UndoTransaction_InsertNilTransaction();

  UndoTransaction_InsertNilTransaction(const UndoTransaction_InsertNilTransaction& from);

  inline UndoTransaction_InsertNilTransaction& operator=(const UndoTransaction_InsertNilTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_InsertNilTransaction& default_instance();

  void Swap(UndoTransaction_InsertNilTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_InsertNilTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_InsertNilTransaction& from);
  void MergeFrom(const UndoTransaction_InsertNilTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attribute_index = 1;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // required uint32 attribute_count = 2;
  inline bool has_attribute_count() const;
  inline void clear_attribute_count();
  static const int kAttributeCountFieldNumber = 2;
  inline ::google::protobuf::uint32 attribute_count() const;
  inline void set_attribute_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.InsertNilTransaction)
 private:
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_attribute_count();
  inline void clear_has_attribute_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attribute_index_;
  ::google::protobuf::uint32 attribute_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_InsertNilTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_CharDeltaTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_CharDeltaTransaction();
  virtual ~UndoTransaction_CharDeltaTransaction();

  UndoTransaction_CharDeltaTransaction(const UndoTransaction_CharDeltaTransaction& from);

  inline UndoTransaction_CharDeltaTransaction& operator=(const UndoTransaction_CharDeltaTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_CharDeltaTransaction& default_instance();

  void Swap(UndoTransaction_CharDeltaTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_CharDeltaTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_CharDeltaTransaction& from);
  void MergeFrom(const UndoTransaction_CharDeltaTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_index = 1;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 char_index() const;
  inline void set_char_index(::google::protobuf::uint32 value);

  // required uint32 attribute_index = 2;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // required sint32 char_delta = 3;
  inline bool has_char_delta() const;
  inline void clear_char_delta();
  static const int kCharDeltaFieldNumber = 3;
  inline ::google::protobuf::int32 char_delta() const;
  inline void set_char_delta(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.CharDeltaTransaction)
 private:
  inline void set_has_char_index();
  inline void clear_has_char_index();
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_char_delta();
  inline void clear_has_char_delta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 char_index_;
  ::google::protobuf::uint32 attribute_index_;
  ::google::protobuf::int32 char_delta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_CharDeltaTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_ParagraphDataTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_ParagraphDataTransaction();
  virtual ~UndoTransaction_ParagraphDataTransaction();

  UndoTransaction_ParagraphDataTransaction(const UndoTransaction_ParagraphDataTransaction& from);

  inline UndoTransaction_ParagraphDataTransaction& operator=(const UndoTransaction_ParagraphDataTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_ParagraphDataTransaction& default_instance();

  void Swap(UndoTransaction_ParagraphDataTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_ParagraphDataTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_ParagraphDataTransaction& from);
  void MergeFrom(const UndoTransaction_ParagraphDataTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attribute_index = 1;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // required uint32 first = 2;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 2;
  inline ::google::protobuf::uint32 first() const;
  inline void set_first(::google::protobuf::uint32 value);

  // required uint32 second = 3;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 3;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // required uint32 char_index = 4;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 char_index() const;
  inline void set_char_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.ParagraphDataTransaction)
 private:
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_char_index();
  inline void clear_has_char_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attribute_index_;
  ::google::protobuf::uint32 first_;
  ::google::protobuf::uint32 second_;
  ::google::protobuf::uint32 char_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_ParagraphDataTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_ObjectDOLCTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_ObjectDOLCTransaction();
  virtual ~UndoTransaction_ObjectDOLCTransaction();

  UndoTransaction_ObjectDOLCTransaction(const UndoTransaction_ObjectDOLCTransaction& from);

  inline UndoTransaction_ObjectDOLCTransaction& operator=(const UndoTransaction_ObjectDOLCTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_ObjectDOLCTransaction& default_instance();

  void Swap(UndoTransaction_ObjectDOLCTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_ObjectDOLCTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_ObjectDOLCTransaction& from);
  void MergeFrom(const UndoTransaction_ObjectDOLCTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional .TSP.Reference object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.ObjectDOLCTransaction)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* object_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_ObjectDOLCTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_CTDateTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_CTDateTransaction();
  virtual ~UndoTransaction_CTDateTransaction();

  UndoTransaction_CTDateTransaction(const UndoTransaction_CTDateTransaction& from);

  inline UndoTransaction_CTDateTransaction& operator=(const UndoTransaction_CTDateTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_CTDateTransaction& default_instance();

  void Swap(UndoTransaction_CTDateTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_CTDateTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_CTDateTransaction& from);
  void MergeFrom(const UndoTransaction_CTDateTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attribute_index = 1;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 attribute_index() const;
  inline void set_attribute_index(::google::protobuf::uint32 value);

  // optional .TSP.Date date = 2;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 2;
  inline const ::TSP::Date& date() const;
  inline ::TSP::Date* mutable_date();
  inline ::TSP::Date* release_date();
  inline void set_allocated_date(::TSP::Date* date);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.CTDateTransaction)
 private:
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Date* date_;
  ::google::protobuf::uint32 attribute_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_CTDateTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction_UnionTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction_UnionTransaction();
  virtual ~UndoTransaction_UnionTransaction();

  UndoTransaction_UnionTransaction(const UndoTransaction_UnionTransaction& from);

  inline UndoTransaction_UnionTransaction& operator=(const UndoTransaction_UnionTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction_UnionTransaction& default_instance();

  void Swap(UndoTransaction_UnionTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction_UnionTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction_UnionTransaction& from);
  void MergeFrom(const UndoTransaction_UnionTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.UndoTransaction.UndoKind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::TSWP::UndoTransaction_UndoKind kind() const;
  inline void set_kind(::TSWP::UndoTransaction_UndoKind value);

  // optional uint32 table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline ::google::protobuf::uint32 table() const;
  inline void set_table(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction.GenericTransaction generic = 5;
  inline bool has_generic() const;
  inline void clear_generic();
  static const int kGenericFieldNumber = 5;
  inline const ::TSWP::UndoTransaction_GenericTransaction& generic() const;
  inline ::TSWP::UndoTransaction_GenericTransaction* mutable_generic();
  inline ::TSWP::UndoTransaction_GenericTransaction* release_generic();
  inline void set_allocated_generic(::TSWP::UndoTransaction_GenericTransaction* generic);

  // optional .TSWP.UndoTransaction.TextTransaction text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::TSWP::UndoTransaction_TextTransaction& text() const;
  inline ::TSWP::UndoTransaction_TextTransaction* mutable_text();
  inline ::TSWP::UndoTransaction_TextTransaction* release_text();
  inline void set_allocated_text(::TSWP::UndoTransaction_TextTransaction* text);

  // optional .TSWP.UndoTransaction.CharIndexTransaction char_index = 7;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 7;
  inline const ::TSWP::UndoTransaction_CharIndexTransaction& char_index() const;
  inline ::TSWP::UndoTransaction_CharIndexTransaction* mutable_char_index();
  inline ::TSWP::UndoTransaction_CharIndexTransaction* release_char_index();
  inline void set_allocated_char_index(::TSWP::UndoTransaction_CharIndexTransaction* char_index);

  // optional .TSWP.UndoTransaction.ReplaceCharIndexTransaction replace_char_index = 8;
  inline bool has_replace_char_index() const;
  inline void clear_replace_char_index();
  static const int kReplaceCharIndexFieldNumber = 8;
  inline const ::TSWP::UndoTransaction_ReplaceCharIndexTransaction& replace_char_index() const;
  inline ::TSWP::UndoTransaction_ReplaceCharIndexTransaction* mutable_replace_char_index();
  inline ::TSWP::UndoTransaction_ReplaceCharIndexTransaction* release_replace_char_index();
  inline void set_allocated_replace_char_index(::TSWP::UndoTransaction_ReplaceCharIndexTransaction* replace_char_index);

  // optional .TSWP.UndoTransaction.AttributeIndexTransaction attribute_index = 9;
  inline bool has_attribute_index() const;
  inline void clear_attribute_index();
  static const int kAttributeIndexFieldNumber = 9;
  inline const ::TSWP::UndoTransaction_AttributeIndexTransaction& attribute_index() const;
  inline ::TSWP::UndoTransaction_AttributeIndexTransaction* mutable_attribute_index();
  inline ::TSWP::UndoTransaction_AttributeIndexTransaction* release_attribute_index();
  inline void set_allocated_attribute_index(::TSWP::UndoTransaction_AttributeIndexTransaction* attribute_index);

  // optional .TSWP.UndoTransaction.InsertNilTransaction insert_nil = 10;
  inline bool has_insert_nil() const;
  inline void clear_insert_nil();
  static const int kInsertNilFieldNumber = 10;
  inline const ::TSWP::UndoTransaction_InsertNilTransaction& insert_nil() const;
  inline ::TSWP::UndoTransaction_InsertNilTransaction* mutable_insert_nil();
  inline ::TSWP::UndoTransaction_InsertNilTransaction* release_insert_nil();
  inline void set_allocated_insert_nil(::TSWP::UndoTransaction_InsertNilTransaction* insert_nil);

  // optional .TSWP.UndoTransaction.InsertAttributeTransaction insert_attribute = 11;
  inline bool has_insert_attribute() const;
  inline void clear_insert_attribute();
  static const int kInsertAttributeFieldNumber = 11;
  inline const ::TSWP::UndoTransaction_InsertAttributeTransaction& insert_attribute() const;
  inline ::TSWP::UndoTransaction_InsertAttributeTransaction* mutable_insert_attribute();
  inline ::TSWP::UndoTransaction_InsertAttributeTransaction* release_insert_attribute();
  inline void set_allocated_insert_attribute(::TSWP::UndoTransaction_InsertAttributeTransaction* insert_attribute);

  // optional .TSWP.UndoTransaction.CharDeltaTransaction char_delta = 12;
  inline bool has_char_delta() const;
  inline void clear_char_delta();
  static const int kCharDeltaFieldNumber = 12;
  inline const ::TSWP::UndoTransaction_CharDeltaTransaction& char_delta() const;
  inline ::TSWP::UndoTransaction_CharDeltaTransaction* mutable_char_delta();
  inline ::TSWP::UndoTransaction_CharDeltaTransaction* release_char_delta();
  inline void set_allocated_char_delta(::TSWP::UndoTransaction_CharDeltaTransaction* char_delta);

  // optional .TSWP.UndoTransaction.ParagraphDataTransaction paragraph_data = 13;
  inline bool has_paragraph_data() const;
  inline void clear_paragraph_data();
  static const int kParagraphDataFieldNumber = 13;
  inline const ::TSWP::UndoTransaction_ParagraphDataTransaction& paragraph_data() const;
  inline ::TSWP::UndoTransaction_ParagraphDataTransaction* mutable_paragraph_data();
  inline ::TSWP::UndoTransaction_ParagraphDataTransaction* release_paragraph_data();
  inline void set_allocated_paragraph_data(::TSWP::UndoTransaction_ParagraphDataTransaction* paragraph_data);

  // optional .TSWP.UndoTransaction.ObjectDOLCTransaction object_dolc = 14;
  inline bool has_object_dolc() const;
  inline void clear_object_dolc();
  static const int kObjectDolcFieldNumber = 14;
  inline const ::TSWP::UndoTransaction_ObjectDOLCTransaction& object_dolc() const;
  inline ::TSWP::UndoTransaction_ObjectDOLCTransaction* mutable_object_dolc();
  inline ::TSWP::UndoTransaction_ObjectDOLCTransaction* release_object_dolc();
  inline void set_allocated_object_dolc(::TSWP::UndoTransaction_ObjectDOLCTransaction* object_dolc);

  // optional .TSWP.UndoTransaction.CTDateTransaction ct_date = 15;
  inline bool has_ct_date() const;
  inline void clear_ct_date();
  static const int kCtDateFieldNumber = 15;
  inline const ::TSWP::UndoTransaction_CTDateTransaction& ct_date() const;
  inline ::TSWP::UndoTransaction_CTDateTransaction* mutable_ct_date();
  inline ::TSWP::UndoTransaction_CTDateTransaction* release_ct_date();
  inline void set_allocated_ct_date(::TSWP::UndoTransaction_CTDateTransaction* ct_date);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction.UnionTransaction)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_generic();
  inline void clear_has_generic();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_char_index();
  inline void clear_has_char_index();
  inline void set_has_replace_char_index();
  inline void clear_has_replace_char_index();
  inline void set_has_attribute_index();
  inline void clear_has_attribute_index();
  inline void set_has_insert_nil();
  inline void clear_has_insert_nil();
  inline void set_has_insert_attribute();
  inline void clear_has_insert_attribute();
  inline void set_has_char_delta();
  inline void clear_has_char_delta();
  inline void set_has_paragraph_data();
  inline void clear_has_paragraph_data();
  inline void set_has_object_dolc();
  inline void clear_has_object_dolc();
  inline void set_has_ct_date();
  inline void clear_has_ct_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int kind_;
  ::google::protobuf::uint32 table_;
  ::TSWP::UndoTransaction_GenericTransaction* generic_;
  ::TSWP::UndoTransaction_TextTransaction* text_;
  ::TSWP::UndoTransaction_CharIndexTransaction* char_index_;
  ::TSWP::UndoTransaction_ReplaceCharIndexTransaction* replace_char_index_;
  ::TSWP::UndoTransaction_AttributeIndexTransaction* attribute_index_;
  ::TSWP::UndoTransaction_InsertNilTransaction* insert_nil_;
  ::TSWP::UndoTransaction_InsertAttributeTransaction* insert_attribute_;
  ::TSWP::UndoTransaction_CharDeltaTransaction* char_delta_;
  ::TSWP::UndoTransaction_ParagraphDataTransaction* paragraph_data_;
  ::TSWP::UndoTransaction_ObjectDOLCTransaction* object_dolc_;
  ::TSWP::UndoTransaction_CTDateTransaction* ct_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction_UnionTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransaction : public ::google::protobuf::Message {
 public:
  UndoTransaction();
  virtual ~UndoTransaction();

  UndoTransaction(const UndoTransaction& from);

  inline UndoTransaction& operator=(const UndoTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransaction& default_instance();

  void Swap(UndoTransaction* other);

  // implements Message ----------------------------------------------

  UndoTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransaction& from);
  void MergeFrom(const UndoTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UndoTransaction_GenericTransaction GenericTransaction;
  typedef UndoTransaction_TextTransaction TextTransaction;
  typedef UndoTransaction_CharIndexTransaction CharIndexTransaction;
  typedef UndoTransaction_ReplaceCharIndexTransaction ReplaceCharIndexTransaction;
  typedef UndoTransaction_AttributeIndexTransaction AttributeIndexTransaction;
  typedef UndoTransaction_InsertAttributeTransaction InsertAttributeTransaction;
  typedef UndoTransaction_InsertNilTransaction InsertNilTransaction;
  typedef UndoTransaction_CharDeltaTransaction CharDeltaTransaction;
  typedef UndoTransaction_ParagraphDataTransaction ParagraphDataTransaction;
  typedef UndoTransaction_ObjectDOLCTransaction ObjectDOLCTransaction;
  typedef UndoTransaction_CTDateTransaction CTDateTransaction;
  typedef UndoTransaction_UnionTransaction UnionTransaction;

  typedef UndoTransaction_UndoKind UndoKind;
  static const UndoKind REPLACE_TEXT = UndoTransaction_UndoKind_REPLACE_TEXT;
  static const UndoKind INSERT_ATTRIBUTE = UndoTransaction_UndoKind_INSERT_ATTRIBUTE;
  static const UndoKind DELETE_ATTRIBUTE = UndoTransaction_UndoKind_DELETE_ATTRIBUTE;
  static const UndoKind ADJUST_CHAR_INDEXES = UndoTransaction_UndoKind_ADJUST_CHAR_INDEXES;
  static const UndoKind COMPR_ADJUST_CHAR_INDEXES = UndoTransaction_UndoKind_COMPR_ADJUST_CHAR_INDEXES;
  static const UndoKind REPLACE_CHAR_INDEX = UndoTransaction_UndoKind_REPLACE_CHAR_INDEX;
  static const UndoKind REPLACE_OBJECT = UndoTransaction_UndoKind_REPLACE_OBJECT;
  static const UndoKind REPLACE_PARAGRAPH_DATA = UndoTransaction_UndoKind_REPLACE_PARAGRAPH_DATA;
  static const UndoKind OBJECT_DOLC = UndoTransaction_UndoKind_OBJECT_DOLC;
  static const UndoKind CT_DATE = UndoTransaction_UndoKind_CT_DATE;
  static inline bool UndoKind_IsValid(int value) {
    return UndoTransaction_UndoKind_IsValid(value);
  }
  static const UndoKind UndoKind_MIN =
    UndoTransaction_UndoKind_UndoKind_MIN;
  static const UndoKind UndoKind_MAX =
    UndoTransaction_UndoKind_UndoKind_MAX;
  static const int UndoKind_ARRAYSIZE =
    UndoTransaction_UndoKind_UndoKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UndoKind_descriptor() {
    return UndoTransaction_UndoKind_descriptor();
  }
  static inline const ::std::string& UndoKind_Name(UndoKind value) {
    return UndoTransaction_UndoKind_Name(value);
  }
  static inline bool UndoKind_Parse(const ::std::string& name,
      UndoKind* value) {
    return UndoTransaction_UndoKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TSWP.UndoTransaction.UnionTransaction entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TSWP::UndoTransaction_UnionTransaction& entries(int index) const;
  inline ::TSWP::UndoTransaction_UnionTransaction* mutable_entries(int index);
  inline ::TSWP::UndoTransaction_UnionTransaction* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::UndoTransaction_UnionTransaction >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::UndoTransaction_UnionTransaction >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransaction)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSWP::UndoTransaction_UnionTransaction > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransaction* default_instance_;
};
// -------------------------------------------------------------------

class UndoTransactionWrapperArchive : public ::google::protobuf::Message {
 public:
  UndoTransactionWrapperArchive();
  virtual ~UndoTransactionWrapperArchive();

  UndoTransactionWrapperArchive(const UndoTransactionWrapperArchive& from);

  inline UndoTransactionWrapperArchive& operator=(const UndoTransactionWrapperArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoTransactionWrapperArchive& default_instance();

  void Swap(UndoTransactionWrapperArchive* other);

  // implements Message ----------------------------------------------

  UndoTransactionWrapperArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoTransactionWrapperArchive& from);
  void MergeFrom(const UndoTransactionWrapperArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.UndoTransaction undo_transaction = 1;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 1;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.UndoTransactionWrapperArchive)
 private:
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoTransactionWrapperArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeInfoArchive : public ::google::protobuf::Message {
 public:
  ShapeInfoArchive();
  virtual ~ShapeInfoArchive();

  ShapeInfoArchive(const ShapeInfoArchive& from);

  inline ShapeInfoArchive& operator=(const ShapeInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeInfoArchive& default_instance();

  void Swap(ShapeInfoArchive* other);

  // implements Message ----------------------------------------------

  ShapeInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeInfoArchive& from);
  void MergeFrom(const ShapeInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.ShapeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::ShapeArchive& super() const;
  inline ::TSD::ShapeArchive* mutable_super();
  inline ::TSD::ShapeArchive* release_super();
  inline void set_allocated_super(::TSD::ShapeArchive* super);

  // optional .TSP.Reference containedStorage = 2;
  inline bool has_containedstorage() const;
  inline void clear_containedstorage();
  static const int kContainedStorageFieldNumber = 2;
  inline const ::TSP::Reference& containedstorage() const;
  inline ::TSP::Reference* mutable_containedstorage();
  inline ::TSP::Reference* release_containedstorage();
  inline void set_allocated_containedstorage(::TSP::Reference* containedstorage);

  // @@protoc_insertion_point(class_scope:TSWP.ShapeInfoArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_containedstorage();
  inline void clear_has_containedstorage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::ShapeArchive* super_;
  ::TSP::Reference* containedstorage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommentInfoArchive : public ::google::protobuf::Message {
 public:
  CommentInfoArchive();
  virtual ~CommentInfoArchive();

  CommentInfoArchive(const CommentInfoArchive& from);

  inline CommentInfoArchive& operator=(const CommentInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentInfoArchive& default_instance();

  void Swap(CommentInfoArchive* other);

  // implements Message ----------------------------------------------

  CommentInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentInfoArchive& from);
  void MergeFrom(const CommentInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.ShapeInfoArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::ShapeInfoArchive& super() const;
  inline ::TSWP::ShapeInfoArchive* mutable_super();
  inline ::TSWP::ShapeInfoArchive* release_super();
  inline void set_allocated_super(::TSWP::ShapeInfoArchive* super);

  // optional .TSP.Reference comment_storage = 2;
  inline bool has_comment_storage() const;
  inline void clear_comment_storage();
  static const int kCommentStorageFieldNumber = 2;
  inline const ::TSP::Reference& comment_storage() const;
  inline ::TSP::Reference* mutable_comment_storage();
  inline ::TSP::Reference* release_comment_storage();
  inline void set_allocated_comment_storage(::TSP::Reference* comment_storage);

  // @@protoc_insertion_point(class_scope:TSWP.CommentInfoArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_comment_storage();
  inline void clear_has_comment_storage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ShapeInfoArchive* super_;
  ::TSP::Reference* comment_storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static CommentInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCInfoArchive : public ::google::protobuf::Message {
 public:
  TOCInfoArchive();
  virtual ~TOCInfoArchive();

  TOCInfoArchive(const TOCInfoArchive& from);

  inline TOCInfoArchive& operator=(const TOCInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCInfoArchive& default_instance();

  void Swap(TOCInfoArchive* other);

  // implements Message ----------------------------------------------

  TOCInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCInfoArchive& from);
  void MergeFrom(const TOCInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.ShapeInfoArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::ShapeInfoArchive& super() const;
  inline ::TSWP::ShapeInfoArchive* mutable_super();
  inline ::TSWP::ShapeInfoArchive* release_super();
  inline void set_allocated_super(::TSWP::ShapeInfoArchive* super);

  // optional .TSP.Reference toc_settings = 2;
  inline bool has_toc_settings() const;
  inline void clear_toc_settings();
  static const int kTocSettingsFieldNumber = 2;
  inline const ::TSP::Reference& toc_settings() const;
  inline ::TSP::Reference* mutable_toc_settings();
  inline ::TSP::Reference* release_toc_settings();
  inline void set_allocated_toc_settings(::TSP::Reference* toc_settings);

  // repeated .TSP.Reference toc_entry_data = 3;
  inline int toc_entry_data_size() const;
  inline void clear_toc_entry_data();
  static const int kTocEntryDataFieldNumber = 3;
  inline const ::TSP::Reference& toc_entry_data(int index) const;
  inline ::TSP::Reference* mutable_toc_entry_data(int index);
  inline ::TSP::Reference* add_toc_entry_data();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      toc_entry_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_toc_entry_data();

  // repeated .TSP.Range page_number_ranges = 4;
  inline int page_number_ranges_size() const;
  inline void clear_page_number_ranges();
  static const int kPageNumberRangesFieldNumber = 4;
  inline const ::TSP::Range& page_number_ranges(int index) const;
  inline ::TSP::Range* mutable_page_number_ranges(int index);
  inline ::TSP::Range* add_page_number_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Range >&
      page_number_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Range >*
      mutable_page_number_ranges();

  // @@protoc_insertion_point(class_scope:TSWP.TOCInfoArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_toc_settings();
  inline void clear_has_toc_settings();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ShapeInfoArchive* super_;
  ::TSP::Reference* toc_settings_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > toc_entry_data_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Range > page_number_ranges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCLayoutHintArchive : public ::google::protobuf::Message {
 public:
  TOCLayoutHintArchive();
  virtual ~TOCLayoutHintArchive();

  TOCLayoutHintArchive(const TOCLayoutHintArchive& from);

  inline TOCLayoutHintArchive& operator=(const TOCLayoutHintArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCLayoutHintArchive& default_instance();

  void Swap(TOCLayoutHintArchive* other);

  // implements Message ----------------------------------------------

  TOCLayoutHintArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCLayoutHintArchive& from);
  void MergeFrom(const TOCLayoutHintArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Range charRange = 1;
  inline bool has_charrange() const;
  inline void clear_charrange();
  static const int kCharRangeFieldNumber = 1;
  inline const ::TSP::Range& charrange() const;
  inline ::TSP::Range* mutable_charrange();
  inline ::TSP::Range* release_charrange();
  inline void set_allocated_charrange(::TSP::Range* charrange);

  // @@protoc_insertion_point(class_scope:TSWP.TOCLayoutHintArchive)
 private:
  inline void set_has_charrange();
  inline void clear_has_charrange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Range* charrange_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCLayoutHintArchive* default_instance_;
};
// -------------------------------------------------------------------

class TextualAttachmentArchive : public ::google::protobuf::Message {
 public:
  TextualAttachmentArchive();
  virtual ~TextualAttachmentArchive();

  TextualAttachmentArchive(const TextualAttachmentArchive& from);

  inline TextualAttachmentArchive& operator=(const TextualAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextualAttachmentArchive& default_instance();

  void Swap(TextualAttachmentArchive* other);

  // implements Message ----------------------------------------------

  TextualAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextualAttachmentArchive& from);
  void MergeFrom(const TextualAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TextualAttachmentArchive_Kind Kind;
  static const Kind kKindPageNumber = TextualAttachmentArchive_Kind_kKindPageNumber;
  static const Kind kKindPageCount = TextualAttachmentArchive_Kind_kKindPageCount;
  static const Kind kKindFootnoteMark = TextualAttachmentArchive_Kind_kKindFootnoteMark;
  static inline bool Kind_IsValid(int value) {
    return TextualAttachmentArchive_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    TextualAttachmentArchive_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    TextualAttachmentArchive_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    TextualAttachmentArchive_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return TextualAttachmentArchive_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return TextualAttachmentArchive_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return TextualAttachmentArchive_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string string_equivalent = 1;
  inline bool has_string_equivalent() const;
  inline void clear_string_equivalent();
  static const int kStringEquivalentFieldNumber = 1;
  inline const ::std::string& string_equivalent() const;
  inline void set_string_equivalent(const ::std::string& value);
  inline void set_string_equivalent(const char* value);
  inline void set_string_equivalent(const char* value, size_t size);
  inline ::std::string* mutable_string_equivalent();
  inline ::std::string* release_string_equivalent();
  inline void set_allocated_string_equivalent(::std::string* string_equivalent);

  // optional .TSWP.TextualAttachmentArchive.Kind kind = 2;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 2;
  inline ::TSWP::TextualAttachmentArchive_Kind kind() const;
  inline void set_kind(::TSWP::TextualAttachmentArchive_Kind value);

  // @@protoc_insertion_point(class_scope:TSWP.TextualAttachmentArchive)
 private:
  inline void set_has_string_equivalent();
  inline void clear_has_string_equivalent();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* string_equivalent_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TextualAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class TSWPTOCPageNumberAttachmentArchive : public ::google::protobuf::Message {
 public:
  TSWPTOCPageNumberAttachmentArchive();
  virtual ~TSWPTOCPageNumberAttachmentArchive();

  TSWPTOCPageNumberAttachmentArchive(const TSWPTOCPageNumberAttachmentArchive& from);

  inline TSWPTOCPageNumberAttachmentArchive& operator=(const TSWPTOCPageNumberAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSWPTOCPageNumberAttachmentArchive& default_instance();

  void Swap(TSWPTOCPageNumberAttachmentArchive* other);

  // implements Message ----------------------------------------------

  TSWPTOCPageNumberAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSWPTOCPageNumberAttachmentArchive& from);
  void MergeFrom(const TSWPTOCPageNumberAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.TextualAttachmentArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextualAttachmentArchive& super() const;
  inline ::TSWP::TextualAttachmentArchive* mutable_super();
  inline ::TSWP::TextualAttachmentArchive* release_super();
  inline void set_allocated_super(::TSWP::TextualAttachmentArchive* super);

  // optional string page_number = 2;
  inline bool has_page_number() const;
  inline void clear_page_number();
  static const int kPageNumberFieldNumber = 2;
  inline const ::std::string& page_number() const;
  inline void set_page_number(const ::std::string& value);
  inline void set_page_number(const char* value);
  inline void set_page_number(const char* value, size_t size);
  inline ::std::string* mutable_page_number();
  inline ::std::string* release_page_number();
  inline void set_allocated_page_number(::std::string* page_number);

  // optional string bookmark_name = 3;
  inline bool has_bookmark_name() const;
  inline void clear_bookmark_name();
  static const int kBookmarkNameFieldNumber = 3;
  inline const ::std::string& bookmark_name() const;
  inline void set_bookmark_name(const ::std::string& value);
  inline void set_bookmark_name(const char* value);
  inline void set_bookmark_name(const char* value, size_t size);
  inline ::std::string* mutable_bookmark_name();
  inline ::std::string* release_bookmark_name();
  inline void set_allocated_bookmark_name(::std::string* bookmark_name);

  // @@protoc_insertion_point(class_scope:TSWP.TSWPTOCPageNumberAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_page_number();
  inline void clear_has_page_number();
  inline void set_has_bookmark_name();
  inline void clear_has_bookmark_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextualAttachmentArchive* super_;
  ::std::string* page_number_;
  ::std::string* bookmark_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TSWPTOCPageNumberAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class UIGraphicalAttachment : public ::google::protobuf::Message {
 public:
  UIGraphicalAttachment();
  virtual ~UIGraphicalAttachment();

  UIGraphicalAttachment(const UIGraphicalAttachment& from);

  inline UIGraphicalAttachment& operator=(const UIGraphicalAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIGraphicalAttachment& default_instance();

  void Swap(UIGraphicalAttachment* other);

  // implements Message ----------------------------------------------

  UIGraphicalAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIGraphicalAttachment& from);
  void MergeFrom(const UIGraphicalAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSWP.UIGraphicalAttachment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UIGraphicalAttachment* default_instance_;
};
// -------------------------------------------------------------------

class DrawableAttachmentArchive : public ::google::protobuf::Message {
 public:
  DrawableAttachmentArchive();
  virtual ~DrawableAttachmentArchive();

  DrawableAttachmentArchive(const DrawableAttachmentArchive& from);

  inline DrawableAttachmentArchive& operator=(const DrawableAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableAttachmentArchive& default_instance();

  void Swap(DrawableAttachmentArchive* other);

  // implements Message ----------------------------------------------

  DrawableAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableAttachmentArchive& from);
  void MergeFrom(const DrawableAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional uint32 h_offset_type = 2;
  inline bool has_h_offset_type() const;
  inline void clear_h_offset_type();
  static const int kHOffsetTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 h_offset_type() const;
  inline void set_h_offset_type(::google::protobuf::uint32 value);

  // optional float h_offset = 3;
  inline bool has_h_offset() const;
  inline void clear_h_offset();
  static const int kHOffsetFieldNumber = 3;
  inline float h_offset() const;
  inline void set_h_offset(float value);

  // optional uint32 v_offset_type = 4;
  inline bool has_v_offset_type() const;
  inline void clear_v_offset_type();
  static const int kVOffsetTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 v_offset_type() const;
  inline void set_v_offset_type(::google::protobuf::uint32 value);

  // optional float v_offset = 5;
  inline bool has_v_offset() const;
  inline void clear_v_offset();
  static const int kVOffsetFieldNumber = 5;
  inline float v_offset() const;
  inline void set_v_offset(float value);

  // @@protoc_insertion_point(class_scope:TSWP.DrawableAttachmentArchive)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_h_offset_type();
  inline void clear_has_h_offset_type();
  inline void set_has_h_offset();
  inline void clear_has_h_offset();
  inline void set_has_v_offset_type();
  inline void clear_has_v_offset_type();
  inline void set_has_v_offset();
  inline void clear_has_v_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::google::protobuf::uint32 h_offset_type_;
  float h_offset_;
  ::google::protobuf::uint32 v_offset_type_;
  float v_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCAttachmentArchive : public ::google::protobuf::Message {
 public:
  TOCAttachmentArchive();
  virtual ~TOCAttachmentArchive();

  TOCAttachmentArchive(const TOCAttachmentArchive& from);

  inline TOCAttachmentArchive& operator=(const TOCAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCAttachmentArchive& default_instance();

  void Swap(TOCAttachmentArchive* other);

  // implements Message ----------------------------------------------

  TOCAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCAttachmentArchive& from);
  void MergeFrom(const TOCAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.DrawableAttachmentArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::DrawableAttachmentArchive& super() const;
  inline ::TSWP::DrawableAttachmentArchive* mutable_super();
  inline ::TSWP::DrawableAttachmentArchive* release_super();
  inline void set_allocated_super(::TSWP::DrawableAttachmentArchive* super);

  // @@protoc_insertion_point(class_scope:TSWP.TOCAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::DrawableAttachmentArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class FootnoteReferenceAttachmentArchive : public ::google::protobuf::Message {
 public:
  FootnoteReferenceAttachmentArchive();
  virtual ~FootnoteReferenceAttachmentArchive();

  FootnoteReferenceAttachmentArchive(const FootnoteReferenceAttachmentArchive& from);

  inline FootnoteReferenceAttachmentArchive& operator=(const FootnoteReferenceAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FootnoteReferenceAttachmentArchive& default_instance();

  void Swap(FootnoteReferenceAttachmentArchive* other);

  // implements Message ----------------------------------------------

  FootnoteReferenceAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FootnoteReferenceAttachmentArchive& from);
  void MergeFrom(const FootnoteReferenceAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.TextualAttachmentArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextualAttachmentArchive& super() const;
  inline ::TSWP::TextualAttachmentArchive* mutable_super();
  inline ::TSWP::TextualAttachmentArchive* release_super();
  inline void set_allocated_super(::TSWP::TextualAttachmentArchive* super);

  // optional .TSP.Reference contained_storage = 2;
  inline bool has_contained_storage() const;
  inline void clear_contained_storage();
  static const int kContainedStorageFieldNumber = 2;
  inline const ::TSP::Reference& contained_storage() const;
  inline ::TSP::Reference* mutable_contained_storage();
  inline ::TSP::Reference* release_contained_storage();
  inline void set_allocated_contained_storage(::TSP::Reference* contained_storage);

  // optional string custom_mark_string = 3;
  inline bool has_custom_mark_string() const;
  inline void clear_custom_mark_string();
  static const int kCustomMarkStringFieldNumber = 3;
  inline const ::std::string& custom_mark_string() const;
  inline void set_custom_mark_string(const ::std::string& value);
  inline void set_custom_mark_string(const char* value);
  inline void set_custom_mark_string(const char* value, size_t size);
  inline ::std::string* mutable_custom_mark_string();
  inline ::std::string* release_custom_mark_string();
  inline void set_allocated_custom_mark_string(::std::string* custom_mark_string);

  // @@protoc_insertion_point(class_scope:TSWP.FootnoteReferenceAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_contained_storage();
  inline void clear_has_contained_storage();
  inline void set_has_custom_mark_string();
  inline void clear_has_custom_mark_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextualAttachmentArchive* super_;
  ::TSP::Reference* contained_storage_;
  ::std::string* custom_mark_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static FootnoteReferenceAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class NumberAttachmentArchive : public ::google::protobuf::Message {
 public:
  NumberAttachmentArchive();
  virtual ~NumberAttachmentArchive();

  NumberAttachmentArchive(const NumberAttachmentArchive& from);

  inline NumberAttachmentArchive& operator=(const NumberAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberAttachmentArchive& default_instance();

  void Swap(NumberAttachmentArchive* other);

  // implements Message ----------------------------------------------

  NumberAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumberAttachmentArchive& from);
  void MergeFrom(const NumberAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.TextualAttachmentArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextualAttachmentArchive& super() const;
  inline ::TSWP::TextualAttachmentArchive* mutable_super();
  inline ::TSWP::TextualAttachmentArchive* release_super();
  inline void set_allocated_super(::TSWP::TextualAttachmentArchive* super);

  // optional uint32 number_format = 2;
  inline bool has_number_format() const;
  inline void clear_number_format();
  static const int kNumberFormatFieldNumber = 2;
  inline ::google::protobuf::uint32 number_format() const;
  inline void set_number_format(::google::protobuf::uint32 value);

  // optional string string_value = 3;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 3;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // @@protoc_insertion_point(class_scope:TSWP.NumberAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_number_format();
  inline void clear_has_number_format();
  inline void set_has_string_value();
  inline void clear_has_string_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextualAttachmentArchive* super_;
  ::std::string* string_value_;
  ::google::protobuf::uint32 number_format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static NumberAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class SmartFieldArchive : public ::google::protobuf::Message {
 public:
  SmartFieldArchive();
  virtual ~SmartFieldArchive();

  SmartFieldArchive(const SmartFieldArchive& from);

  inline SmartFieldArchive& operator=(const SmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartFieldArchive& default_instance();

  void Swap(SmartFieldArchive* other);

  // implements Message ----------------------------------------------

  SmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmartFieldArchive& from);
  void MergeFrom(const SmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSWP.SmartFieldArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static SmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class HyperlinkFieldArchive : public ::google::protobuf::Message {
 public:
  HyperlinkFieldArchive();
  virtual ~HyperlinkFieldArchive();

  HyperlinkFieldArchive(const HyperlinkFieldArchive& from);

  inline HyperlinkFieldArchive& operator=(const HyperlinkFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HyperlinkFieldArchive& default_instance();

  void Swap(HyperlinkFieldArchive* other);

  // implements Message ----------------------------------------------

  HyperlinkFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HyperlinkFieldArchive& from);
  void MergeFrom(const HyperlinkFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // optional string url_ref = 2;
  inline bool has_url_ref() const;
  inline void clear_url_ref();
  static const int kUrlRefFieldNumber = 2;
  inline const ::std::string& url_ref() const;
  inline void set_url_ref(const ::std::string& value);
  inline void set_url_ref(const char* value);
  inline void set_url_ref(const char* value, size_t size);
  inline ::std::string* mutable_url_ref();
  inline ::std::string* release_url_ref();
  inline void set_allocated_url_ref(::std::string* url_ref);

  // @@protoc_insertion_point(class_scope:TSWP.HyperlinkFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_url_ref();
  inline void clear_has_url_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  ::std::string* url_ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static HyperlinkFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class PlaceholderSmartFieldArchive : public ::google::protobuf::Message {
 public:
  PlaceholderSmartFieldArchive();
  virtual ~PlaceholderSmartFieldArchive();

  PlaceholderSmartFieldArchive(const PlaceholderSmartFieldArchive& from);

  inline PlaceholderSmartFieldArchive& operator=(const PlaceholderSmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaceholderSmartFieldArchive& default_instance();

  void Swap(PlaceholderSmartFieldArchive* other);

  // implements Message ----------------------------------------------

  PlaceholderSmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaceholderSmartFieldArchive& from);
  void MergeFrom(const PlaceholderSmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // optional bool localizable = 2;
  inline bool has_localizable() const;
  inline void clear_localizable();
  static const int kLocalizableFieldNumber = 2;
  inline bool localizable() const;
  inline void set_localizable(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.PlaceholderSmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_localizable();
  inline void clear_has_localizable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  bool localizable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static PlaceholderSmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class UnsupportedHyperlinkFieldArchive : public ::google::protobuf::Message {
 public:
  UnsupportedHyperlinkFieldArchive();
  virtual ~UnsupportedHyperlinkFieldArchive();

  UnsupportedHyperlinkFieldArchive(const UnsupportedHyperlinkFieldArchive& from);

  inline UnsupportedHyperlinkFieldArchive& operator=(const UnsupportedHyperlinkFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsupportedHyperlinkFieldArchive& default_instance();

  void Swap(UnsupportedHyperlinkFieldArchive* other);

  // implements Message ----------------------------------------------

  UnsupportedHyperlinkFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnsupportedHyperlinkFieldArchive& from);
  void MergeFrom(const UnsupportedHyperlinkFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.PlaceholderSmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::PlaceholderSmartFieldArchive& super() const;
  inline ::TSWP::PlaceholderSmartFieldArchive* mutable_super();
  inline ::TSWP::PlaceholderSmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super);

  // optional string url_ref = 2;
  inline bool has_url_ref() const;
  inline void clear_url_ref();
  static const int kUrlRefFieldNumber = 2;
  inline const ::std::string& url_ref() const;
  inline void set_url_ref(const ::std::string& value);
  inline void set_url_ref(const char* value);
  inline void set_url_ref(const char* value, size_t size);
  inline ::std::string* mutable_url_ref();
  inline ::std::string* release_url_ref();
  inline void set_allocated_url_ref(::std::string* url_ref);

  // @@protoc_insertion_point(class_scope:TSWP.UnsupportedHyperlinkFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_url_ref();
  inline void clear_has_url_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::PlaceholderSmartFieldArchive* super_;
  ::std::string* url_ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static UnsupportedHyperlinkFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class BibliographySmartFieldArchive : public ::google::protobuf::Message {
 public:
  BibliographySmartFieldArchive();
  virtual ~BibliographySmartFieldArchive();

  BibliographySmartFieldArchive(const BibliographySmartFieldArchive& from);

  inline BibliographySmartFieldArchive& operator=(const BibliographySmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BibliographySmartFieldArchive& default_instance();

  void Swap(BibliographySmartFieldArchive* other);

  // implements Message ----------------------------------------------

  BibliographySmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BibliographySmartFieldArchive& from);
  void MergeFrom(const BibliographySmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // repeated .TSP.Reference citation_records = 2;
  inline int citation_records_size() const;
  inline void clear_citation_records();
  static const int kCitationRecordsFieldNumber = 2;
  inline const ::TSP::Reference& citation_records(int index) const;
  inline ::TSP::Reference* mutable_citation_records(int index);
  inline ::TSP::Reference* add_citation_records();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      citation_records() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_citation_records();

  // optional bool localizable = 4;
  inline bool has_localizable() const;
  inline void clear_localizable();
  static const int kLocalizableFieldNumber = 4;
  inline bool localizable() const;
  inline void set_localizable(bool value);

  // optional .TSWP.PlaceholderSmartFieldArchive old_super = 1;
  inline bool has_old_super() const;
  inline void clear_old_super();
  static const int kOldSuperFieldNumber = 1;
  inline const ::TSWP::PlaceholderSmartFieldArchive& old_super() const;
  inline ::TSWP::PlaceholderSmartFieldArchive* mutable_old_super();
  inline ::TSWP::PlaceholderSmartFieldArchive* release_old_super();
  inline void set_allocated_old_super(::TSWP::PlaceholderSmartFieldArchive* old_super);

  // @@protoc_insertion_point(class_scope:TSWP.BibliographySmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_localizable();
  inline void clear_has_localizable();
  inline void set_has_old_super();
  inline void clear_has_old_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > citation_records_;
  ::TSWP::PlaceholderSmartFieldArchive* old_super_;
  bool localizable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static BibliographySmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class CitationRecordArchive : public ::google::protobuf::Message {
 public:
  CitationRecordArchive();
  virtual ~CitationRecordArchive();

  CitationRecordArchive(const CitationRecordArchive& from);

  inline CitationRecordArchive& operator=(const CitationRecordArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CitationRecordArchive& default_instance();

  void Swap(CitationRecordArchive* other);

  // implements Message ----------------------------------------------

  CitationRecordArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CitationRecordArchive& from);
  void MergeFrom(const CitationRecordArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string endnote_xml = 1;
  inline bool has_endnote_xml() const;
  inline void clear_endnote_xml();
  static const int kEndnoteXmlFieldNumber = 1;
  inline const ::std::string& endnote_xml() const;
  inline void set_endnote_xml(const ::std::string& value);
  inline void set_endnote_xml(const char* value);
  inline void set_endnote_xml(const char* value, size_t size);
  inline ::std::string* mutable_endnote_xml();
  inline ::std::string* release_endnote_xml();
  inline void set_allocated_endnote_xml(::std::string* endnote_xml);

  // optional bool hide_author_names = 2;
  inline bool has_hide_author_names() const;
  inline void clear_hide_author_names();
  static const int kHideAuthorNamesFieldNumber = 2;
  inline bool hide_author_names() const;
  inline void set_hide_author_names(bool value);

  // optional bool hide_year = 3;
  inline bool has_hide_year() const;
  inline void clear_hide_year();
  static const int kHideYearFieldNumber = 3;
  inline bool hide_year() const;
  inline void set_hide_year(bool value);

  // optional string page_range = 4;
  inline bool has_page_range() const;
  inline void clear_page_range();
  static const int kPageRangeFieldNumber = 4;
  inline const ::std::string& page_range() const;
  inline void set_page_range(const ::std::string& value);
  inline void set_page_range(const char* value);
  inline void set_page_range(const char* value, size_t size);
  inline ::std::string* mutable_page_range();
  inline ::std::string* release_page_range();
  inline void set_allocated_page_range(::std::string* page_range);

  // optional string prefix = 5;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 5;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // optional string suffix = 6;
  inline bool has_suffix() const;
  inline void clear_suffix();
  static const int kSuffixFieldNumber = 6;
  inline const ::std::string& suffix() const;
  inline void set_suffix(const ::std::string& value);
  inline void set_suffix(const char* value);
  inline void set_suffix(const char* value, size_t size);
  inline ::std::string* mutable_suffix();
  inline ::std::string* release_suffix();
  inline void set_allocated_suffix(::std::string* suffix);

  // optional string authors_string = 7;
  inline bool has_authors_string() const;
  inline void clear_authors_string();
  static const int kAuthorsStringFieldNumber = 7;
  inline const ::std::string& authors_string() const;
  inline void set_authors_string(const ::std::string& value);
  inline void set_authors_string(const char* value);
  inline void set_authors_string(const char* value, size_t size);
  inline ::std::string* mutable_authors_string();
  inline ::std::string* release_authors_string();
  inline void set_allocated_authors_string(::std::string* authors_string);

  // optional string title = 8;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 8;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string year = 9;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 9;
  inline const ::std::string& year() const;
  inline void set_year(const ::std::string& value);
  inline void set_year(const char* value);
  inline void set_year(const char* value, size_t size);
  inline ::std::string* mutable_year();
  inline ::std::string* release_year();
  inline void set_allocated_year(::std::string* year);

  // optional string type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:TSWP.CitationRecordArchive)
 private:
  inline void set_has_endnote_xml();
  inline void clear_has_endnote_xml();
  inline void set_has_hide_author_names();
  inline void clear_has_hide_author_names();
  inline void set_has_hide_year();
  inline void clear_has_hide_year();
  inline void set_has_page_range();
  inline void clear_has_page_range();
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_suffix();
  inline void clear_has_suffix();
  inline void set_has_authors_string();
  inline void clear_has_authors_string();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* endnote_xml_;
  ::std::string* page_range_;
  ::std::string* prefix_;
  ::std::string* suffix_;
  ::std::string* authors_string_;
  ::std::string* title_;
  ::std::string* year_;
  ::std::string* type_;
  bool hide_author_names_;
  bool hide_year_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static CitationRecordArchive* default_instance_;
};
// -------------------------------------------------------------------

class CitationSmartFieldArchive : public ::google::protobuf::Message {
 public:
  CitationSmartFieldArchive();
  virtual ~CitationSmartFieldArchive();

  CitationSmartFieldArchive(const CitationSmartFieldArchive& from);

  inline CitationSmartFieldArchive& operator=(const CitationSmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CitationSmartFieldArchive& default_instance();

  void Swap(CitationSmartFieldArchive* other);

  // implements Message ----------------------------------------------

  CitationSmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CitationSmartFieldArchive& from);
  void MergeFrom(const CitationSmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // repeated .TSP.Reference citation_records = 2;
  inline int citation_records_size() const;
  inline void clear_citation_records();
  static const int kCitationRecordsFieldNumber = 2;
  inline const ::TSP::Reference& citation_records(int index) const;
  inline ::TSP::Reference* mutable_citation_records(int index);
  inline ::TSP::Reference* add_citation_records();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      citation_records() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_citation_records();

  // optional bool localizable = 4;
  inline bool has_localizable() const;
  inline void clear_localizable();
  static const int kLocalizableFieldNumber = 4;
  inline bool localizable() const;
  inline void set_localizable(bool value);

  // optional .TSWP.PlaceholderSmartFieldArchive old_super = 1;
  inline bool has_old_super() const;
  inline void clear_old_super();
  static const int kOldSuperFieldNumber = 1;
  inline const ::TSWP::PlaceholderSmartFieldArchive& old_super() const;
  inline ::TSWP::PlaceholderSmartFieldArchive* mutable_old_super();
  inline ::TSWP::PlaceholderSmartFieldArchive* release_old_super();
  inline void set_allocated_old_super(::TSWP::PlaceholderSmartFieldArchive* old_super);

  // @@protoc_insertion_point(class_scope:TSWP.CitationSmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_localizable();
  inline void clear_has_localizable();
  inline void set_has_old_super();
  inline void clear_has_old_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > citation_records_;
  ::TSWP::PlaceholderSmartFieldArchive* old_super_;
  bool localizable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static CitationSmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class DateTimeSmartFieldArchive : public ::google::protobuf::Message {
 public:
  DateTimeSmartFieldArchive();
  virtual ~DateTimeSmartFieldArchive();

  DateTimeSmartFieldArchive(const DateTimeSmartFieldArchive& from);

  inline DateTimeSmartFieldArchive& operator=(const DateTimeSmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateTimeSmartFieldArchive& default_instance();

  void Swap(DateTimeSmartFieldArchive* other);

  // implements Message ----------------------------------------------

  DateTimeSmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateTimeSmartFieldArchive& from);
  void MergeFrom(const DateTimeSmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DateTimeSmartFieldArchive_DateTimeUpdatePlan DateTimeUpdatePlan;
  static const DateTimeUpdatePlan kDateTimeUpdatePlanNever = DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanNever;
  static const DateTimeUpdatePlan kDateTimeUpdatePlanAuto = DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanAuto;
  static const DateTimeUpdatePlan kDateTimeUpdatePlanOnce = DateTimeSmartFieldArchive_DateTimeUpdatePlan_kDateTimeUpdatePlanOnce;
  static inline bool DateTimeUpdatePlan_IsValid(int value) {
    return DateTimeSmartFieldArchive_DateTimeUpdatePlan_IsValid(value);
  }
  static const DateTimeUpdatePlan DateTimeUpdatePlan_MIN =
    DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_MIN;
  static const DateTimeUpdatePlan DateTimeUpdatePlan_MAX =
    DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_MAX;
  static const int DateTimeUpdatePlan_ARRAYSIZE =
    DateTimeSmartFieldArchive_DateTimeUpdatePlan_DateTimeUpdatePlan_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DateTimeUpdatePlan_descriptor() {
    return DateTimeSmartFieldArchive_DateTimeUpdatePlan_descriptor();
  }
  static inline const ::std::string& DateTimeUpdatePlan_Name(DateTimeUpdatePlan value) {
    return DateTimeSmartFieldArchive_DateTimeUpdatePlan_Name(value);
  }
  static inline bool DateTimeUpdatePlan_Parse(const ::std::string& name,
      DateTimeUpdatePlan* value) {
    return DateTimeSmartFieldArchive_DateTimeUpdatePlan_Parse(name, value);
  }

  typedef DateTimeSmartFieldArchive_DateTimeFormatterStyle DateTimeFormatterStyle;
  static const DateTimeFormatterStyle kDateTimeFormatterStyleNone = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleNone;
  static const DateTimeFormatterStyle kDateTimeFormatterStyleShort = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleShort;
  static const DateTimeFormatterStyle kDateTimeFormatterStyleMedium = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleMedium;
  static const DateTimeFormatterStyle kDateTimeFormatterStyleLong = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleLong;
  static const DateTimeFormatterStyle kDateTimeFormatterStyleFull = DateTimeSmartFieldArchive_DateTimeFormatterStyle_kDateTimeFormatterStyleFull;
  static inline bool DateTimeFormatterStyle_IsValid(int value) {
    return DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value);
  }
  static const DateTimeFormatterStyle DateTimeFormatterStyle_MIN =
    DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_MIN;
  static const DateTimeFormatterStyle DateTimeFormatterStyle_MAX =
    DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_MAX;
  static const int DateTimeFormatterStyle_ARRAYSIZE =
    DateTimeSmartFieldArchive_DateTimeFormatterStyle_DateTimeFormatterStyle_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DateTimeFormatterStyle_descriptor() {
    return DateTimeSmartFieldArchive_DateTimeFormatterStyle_descriptor();
  }
  static inline const ::std::string& DateTimeFormatterStyle_Name(DateTimeFormatterStyle value) {
    return DateTimeSmartFieldArchive_DateTimeFormatterStyle_Name(value);
  }
  static inline bool DateTimeFormatterStyle_Parse(const ::std::string& name,
      DateTimeFormatterStyle* value) {
    return DateTimeSmartFieldArchive_DateTimeFormatterStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // optional string format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // optional string locale_identifier = 3;
  inline bool has_locale_identifier() const;
  inline void clear_locale_identifier();
  static const int kLocaleIdentifierFieldNumber = 3;
  inline const ::std::string& locale_identifier() const;
  inline void set_locale_identifier(const ::std::string& value);
  inline void set_locale_identifier(const char* value);
  inline void set_locale_identifier(const char* value, size_t size);
  inline ::std::string* mutable_locale_identifier();
  inline ::std::string* release_locale_identifier();
  inline void set_allocated_locale_identifier(::std::string* locale_identifier);

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
  inline bool has_date_style() const;
  inline void clear_date_style();
  static const int kDateStyleFieldNumber = 4;
  inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle date_style() const;
  inline void set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
  inline bool has_time_style() const;
  inline void clear_time_style();
  static const int kTimeStyleFieldNumber = 5;
  inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle time_style() const;
  inline void set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeUpdatePlan update_plan = 6;
  inline bool has_update_plan() const;
  inline void clear_update_plan();
  static const int kUpdatePlanFieldNumber = 6;
  inline ::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan update_plan() const;
  inline void set_update_plan(::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan value);

  // optional bool needs_update = 7;
  inline bool has_needs_update() const;
  inline void clear_needs_update();
  static const int kNeedsUpdateFieldNumber = 7;
  inline bool needs_update() const;
  inline void set_needs_update(bool value);

  // optional .TSP.Date date = 8;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 8;
  inline const ::TSP::Date& date() const;
  inline ::TSP::Date* mutable_date();
  inline ::TSP::Date* release_date();
  inline void set_allocated_date(::TSP::Date* date);

  // @@protoc_insertion_point(class_scope:TSWP.DateTimeSmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_locale_identifier();
  inline void clear_has_locale_identifier();
  inline void set_has_date_style();
  inline void clear_has_date_style();
  inline void set_has_time_style();
  inline void clear_has_time_style();
  inline void set_has_update_plan();
  inline void clear_has_update_plan();
  inline void set_has_needs_update();
  inline void clear_has_needs_update();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  ::std::string* format_;
  ::std::string* locale_identifier_;
  int date_style_;
  int time_style_;
  int update_plan_;
  bool needs_update_;
  ::TSP::Date* date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static DateTimeSmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class BookmarkFieldArchive : public ::google::protobuf::Message {
 public:
  BookmarkFieldArchive();
  virtual ~BookmarkFieldArchive();

  BookmarkFieldArchive(const BookmarkFieldArchive& from);

  inline BookmarkFieldArchive& operator=(const BookmarkFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BookmarkFieldArchive& default_instance();

  void Swap(BookmarkFieldArchive* other);

  // implements Message ----------------------------------------------

  BookmarkFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BookmarkFieldArchive& from);
  void MergeFrom(const BookmarkFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 ranged = 3;
  inline bool has_ranged() const;
  inline void clear_ranged();
  static const int kRangedFieldNumber = 3;
  inline ::google::protobuf::uint32 ranged() const;
  inline void set_ranged(::google::protobuf::uint32 value);

  // optional uint32 hidden = 4;
  inline bool has_hidden() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 4;
  inline ::google::protobuf::uint32 hidden() const;
  inline void set_hidden(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.BookmarkFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ranged();
  inline void clear_has_ranged();
  inline void set_has_hidden();
  inline void clear_has_hidden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  ::std::string* name_;
  ::google::protobuf::uint32 ranged_;
  ::google::protobuf::uint32 hidden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static BookmarkFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class FilenameSmartFieldArchive : public ::google::protobuf::Message {
 public:
  FilenameSmartFieldArchive();
  virtual ~FilenameSmartFieldArchive();

  FilenameSmartFieldArchive(const FilenameSmartFieldArchive& from);

  inline FilenameSmartFieldArchive& operator=(const FilenameSmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilenameSmartFieldArchive& default_instance();

  void Swap(FilenameSmartFieldArchive* other);

  // implements Message ----------------------------------------------

  FilenameSmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilenameSmartFieldArchive& from);
  void MergeFrom(const FilenameSmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.PlaceholderSmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::PlaceholderSmartFieldArchive& super() const;
  inline ::TSWP::PlaceholderSmartFieldArchive* mutable_super();
  inline ::TSWP::PlaceholderSmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super);

  // optional uint32 display_flags = 2;
  inline bool has_display_flags() const;
  inline void clear_display_flags();
  static const int kDisplayFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 display_flags() const;
  inline void set_display_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.FilenameSmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_display_flags();
  inline void clear_has_display_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::PlaceholderSmartFieldArchive* super_;
  ::google::protobuf::uint32 display_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static FilenameSmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class MergeSmartFieldArchive : public ::google::protobuf::Message {
 public:
  MergeSmartFieldArchive();
  virtual ~MergeSmartFieldArchive();

  MergeSmartFieldArchive(const MergeSmartFieldArchive& from);

  inline MergeSmartFieldArchive& operator=(const MergeSmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeSmartFieldArchive& default_instance();

  void Swap(MergeSmartFieldArchive* other);

  // implements Message ----------------------------------------------

  MergeSmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MergeSmartFieldArchive& from);
  void MergeFrom(const MergeSmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MergeSmartFieldArchive_MergeCategory MergeCategory;
  static const MergeCategory kMergeCategoryTo = MergeSmartFieldArchive_MergeCategory_kMergeCategoryTo;
  static const MergeCategory kMergeCategoryFrom = MergeSmartFieldArchive_MergeCategory_kMergeCategoryFrom;
  static inline bool MergeCategory_IsValid(int value) {
    return MergeSmartFieldArchive_MergeCategory_IsValid(value);
  }
  static const MergeCategory MergeCategory_MIN =
    MergeSmartFieldArchive_MergeCategory_MergeCategory_MIN;
  static const MergeCategory MergeCategory_MAX =
    MergeSmartFieldArchive_MergeCategory_MergeCategory_MAX;
  static const int MergeCategory_ARRAYSIZE =
    MergeSmartFieldArchive_MergeCategory_MergeCategory_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MergeCategory_descriptor() {
    return MergeSmartFieldArchive_MergeCategory_descriptor();
  }
  static inline const ::std::string& MergeCategory_Name(MergeCategory value) {
    return MergeSmartFieldArchive_MergeCategory_Name(value);
  }
  static inline bool MergeCategory_Parse(const ::std::string& name,
      MergeCategory* value) {
    return MergeSmartFieldArchive_MergeCategory_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSWP.PlaceholderSmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::PlaceholderSmartFieldArchive& super() const;
  inline ::TSWP::PlaceholderSmartFieldArchive* mutable_super();
  inline ::TSWP::PlaceholderSmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super);

  // optional string property = 2;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 2;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // optional string label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional string key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .TSWP.MergeSmartFieldArchive.MergeCategory category = 5;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 5;
  inline ::TSWP::MergeSmartFieldArchive_MergeCategory category() const;
  inline void set_category(::TSWP::MergeSmartFieldArchive_MergeCategory value);

  // optional bool requires_following_whitespace = 6;
  inline bool has_requires_following_whitespace() const;
  inline void clear_requires_following_whitespace();
  static const int kRequiresFollowingWhitespaceFieldNumber = 6;
  inline bool requires_following_whitespace() const;
  inline void set_requires_following_whitespace(bool value);

  // optional string whitespace = 7;
  inline bool has_whitespace() const;
  inline void clear_whitespace();
  static const int kWhitespaceFieldNumber = 7;
  inline const ::std::string& whitespace() const;
  inline void set_whitespace(const ::std::string& value);
  inline void set_whitespace(const char* value);
  inline void set_whitespace(const char* value, size_t size);
  inline ::std::string* mutable_whitespace();
  inline ::std::string* release_whitespace();
  inline void set_allocated_whitespace(::std::string* whitespace);

  // optional string guid = 8;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 8;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // optional string table_field = 9;
  inline bool has_table_field() const;
  inline void clear_table_field();
  static const int kTableFieldFieldNumber = 9;
  inline const ::std::string& table_field() const;
  inline void set_table_field(const ::std::string& value);
  inline void set_table_field(const char* value);
  inline void set_table_field(const char* value, size_t size);
  inline ::std::string* mutable_table_field();
  inline ::std::string* release_table_field();
  inline void set_allocated_table_field(::std::string* table_field);

  // @@protoc_insertion_point(class_scope:TSWP.MergeSmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_requires_following_whitespace();
  inline void clear_has_requires_following_whitespace();
  inline void set_has_whitespace();
  inline void clear_has_whitespace();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_table_field();
  inline void clear_has_table_field();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::PlaceholderSmartFieldArchive* super_;
  ::std::string* property_;
  ::std::string* label_;
  ::std::string* key_;
  int category_;
  bool requires_following_whitespace_;
  ::std::string* whitespace_;
  ::std::string* guid_;
  ::std::string* table_field_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static MergeSmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class TOCSmartFieldArchive_TOCEntry : public ::google::protobuf::Message {
 public:
  TOCSmartFieldArchive_TOCEntry();
  virtual ~TOCSmartFieldArchive_TOCEntry();

  TOCSmartFieldArchive_TOCEntry(const TOCSmartFieldArchive_TOCEntry& from);

  inline TOCSmartFieldArchive_TOCEntry& operator=(const TOCSmartFieldArchive_TOCEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCSmartFieldArchive_TOCEntry& default_instance();

  void Swap(TOCSmartFieldArchive_TOCEntry* other);

  // implements Message ----------------------------------------------

  TOCSmartFieldArchive_TOCEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCSmartFieldArchive_TOCEntry& from);
  void MergeFrom(const TOCSmartFieldArchive_TOCEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bookmark_name = 1;
  inline bool has_bookmark_name() const;
  inline void clear_bookmark_name();
  static const int kBookmarkNameFieldNumber = 1;
  inline const ::std::string& bookmark_name() const;
  inline void set_bookmark_name(const ::std::string& value);
  inline void set_bookmark_name(const char* value);
  inline void set_bookmark_name(const char* value, size_t size);
  inline ::std::string* mutable_bookmark_name();
  inline ::std::string* release_bookmark_name();
  inline void set_allocated_bookmark_name(::std::string* bookmark_name);

  // optional .TSP.Reference target_style = 2;
  inline bool has_target_style() const;
  inline void clear_target_style();
  static const int kTargetStyleFieldNumber = 2;
  inline const ::TSP::Reference& target_style() const;
  inline ::TSP::Reference* mutable_target_style();
  inline ::TSP::Reference* release_target_style();
  inline void set_allocated_target_style(::TSP::Reference* target_style);

  // optional .TSP.Range range = 3;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 3;
  inline const ::TSP::Range& range() const;
  inline ::TSP::Range* mutable_range();
  inline ::TSP::Range* release_range();
  inline void set_allocated_range(::TSP::Range* range);

  // @@protoc_insertion_point(class_scope:TSWP.TOCSmartFieldArchive.TOCEntry)
 private:
  inline void set_has_bookmark_name();
  inline void clear_has_bookmark_name();
  inline void set_has_target_style();
  inline void clear_has_target_style();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bookmark_name_;
  ::TSP::Reference* target_style_;
  ::TSP::Range* range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCSmartFieldArchive_TOCEntry* default_instance_;
};
// -------------------------------------------------------------------

class TOCSmartFieldArchive : public ::google::protobuf::Message {
 public:
  TOCSmartFieldArchive();
  virtual ~TOCSmartFieldArchive();

  TOCSmartFieldArchive(const TOCSmartFieldArchive& from);

  inline TOCSmartFieldArchive& operator=(const TOCSmartFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOCSmartFieldArchive& default_instance();

  void Swap(TOCSmartFieldArchive* other);

  // implements Message ----------------------------------------------

  TOCSmartFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOCSmartFieldArchive& from);
  void MergeFrom(const TOCSmartFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TOCSmartFieldArchive_TOCEntry TOCEntry;

  // accessors -------------------------------------------------------

  // optional .TSWP.PlaceholderSmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::PlaceholderSmartFieldArchive& super() const;
  inline ::TSWP::PlaceholderSmartFieldArchive* mutable_super();
  inline ::TSWP::PlaceholderSmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super);

  // repeated .TSWP.TOCSmartFieldArchive.TOCEntry toc_entries = 2;
  inline int toc_entries_size() const;
  inline void clear_toc_entries();
  static const int kTocEntriesFieldNumber = 2;
  inline const ::TSWP::TOCSmartFieldArchive_TOCEntry& toc_entries(int index) const;
  inline ::TSWP::TOCSmartFieldArchive_TOCEntry* mutable_toc_entries(int index);
  inline ::TSWP::TOCSmartFieldArchive_TOCEntry* add_toc_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSmartFieldArchive_TOCEntry >&
      toc_entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSmartFieldArchive_TOCEntry >*
      mutable_toc_entries();

  // @@protoc_insertion_point(class_scope:TSWP.TOCSmartFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::PlaceholderSmartFieldArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSmartFieldArchive_TOCEntry > toc_entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static TOCSmartFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class RubyFieldArchive : public ::google::protobuf::Message {
 public:
  RubyFieldArchive();
  virtual ~RubyFieldArchive();

  RubyFieldArchive(const RubyFieldArchive& from);

  inline RubyFieldArchive& operator=(const RubyFieldArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RubyFieldArchive& default_instance();

  void Swap(RubyFieldArchive* other);

  // implements Message ----------------------------------------------

  RubyFieldArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RubyFieldArchive& from);
  void MergeFrom(const RubyFieldArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.SmartFieldArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::SmartFieldArchive& super() const;
  inline ::TSWP::SmartFieldArchive* mutable_super();
  inline ::TSWP::SmartFieldArchive* release_super();
  inline void set_allocated_super(::TSWP::SmartFieldArchive* super);

  // optional string ruby_text = 2;
  inline bool has_ruby_text() const;
  inline void clear_ruby_text();
  static const int kRubyTextFieldNumber = 2;
  inline const ::std::string& ruby_text() const;
  inline void set_ruby_text(const ::std::string& value);
  inline void set_ruby_text(const char* value);
  inline void set_ruby_text(const char* value, size_t size);
  inline ::std::string* mutable_ruby_text();
  inline ::std::string* release_ruby_text();
  inline void set_allocated_ruby_text(::std::string* ruby_text);

  // @@protoc_insertion_point(class_scope:TSWP.RubyFieldArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_ruby_text();
  inline void clear_has_ruby_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::SmartFieldArchive* super_;
  ::std::string* ruby_text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static RubyFieldArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeArchive : public ::google::protobuf::Message {
 public:
  ChangeArchive();
  virtual ~ChangeArchive();

  ChangeArchive(const ChangeArchive& from);

  inline ChangeArchive& operator=(const ChangeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeArchive& default_instance();

  void Swap(ChangeArchive* other);

  // implements Message ----------------------------------------------

  ChangeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeArchive& from);
  void MergeFrom(const ChangeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeArchive_ChangeKind ChangeKind;
  static const ChangeKind kChangeKindInsertion = ChangeArchive_ChangeKind_kChangeKindInsertion;
  static const ChangeKind kChangeKindDeletion = ChangeArchive_ChangeKind_kChangeKindDeletion;
  static inline bool ChangeKind_IsValid(int value) {
    return ChangeArchive_ChangeKind_IsValid(value);
  }
  static const ChangeKind ChangeKind_MIN =
    ChangeArchive_ChangeKind_ChangeKind_MIN;
  static const ChangeKind ChangeKind_MAX =
    ChangeArchive_ChangeKind_ChangeKind_MAX;
  static const int ChangeKind_ARRAYSIZE =
    ChangeArchive_ChangeKind_ChangeKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ChangeKind_descriptor() {
    return ChangeArchive_ChangeKind_descriptor();
  }
  static inline const ::std::string& ChangeKind_Name(ChangeKind value) {
    return ChangeArchive_ChangeKind_Name(value);
  }
  static inline bool ChangeKind_Parse(const ::std::string& name,
      ChangeKind* value) {
    return ChangeArchive_ChangeKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSWP.ChangeArchive.ChangeKind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::TSWP::ChangeArchive_ChangeKind kind() const;
  inline void set_kind(::TSWP::ChangeArchive_ChangeKind value);

  // optional .TSP.Reference session = 2;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::TSP::Reference& session() const;
  inline ::TSP::Reference* mutable_session();
  inline ::TSP::Reference* release_session();
  inline void set_allocated_session(::TSP::Reference* session);

  // optional .TSP.Date date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::TSP::Date& date() const;
  inline ::TSP::Date* mutable_date();
  inline ::TSP::Date* release_date();
  inline void set_allocated_date(::TSP::Date* date);

  // optional bool hidden = 4;
  inline bool has_hidden() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 4;
  inline bool hidden() const;
  inline void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.ChangeArchive)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_hidden();
  inline void clear_has_hidden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* session_;
  int kind_;
  bool hidden_;
  ::TSP::Date* date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeSessionArchive : public ::google::protobuf::Message {
 public:
  ChangeSessionArchive();
  virtual ~ChangeSessionArchive();

  ChangeSessionArchive(const ChangeSessionArchive& from);

  inline ChangeSessionArchive& operator=(const ChangeSessionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeSessionArchive& default_instance();

  void Swap(ChangeSessionArchive* other);

  // implements Message ----------------------------------------------

  ChangeSessionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeSessionArchive& from);
  void MergeFrom(const ChangeSessionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 session_uid = 1;
  inline bool has_session_uid() const;
  inline void clear_session_uid();
  static const int kSessionUidFieldNumber = 1;
  inline ::google::protobuf::uint32 session_uid() const;
  inline void set_session_uid(::google::protobuf::uint32 value);

  // optional .TSP.Reference author = 2;
  inline bool has_author() const;
  inline void clear_author();
  static const int kAuthorFieldNumber = 2;
  inline const ::TSP::Reference& author() const;
  inline ::TSP::Reference* mutable_author();
  inline ::TSP::Reference* release_author();
  inline void set_allocated_author(::TSP::Reference* author);

  // optional .TSP.Date date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::TSP::Date& date() const;
  inline ::TSP::Date* mutable_date();
  inline ::TSP::Date* release_date();
  inline void set_allocated_date(::TSP::Date* date);

  // @@protoc_insertion_point(class_scope:TSWP.ChangeSessionArchive)
 private:
  inline void set_has_session_uid();
  inline void clear_has_session_uid();
  inline void set_has_author();
  inline void clear_has_author();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* author_;
  ::TSP::Date* date_;
  ::google::protobuf::uint32 session_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeSessionArchive* default_instance_;
};
// -------------------------------------------------------------------

class SectionPlaceholderArchive : public ::google::protobuf::Message {
 public:
  SectionPlaceholderArchive();
  virtual ~SectionPlaceholderArchive();

  SectionPlaceholderArchive(const SectionPlaceholderArchive& from);

  inline SectionPlaceholderArchive& operator=(const SectionPlaceholderArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SectionPlaceholderArchive& default_instance();

  void Swap(SectionPlaceholderArchive* other);

  // implements Message ----------------------------------------------

  SectionPlaceholderArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SectionPlaceholderArchive& from);
  void MergeFrom(const SectionPlaceholderArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSWP.SectionPlaceholderArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_TSWPArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPArchives_2eproto();

  void InitAsDefaultInstance();
  static SectionPlaceholderArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// SelectionArchive

// required .TSWP.SelectionType type = 1;
inline bool SelectionArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectionArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectionArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectionArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSWP::SelectionType SelectionArchive::type() const {
  return static_cast< ::TSWP::SelectionType >(type_);
}
inline void SelectionArchive::set_type(::TSWP::SelectionType value) {
  assert(::TSWP::SelectionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TSP.Range range = 2;
inline bool SelectionArchive::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectionArchive::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectionArchive::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectionArchive::clear_range() {
  if (range_ != NULL) range_->::TSP::Range::Clear();
  clear_has_range();
}
inline const ::TSP::Range& SelectionArchive::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::TSP::Range* SelectionArchive::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::TSP::Range;
  return range_;
}
inline ::TSP::Range* SelectionArchive::release_range() {
  clear_has_range();
  ::TSP::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void SelectionArchive::set_allocated_range(::TSP::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
}

// required .TSWP.StyleInsertionBehavior styleInsertionBehavior = 3;
inline bool SelectionArchive::has_styleinsertionbehavior() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelectionArchive::set_has_styleinsertionbehavior() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelectionArchive::clear_has_styleinsertionbehavior() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelectionArchive::clear_styleinsertionbehavior() {
  styleinsertionbehavior_ = 0;
  clear_has_styleinsertionbehavior();
}
inline ::TSWP::StyleInsertionBehavior SelectionArchive::styleinsertionbehavior() const {
  return static_cast< ::TSWP::StyleInsertionBehavior >(styleinsertionbehavior_);
}
inline void SelectionArchive::set_styleinsertionbehavior(::TSWP::StyleInsertionBehavior value) {
  assert(::TSWP::StyleInsertionBehavior_IsValid(value));
  set_has_styleinsertionbehavior();
  styleinsertionbehavior_ = value;
}

// required .TSWP.CaretAffinity caretAffinity = 4;
inline bool SelectionArchive::has_caretaffinity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SelectionArchive::set_has_caretaffinity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SelectionArchive::clear_has_caretaffinity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SelectionArchive::clear_caretaffinity() {
  caretaffinity_ = 0;
  clear_has_caretaffinity();
}
inline ::TSWP::CaretAffinity SelectionArchive::caretaffinity() const {
  return static_cast< ::TSWP::CaretAffinity >(caretaffinity_);
}
inline void SelectionArchive::set_caretaffinity(::TSWP::CaretAffinity value) {
  assert(::TSWP::CaretAffinity_IsValid(value));
  set_has_caretaffinity();
  caretaffinity_ = value;
}

// required .TSP.Range smart_field_range = 5;
inline bool SelectionArchive::has_smart_field_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SelectionArchive::set_has_smart_field_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SelectionArchive::clear_has_smart_field_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SelectionArchive::clear_smart_field_range() {
  if (smart_field_range_ != NULL) smart_field_range_->::TSP::Range::Clear();
  clear_has_smart_field_range();
}
inline const ::TSP::Range& SelectionArchive::smart_field_range() const {
  return smart_field_range_ != NULL ? *smart_field_range_ : *default_instance_->smart_field_range_;
}
inline ::TSP::Range* SelectionArchive::mutable_smart_field_range() {
  set_has_smart_field_range();
  if (smart_field_range_ == NULL) smart_field_range_ = new ::TSP::Range;
  return smart_field_range_;
}
inline ::TSP::Range* SelectionArchive::release_smart_field_range() {
  clear_has_smart_field_range();
  ::TSP::Range* temp = smart_field_range_;
  smart_field_range_ = NULL;
  return temp;
}
inline void SelectionArchive::set_allocated_smart_field_range(::TSP::Range* smart_field_range) {
  delete smart_field_range_;
  smart_field_range_ = smart_field_range;
  if (smart_field_range) {
    set_has_smart_field_range();
  } else {
    clear_has_smart_field_range();
  }
}

// -------------------------------------------------------------------

// ObjectAttributeTable_ObjectAttribute

// required uint32 character_index = 1;
inline bool ObjectAttributeTable_ObjectAttribute::has_character_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectAttributeTable_ObjectAttribute::set_has_character_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectAttributeTable_ObjectAttribute::clear_has_character_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectAttributeTable_ObjectAttribute::clear_character_index() {
  character_index_ = 0u;
  clear_has_character_index();
}
inline ::google::protobuf::uint32 ObjectAttributeTable_ObjectAttribute::character_index() const {
  return character_index_;
}
inline void ObjectAttributeTable_ObjectAttribute::set_character_index(::google::protobuf::uint32 value) {
  set_has_character_index();
  character_index_ = value;
}

// optional .TSP.Reference object = 2;
inline bool ObjectAttributeTable_ObjectAttribute::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectAttributeTable_ObjectAttribute::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectAttributeTable_ObjectAttribute::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectAttributeTable_ObjectAttribute::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& ObjectAttributeTable_ObjectAttribute::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* ObjectAttributeTable_ObjectAttribute::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* ObjectAttributeTable_ObjectAttribute::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void ObjectAttributeTable_ObjectAttribute::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// -------------------------------------------------------------------

// ObjectAttributeTable

// repeated .TSWP.ObjectAttributeTable.ObjectAttribute entries = 1;
inline int ObjectAttributeTable::entries_size() const {
  return entries_.size();
}
inline void ObjectAttributeTable::clear_entries() {
  entries_.Clear();
}
inline const ::TSWP::ObjectAttributeTable_ObjectAttribute& ObjectAttributeTable::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSWP::ObjectAttributeTable_ObjectAttribute* ObjectAttributeTable::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSWP::ObjectAttributeTable_ObjectAttribute* ObjectAttributeTable::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ObjectAttributeTable_ObjectAttribute >&
ObjectAttributeTable::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::ObjectAttributeTable_ObjectAttribute >*
ObjectAttributeTable::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// StringAttributeTable_StringAttribute

// required uint32 character_index = 1;
inline bool StringAttributeTable_StringAttribute::has_character_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringAttributeTable_StringAttribute::set_has_character_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringAttributeTable_StringAttribute::clear_has_character_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringAttributeTable_StringAttribute::clear_character_index() {
  character_index_ = 0u;
  clear_has_character_index();
}
inline ::google::protobuf::uint32 StringAttributeTable_StringAttribute::character_index() const {
  return character_index_;
}
inline void StringAttributeTable_StringAttribute::set_character_index(::google::protobuf::uint32 value) {
  set_has_character_index();
  character_index_ = value;
}

// optional string object = 2;
inline bool StringAttributeTable_StringAttribute::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringAttributeTable_StringAttribute::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringAttributeTable_StringAttribute::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringAttributeTable_StringAttribute::clear_object() {
  if (object_ != &::google::protobuf::internal::kEmptyString) {
    object_->clear();
  }
  clear_has_object();
}
inline const ::std::string& StringAttributeTable_StringAttribute::object() const {
  return *object_;
}
inline void StringAttributeTable_StringAttribute::set_object(const ::std::string& value) {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  object_->assign(value);
}
inline void StringAttributeTable_StringAttribute::set_object(const char* value) {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  object_->assign(value);
}
inline void StringAttributeTable_StringAttribute::set_object(const char* value, size_t size) {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  object_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringAttributeTable_StringAttribute::mutable_object() {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  return object_;
}
inline ::std::string* StringAttributeTable_StringAttribute::release_object() {
  clear_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_;
    object_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StringAttributeTable_StringAttribute::set_allocated_object(::std::string* object) {
  if (object_ != &::google::protobuf::internal::kEmptyString) {
    delete object_;
  }
  if (object) {
    set_has_object();
    object_ = object;
  } else {
    clear_has_object();
    object_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StringAttributeTable

// repeated .TSWP.StringAttributeTable.StringAttribute entries = 1;
inline int StringAttributeTable::entries_size() const {
  return entries_.size();
}
inline void StringAttributeTable::clear_entries() {
  entries_.Clear();
}
inline const ::TSWP::StringAttributeTable_StringAttribute& StringAttributeTable::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSWP::StringAttributeTable_StringAttribute* StringAttributeTable::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSWP::StringAttributeTable_StringAttribute* StringAttributeTable::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::StringAttributeTable_StringAttribute >&
StringAttributeTable::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::StringAttributeTable_StringAttribute >*
StringAttributeTable::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// ParaDataAttributeTable_ParaDataAttribute

// required uint32 character_index = 1;
inline bool ParaDataAttributeTable_ParaDataAttribute::has_character_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParaDataAttributeTable_ParaDataAttribute::set_has_character_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParaDataAttributeTable_ParaDataAttribute::clear_has_character_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParaDataAttributeTable_ParaDataAttribute::clear_character_index() {
  character_index_ = 0u;
  clear_has_character_index();
}
inline ::google::protobuf::uint32 ParaDataAttributeTable_ParaDataAttribute::character_index() const {
  return character_index_;
}
inline void ParaDataAttributeTable_ParaDataAttribute::set_character_index(::google::protobuf::uint32 value) {
  set_has_character_index();
  character_index_ = value;
}

// required uint32 first = 2;
inline bool ParaDataAttributeTable_ParaDataAttribute::has_first() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParaDataAttributeTable_ParaDataAttribute::set_has_first() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParaDataAttributeTable_ParaDataAttribute::clear_has_first() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParaDataAttributeTable_ParaDataAttribute::clear_first() {
  first_ = 0u;
  clear_has_first();
}
inline ::google::protobuf::uint32 ParaDataAttributeTable_ParaDataAttribute::first() const {
  return first_;
}
inline void ParaDataAttributeTable_ParaDataAttribute::set_first(::google::protobuf::uint32 value) {
  set_has_first();
  first_ = value;
}

// required uint32 second = 3;
inline bool ParaDataAttributeTable_ParaDataAttribute::has_second() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParaDataAttributeTable_ParaDataAttribute::set_has_second() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParaDataAttributeTable_ParaDataAttribute::clear_has_second() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParaDataAttributeTable_ParaDataAttribute::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 ParaDataAttributeTable_ParaDataAttribute::second() const {
  return second_;
}
inline void ParaDataAttributeTable_ParaDataAttribute::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
}

// -------------------------------------------------------------------

// ParaDataAttributeTable

// repeated .TSWP.ParaDataAttributeTable.ParaDataAttribute entries = 1;
inline int ParaDataAttributeTable::entries_size() const {
  return entries_.size();
}
inline void ParaDataAttributeTable::clear_entries() {
  entries_.Clear();
}
inline const ::TSWP::ParaDataAttributeTable_ParaDataAttribute& ParaDataAttributeTable::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSWP::ParaDataAttributeTable_ParaDataAttribute* ParaDataAttributeTable::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSWP::ParaDataAttributeTable_ParaDataAttribute* ParaDataAttributeTable::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ParaDataAttributeTable_ParaDataAttribute >&
ParaDataAttributeTable::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::ParaDataAttributeTable_ParaDataAttribute >*
ParaDataAttributeTable::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// SparseObjectAttributeTable_SparseObjectAttribute

// required uint32 character_index = 1;
inline bool SparseObjectAttributeTable_SparseObjectAttribute::has_character_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::set_has_character_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::clear_has_character_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::clear_character_index() {
  character_index_ = 0u;
  clear_has_character_index();
}
inline ::google::protobuf::uint32 SparseObjectAttributeTable_SparseObjectAttribute::character_index() const {
  return character_index_;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::set_character_index(::google::protobuf::uint32 value) {
  set_has_character_index();
  character_index_ = value;
}

// optional .TSP.Reference object = 2;
inline bool SparseObjectAttributeTable_SparseObjectAttribute::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& SparseObjectAttributeTable_SparseObjectAttribute::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* SparseObjectAttributeTable_SparseObjectAttribute::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* SparseObjectAttributeTable_SparseObjectAttribute::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// required uint32 run_length = 3;
inline bool SparseObjectAttributeTable_SparseObjectAttribute::has_run_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::set_has_run_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::clear_has_run_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::clear_run_length() {
  run_length_ = 0u;
  clear_has_run_length();
}
inline ::google::protobuf::uint32 SparseObjectAttributeTable_SparseObjectAttribute::run_length() const {
  return run_length_;
}
inline void SparseObjectAttributeTable_SparseObjectAttribute::set_run_length(::google::protobuf::uint32 value) {
  set_has_run_length();
  run_length_ = value;
}

// -------------------------------------------------------------------

// SparseObjectAttributeTable

// required uint32 total_count = 1;
inline bool SparseObjectAttributeTable::has_total_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseObjectAttributeTable::set_has_total_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseObjectAttributeTable::clear_has_total_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseObjectAttributeTable::clear_total_count() {
  total_count_ = 0u;
  clear_has_total_count();
}
inline ::google::protobuf::uint32 SparseObjectAttributeTable::total_count() const {
  return total_count_;
}
inline void SparseObjectAttributeTable::set_total_count(::google::protobuf::uint32 value) {
  set_has_total_count();
  total_count_ = value;
}

// repeated .TSWP.SparseObjectAttributeTable.SparseObjectAttribute entries = 2;
inline int SparseObjectAttributeTable::entries_size() const {
  return entries_.size();
}
inline void SparseObjectAttributeTable::clear_entries() {
  entries_.Clear();
}
inline const ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute& SparseObjectAttributeTable::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute* SparseObjectAttributeTable::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute* SparseObjectAttributeTable::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute >&
SparseObjectAttributeTable::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::SparseObjectAttributeTable_SparseObjectAttribute >*
SparseObjectAttributeTable::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// StorageArchive

// optional .TSWP.StorageArchive.KindType kind = 1 [default = TEXTBOX];
inline bool StorageArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageArchive::clear_kind() {
  kind_ = 3;
  clear_has_kind();
}
inline ::TSWP::StorageArchive_KindType StorageArchive::kind() const {
  return static_cast< ::TSWP::StorageArchive_KindType >(kind_);
}
inline void StorageArchive::set_kind(::TSWP::StorageArchive_KindType value) {
  assert(::TSWP::StorageArchive_KindType_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional .TSP.Reference style_sheet = 2;
inline bool StorageArchive::has_style_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageArchive::set_has_style_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageArchive::clear_has_style_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageArchive::clear_style_sheet() {
  if (style_sheet_ != NULL) style_sheet_->::TSP::Reference::Clear();
  clear_has_style_sheet();
}
inline const ::TSP::Reference& StorageArchive::style_sheet() const {
  return style_sheet_ != NULL ? *style_sheet_ : *default_instance_->style_sheet_;
}
inline ::TSP::Reference* StorageArchive::mutable_style_sheet() {
  set_has_style_sheet();
  if (style_sheet_ == NULL) style_sheet_ = new ::TSP::Reference;
  return style_sheet_;
}
inline ::TSP::Reference* StorageArchive::release_style_sheet() {
  clear_has_style_sheet();
  ::TSP::Reference* temp = style_sheet_;
  style_sheet_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_style_sheet(::TSP::Reference* style_sheet) {
  delete style_sheet_;
  style_sheet_ = style_sheet;
  if (style_sheet) {
    set_has_style_sheet();
  } else {
    clear_has_style_sheet();
  }
}

// repeated string text = 3;
inline int StorageArchive::text_size() const {
  return text_.size();
}
inline void StorageArchive::clear_text() {
  text_.Clear();
}
inline const ::std::string& StorageArchive::text(int index) const {
  return text_.Get(index);
}
inline ::std::string* StorageArchive::mutable_text(int index) {
  return text_.Mutable(index);
}
inline void StorageArchive::set_text(int index, const ::std::string& value) {
  text_.Mutable(index)->assign(value);
}
inline void StorageArchive::set_text(int index, const char* value) {
  text_.Mutable(index)->assign(value);
}
inline void StorageArchive::set_text(int index, const char* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorageArchive::add_text() {
  return text_.Add();
}
inline void StorageArchive::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
}
inline void StorageArchive::add_text(const char* value) {
  text_.Add()->assign(value);
}
inline void StorageArchive::add_text(const char* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StorageArchive::text() const {
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StorageArchive::mutable_text() {
  return &text_;
}

// optional bool has_itext = 4 [default = false];
inline bool StorageArchive::has_has_itext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StorageArchive::set_has_has_itext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StorageArchive::clear_has_has_itext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StorageArchive::clear_has_itext() {
  has_itext_ = false;
  clear_has_has_itext();
}
inline bool StorageArchive::has_itext() const {
  return has_itext_;
}
inline void StorageArchive::set_has_itext(bool value) {
  set_has_has_itext();
  has_itext_ = value;
}

// optional bool in_document = 10 [default = false];
inline bool StorageArchive::has_in_document() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StorageArchive::set_has_in_document() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StorageArchive::clear_has_in_document() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StorageArchive::clear_in_document() {
  in_document_ = false;
  clear_has_in_document();
}
inline bool StorageArchive::in_document() const {
  return in_document_;
}
inline void StorageArchive::set_in_document(bool value) {
  set_has_in_document();
  in_document_ = value;
}

// optional .TSWP.ObjectAttributeTable table_para_style = 5;
inline bool StorageArchive::has_table_para_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StorageArchive::set_has_table_para_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StorageArchive::clear_has_table_para_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StorageArchive::clear_table_para_style() {
  if (table_para_style_ != NULL) table_para_style_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_para_style();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_para_style() const {
  return table_para_style_ != NULL ? *table_para_style_ : *default_instance_->table_para_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_para_style() {
  set_has_table_para_style();
  if (table_para_style_ == NULL) table_para_style_ = new ::TSWP::ObjectAttributeTable;
  return table_para_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_para_style() {
  clear_has_table_para_style();
  ::TSWP::ObjectAttributeTable* temp = table_para_style_;
  table_para_style_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_para_style(::TSWP::ObjectAttributeTable* table_para_style) {
  delete table_para_style_;
  table_para_style_ = table_para_style;
  if (table_para_style) {
    set_has_table_para_style();
  } else {
    clear_has_table_para_style();
  }
}

// optional .TSWP.ParaDataAttributeTable table_para_data = 6;
inline bool StorageArchive::has_table_para_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StorageArchive::set_has_table_para_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StorageArchive::clear_has_table_para_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StorageArchive::clear_table_para_data() {
  if (table_para_data_ != NULL) table_para_data_->::TSWP::ParaDataAttributeTable::Clear();
  clear_has_table_para_data();
}
inline const ::TSWP::ParaDataAttributeTable& StorageArchive::table_para_data() const {
  return table_para_data_ != NULL ? *table_para_data_ : *default_instance_->table_para_data_;
}
inline ::TSWP::ParaDataAttributeTable* StorageArchive::mutable_table_para_data() {
  set_has_table_para_data();
  if (table_para_data_ == NULL) table_para_data_ = new ::TSWP::ParaDataAttributeTable;
  return table_para_data_;
}
inline ::TSWP::ParaDataAttributeTable* StorageArchive::release_table_para_data() {
  clear_has_table_para_data();
  ::TSWP::ParaDataAttributeTable* temp = table_para_data_;
  table_para_data_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_para_data(::TSWP::ParaDataAttributeTable* table_para_data) {
  delete table_para_data_;
  table_para_data_ = table_para_data;
  if (table_para_data) {
    set_has_table_para_data();
  } else {
    clear_has_table_para_data();
  }
}

// optional .TSWP.ObjectAttributeTable table_list_style = 7;
inline bool StorageArchive::has_table_list_style() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StorageArchive::set_has_table_list_style() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StorageArchive::clear_has_table_list_style() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StorageArchive::clear_table_list_style() {
  if (table_list_style_ != NULL) table_list_style_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_list_style();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_list_style() const {
  return table_list_style_ != NULL ? *table_list_style_ : *default_instance_->table_list_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_list_style() {
  set_has_table_list_style();
  if (table_list_style_ == NULL) table_list_style_ = new ::TSWP::ObjectAttributeTable;
  return table_list_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_list_style() {
  clear_has_table_list_style();
  ::TSWP::ObjectAttributeTable* temp = table_list_style_;
  table_list_style_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_list_style(::TSWP::ObjectAttributeTable* table_list_style) {
  delete table_list_style_;
  table_list_style_ = table_list_style;
  if (table_list_style) {
    set_has_table_list_style();
  } else {
    clear_has_table_list_style();
  }
}

// optional .TSWP.ObjectAttributeTable table_char_style = 8;
inline bool StorageArchive::has_table_char_style() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StorageArchive::set_has_table_char_style() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StorageArchive::clear_has_table_char_style() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StorageArchive::clear_table_char_style() {
  if (table_char_style_ != NULL) table_char_style_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_char_style();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_char_style() const {
  return table_char_style_ != NULL ? *table_char_style_ : *default_instance_->table_char_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_char_style() {
  set_has_table_char_style();
  if (table_char_style_ == NULL) table_char_style_ = new ::TSWP::ObjectAttributeTable;
  return table_char_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_char_style() {
  clear_has_table_char_style();
  ::TSWP::ObjectAttributeTable* temp = table_char_style_;
  table_char_style_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_char_style(::TSWP::ObjectAttributeTable* table_char_style) {
  delete table_char_style_;
  table_char_style_ = table_char_style;
  if (table_char_style) {
    set_has_table_char_style();
  } else {
    clear_has_table_char_style();
  }
}

// optional .TSWP.ObjectAttributeTable table_attachment = 9;
inline bool StorageArchive::has_table_attachment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StorageArchive::set_has_table_attachment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StorageArchive::clear_has_table_attachment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StorageArchive::clear_table_attachment() {
  if (table_attachment_ != NULL) table_attachment_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_attachment();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_attachment() const {
  return table_attachment_ != NULL ? *table_attachment_ : *default_instance_->table_attachment_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_attachment() {
  set_has_table_attachment();
  if (table_attachment_ == NULL) table_attachment_ = new ::TSWP::ObjectAttributeTable;
  return table_attachment_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_attachment() {
  clear_has_table_attachment();
  ::TSWP::ObjectAttributeTable* temp = table_attachment_;
  table_attachment_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_attachment(::TSWP::ObjectAttributeTable* table_attachment) {
  delete table_attachment_;
  table_attachment_ = table_attachment;
  if (table_attachment) {
    set_has_table_attachment();
  } else {
    clear_has_table_attachment();
  }
}

// optional .TSWP.ObjectAttributeTable table_smartfield = 11;
inline bool StorageArchive::has_table_smartfield() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StorageArchive::set_has_table_smartfield() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StorageArchive::clear_has_table_smartfield() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StorageArchive::clear_table_smartfield() {
  if (table_smartfield_ != NULL) table_smartfield_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_smartfield();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_smartfield() const {
  return table_smartfield_ != NULL ? *table_smartfield_ : *default_instance_->table_smartfield_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_smartfield() {
  set_has_table_smartfield();
  if (table_smartfield_ == NULL) table_smartfield_ = new ::TSWP::ObjectAttributeTable;
  return table_smartfield_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_smartfield() {
  clear_has_table_smartfield();
  ::TSWP::ObjectAttributeTable* temp = table_smartfield_;
  table_smartfield_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_smartfield(::TSWP::ObjectAttributeTable* table_smartfield) {
  delete table_smartfield_;
  table_smartfield_ = table_smartfield;
  if (table_smartfield) {
    set_has_table_smartfield();
  } else {
    clear_has_table_smartfield();
  }
}

// optional .TSWP.ObjectAttributeTable table_layout_style = 12;
inline bool StorageArchive::has_table_layout_style() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StorageArchive::set_has_table_layout_style() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StorageArchive::clear_has_table_layout_style() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StorageArchive::clear_table_layout_style() {
  if (table_layout_style_ != NULL) table_layout_style_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_layout_style();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_layout_style() const {
  return table_layout_style_ != NULL ? *table_layout_style_ : *default_instance_->table_layout_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_layout_style() {
  set_has_table_layout_style();
  if (table_layout_style_ == NULL) table_layout_style_ = new ::TSWP::ObjectAttributeTable;
  return table_layout_style_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_layout_style() {
  clear_has_table_layout_style();
  ::TSWP::ObjectAttributeTable* temp = table_layout_style_;
  table_layout_style_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_layout_style(::TSWP::ObjectAttributeTable* table_layout_style) {
  delete table_layout_style_;
  table_layout_style_ = table_layout_style;
  if (table_layout_style) {
    set_has_table_layout_style();
  } else {
    clear_has_table_layout_style();
  }
}

// optional .TSWP.ParaDataAttributeTable table_para_starts = 14;
inline bool StorageArchive::has_table_para_starts() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StorageArchive::set_has_table_para_starts() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StorageArchive::clear_has_table_para_starts() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StorageArchive::clear_table_para_starts() {
  if (table_para_starts_ != NULL) table_para_starts_->::TSWP::ParaDataAttributeTable::Clear();
  clear_has_table_para_starts();
}
inline const ::TSWP::ParaDataAttributeTable& StorageArchive::table_para_starts() const {
  return table_para_starts_ != NULL ? *table_para_starts_ : *default_instance_->table_para_starts_;
}
inline ::TSWP::ParaDataAttributeTable* StorageArchive::mutable_table_para_starts() {
  set_has_table_para_starts();
  if (table_para_starts_ == NULL) table_para_starts_ = new ::TSWP::ParaDataAttributeTable;
  return table_para_starts_;
}
inline ::TSWP::ParaDataAttributeTable* StorageArchive::release_table_para_starts() {
  clear_has_table_para_starts();
  ::TSWP::ParaDataAttributeTable* temp = table_para_starts_;
  table_para_starts_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_para_starts(::TSWP::ParaDataAttributeTable* table_para_starts) {
  delete table_para_starts_;
  table_para_starts_ = table_para_starts;
  if (table_para_starts) {
    set_has_table_para_starts();
  } else {
    clear_has_table_para_starts();
  }
}

// optional .TSWP.ObjectAttributeTable table_bookmark = 15;
inline bool StorageArchive::has_table_bookmark() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StorageArchive::set_has_table_bookmark() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StorageArchive::clear_has_table_bookmark() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StorageArchive::clear_table_bookmark() {
  if (table_bookmark_ != NULL) table_bookmark_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_bookmark();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_bookmark() const {
  return table_bookmark_ != NULL ? *table_bookmark_ : *default_instance_->table_bookmark_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_bookmark() {
  set_has_table_bookmark();
  if (table_bookmark_ == NULL) table_bookmark_ = new ::TSWP::ObjectAttributeTable;
  return table_bookmark_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_bookmark() {
  clear_has_table_bookmark();
  ::TSWP::ObjectAttributeTable* temp = table_bookmark_;
  table_bookmark_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_bookmark(::TSWP::ObjectAttributeTable* table_bookmark) {
  delete table_bookmark_;
  table_bookmark_ = table_bookmark;
  if (table_bookmark) {
    set_has_table_bookmark();
  } else {
    clear_has_table_bookmark();
  }
}

// optional .TSWP.ObjectAttributeTable table_footnote = 16;
inline bool StorageArchive::has_table_footnote() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StorageArchive::set_has_table_footnote() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StorageArchive::clear_has_table_footnote() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StorageArchive::clear_table_footnote() {
  if (table_footnote_ != NULL) table_footnote_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_footnote();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_footnote() const {
  return table_footnote_ != NULL ? *table_footnote_ : *default_instance_->table_footnote_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_footnote() {
  set_has_table_footnote();
  if (table_footnote_ == NULL) table_footnote_ = new ::TSWP::ObjectAttributeTable;
  return table_footnote_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_footnote() {
  clear_has_table_footnote();
  ::TSWP::ObjectAttributeTable* temp = table_footnote_;
  table_footnote_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_footnote(::TSWP::ObjectAttributeTable* table_footnote) {
  delete table_footnote_;
  table_footnote_ = table_footnote;
  if (table_footnote) {
    set_has_table_footnote();
  } else {
    clear_has_table_footnote();
  }
}

// optional .TSWP.ObjectAttributeTable table_section = 17;
inline bool StorageArchive::has_table_section() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StorageArchive::set_has_table_section() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StorageArchive::clear_has_table_section() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StorageArchive::clear_table_section() {
  if (table_section_ != NULL) table_section_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_section();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_section() const {
  return table_section_ != NULL ? *table_section_ : *default_instance_->table_section_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_section() {
  set_has_table_section();
  if (table_section_ == NULL) table_section_ = new ::TSWP::ObjectAttributeTable;
  return table_section_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_section() {
  clear_has_table_section();
  ::TSWP::ObjectAttributeTable* temp = table_section_;
  table_section_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_section(::TSWP::ObjectAttributeTable* table_section) {
  delete table_section_;
  table_section_ = table_section;
  if (table_section) {
    set_has_table_section();
  } else {
    clear_has_table_section();
  }
}

// optional .TSWP.ObjectAttributeTable table_rubyfield = 18;
inline bool StorageArchive::has_table_rubyfield() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StorageArchive::set_has_table_rubyfield() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StorageArchive::clear_has_table_rubyfield() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StorageArchive::clear_table_rubyfield() {
  if (table_rubyfield_ != NULL) table_rubyfield_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_rubyfield();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_rubyfield() const {
  return table_rubyfield_ != NULL ? *table_rubyfield_ : *default_instance_->table_rubyfield_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_rubyfield() {
  set_has_table_rubyfield();
  if (table_rubyfield_ == NULL) table_rubyfield_ = new ::TSWP::ObjectAttributeTable;
  return table_rubyfield_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_rubyfield() {
  clear_has_table_rubyfield();
  ::TSWP::ObjectAttributeTable* temp = table_rubyfield_;
  table_rubyfield_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_rubyfield(::TSWP::ObjectAttributeTable* table_rubyfield) {
  delete table_rubyfield_;
  table_rubyfield_ = table_rubyfield;
  if (table_rubyfield) {
    set_has_table_rubyfield();
  } else {
    clear_has_table_rubyfield();
  }
}

// optional .TSWP.StringAttributeTable table_language = 19;
inline bool StorageArchive::has_table_language() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StorageArchive::set_has_table_language() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StorageArchive::clear_has_table_language() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StorageArchive::clear_table_language() {
  if (table_language_ != NULL) table_language_->::TSWP::StringAttributeTable::Clear();
  clear_has_table_language();
}
inline const ::TSWP::StringAttributeTable& StorageArchive::table_language() const {
  return table_language_ != NULL ? *table_language_ : *default_instance_->table_language_;
}
inline ::TSWP::StringAttributeTable* StorageArchive::mutable_table_language() {
  set_has_table_language();
  if (table_language_ == NULL) table_language_ = new ::TSWP::StringAttributeTable;
  return table_language_;
}
inline ::TSWP::StringAttributeTable* StorageArchive::release_table_language() {
  clear_has_table_language();
  ::TSWP::StringAttributeTable* temp = table_language_;
  table_language_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_language(::TSWP::StringAttributeTable* table_language) {
  delete table_language_;
  table_language_ = table_language;
  if (table_language) {
    set_has_table_language();
  } else {
    clear_has_table_language();
  }
}

// optional .TSWP.StringAttributeTable table_dictation = 20;
inline bool StorageArchive::has_table_dictation() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StorageArchive::set_has_table_dictation() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StorageArchive::clear_has_table_dictation() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void StorageArchive::clear_table_dictation() {
  if (table_dictation_ != NULL) table_dictation_->::TSWP::StringAttributeTable::Clear();
  clear_has_table_dictation();
}
inline const ::TSWP::StringAttributeTable& StorageArchive::table_dictation() const {
  return table_dictation_ != NULL ? *table_dictation_ : *default_instance_->table_dictation_;
}
inline ::TSWP::StringAttributeTable* StorageArchive::mutable_table_dictation() {
  set_has_table_dictation();
  if (table_dictation_ == NULL) table_dictation_ = new ::TSWP::StringAttributeTable;
  return table_dictation_;
}
inline ::TSWP::StringAttributeTable* StorageArchive::release_table_dictation() {
  clear_has_table_dictation();
  ::TSWP::StringAttributeTable* temp = table_dictation_;
  table_dictation_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_dictation(::TSWP::StringAttributeTable* table_dictation) {
  delete table_dictation_;
  table_dictation_ = table_dictation;
  if (table_dictation) {
    set_has_table_dictation();
  } else {
    clear_has_table_dictation();
  }
}

// optional .TSWP.ObjectAttributeTable table_insertion = 21;
inline bool StorageArchive::has_table_insertion() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void StorageArchive::set_has_table_insertion() {
  _has_bits_[0] |= 0x00080000u;
}
inline void StorageArchive::clear_has_table_insertion() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void StorageArchive::clear_table_insertion() {
  if (table_insertion_ != NULL) table_insertion_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_insertion();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_insertion() const {
  return table_insertion_ != NULL ? *table_insertion_ : *default_instance_->table_insertion_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_insertion() {
  set_has_table_insertion();
  if (table_insertion_ == NULL) table_insertion_ = new ::TSWP::ObjectAttributeTable;
  return table_insertion_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_insertion() {
  clear_has_table_insertion();
  ::TSWP::ObjectAttributeTable* temp = table_insertion_;
  table_insertion_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_insertion(::TSWP::ObjectAttributeTable* table_insertion) {
  delete table_insertion_;
  table_insertion_ = table_insertion;
  if (table_insertion) {
    set_has_table_insertion();
  } else {
    clear_has_table_insertion();
  }
}

// optional .TSWP.ObjectAttributeTable table_deletion = 22;
inline bool StorageArchive::has_table_deletion() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void StorageArchive::set_has_table_deletion() {
  _has_bits_[0] |= 0x00100000u;
}
inline void StorageArchive::clear_has_table_deletion() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void StorageArchive::clear_table_deletion() {
  if (table_deletion_ != NULL) table_deletion_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_deletion();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_deletion() const {
  return table_deletion_ != NULL ? *table_deletion_ : *default_instance_->table_deletion_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_deletion() {
  set_has_table_deletion();
  if (table_deletion_ == NULL) table_deletion_ = new ::TSWP::ObjectAttributeTable;
  return table_deletion_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_deletion() {
  clear_has_table_deletion();
  ::TSWP::ObjectAttributeTable* temp = table_deletion_;
  table_deletion_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_deletion(::TSWP::ObjectAttributeTable* table_deletion) {
  delete table_deletion_;
  table_deletion_ = table_deletion;
  if (table_deletion) {
    set_has_table_deletion();
  } else {
    clear_has_table_deletion();
  }
}

// optional .TSWP.ObjectAttributeTable table_highlight = 23;
inline bool StorageArchive::has_table_highlight() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void StorageArchive::set_has_table_highlight() {
  _has_bits_[0] |= 0x00200000u;
}
inline void StorageArchive::clear_has_table_highlight() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void StorageArchive::clear_table_highlight() {
  if (table_highlight_ != NULL) table_highlight_->::TSWP::ObjectAttributeTable::Clear();
  clear_has_table_highlight();
}
inline const ::TSWP::ObjectAttributeTable& StorageArchive::table_highlight() const {
  return table_highlight_ != NULL ? *table_highlight_ : *default_instance_->table_highlight_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::mutable_table_highlight() {
  set_has_table_highlight();
  if (table_highlight_ == NULL) table_highlight_ = new ::TSWP::ObjectAttributeTable;
  return table_highlight_;
}
inline ::TSWP::ObjectAttributeTable* StorageArchive::release_table_highlight() {
  clear_has_table_highlight();
  ::TSWP::ObjectAttributeTable* temp = table_highlight_;
  table_highlight_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_highlight(::TSWP::ObjectAttributeTable* table_highlight) {
  delete table_highlight_;
  table_highlight_ = table_highlight;
  if (table_highlight) {
    set_has_table_highlight();
  } else {
    clear_has_table_highlight();
  }
}

// optional .TSWP.ParaDataAttributeTable table_para_bidi = 24;
inline bool StorageArchive::has_table_para_bidi() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void StorageArchive::set_has_table_para_bidi() {
  _has_bits_[0] |= 0x00400000u;
}
inline void StorageArchive::clear_has_table_para_bidi() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void StorageArchive::clear_table_para_bidi() {
  if (table_para_bidi_ != NULL) table_para_bidi_->::TSWP::ParaDataAttributeTable::Clear();
  clear_has_table_para_bidi();
}
inline const ::TSWP::ParaDataAttributeTable& StorageArchive::table_para_bidi() const {
  return table_para_bidi_ != NULL ? *table_para_bidi_ : *default_instance_->table_para_bidi_;
}
inline ::TSWP::ParaDataAttributeTable* StorageArchive::mutable_table_para_bidi() {
  set_has_table_para_bidi();
  if (table_para_bidi_ == NULL) table_para_bidi_ = new ::TSWP::ParaDataAttributeTable;
  return table_para_bidi_;
}
inline ::TSWP::ParaDataAttributeTable* StorageArchive::release_table_para_bidi() {
  clear_has_table_para_bidi();
  ::TSWP::ParaDataAttributeTable* temp = table_para_bidi_;
  table_para_bidi_ = NULL;
  return temp;
}
inline void StorageArchive::set_allocated_table_para_bidi(::TSWP::ParaDataAttributeTable* table_para_bidi) {
  delete table_para_bidi_;
  table_para_bidi_ = table_para_bidi;
  if (table_para_bidi) {
    set_has_table_para_bidi();
  } else {
    clear_has_table_para_bidi();
  }
}

// -------------------------------------------------------------------

// HighlightArchive

// optional .TSP.Reference commentStorage = 1;
inline bool HighlightArchive::has_commentstorage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HighlightArchive::set_has_commentstorage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HighlightArchive::clear_has_commentstorage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HighlightArchive::clear_commentstorage() {
  if (commentstorage_ != NULL) commentstorage_->::TSP::Reference::Clear();
  clear_has_commentstorage();
}
inline const ::TSP::Reference& HighlightArchive::commentstorage() const {
  return commentstorage_ != NULL ? *commentstorage_ : *default_instance_->commentstorage_;
}
inline ::TSP::Reference* HighlightArchive::mutable_commentstorage() {
  set_has_commentstorage();
  if (commentstorage_ == NULL) commentstorage_ = new ::TSP::Reference;
  return commentstorage_;
}
inline ::TSP::Reference* HighlightArchive::release_commentstorage() {
  clear_has_commentstorage();
  ::TSP::Reference* temp = commentstorage_;
  commentstorage_ = NULL;
  return temp;
}
inline void HighlightArchive::set_allocated_commentstorage(::TSP::Reference* commentstorage) {
  delete commentstorage_;
  commentstorage_ = commentstorage;
  if (commentstorage) {
    set_has_commentstorage();
  } else {
    clear_has_commentstorage();
  }
}

// -------------------------------------------------------------------

// FontFeatureArchive

// required uint32 feature_type = 1;
inline bool FontFeatureArchive::has_feature_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FontFeatureArchive::set_has_feature_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FontFeatureArchive::clear_has_feature_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FontFeatureArchive::clear_feature_type() {
  feature_type_ = 0u;
  clear_has_feature_type();
}
inline ::google::protobuf::uint32 FontFeatureArchive::feature_type() const {
  return feature_type_;
}
inline void FontFeatureArchive::set_feature_type(::google::protobuf::uint32 value) {
  set_has_feature_type();
  feature_type_ = value;
}

// required uint32 feature_selector = 2;
inline bool FontFeatureArchive::has_feature_selector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FontFeatureArchive::set_has_feature_selector() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FontFeatureArchive::clear_has_feature_selector() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FontFeatureArchive::clear_feature_selector() {
  feature_selector_ = 0u;
  clear_has_feature_selector();
}
inline ::google::protobuf::uint32 FontFeatureArchive::feature_selector() const {
  return feature_selector_;
}
inline void FontFeatureArchive::set_feature_selector(::google::protobuf::uint32 value) {
  set_has_feature_selector();
  feature_selector_ = value;
}

// -------------------------------------------------------------------

// CharacterStylePropertiesArchive

// optional bool bold = 1;
inline bool CharacterStylePropertiesArchive::has_bold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_bold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharacterStylePropertiesArchive::clear_has_bold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharacterStylePropertiesArchive::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool CharacterStylePropertiesArchive::bold() const {
  return bold_;
}
inline void CharacterStylePropertiesArchive::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
}

// optional bool italic = 2;
inline bool CharacterStylePropertiesArchive::has_italic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_italic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharacterStylePropertiesArchive::clear_has_italic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharacterStylePropertiesArchive::clear_italic() {
  italic_ = false;
  clear_has_italic();
}
inline bool CharacterStylePropertiesArchive::italic() const {
  return italic_;
}
inline void CharacterStylePropertiesArchive::set_italic(bool value) {
  set_has_italic();
  italic_ = value;
}

// optional float font_size = 3;
inline bool CharacterStylePropertiesArchive::has_font_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_font_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharacterStylePropertiesArchive::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharacterStylePropertiesArchive::clear_font_size() {
  font_size_ = 0;
  clear_has_font_size();
}
inline float CharacterStylePropertiesArchive::font_size() const {
  return font_size_;
}
inline void CharacterStylePropertiesArchive::set_font_size(float value) {
  set_has_font_size();
  font_size_ = value;
}

// optional bool font_name_null = 4;
inline bool CharacterStylePropertiesArchive::has_font_name_null() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_font_name_null() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharacterStylePropertiesArchive::clear_has_font_name_null() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharacterStylePropertiesArchive::clear_font_name_null() {
  font_name_null_ = false;
  clear_has_font_name_null();
}
inline bool CharacterStylePropertiesArchive::font_name_null() const {
  return font_name_null_;
}
inline void CharacterStylePropertiesArchive::set_font_name_null(bool value) {
  set_has_font_name_null();
  font_name_null_ = value;
}

// optional string font_name = 5;
inline bool CharacterStylePropertiesArchive::has_font_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_font_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CharacterStylePropertiesArchive::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CharacterStylePropertiesArchive::clear_font_name() {
  if (font_name_ != &::google::protobuf::internal::kEmptyString) {
    font_name_->clear();
  }
  clear_has_font_name();
}
inline const ::std::string& CharacterStylePropertiesArchive::font_name() const {
  return *font_name_;
}
inline void CharacterStylePropertiesArchive::set_font_name(const ::std::string& value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_font_name(const char* value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterStylePropertiesArchive::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  return font_name_;
}
inline ::std::string* CharacterStylePropertiesArchive::release_font_name() {
  clear_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = font_name_;
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterStylePropertiesArchive::set_allocated_font_name(::std::string* font_name) {
  if (font_name_ != &::google::protobuf::internal::kEmptyString) {
    delete font_name_;
  }
  if (font_name) {
    set_has_font_name();
    font_name_ = font_name;
  } else {
    clear_has_font_name();
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool font_color_null = 6;
inline bool CharacterStylePropertiesArchive::has_font_color_null() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_font_color_null() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CharacterStylePropertiesArchive::clear_has_font_color_null() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CharacterStylePropertiesArchive::clear_font_color_null() {
  font_color_null_ = false;
  clear_has_font_color_null();
}
inline bool CharacterStylePropertiesArchive::font_color_null() const {
  return font_color_null_;
}
inline void CharacterStylePropertiesArchive::set_font_color_null(bool value) {
  set_has_font_color_null();
  font_color_null_ = value;
}

// optional .TSP.Color font_color = 7;
inline bool CharacterStylePropertiesArchive::has_font_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_font_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CharacterStylePropertiesArchive::clear_has_font_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CharacterStylePropertiesArchive::clear_font_color() {
  if (font_color_ != NULL) font_color_->::TSP::Color::Clear();
  clear_has_font_color();
}
inline const ::TSP::Color& CharacterStylePropertiesArchive::font_color() const {
  return font_color_ != NULL ? *font_color_ : *default_instance_->font_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::mutable_font_color() {
  set_has_font_color();
  if (font_color_ == NULL) font_color_ = new ::TSP::Color;
  return font_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::release_font_color() {
  clear_has_font_color();
  ::TSP::Color* temp = font_color_;
  font_color_ = NULL;
  return temp;
}
inline void CharacterStylePropertiesArchive::set_allocated_font_color(::TSP::Color* font_color) {
  delete font_color_;
  font_color_ = font_color;
  if (font_color) {
    set_has_font_color();
  } else {
    clear_has_font_color();
  }
}

// optional bool language_null = 8;
inline bool CharacterStylePropertiesArchive::has_language_null() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_language_null() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CharacterStylePropertiesArchive::clear_has_language_null() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CharacterStylePropertiesArchive::clear_language_null() {
  language_null_ = false;
  clear_has_language_null();
}
inline bool CharacterStylePropertiesArchive::language_null() const {
  return language_null_;
}
inline void CharacterStylePropertiesArchive::set_language_null(bool value) {
  set_has_language_null();
  language_null_ = value;
}

// optional string language = 9;
inline bool CharacterStylePropertiesArchive::has_language() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_language() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CharacterStylePropertiesArchive::clear_has_language() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CharacterStylePropertiesArchive::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& CharacterStylePropertiesArchive::language() const {
  return *language_;
}
inline void CharacterStylePropertiesArchive::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterStylePropertiesArchive::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* CharacterStylePropertiesArchive::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterStylePropertiesArchive::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.CharacterStylePropertiesArchive.SuperscriptType superscript = 10;
inline bool CharacterStylePropertiesArchive::has_superscript() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_superscript() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CharacterStylePropertiesArchive::clear_has_superscript() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CharacterStylePropertiesArchive::clear_superscript() {
  superscript_ = 0;
  clear_has_superscript();
}
inline ::TSWP::CharacterStylePropertiesArchive_SuperscriptType CharacterStylePropertiesArchive::superscript() const {
  return static_cast< ::TSWP::CharacterStylePropertiesArchive_SuperscriptType >(superscript_);
}
inline void CharacterStylePropertiesArchive::set_superscript(::TSWP::CharacterStylePropertiesArchive_SuperscriptType value) {
  assert(::TSWP::CharacterStylePropertiesArchive_SuperscriptType_IsValid(value));
  set_has_superscript();
  superscript_ = value;
}

// optional .TSWP.CharacterStylePropertiesArchive.UnderlineType underline = 11;
inline bool CharacterStylePropertiesArchive::has_underline() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_underline() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CharacterStylePropertiesArchive::clear_has_underline() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CharacterStylePropertiesArchive::clear_underline() {
  underline_ = 0;
  clear_has_underline();
}
inline ::TSWP::CharacterStylePropertiesArchive_UnderlineType CharacterStylePropertiesArchive::underline() const {
  return static_cast< ::TSWP::CharacterStylePropertiesArchive_UnderlineType >(underline_);
}
inline void CharacterStylePropertiesArchive::set_underline(::TSWP::CharacterStylePropertiesArchive_UnderlineType value) {
  assert(::TSWP::CharacterStylePropertiesArchive_UnderlineType_IsValid(value));
  set_has_underline();
  underline_ = value;
}

// optional .TSWP.CharacterStylePropertiesArchive.StrikethruType strikethru = 12;
inline bool CharacterStylePropertiesArchive::has_strikethru() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_strikethru() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CharacterStylePropertiesArchive::clear_has_strikethru() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CharacterStylePropertiesArchive::clear_strikethru() {
  strikethru_ = 0;
  clear_has_strikethru();
}
inline ::TSWP::CharacterStylePropertiesArchive_StrikethruType CharacterStylePropertiesArchive::strikethru() const {
  return static_cast< ::TSWP::CharacterStylePropertiesArchive_StrikethruType >(strikethru_);
}
inline void CharacterStylePropertiesArchive::set_strikethru(::TSWP::CharacterStylePropertiesArchive_StrikethruType value) {
  assert(::TSWP::CharacterStylePropertiesArchive_StrikethruType_IsValid(value));
  set_has_strikethru();
  strikethru_ = value;
}

// optional .TSWP.CharacterStylePropertiesArchive.CapitalizationType capitalization = 13;
inline bool CharacterStylePropertiesArchive::has_capitalization() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_capitalization() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharacterStylePropertiesArchive::clear_has_capitalization() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharacterStylePropertiesArchive::clear_capitalization() {
  capitalization_ = 0;
  clear_has_capitalization();
}
inline ::TSWP::CharacterStylePropertiesArchive_CapitalizationType CharacterStylePropertiesArchive::capitalization() const {
  return static_cast< ::TSWP::CharacterStylePropertiesArchive_CapitalizationType >(capitalization_);
}
inline void CharacterStylePropertiesArchive::set_capitalization(::TSWP::CharacterStylePropertiesArchive_CapitalizationType value) {
  assert(::TSWP::CharacterStylePropertiesArchive_CapitalizationType_IsValid(value));
  set_has_capitalization();
  capitalization_ = value;
}

// optional float baseline_shift = 14;
inline bool CharacterStylePropertiesArchive::has_baseline_shift() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_baseline_shift() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharacterStylePropertiesArchive::clear_has_baseline_shift() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharacterStylePropertiesArchive::clear_baseline_shift() {
  baseline_shift_ = 0;
  clear_has_baseline_shift();
}
inline float CharacterStylePropertiesArchive::baseline_shift() const {
  return baseline_shift_;
}
inline void CharacterStylePropertiesArchive::set_baseline_shift(float value) {
  set_has_baseline_shift();
  baseline_shift_ = value;
}

// optional float kerning = 15;
inline bool CharacterStylePropertiesArchive::has_kerning() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_kerning() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CharacterStylePropertiesArchive::clear_has_kerning() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CharacterStylePropertiesArchive::clear_kerning() {
  kerning_ = 0;
  clear_has_kerning();
}
inline float CharacterStylePropertiesArchive::kerning() const {
  return kerning_;
}
inline void CharacterStylePropertiesArchive::set_kerning(float value) {
  set_has_kerning();
  kerning_ = value;
}

// optional .TSWP.CharacterStylePropertiesArchive.LigaturesType ligatures = 16;
inline bool CharacterStylePropertiesArchive::has_ligatures() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_ligatures() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CharacterStylePropertiesArchive::clear_has_ligatures() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CharacterStylePropertiesArchive::clear_ligatures() {
  ligatures_ = 0;
  clear_has_ligatures();
}
inline ::TSWP::CharacterStylePropertiesArchive_LigaturesType CharacterStylePropertiesArchive::ligatures() const {
  return static_cast< ::TSWP::CharacterStylePropertiesArchive_LigaturesType >(ligatures_);
}
inline void CharacterStylePropertiesArchive::set_ligatures(::TSWP::CharacterStylePropertiesArchive_LigaturesType value) {
  assert(::TSWP::CharacterStylePropertiesArchive_LigaturesType_IsValid(value));
  set_has_ligatures();
  ligatures_ = value;
}

// optional bool outline_color_null = 17;
inline bool CharacterStylePropertiesArchive::has_outline_color_null() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_outline_color_null() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CharacterStylePropertiesArchive::clear_has_outline_color_null() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CharacterStylePropertiesArchive::clear_outline_color_null() {
  outline_color_null_ = false;
  clear_has_outline_color_null();
}
inline bool CharacterStylePropertiesArchive::outline_color_null() const {
  return outline_color_null_;
}
inline void CharacterStylePropertiesArchive::set_outline_color_null(bool value) {
  set_has_outline_color_null();
  outline_color_null_ = value;
}

// optional .TSP.Color outline_color = 18;
inline bool CharacterStylePropertiesArchive::has_outline_color() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_outline_color() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CharacterStylePropertiesArchive::clear_has_outline_color() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CharacterStylePropertiesArchive::clear_outline_color() {
  if (outline_color_ != NULL) outline_color_->::TSP::Color::Clear();
  clear_has_outline_color();
}
inline const ::TSP::Color& CharacterStylePropertiesArchive::outline_color() const {
  return outline_color_ != NULL ? *outline_color_ : *default_instance_->outline_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::mutable_outline_color() {
  set_has_outline_color();
  if (outline_color_ == NULL) outline_color_ = new ::TSP::Color;
  return outline_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::release_outline_color() {
  clear_has_outline_color();
  ::TSP::Color* temp = outline_color_;
  outline_color_ = NULL;
  return temp;
}
inline void CharacterStylePropertiesArchive::set_allocated_outline_color(::TSP::Color* outline_color) {
  delete outline_color_;
  outline_color_ = outline_color;
  if (outline_color) {
    set_has_outline_color();
  } else {
    clear_has_outline_color();
  }
}

// optional float outline = 19;
inline bool CharacterStylePropertiesArchive::has_outline() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_outline() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CharacterStylePropertiesArchive::clear_has_outline() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CharacterStylePropertiesArchive::clear_outline() {
  outline_ = 0;
  clear_has_outline();
}
inline float CharacterStylePropertiesArchive::outline() const {
  return outline_;
}
inline void CharacterStylePropertiesArchive::set_outline(float value) {
  set_has_outline();
  outline_ = value;
}

// optional bool shadow_null = 20;
inline bool CharacterStylePropertiesArchive::has_shadow_null() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_shadow_null() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CharacterStylePropertiesArchive::clear_has_shadow_null() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CharacterStylePropertiesArchive::clear_shadow_null() {
  shadow_null_ = false;
  clear_has_shadow_null();
}
inline bool CharacterStylePropertiesArchive::shadow_null() const {
  return shadow_null_;
}
inline void CharacterStylePropertiesArchive::set_shadow_null(bool value) {
  set_has_shadow_null();
  shadow_null_ = value;
}

// optional .TSD.ShadowArchive shadow = 21;
inline bool CharacterStylePropertiesArchive::has_shadow() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_shadow() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CharacterStylePropertiesArchive::clear_has_shadow() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CharacterStylePropertiesArchive::clear_shadow() {
  if (shadow_ != NULL) shadow_->::TSD::ShadowArchive::Clear();
  clear_has_shadow();
}
inline const ::TSD::ShadowArchive& CharacterStylePropertiesArchive::shadow() const {
  return shadow_ != NULL ? *shadow_ : *default_instance_->shadow_;
}
inline ::TSD::ShadowArchive* CharacterStylePropertiesArchive::mutable_shadow() {
  set_has_shadow();
  if (shadow_ == NULL) shadow_ = new ::TSD::ShadowArchive;
  return shadow_;
}
inline ::TSD::ShadowArchive* CharacterStylePropertiesArchive::release_shadow() {
  clear_has_shadow();
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = NULL;
  return temp;
}
inline void CharacterStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  delete shadow_;
  shadow_ = shadow;
  if (shadow) {
    set_has_shadow();
  } else {
    clear_has_shadow();
  }
}

// optional bool strikethru_color_null = 22;
inline bool CharacterStylePropertiesArchive::has_strikethru_color_null() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_strikethru_color_null() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CharacterStylePropertiesArchive::clear_has_strikethru_color_null() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CharacterStylePropertiesArchive::clear_strikethru_color_null() {
  strikethru_color_null_ = false;
  clear_has_strikethru_color_null();
}
inline bool CharacterStylePropertiesArchive::strikethru_color_null() const {
  return strikethru_color_null_;
}
inline void CharacterStylePropertiesArchive::set_strikethru_color_null(bool value) {
  set_has_strikethru_color_null();
  strikethru_color_null_ = value;
}

// optional .TSP.Color strikethru_color = 23;
inline bool CharacterStylePropertiesArchive::has_strikethru_color() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_strikethru_color() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CharacterStylePropertiesArchive::clear_has_strikethru_color() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CharacterStylePropertiesArchive::clear_strikethru_color() {
  if (strikethru_color_ != NULL) strikethru_color_->::TSP::Color::Clear();
  clear_has_strikethru_color();
}
inline const ::TSP::Color& CharacterStylePropertiesArchive::strikethru_color() const {
  return strikethru_color_ != NULL ? *strikethru_color_ : *default_instance_->strikethru_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::mutable_strikethru_color() {
  set_has_strikethru_color();
  if (strikethru_color_ == NULL) strikethru_color_ = new ::TSP::Color;
  return strikethru_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::release_strikethru_color() {
  clear_has_strikethru_color();
  ::TSP::Color* temp = strikethru_color_;
  strikethru_color_ = NULL;
  return temp;
}
inline void CharacterStylePropertiesArchive::set_allocated_strikethru_color(::TSP::Color* strikethru_color) {
  delete strikethru_color_;
  strikethru_color_ = strikethru_color;
  if (strikethru_color) {
    set_has_strikethru_color();
  } else {
    clear_has_strikethru_color();
  }
}

// optional float strikethru_width = 24;
inline bool CharacterStylePropertiesArchive::has_strikethru_width() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_strikethru_width() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CharacterStylePropertiesArchive::clear_has_strikethru_width() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CharacterStylePropertiesArchive::clear_strikethru_width() {
  strikethru_width_ = 0;
  clear_has_strikethru_width();
}
inline float CharacterStylePropertiesArchive::strikethru_width() const {
  return strikethru_width_;
}
inline void CharacterStylePropertiesArchive::set_strikethru_width(float value) {
  set_has_strikethru_width();
  strikethru_width_ = value;
}

// optional bool background_color_null = 25;
inline bool CharacterStylePropertiesArchive::has_background_color_null() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_background_color_null() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_background_color_null() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CharacterStylePropertiesArchive::clear_background_color_null() {
  background_color_null_ = false;
  clear_has_background_color_null();
}
inline bool CharacterStylePropertiesArchive::background_color_null() const {
  return background_color_null_;
}
inline void CharacterStylePropertiesArchive::set_background_color_null(bool value) {
  set_has_background_color_null();
  background_color_null_ = value;
}

// optional .TSP.Color background_color = 26;
inline bool CharacterStylePropertiesArchive::has_background_color() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_background_color() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_background_color() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CharacterStylePropertiesArchive::clear_background_color() {
  if (background_color_ != NULL) background_color_->::TSP::Color::Clear();
  clear_has_background_color();
}
inline const ::TSP::Color& CharacterStylePropertiesArchive::background_color() const {
  return background_color_ != NULL ? *background_color_ : *default_instance_->background_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::mutable_background_color() {
  set_has_background_color();
  if (background_color_ == NULL) background_color_ = new ::TSP::Color;
  return background_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::release_background_color() {
  clear_has_background_color();
  ::TSP::Color* temp = background_color_;
  background_color_ = NULL;
  return temp;
}
inline void CharacterStylePropertiesArchive::set_allocated_background_color(::TSP::Color* background_color) {
  delete background_color_;
  background_color_ = background_color;
  if (background_color) {
    set_has_background_color();
  } else {
    clear_has_background_color();
  }
}

// optional float tracking = 27;
inline bool CharacterStylePropertiesArchive::has_tracking() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_tracking() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_tracking() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CharacterStylePropertiesArchive::clear_tracking() {
  tracking_ = 0;
  clear_has_tracking();
}
inline float CharacterStylePropertiesArchive::tracking() const {
  return tracking_;
}
inline void CharacterStylePropertiesArchive::set_tracking(float value) {
  set_has_tracking();
  tracking_ = value;
}

// optional bool underline_color_null = 28;
inline bool CharacterStylePropertiesArchive::has_underline_color_null() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_underline_color_null() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_underline_color_null() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CharacterStylePropertiesArchive::clear_underline_color_null() {
  underline_color_null_ = false;
  clear_has_underline_color_null();
}
inline bool CharacterStylePropertiesArchive::underline_color_null() const {
  return underline_color_null_;
}
inline void CharacterStylePropertiesArchive::set_underline_color_null(bool value) {
  set_has_underline_color_null();
  underline_color_null_ = value;
}

// optional .TSP.Color underline_color = 29;
inline bool CharacterStylePropertiesArchive::has_underline_color() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_underline_color() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_underline_color() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CharacterStylePropertiesArchive::clear_underline_color() {
  if (underline_color_ != NULL) underline_color_->::TSP::Color::Clear();
  clear_has_underline_color();
}
inline const ::TSP::Color& CharacterStylePropertiesArchive::underline_color() const {
  return underline_color_ != NULL ? *underline_color_ : *default_instance_->underline_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::mutable_underline_color() {
  set_has_underline_color();
  if (underline_color_ == NULL) underline_color_ = new ::TSP::Color;
  return underline_color_;
}
inline ::TSP::Color* CharacterStylePropertiesArchive::release_underline_color() {
  clear_has_underline_color();
  ::TSP::Color* temp = underline_color_;
  underline_color_ = NULL;
  return temp;
}
inline void CharacterStylePropertiesArchive::set_allocated_underline_color(::TSP::Color* underline_color) {
  delete underline_color_;
  underline_color_ = underline_color;
  if (underline_color) {
    set_has_underline_color();
  } else {
    clear_has_underline_color();
  }
}

// optional float underline_width = 30;
inline bool CharacterStylePropertiesArchive::has_underline_width() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_underline_width() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_underline_width() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CharacterStylePropertiesArchive::clear_underline_width() {
  underline_width_ = 0;
  clear_has_underline_width();
}
inline float CharacterStylePropertiesArchive::underline_width() const {
  return underline_width_;
}
inline void CharacterStylePropertiesArchive::set_underline_width(float value) {
  set_has_underline_width();
  underline_width_ = value;
}

// optional bool word_strikethru = 31;
inline bool CharacterStylePropertiesArchive::has_word_strikethru() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_word_strikethru() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_word_strikethru() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CharacterStylePropertiesArchive::clear_word_strikethru() {
  word_strikethru_ = false;
  clear_has_word_strikethru();
}
inline bool CharacterStylePropertiesArchive::word_strikethru() const {
  return word_strikethru_;
}
inline void CharacterStylePropertiesArchive::set_word_strikethru(bool value) {
  set_has_word_strikethru();
  word_strikethru_ = value;
}

// optional bool word_underline = 32;
inline bool CharacterStylePropertiesArchive::has_word_underline() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_word_underline() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CharacterStylePropertiesArchive::clear_has_word_underline() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CharacterStylePropertiesArchive::clear_word_underline() {
  word_underline_ = false;
  clear_has_word_underline();
}
inline bool CharacterStylePropertiesArchive::word_underline() const {
  return word_underline_;
}
inline void CharacterStylePropertiesArchive::set_word_underline(bool value) {
  set_has_word_underline();
  word_underline_ = value;
}

// optional bool font_features_null = 33;
inline bool CharacterStylePropertiesArchive::has_font_features_null() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_font_features_null() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CharacterStylePropertiesArchive::clear_has_font_features_null() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CharacterStylePropertiesArchive::clear_font_features_null() {
  font_features_null_ = false;
  clear_has_font_features_null();
}
inline bool CharacterStylePropertiesArchive::font_features_null() const {
  return font_features_null_;
}
inline void CharacterStylePropertiesArchive::set_font_features_null(bool value) {
  set_has_font_features_null();
  font_features_null_ = value;
}

// repeated .TSWP.FontFeatureArchive font_features = 34;
inline int CharacterStylePropertiesArchive::font_features_size() const {
  return font_features_.size();
}
inline void CharacterStylePropertiesArchive::clear_font_features() {
  font_features_.Clear();
}
inline const ::TSWP::FontFeatureArchive& CharacterStylePropertiesArchive::font_features(int index) const {
  return font_features_.Get(index);
}
inline ::TSWP::FontFeatureArchive* CharacterStylePropertiesArchive::mutable_font_features(int index) {
  return font_features_.Mutable(index);
}
inline ::TSWP::FontFeatureArchive* CharacterStylePropertiesArchive::add_font_features() {
  return font_features_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::FontFeatureArchive >&
CharacterStylePropertiesArchive::font_features() const {
  return font_features_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::FontFeatureArchive >*
CharacterStylePropertiesArchive::mutable_font_features() {
  return &font_features_;
}

// optional .TSWP.WritingDirectionType writing_direction = 35 [default = kWritingDirectionNatural];
inline bool CharacterStylePropertiesArchive::has_writing_direction() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_writing_direction() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CharacterStylePropertiesArchive::clear_has_writing_direction() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CharacterStylePropertiesArchive::clear_writing_direction() {
  writing_direction_ = -1;
  clear_has_writing_direction();
}
inline ::TSWP::WritingDirectionType CharacterStylePropertiesArchive::writing_direction() const {
  return static_cast< ::TSWP::WritingDirectionType >(writing_direction_);
}
inline void CharacterStylePropertiesArchive::set_writing_direction(::TSWP::WritingDirectionType value) {
  assert(::TSWP::WritingDirectionType_IsValid(value));
  set_has_writing_direction();
  writing_direction_ = value;
}

// optional bool emphasis_marks_null = 36;
inline bool CharacterStylePropertiesArchive::has_emphasis_marks_null() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_emphasis_marks_null() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CharacterStylePropertiesArchive::clear_has_emphasis_marks_null() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CharacterStylePropertiesArchive::clear_emphasis_marks_null() {
  emphasis_marks_null_ = false;
  clear_has_emphasis_marks_null();
}
inline bool CharacterStylePropertiesArchive::emphasis_marks_null() const {
  return emphasis_marks_null_;
}
inline void CharacterStylePropertiesArchive::set_emphasis_marks_null(bool value) {
  set_has_emphasis_marks_null();
  emphasis_marks_null_ = value;
}

// optional string emphasis_marks = 37;
inline bool CharacterStylePropertiesArchive::has_emphasis_marks() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_emphasis_marks() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CharacterStylePropertiesArchive::clear_has_emphasis_marks() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CharacterStylePropertiesArchive::clear_emphasis_marks() {
  if (emphasis_marks_ != &::google::protobuf::internal::kEmptyString) {
    emphasis_marks_->clear();
  }
  clear_has_emphasis_marks();
}
inline const ::std::string& CharacterStylePropertiesArchive::emphasis_marks() const {
  return *emphasis_marks_;
}
inline void CharacterStylePropertiesArchive::set_emphasis_marks(const ::std::string& value) {
  set_has_emphasis_marks();
  if (emphasis_marks_ == &::google::protobuf::internal::kEmptyString) {
    emphasis_marks_ = new ::std::string;
  }
  emphasis_marks_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_emphasis_marks(const char* value) {
  set_has_emphasis_marks();
  if (emphasis_marks_ == &::google::protobuf::internal::kEmptyString) {
    emphasis_marks_ = new ::std::string;
  }
  emphasis_marks_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_emphasis_marks(const char* value, size_t size) {
  set_has_emphasis_marks();
  if (emphasis_marks_ == &::google::protobuf::internal::kEmptyString) {
    emphasis_marks_ = new ::std::string;
  }
  emphasis_marks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterStylePropertiesArchive::mutable_emphasis_marks() {
  set_has_emphasis_marks();
  if (emphasis_marks_ == &::google::protobuf::internal::kEmptyString) {
    emphasis_marks_ = new ::std::string;
  }
  return emphasis_marks_;
}
inline ::std::string* CharacterStylePropertiesArchive::release_emphasis_marks() {
  clear_has_emphasis_marks();
  if (emphasis_marks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emphasis_marks_;
    emphasis_marks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterStylePropertiesArchive::set_allocated_emphasis_marks(::std::string* emphasis_marks) {
  if (emphasis_marks_ != &::google::protobuf::internal::kEmptyString) {
    delete emphasis_marks_;
  }
  if (emphasis_marks) {
    set_has_emphasis_marks();
    emphasis_marks_ = emphasis_marks;
  } else {
    clear_has_emphasis_marks();
    emphasis_marks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool compatibility_font_name_null = 38;
inline bool CharacterStylePropertiesArchive::has_compatibility_font_name_null() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_compatibility_font_name_null() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CharacterStylePropertiesArchive::clear_has_compatibility_font_name_null() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CharacterStylePropertiesArchive::clear_compatibility_font_name_null() {
  compatibility_font_name_null_ = false;
  clear_has_compatibility_font_name_null();
}
inline bool CharacterStylePropertiesArchive::compatibility_font_name_null() const {
  return compatibility_font_name_null_;
}
inline void CharacterStylePropertiesArchive::set_compatibility_font_name_null(bool value) {
  set_has_compatibility_font_name_null();
  compatibility_font_name_null_ = value;
}

// optional string compatibility_font_name = 39;
inline bool CharacterStylePropertiesArchive::has_compatibility_font_name() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CharacterStylePropertiesArchive::set_has_compatibility_font_name() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CharacterStylePropertiesArchive::clear_has_compatibility_font_name() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CharacterStylePropertiesArchive::clear_compatibility_font_name() {
  if (compatibility_font_name_ != &::google::protobuf::internal::kEmptyString) {
    compatibility_font_name_->clear();
  }
  clear_has_compatibility_font_name();
}
inline const ::std::string& CharacterStylePropertiesArchive::compatibility_font_name() const {
  return *compatibility_font_name_;
}
inline void CharacterStylePropertiesArchive::set_compatibility_font_name(const ::std::string& value) {
  set_has_compatibility_font_name();
  if (compatibility_font_name_ == &::google::protobuf::internal::kEmptyString) {
    compatibility_font_name_ = new ::std::string;
  }
  compatibility_font_name_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_compatibility_font_name(const char* value) {
  set_has_compatibility_font_name();
  if (compatibility_font_name_ == &::google::protobuf::internal::kEmptyString) {
    compatibility_font_name_ = new ::std::string;
  }
  compatibility_font_name_->assign(value);
}
inline void CharacterStylePropertiesArchive::set_compatibility_font_name(const char* value, size_t size) {
  set_has_compatibility_font_name();
  if (compatibility_font_name_ == &::google::protobuf::internal::kEmptyString) {
    compatibility_font_name_ = new ::std::string;
  }
  compatibility_font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterStylePropertiesArchive::mutable_compatibility_font_name() {
  set_has_compatibility_font_name();
  if (compatibility_font_name_ == &::google::protobuf::internal::kEmptyString) {
    compatibility_font_name_ = new ::std::string;
  }
  return compatibility_font_name_;
}
inline ::std::string* CharacterStylePropertiesArchive::release_compatibility_font_name() {
  clear_has_compatibility_font_name();
  if (compatibility_font_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compatibility_font_name_;
    compatibility_font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterStylePropertiesArchive::set_allocated_compatibility_font_name(::std::string* compatibility_font_name) {
  if (compatibility_font_name_ != &::google::protobuf::internal::kEmptyString) {
    delete compatibility_font_name_;
  }
  if (compatibility_font_name) {
    set_has_compatibility_font_name();
    compatibility_font_name_ = compatibility_font_name;
  } else {
    clear_has_compatibility_font_name();
    compatibility_font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CharacterStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool CharacterStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharacterStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharacterStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharacterStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& CharacterStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* CharacterStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* CharacterStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CharacterStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool CharacterStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharacterStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharacterStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharacterStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 CharacterStyleArchive::override_count() const {
  return override_count_;
}
inline void CharacterStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TSWP.CharacterStylePropertiesArchive char_properties = 11;
inline bool CharacterStyleArchive::has_char_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharacterStyleArchive::set_has_char_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharacterStyleArchive::clear_has_char_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharacterStyleArchive::clear_char_properties() {
  if (char_properties_ != NULL) char_properties_->::TSWP::CharacterStylePropertiesArchive::Clear();
  clear_has_char_properties();
}
inline const ::TSWP::CharacterStylePropertiesArchive& CharacterStyleArchive::char_properties() const {
  return char_properties_ != NULL ? *char_properties_ : *default_instance_->char_properties_;
}
inline ::TSWP::CharacterStylePropertiesArchive* CharacterStyleArchive::mutable_char_properties() {
  set_has_char_properties();
  if (char_properties_ == NULL) char_properties_ = new ::TSWP::CharacterStylePropertiesArchive;
  return char_properties_;
}
inline ::TSWP::CharacterStylePropertiesArchive* CharacterStyleArchive::release_char_properties() {
  clear_has_char_properties();
  ::TSWP::CharacterStylePropertiesArchive* temp = char_properties_;
  char_properties_ = NULL;
  return temp;
}
inline void CharacterStyleArchive::set_allocated_char_properties(::TSWP::CharacterStylePropertiesArchive* char_properties) {
  delete char_properties_;
  char_properties_ = char_properties;
  if (char_properties) {
    set_has_char_properties();
  } else {
    clear_has_char_properties();
  }
}

// -------------------------------------------------------------------

// TabArchive

// optional float position = 1;
inline bool TabArchive::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TabArchive::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TabArchive::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TabArchive::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline float TabArchive::position() const {
  return position_;
}
inline void TabArchive::set_position(float value) {
  set_has_position();
  position_ = value;
}

// optional .TSWP.TabArchive.TabAlignmentType alignment = 2;
inline bool TabArchive::has_alignment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TabArchive::set_has_alignment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TabArchive::clear_has_alignment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TabArchive::clear_alignment() {
  alignment_ = 0;
  clear_has_alignment();
}
inline ::TSWP::TabArchive_TabAlignmentType TabArchive::alignment() const {
  return static_cast< ::TSWP::TabArchive_TabAlignmentType >(alignment_);
}
inline void TabArchive::set_alignment(::TSWP::TabArchive_TabAlignmentType value) {
  assert(::TSWP::TabArchive_TabAlignmentType_IsValid(value));
  set_has_alignment();
  alignment_ = value;
}

// optional string leader = 3;
inline bool TabArchive::has_leader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TabArchive::set_has_leader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TabArchive::clear_has_leader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TabArchive::clear_leader() {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    leader_->clear();
  }
  clear_has_leader();
}
inline const ::std::string& TabArchive::leader() const {
  return *leader_;
}
inline void TabArchive::set_leader(const ::std::string& value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void TabArchive::set_leader(const char* value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void TabArchive::set_leader(const char* value, size_t size) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabArchive::mutable_leader() {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  return leader_;
}
inline ::std::string* TabArchive::release_leader() {
  clear_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leader_;
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TabArchive::set_allocated_leader(::std::string* leader) {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    delete leader_;
  }
  if (leader) {
    set_has_leader();
    leader_ = leader;
  } else {
    clear_has_leader();
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TabsArchive

// repeated .TSWP.TabArchive tabs = 1;
inline int TabsArchive::tabs_size() const {
  return tabs_.size();
}
inline void TabsArchive::clear_tabs() {
  tabs_.Clear();
}
inline const ::TSWP::TabArchive& TabsArchive::tabs(int index) const {
  return tabs_.Get(index);
}
inline ::TSWP::TabArchive* TabsArchive::mutable_tabs(int index) {
  return tabs_.Mutable(index);
}
inline ::TSWP::TabArchive* TabsArchive::add_tabs() {
  return tabs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::TabArchive >&
TabsArchive::tabs() const {
  return tabs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::TabArchive >*
TabsArchive::mutable_tabs() {
  return &tabs_;
}

// -------------------------------------------------------------------

// LineSpacingArchive

// optional .TSWP.LineSpacingArchive.LineSpacingModeType mode = 1;
inline bool LineSpacingArchive::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineSpacingArchive::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineSpacingArchive::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineSpacingArchive::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::TSWP::LineSpacingArchive_LineSpacingModeType LineSpacingArchive::mode() const {
  return static_cast< ::TSWP::LineSpacingArchive_LineSpacingModeType >(mode_);
}
inline void LineSpacingArchive::set_mode(::TSWP::LineSpacingArchive_LineSpacingModeType value) {
  assert(::TSWP::LineSpacingArchive_LineSpacingModeType_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional float amount = 2;
inline bool LineSpacingArchive::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineSpacingArchive::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineSpacingArchive::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineSpacingArchive::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline float LineSpacingArchive::amount() const {
  return amount_;
}
inline void LineSpacingArchive::set_amount(float value) {
  set_has_amount();
  amount_ = value;
}

// optional float baselineRule = 3;
inline bool LineSpacingArchive::has_baselinerule() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineSpacingArchive::set_has_baselinerule() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineSpacingArchive::clear_has_baselinerule() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineSpacingArchive::clear_baselinerule() {
  baselinerule_ = 0;
  clear_has_baselinerule();
}
inline float LineSpacingArchive::baselinerule() const {
  return baselinerule_;
}
inline void LineSpacingArchive::set_baselinerule(float value) {
  set_has_baselinerule();
  baselinerule_ = value;
}

// -------------------------------------------------------------------

// ParagraphStylePropertiesArchive

// optional .TSWP.ParagraphStylePropertiesArchive.TextAlignmentType alignment = 1;
inline bool ParagraphStylePropertiesArchive::has_alignment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_alignment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParagraphStylePropertiesArchive::clear_has_alignment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParagraphStylePropertiesArchive::clear_alignment() {
  alignment_ = 0;
  clear_has_alignment();
}
inline ::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType ParagraphStylePropertiesArchive::alignment() const {
  return static_cast< ::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType >(alignment_);
}
inline void ParagraphStylePropertiesArchive::set_alignment(::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType value) {
  assert(::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType_IsValid(value));
  set_has_alignment();
  alignment_ = value;
}

// optional bool decimal_tab_null = 2;
inline bool ParagraphStylePropertiesArchive::has_decimal_tab_null() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_decimal_tab_null() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParagraphStylePropertiesArchive::clear_has_decimal_tab_null() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParagraphStylePropertiesArchive::clear_decimal_tab_null() {
  decimal_tab_null_ = false;
  clear_has_decimal_tab_null();
}
inline bool ParagraphStylePropertiesArchive::decimal_tab_null() const {
  return decimal_tab_null_;
}
inline void ParagraphStylePropertiesArchive::set_decimal_tab_null(bool value) {
  set_has_decimal_tab_null();
  decimal_tab_null_ = value;
}

// optional string decimal_tab = 3;
inline bool ParagraphStylePropertiesArchive::has_decimal_tab() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_decimal_tab() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParagraphStylePropertiesArchive::clear_has_decimal_tab() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParagraphStylePropertiesArchive::clear_decimal_tab() {
  if (decimal_tab_ != &::google::protobuf::internal::kEmptyString) {
    decimal_tab_->clear();
  }
  clear_has_decimal_tab();
}
inline const ::std::string& ParagraphStylePropertiesArchive::decimal_tab() const {
  return *decimal_tab_;
}
inline void ParagraphStylePropertiesArchive::set_decimal_tab(const ::std::string& value) {
  set_has_decimal_tab();
  if (decimal_tab_ == &::google::protobuf::internal::kEmptyString) {
    decimal_tab_ = new ::std::string;
  }
  decimal_tab_->assign(value);
}
inline void ParagraphStylePropertiesArchive::set_decimal_tab(const char* value) {
  set_has_decimal_tab();
  if (decimal_tab_ == &::google::protobuf::internal::kEmptyString) {
    decimal_tab_ = new ::std::string;
  }
  decimal_tab_->assign(value);
}
inline void ParagraphStylePropertiesArchive::set_decimal_tab(const char* value, size_t size) {
  set_has_decimal_tab();
  if (decimal_tab_ == &::google::protobuf::internal::kEmptyString) {
    decimal_tab_ = new ::std::string;
  }
  decimal_tab_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParagraphStylePropertiesArchive::mutable_decimal_tab() {
  set_has_decimal_tab();
  if (decimal_tab_ == &::google::protobuf::internal::kEmptyString) {
    decimal_tab_ = new ::std::string;
  }
  return decimal_tab_;
}
inline ::std::string* ParagraphStylePropertiesArchive::release_decimal_tab() {
  clear_has_decimal_tab();
  if (decimal_tab_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = decimal_tab_;
    decimal_tab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParagraphStylePropertiesArchive::set_allocated_decimal_tab(::std::string* decimal_tab) {
  if (decimal_tab_ != &::google::protobuf::internal::kEmptyString) {
    delete decimal_tab_;
  }
  if (decimal_tab) {
    set_has_decimal_tab();
    decimal_tab_ = decimal_tab;
  } else {
    clear_has_decimal_tab();
    decimal_tab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float default_tab_stops = 4;
inline bool ParagraphStylePropertiesArchive::has_default_tab_stops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_default_tab_stops() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParagraphStylePropertiesArchive::clear_has_default_tab_stops() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParagraphStylePropertiesArchive::clear_default_tab_stops() {
  default_tab_stops_ = 0;
  clear_has_default_tab_stops();
}
inline float ParagraphStylePropertiesArchive::default_tab_stops() const {
  return default_tab_stops_;
}
inline void ParagraphStylePropertiesArchive::set_default_tab_stops(float value) {
  set_has_default_tab_stops();
  default_tab_stops_ = value;
}

// optional bool fill_null = 5;
inline bool ParagraphStylePropertiesArchive::has_fill_null() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_fill_null() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParagraphStylePropertiesArchive::clear_has_fill_null() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParagraphStylePropertiesArchive::clear_fill_null() {
  fill_null_ = false;
  clear_has_fill_null();
}
inline bool ParagraphStylePropertiesArchive::fill_null() const {
  return fill_null_;
}
inline void ParagraphStylePropertiesArchive::set_fill_null(bool value) {
  set_has_fill_null();
  fill_null_ = value;
}

// optional .TSP.Color fill = 6;
inline bool ParagraphStylePropertiesArchive::has_fill() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_fill() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParagraphStylePropertiesArchive::clear_has_fill() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParagraphStylePropertiesArchive::clear_fill() {
  if (fill_ != NULL) fill_->::TSP::Color::Clear();
  clear_has_fill();
}
inline const ::TSP::Color& ParagraphStylePropertiesArchive::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSP::Color* ParagraphStylePropertiesArchive::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSP::Color;
  return fill_;
}
inline ::TSP::Color* ParagraphStylePropertiesArchive::release_fill() {
  clear_has_fill();
  ::TSP::Color* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_fill(::TSP::Color* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// optional float first_line_indent = 7;
inline bool ParagraphStylePropertiesArchive::has_first_line_indent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_first_line_indent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParagraphStylePropertiesArchive::clear_has_first_line_indent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParagraphStylePropertiesArchive::clear_first_line_indent() {
  first_line_indent_ = 0;
  clear_has_first_line_indent();
}
inline float ParagraphStylePropertiesArchive::first_line_indent() const {
  return first_line_indent_;
}
inline void ParagraphStylePropertiesArchive::set_first_line_indent(float value) {
  set_has_first_line_indent();
  first_line_indent_ = value;
}

// optional bool hyphenate = 8;
inline bool ParagraphStylePropertiesArchive::has_hyphenate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_hyphenate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ParagraphStylePropertiesArchive::clear_has_hyphenate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ParagraphStylePropertiesArchive::clear_hyphenate() {
  hyphenate_ = false;
  clear_has_hyphenate();
}
inline bool ParagraphStylePropertiesArchive::hyphenate() const {
  return hyphenate_;
}
inline void ParagraphStylePropertiesArchive::set_hyphenate(bool value) {
  set_has_hyphenate();
  hyphenate_ = value;
}

// optional bool keep_lines_together = 9;
inline bool ParagraphStylePropertiesArchive::has_keep_lines_together() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_keep_lines_together() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ParagraphStylePropertiesArchive::clear_has_keep_lines_together() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ParagraphStylePropertiesArchive::clear_keep_lines_together() {
  keep_lines_together_ = false;
  clear_has_keep_lines_together();
}
inline bool ParagraphStylePropertiesArchive::keep_lines_together() const {
  return keep_lines_together_;
}
inline void ParagraphStylePropertiesArchive::set_keep_lines_together(bool value) {
  set_has_keep_lines_together();
  keep_lines_together_ = value;
}

// optional bool keep_with_next = 10;
inline bool ParagraphStylePropertiesArchive::has_keep_with_next() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_keep_with_next() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ParagraphStylePropertiesArchive::clear_has_keep_with_next() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ParagraphStylePropertiesArchive::clear_keep_with_next() {
  keep_with_next_ = false;
  clear_has_keep_with_next();
}
inline bool ParagraphStylePropertiesArchive::keep_with_next() const {
  return keep_with_next_;
}
inline void ParagraphStylePropertiesArchive::set_keep_with_next(bool value) {
  set_has_keep_with_next();
  keep_with_next_ = value;
}

// optional float left_indent = 11;
inline bool ParagraphStylePropertiesArchive::has_left_indent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_left_indent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ParagraphStylePropertiesArchive::clear_has_left_indent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ParagraphStylePropertiesArchive::clear_left_indent() {
  left_indent_ = 0;
  clear_has_left_indent();
}
inline float ParagraphStylePropertiesArchive::left_indent() const {
  return left_indent_;
}
inline void ParagraphStylePropertiesArchive::set_left_indent(float value) {
  set_has_left_indent();
  left_indent_ = value;
}

// optional bool line_spacing_null = 12;
inline bool ParagraphStylePropertiesArchive::has_line_spacing_null() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_line_spacing_null() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ParagraphStylePropertiesArchive::clear_has_line_spacing_null() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ParagraphStylePropertiesArchive::clear_line_spacing_null() {
  line_spacing_null_ = false;
  clear_has_line_spacing_null();
}
inline bool ParagraphStylePropertiesArchive::line_spacing_null() const {
  return line_spacing_null_;
}
inline void ParagraphStylePropertiesArchive::set_line_spacing_null(bool value) {
  set_has_line_spacing_null();
  line_spacing_null_ = value;
}

// optional .TSWP.LineSpacingArchive line_spacing = 13;
inline bool ParagraphStylePropertiesArchive::has_line_spacing() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_line_spacing() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_line_spacing() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ParagraphStylePropertiesArchive::clear_line_spacing() {
  if (line_spacing_ != NULL) line_spacing_->::TSWP::LineSpacingArchive::Clear();
  clear_has_line_spacing();
}
inline const ::TSWP::LineSpacingArchive& ParagraphStylePropertiesArchive::line_spacing() const {
  return line_spacing_ != NULL ? *line_spacing_ : *default_instance_->line_spacing_;
}
inline ::TSWP::LineSpacingArchive* ParagraphStylePropertiesArchive::mutable_line_spacing() {
  set_has_line_spacing();
  if (line_spacing_ == NULL) line_spacing_ = new ::TSWP::LineSpacingArchive;
  return line_spacing_;
}
inline ::TSWP::LineSpacingArchive* ParagraphStylePropertiesArchive::release_line_spacing() {
  clear_has_line_spacing();
  ::TSWP::LineSpacingArchive* temp = line_spacing_;
  line_spacing_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_line_spacing(::TSWP::LineSpacingArchive* line_spacing) {
  delete line_spacing_;
  line_spacing_ = line_spacing;
  if (line_spacing) {
    set_has_line_spacing();
  } else {
    clear_has_line_spacing();
  }
}

// optional bool page_break_before = 14;
inline bool ParagraphStylePropertiesArchive::has_page_break_before() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_page_break_before() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_page_break_before() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ParagraphStylePropertiesArchive::clear_page_break_before() {
  page_break_before_ = false;
  clear_has_page_break_before();
}
inline bool ParagraphStylePropertiesArchive::page_break_before() const {
  return page_break_before_;
}
inline void ParagraphStylePropertiesArchive::set_page_break_before(bool value) {
  set_has_page_break_before();
  page_break_before_ = value;
}

// optional .TSWP.ParagraphStylePropertiesArchive.ParagraphBorderType borders = 15;
inline bool ParagraphStylePropertiesArchive::has_borders() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_borders() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_borders() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ParagraphStylePropertiesArchive::clear_borders() {
  borders_ = 0;
  clear_has_borders();
}
inline ::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType ParagraphStylePropertiesArchive::borders() const {
  return static_cast< ::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType >(borders_);
}
inline void ParagraphStylePropertiesArchive::set_borders(::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType value) {
  assert(::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType_IsValid(value));
  set_has_borders();
  borders_ = value;
}

// optional bool rule_offset_null = 16;
inline bool ParagraphStylePropertiesArchive::has_rule_offset_null() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_rule_offset_null() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_rule_offset_null() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ParagraphStylePropertiesArchive::clear_rule_offset_null() {
  rule_offset_null_ = false;
  clear_has_rule_offset_null();
}
inline bool ParagraphStylePropertiesArchive::rule_offset_null() const {
  return rule_offset_null_;
}
inline void ParagraphStylePropertiesArchive::set_rule_offset_null(bool value) {
  set_has_rule_offset_null();
  rule_offset_null_ = value;
}

// optional .TSP.Point rule_offset = 17;
inline bool ParagraphStylePropertiesArchive::has_rule_offset() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_rule_offset() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_rule_offset() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ParagraphStylePropertiesArchive::clear_rule_offset() {
  if (rule_offset_ != NULL) rule_offset_->::TSP::Point::Clear();
  clear_has_rule_offset();
}
inline const ::TSP::Point& ParagraphStylePropertiesArchive::rule_offset() const {
  return rule_offset_ != NULL ? *rule_offset_ : *default_instance_->rule_offset_;
}
inline ::TSP::Point* ParagraphStylePropertiesArchive::mutable_rule_offset() {
  set_has_rule_offset();
  if (rule_offset_ == NULL) rule_offset_ = new ::TSP::Point;
  return rule_offset_;
}
inline ::TSP::Point* ParagraphStylePropertiesArchive::release_rule_offset() {
  clear_has_rule_offset();
  ::TSP::Point* temp = rule_offset_;
  rule_offset_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_rule_offset(::TSP::Point* rule_offset) {
  delete rule_offset_;
  rule_offset_ = rule_offset;
  if (rule_offset) {
    set_has_rule_offset();
  } else {
    clear_has_rule_offset();
  }
}

// optional float rule_width = 18;
inline bool ParagraphStylePropertiesArchive::has_rule_width() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_rule_width() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_rule_width() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ParagraphStylePropertiesArchive::clear_rule_width() {
  rule_width_ = 0;
  clear_has_rule_width();
}
inline float ParagraphStylePropertiesArchive::rule_width() const {
  return rule_width_;
}
inline void ParagraphStylePropertiesArchive::set_rule_width(float value) {
  set_has_rule_width();
  rule_width_ = value;
}

// optional float right_indent = 19;
inline bool ParagraphStylePropertiesArchive::has_right_indent() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_right_indent() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_right_indent() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ParagraphStylePropertiesArchive::clear_right_indent() {
  right_indent_ = 0;
  clear_has_right_indent();
}
inline float ParagraphStylePropertiesArchive::right_indent() const {
  return right_indent_;
}
inline void ParagraphStylePropertiesArchive::set_right_indent(float value) {
  set_has_right_indent();
  right_indent_ = value;
}

// optional float space_after = 20;
inline bool ParagraphStylePropertiesArchive::has_space_after() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_space_after() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_space_after() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ParagraphStylePropertiesArchive::clear_space_after() {
  space_after_ = 0;
  clear_has_space_after();
}
inline float ParagraphStylePropertiesArchive::space_after() const {
  return space_after_;
}
inline void ParagraphStylePropertiesArchive::set_space_after(float value) {
  set_has_space_after();
  space_after_ = value;
}

// optional float space_before = 21;
inline bool ParagraphStylePropertiesArchive::has_space_before() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_space_before() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_space_before() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ParagraphStylePropertiesArchive::clear_space_before() {
  space_before_ = 0;
  clear_has_space_before();
}
inline float ParagraphStylePropertiesArchive::space_before() const {
  return space_before_;
}
inline void ParagraphStylePropertiesArchive::set_space_before(float value) {
  set_has_space_before();
  space_before_ = value;
}

// optional bool tabs_null = 24;
inline bool ParagraphStylePropertiesArchive::has_tabs_null() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_tabs_null() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_tabs_null() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ParagraphStylePropertiesArchive::clear_tabs_null() {
  tabs_null_ = false;
  clear_has_tabs_null();
}
inline bool ParagraphStylePropertiesArchive::tabs_null() const {
  return tabs_null_;
}
inline void ParagraphStylePropertiesArchive::set_tabs_null(bool value) {
  set_has_tabs_null();
  tabs_null_ = value;
}

// optional .TSWP.TabsArchive tabs = 25;
inline bool ParagraphStylePropertiesArchive::has_tabs() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_tabs() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_tabs() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ParagraphStylePropertiesArchive::clear_tabs() {
  if (tabs_ != NULL) tabs_->::TSWP::TabsArchive::Clear();
  clear_has_tabs();
}
inline const ::TSWP::TabsArchive& ParagraphStylePropertiesArchive::tabs() const {
  return tabs_ != NULL ? *tabs_ : *default_instance_->tabs_;
}
inline ::TSWP::TabsArchive* ParagraphStylePropertiesArchive::mutable_tabs() {
  set_has_tabs();
  if (tabs_ == NULL) tabs_ = new ::TSWP::TabsArchive;
  return tabs_;
}
inline ::TSWP::TabsArchive* ParagraphStylePropertiesArchive::release_tabs() {
  clear_has_tabs();
  ::TSWP::TabsArchive* temp = tabs_;
  tabs_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_tabs(::TSWP::TabsArchive* tabs) {
  delete tabs_;
  tabs_ = tabs;
  if (tabs) {
    set_has_tabs();
  } else {
    clear_has_tabs();
  }
}

// optional bool widow_control = 26;
inline bool ParagraphStylePropertiesArchive::has_widow_control() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_widow_control() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_widow_control() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ParagraphStylePropertiesArchive::clear_widow_control() {
  widow_control_ = false;
  clear_has_widow_control();
}
inline bool ParagraphStylePropertiesArchive::widow_control() const {
  return widow_control_;
}
inline void ParagraphStylePropertiesArchive::set_widow_control(bool value) {
  set_has_widow_control();
  widow_control_ = value;
}

// optional uint32 outline_level = 27;
inline bool ParagraphStylePropertiesArchive::has_outline_level() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_outline_level() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_outline_level() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ParagraphStylePropertiesArchive::clear_outline_level() {
  outline_level_ = 0u;
  clear_has_outline_level();
}
inline ::google::protobuf::uint32 ParagraphStylePropertiesArchive::outline_level() const {
  return outline_level_;
}
inline void ParagraphStylePropertiesArchive::set_outline_level(::google::protobuf::uint32 value) {
  set_has_outline_level();
  outline_level_ = value;
}

// optional .TSWP.ParagraphStylePropertiesArchive.OutlineStyleType outline_style = 28;
inline bool ParagraphStylePropertiesArchive::has_outline_style() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_outline_style() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_outline_style() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ParagraphStylePropertiesArchive::clear_outline_style() {
  outline_style_ = 0;
  clear_has_outline_style();
}
inline ::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType ParagraphStylePropertiesArchive::outline_style() const {
  return static_cast< ::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType >(outline_style_);
}
inline void ParagraphStylePropertiesArchive::set_outline_style(::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType value) {
  assert(::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType_IsValid(value));
  set_has_outline_style();
  outline_style_ = value;
}

// optional bool following_style_id_null = 29;
inline bool ParagraphStylePropertiesArchive::has_following_style_id_null() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_following_style_id_null() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_following_style_id_null() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ParagraphStylePropertiesArchive::clear_following_style_id_null() {
  following_style_id_null_ = false;
  clear_has_following_style_id_null();
}
inline bool ParagraphStylePropertiesArchive::following_style_id_null() const {
  return following_style_id_null_;
}
inline void ParagraphStylePropertiesArchive::set_following_style_id_null(bool value) {
  set_has_following_style_id_null();
  following_style_id_null_ = value;
}

// optional string following_style_id = 30;
inline bool ParagraphStylePropertiesArchive::has_following_style_id() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_following_style_id() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_following_style_id() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ParagraphStylePropertiesArchive::clear_following_style_id() {
  if (following_style_id_ != &::google::protobuf::internal::kEmptyString) {
    following_style_id_->clear();
  }
  clear_has_following_style_id();
}
inline const ::std::string& ParagraphStylePropertiesArchive::following_style_id() const {
  return *following_style_id_;
}
inline void ParagraphStylePropertiesArchive::set_following_style_id(const ::std::string& value) {
  set_has_following_style_id();
  if (following_style_id_ == &::google::protobuf::internal::kEmptyString) {
    following_style_id_ = new ::std::string;
  }
  following_style_id_->assign(value);
}
inline void ParagraphStylePropertiesArchive::set_following_style_id(const char* value) {
  set_has_following_style_id();
  if (following_style_id_ == &::google::protobuf::internal::kEmptyString) {
    following_style_id_ = new ::std::string;
  }
  following_style_id_->assign(value);
}
inline void ParagraphStylePropertiesArchive::set_following_style_id(const char* value, size_t size) {
  set_has_following_style_id();
  if (following_style_id_ == &::google::protobuf::internal::kEmptyString) {
    following_style_id_ = new ::std::string;
  }
  following_style_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParagraphStylePropertiesArchive::mutable_following_style_id() {
  set_has_following_style_id();
  if (following_style_id_ == &::google::protobuf::internal::kEmptyString) {
    following_style_id_ = new ::std::string;
  }
  return following_style_id_;
}
inline ::std::string* ParagraphStylePropertiesArchive::release_following_style_id() {
  clear_has_following_style_id();
  if (following_style_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = following_style_id_;
    following_style_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParagraphStylePropertiesArchive::set_allocated_following_style_id(::std::string* following_style_id) {
  if (following_style_id_ != &::google::protobuf::internal::kEmptyString) {
    delete following_style_id_;
  }
  if (following_style_id) {
    set_has_following_style_id();
    following_style_id_ = following_style_id;
  } else {
    clear_has_following_style_id();
    following_style_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool stroke_null = 31;
inline bool ParagraphStylePropertiesArchive::has_stroke_null() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_stroke_null() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_stroke_null() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ParagraphStylePropertiesArchive::clear_stroke_null() {
  stroke_null_ = false;
  clear_has_stroke_null();
}
inline bool ParagraphStylePropertiesArchive::stroke_null() const {
  return stroke_null_;
}
inline void ParagraphStylePropertiesArchive::set_stroke_null(bool value) {
  set_has_stroke_null();
  stroke_null_ = value;
}

// optional .TSD.StrokeArchive stroke = 32;
inline bool ParagraphStylePropertiesArchive::has_stroke() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_stroke() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_stroke() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ParagraphStylePropertiesArchive::clear_stroke() {
  if (stroke_ != NULL) stroke_->::TSD::StrokeArchive::Clear();
  clear_has_stroke();
}
inline const ::TSD::StrokeArchive& ParagraphStylePropertiesArchive::stroke() const {
  return stroke_ != NULL ? *stroke_ : *default_instance_->stroke_;
}
inline ::TSD::StrokeArchive* ParagraphStylePropertiesArchive::mutable_stroke() {
  set_has_stroke();
  if (stroke_ == NULL) stroke_ = new ::TSD::StrokeArchive;
  return stroke_;
}
inline ::TSD::StrokeArchive* ParagraphStylePropertiesArchive::release_stroke() {
  clear_has_stroke();
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  delete stroke_;
  stroke_ = stroke;
  if (stroke) {
    set_has_stroke();
  } else {
    clear_has_stroke();
  }
}

// optional bool show_in_toc = 33;
inline bool ParagraphStylePropertiesArchive::has_show_in_toc() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_show_in_toc() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_show_in_toc() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ParagraphStylePropertiesArchive::clear_show_in_toc() {
  show_in_toc_ = false;
  clear_has_show_in_toc();
}
inline bool ParagraphStylePropertiesArchive::show_in_toc() const {
  return show_in_toc_;
}
inline void ParagraphStylePropertiesArchive::set_show_in_toc(bool value) {
  set_has_show_in_toc();
  show_in_toc_ = value;
}

// optional bool toc_style_id_null = 34;
inline bool ParagraphStylePropertiesArchive::has_toc_style_id_null() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_toc_style_id_null() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ParagraphStylePropertiesArchive::clear_has_toc_style_id_null() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ParagraphStylePropertiesArchive::clear_toc_style_id_null() {
  toc_style_id_null_ = false;
  clear_has_toc_style_id_null();
}
inline bool ParagraphStylePropertiesArchive::toc_style_id_null() const {
  return toc_style_id_null_;
}
inline void ParagraphStylePropertiesArchive::set_toc_style_id_null(bool value) {
  set_has_toc_style_id_null();
  toc_style_id_null_ = value;
}

// optional string toc_style_id = 35;
inline bool ParagraphStylePropertiesArchive::has_toc_style_id() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_toc_style_id() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ParagraphStylePropertiesArchive::clear_has_toc_style_id() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ParagraphStylePropertiesArchive::clear_toc_style_id() {
  if (toc_style_id_ != &::google::protobuf::internal::kEmptyString) {
    toc_style_id_->clear();
  }
  clear_has_toc_style_id();
}
inline const ::std::string& ParagraphStylePropertiesArchive::toc_style_id() const {
  return *toc_style_id_;
}
inline void ParagraphStylePropertiesArchive::set_toc_style_id(const ::std::string& value) {
  set_has_toc_style_id();
  if (toc_style_id_ == &::google::protobuf::internal::kEmptyString) {
    toc_style_id_ = new ::std::string;
  }
  toc_style_id_->assign(value);
}
inline void ParagraphStylePropertiesArchive::set_toc_style_id(const char* value) {
  set_has_toc_style_id();
  if (toc_style_id_ == &::google::protobuf::internal::kEmptyString) {
    toc_style_id_ = new ::std::string;
  }
  toc_style_id_->assign(value);
}
inline void ParagraphStylePropertiesArchive::set_toc_style_id(const char* value, size_t size) {
  set_has_toc_style_id();
  if (toc_style_id_ == &::google::protobuf::internal::kEmptyString) {
    toc_style_id_ = new ::std::string;
  }
  toc_style_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParagraphStylePropertiesArchive::mutable_toc_style_id() {
  set_has_toc_style_id();
  if (toc_style_id_ == &::google::protobuf::internal::kEmptyString) {
    toc_style_id_ = new ::std::string;
  }
  return toc_style_id_;
}
inline ::std::string* ParagraphStylePropertiesArchive::release_toc_style_id() {
  clear_has_toc_style_id();
  if (toc_style_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toc_style_id_;
    toc_style_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParagraphStylePropertiesArchive::set_allocated_toc_style_id(::std::string* toc_style_id) {
  if (toc_style_id_ != &::google::protobuf::internal::kEmptyString) {
    delete toc_style_id_;
  }
  if (toc_style_id) {
    set_has_toc_style_id();
    toc_style_id_ = toc_style_id;
  } else {
    clear_has_toc_style_id();
    toc_style_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.WritingDirectionType writing_direction = 38 [default = kWritingDirectionNatural];
inline bool ParagraphStylePropertiesArchive::has_writing_direction() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_writing_direction() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ParagraphStylePropertiesArchive::clear_has_writing_direction() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ParagraphStylePropertiesArchive::clear_writing_direction() {
  writing_direction_ = -1;
  clear_has_writing_direction();
}
inline ::TSWP::WritingDirectionType ParagraphStylePropertiesArchive::writing_direction() const {
  return static_cast< ::TSWP::WritingDirectionType >(writing_direction_);
}
inline void ParagraphStylePropertiesArchive::set_writing_direction(::TSWP::WritingDirectionType value) {
  assert(::TSWP::WritingDirectionType_IsValid(value));
  set_has_writing_direction();
  writing_direction_ = value;
}

// optional bool list_style_null = 39;
inline bool ParagraphStylePropertiesArchive::has_list_style_null() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_list_style_null() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ParagraphStylePropertiesArchive::clear_has_list_style_null() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ParagraphStylePropertiesArchive::clear_list_style_null() {
  list_style_null_ = false;
  clear_has_list_style_null();
}
inline bool ParagraphStylePropertiesArchive::list_style_null() const {
  return list_style_null_;
}
inline void ParagraphStylePropertiesArchive::set_list_style_null(bool value) {
  set_has_list_style_null();
  list_style_null_ = value;
}

// optional .TSP.Reference list_style = 40;
inline bool ParagraphStylePropertiesArchive::has_list_style() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_list_style() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ParagraphStylePropertiesArchive::clear_has_list_style() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ParagraphStylePropertiesArchive::clear_list_style() {
  if (list_style_ != NULL) list_style_->::TSP::Reference::Clear();
  clear_has_list_style();
}
inline const ::TSP::Reference& ParagraphStylePropertiesArchive::list_style() const {
  return list_style_ != NULL ? *list_style_ : *default_instance_->list_style_;
}
inline ::TSP::Reference* ParagraphStylePropertiesArchive::mutable_list_style() {
  set_has_list_style();
  if (list_style_ == NULL) list_style_ = new ::TSP::Reference;
  return list_style_;
}
inline ::TSP::Reference* ParagraphStylePropertiesArchive::release_list_style() {
  clear_has_list_style();
  ::TSP::Reference* temp = list_style_;
  list_style_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_list_style(::TSP::Reference* list_style) {
  delete list_style_;
  list_style_ = list_style;
  if (list_style) {
    set_has_list_style();
  } else {
    clear_has_list_style();
  }
}

// optional bool following_style_null = 41;
inline bool ParagraphStylePropertiesArchive::has_following_style_null() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_following_style_null() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ParagraphStylePropertiesArchive::clear_has_following_style_null() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ParagraphStylePropertiesArchive::clear_following_style_null() {
  following_style_null_ = false;
  clear_has_following_style_null();
}
inline bool ParagraphStylePropertiesArchive::following_style_null() const {
  return following_style_null_;
}
inline void ParagraphStylePropertiesArchive::set_following_style_null(bool value) {
  set_has_following_style_null();
  following_style_null_ = value;
}

// optional .TSP.Reference following_style = 42;
inline bool ParagraphStylePropertiesArchive::has_following_style() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ParagraphStylePropertiesArchive::set_has_following_style() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ParagraphStylePropertiesArchive::clear_has_following_style() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ParagraphStylePropertiesArchive::clear_following_style() {
  if (following_style_ != NULL) following_style_->::TSP::Reference::Clear();
  clear_has_following_style();
}
inline const ::TSP::Reference& ParagraphStylePropertiesArchive::following_style() const {
  return following_style_ != NULL ? *following_style_ : *default_instance_->following_style_;
}
inline ::TSP::Reference* ParagraphStylePropertiesArchive::mutable_following_style() {
  set_has_following_style();
  if (following_style_ == NULL) following_style_ = new ::TSP::Reference;
  return following_style_;
}
inline ::TSP::Reference* ParagraphStylePropertiesArchive::release_following_style() {
  clear_has_following_style();
  ::TSP::Reference* temp = following_style_;
  following_style_ = NULL;
  return temp;
}
inline void ParagraphStylePropertiesArchive::set_allocated_following_style(::TSP::Reference* following_style) {
  delete following_style_;
  following_style_ = following_style;
  if (following_style) {
    set_has_following_style();
  } else {
    clear_has_following_style();
  }
}

// -------------------------------------------------------------------

// ParagraphStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool ParagraphStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParagraphStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParagraphStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParagraphStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ParagraphStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ParagraphStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ParagraphStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ParagraphStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool ParagraphStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParagraphStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParagraphStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParagraphStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 ParagraphStyleArchive::override_count() const {
  return override_count_;
}
inline void ParagraphStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TSWP.CharacterStylePropertiesArchive char_properties = 11;
inline bool ParagraphStyleArchive::has_char_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParagraphStyleArchive::set_has_char_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParagraphStyleArchive::clear_has_char_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParagraphStyleArchive::clear_char_properties() {
  if (char_properties_ != NULL) char_properties_->::TSWP::CharacterStylePropertiesArchive::Clear();
  clear_has_char_properties();
}
inline const ::TSWP::CharacterStylePropertiesArchive& ParagraphStyleArchive::char_properties() const {
  return char_properties_ != NULL ? *char_properties_ : *default_instance_->char_properties_;
}
inline ::TSWP::CharacterStylePropertiesArchive* ParagraphStyleArchive::mutable_char_properties() {
  set_has_char_properties();
  if (char_properties_ == NULL) char_properties_ = new ::TSWP::CharacterStylePropertiesArchive;
  return char_properties_;
}
inline ::TSWP::CharacterStylePropertiesArchive* ParagraphStyleArchive::release_char_properties() {
  clear_has_char_properties();
  ::TSWP::CharacterStylePropertiesArchive* temp = char_properties_;
  char_properties_ = NULL;
  return temp;
}
inline void ParagraphStyleArchive::set_allocated_char_properties(::TSWP::CharacterStylePropertiesArchive* char_properties) {
  delete char_properties_;
  char_properties_ = char_properties;
  if (char_properties) {
    set_has_char_properties();
  } else {
    clear_has_char_properties();
  }
}

// optional .TSWP.ParagraphStylePropertiesArchive para_properties = 12;
inline bool ParagraphStyleArchive::has_para_properties() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParagraphStyleArchive::set_has_para_properties() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParagraphStyleArchive::clear_has_para_properties() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParagraphStyleArchive::clear_para_properties() {
  if (para_properties_ != NULL) para_properties_->::TSWP::ParagraphStylePropertiesArchive::Clear();
  clear_has_para_properties();
}
inline const ::TSWP::ParagraphStylePropertiesArchive& ParagraphStyleArchive::para_properties() const {
  return para_properties_ != NULL ? *para_properties_ : *default_instance_->para_properties_;
}
inline ::TSWP::ParagraphStylePropertiesArchive* ParagraphStyleArchive::mutable_para_properties() {
  set_has_para_properties();
  if (para_properties_ == NULL) para_properties_ = new ::TSWP::ParagraphStylePropertiesArchive;
  return para_properties_;
}
inline ::TSWP::ParagraphStylePropertiesArchive* ParagraphStyleArchive::release_para_properties() {
  clear_has_para_properties();
  ::TSWP::ParagraphStylePropertiesArchive* temp = para_properties_;
  para_properties_ = NULL;
  return temp;
}
inline void ParagraphStyleArchive::set_allocated_para_properties(::TSWP::ParagraphStylePropertiesArchive* para_properties) {
  delete para_properties_;
  para_properties_ = para_properties;
  if (para_properties) {
    set_has_para_properties();
  } else {
    clear_has_para_properties();
  }
}

// -------------------------------------------------------------------

// ListStyleArchive_LabelGeometry

// optional float scale = 1 [default = 1];
inline bool ListStyleArchive_LabelGeometry::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListStyleArchive_LabelGeometry::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListStyleArchive_LabelGeometry::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListStyleArchive_LabelGeometry::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float ListStyleArchive_LabelGeometry::scale() const {
  return scale_;
}
inline void ListStyleArchive_LabelGeometry::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float baseline_offset = 2 [default = 0];
inline bool ListStyleArchive_LabelGeometry::has_baseline_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListStyleArchive_LabelGeometry::set_has_baseline_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListStyleArchive_LabelGeometry::clear_has_baseline_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListStyleArchive_LabelGeometry::clear_baseline_offset() {
  baseline_offset_ = 0;
  clear_has_baseline_offset();
}
inline float ListStyleArchive_LabelGeometry::baseline_offset() const {
  return baseline_offset_;
}
inline void ListStyleArchive_LabelGeometry::set_baseline_offset(float value) {
  set_has_baseline_offset();
  baseline_offset_ = value;
}

// optional bool scale_with_text = 3 [default = true];
inline bool ListStyleArchive_LabelGeometry::has_scale_with_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListStyleArchive_LabelGeometry::set_has_scale_with_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListStyleArchive_LabelGeometry::clear_has_scale_with_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListStyleArchive_LabelGeometry::clear_scale_with_text() {
  scale_with_text_ = true;
  clear_has_scale_with_text();
}
inline bool ListStyleArchive_LabelGeometry::scale_with_text() const {
  return scale_with_text_;
}
inline void ListStyleArchive_LabelGeometry::set_scale_with_text(bool value) {
  set_has_scale_with_text();
  scale_with_text_ = value;
}

// -------------------------------------------------------------------

// ListStyleArchive_LabelImage

// optional .TSP.DataReference image = 3;
inline bool ListStyleArchive_LabelImage::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListStyleArchive_LabelImage::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListStyleArchive_LabelImage::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListStyleArchive_LabelImage::clear_image() {
  if (image_ != NULL) image_->::TSP::DataReference::Clear();
  clear_has_image();
}
inline const ::TSP::DataReference& ListStyleArchive_LabelImage::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::TSP::DataReference* ListStyleArchive_LabelImage::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::TSP::DataReference;
  return image_;
}
inline ::TSP::DataReference* ListStyleArchive_LabelImage::release_image() {
  clear_has_image();
  ::TSP::DataReference* temp = image_;
  image_ = NULL;
  return temp;
}
inline void ListStyleArchive_LabelImage::set_allocated_image(::TSP::DataReference* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// optional bool image_null = 2;
inline bool ListStyleArchive_LabelImage::has_image_null() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListStyleArchive_LabelImage::set_has_image_null() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListStyleArchive_LabelImage::clear_has_image_null() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListStyleArchive_LabelImage::clear_image_null() {
  image_null_ = false;
  clear_has_image_null();
}
inline bool ListStyleArchive_LabelImage::image_null() const {
  return image_null_;
}
inline void ListStyleArchive_LabelImage::set_image_null(bool value) {
  set_has_image_null();
  image_null_ = value;
}

// optional .TSP.Reference database_image = 1;
inline bool ListStyleArchive_LabelImage::has_database_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListStyleArchive_LabelImage::set_has_database_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListStyleArchive_LabelImage::clear_has_database_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListStyleArchive_LabelImage::clear_database_image() {
  if (database_image_ != NULL) database_image_->::TSP::Reference::Clear();
  clear_has_database_image();
}
inline const ::TSP::Reference& ListStyleArchive_LabelImage::database_image() const {
  return database_image_ != NULL ? *database_image_ : *default_instance_->database_image_;
}
inline ::TSP::Reference* ListStyleArchive_LabelImage::mutable_database_image() {
  set_has_database_image();
  if (database_image_ == NULL) database_image_ = new ::TSP::Reference;
  return database_image_;
}
inline ::TSP::Reference* ListStyleArchive_LabelImage::release_database_image() {
  clear_has_database_image();
  ::TSP::Reference* temp = database_image_;
  database_image_ = NULL;
  return temp;
}
inline void ListStyleArchive_LabelImage::set_allocated_database_image(::TSP::Reference* database_image) {
  delete database_image_;
  database_image_ = database_image;
  if (database_image) {
    set_has_database_image();
  } else {
    clear_has_database_image();
  }
}

// -------------------------------------------------------------------

// ListStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool ListStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ListStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ListStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ListStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ListStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool ListStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 ListStyleArchive::override_count() const {
  return override_count_;
}
inline void ListStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// repeated .TSWP.ListStyleArchive.LabelType label_types = 11;
inline int ListStyleArchive::label_types_size() const {
  return label_types_.size();
}
inline void ListStyleArchive::clear_label_types() {
  label_types_.Clear();
}
inline ::TSWP::ListStyleArchive_LabelType ListStyleArchive::label_types(int index) const {
  return static_cast< ::TSWP::ListStyleArchive_LabelType >(label_types_.Get(index));
}
inline void ListStyleArchive::set_label_types(int index, ::TSWP::ListStyleArchive_LabelType value) {
  assert(::TSWP::ListStyleArchive_LabelType_IsValid(value));
  label_types_.Set(index, value);
}
inline void ListStyleArchive::add_label_types(::TSWP::ListStyleArchive_LabelType value) {
  assert(::TSWP::ListStyleArchive_LabelType_IsValid(value));
  label_types_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ListStyleArchive::label_types() const {
  return label_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ListStyleArchive::mutable_label_types() {
  return &label_types_;
}

// repeated float text_indents = 12;
inline int ListStyleArchive::text_indents_size() const {
  return text_indents_.size();
}
inline void ListStyleArchive::clear_text_indents() {
  text_indents_.Clear();
}
inline float ListStyleArchive::text_indents(int index) const {
  return text_indents_.Get(index);
}
inline void ListStyleArchive::set_text_indents(int index, float value) {
  text_indents_.Set(index, value);
}
inline void ListStyleArchive::add_text_indents(float value) {
  text_indents_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ListStyleArchive::text_indents() const {
  return text_indents_;
}
inline ::google::protobuf::RepeatedField< float >*
ListStyleArchive::mutable_text_indents() {
  return &text_indents_;
}

// repeated float indents = 13;
inline int ListStyleArchive::indents_size() const {
  return indents_.size();
}
inline void ListStyleArchive::clear_indents() {
  indents_.Clear();
}
inline float ListStyleArchive::indents(int index) const {
  return indents_.Get(index);
}
inline void ListStyleArchive::set_indents(int index, float value) {
  indents_.Set(index, value);
}
inline void ListStyleArchive::add_indents(float value) {
  indents_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ListStyleArchive::indents() const {
  return indents_;
}
inline ::google::protobuf::RepeatedField< float >*
ListStyleArchive::mutable_indents() {
  return &indents_;
}

// repeated .TSWP.ListStyleArchive.LabelGeometry geometries = 14;
inline int ListStyleArchive::geometries_size() const {
  return geometries_.size();
}
inline void ListStyleArchive::clear_geometries() {
  geometries_.Clear();
}
inline const ::TSWP::ListStyleArchive_LabelGeometry& ListStyleArchive::geometries(int index) const {
  return geometries_.Get(index);
}
inline ::TSWP::ListStyleArchive_LabelGeometry* ListStyleArchive::mutable_geometries(int index) {
  return geometries_.Mutable(index);
}
inline ::TSWP::ListStyleArchive_LabelGeometry* ListStyleArchive::add_geometries() {
  return geometries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelGeometry >&
ListStyleArchive::geometries() const {
  return geometries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelGeometry >*
ListStyleArchive::mutable_geometries() {
  return &geometries_;
}

// repeated .TSWP.ListStyleArchive.NumberType number_types = 15;
inline int ListStyleArchive::number_types_size() const {
  return number_types_.size();
}
inline void ListStyleArchive::clear_number_types() {
  number_types_.Clear();
}
inline ::TSWP::ListStyleArchive_NumberType ListStyleArchive::number_types(int index) const {
  return static_cast< ::TSWP::ListStyleArchive_NumberType >(number_types_.Get(index));
}
inline void ListStyleArchive::set_number_types(int index, ::TSWP::ListStyleArchive_NumberType value) {
  assert(::TSWP::ListStyleArchive_NumberType_IsValid(value));
  number_types_.Set(index, value);
}
inline void ListStyleArchive::add_number_types(::TSWP::ListStyleArchive_NumberType value) {
  assert(::TSWP::ListStyleArchive_NumberType_IsValid(value));
  number_types_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ListStyleArchive::number_types() const {
  return number_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ListStyleArchive::mutable_number_types() {
  return &number_types_;
}

// repeated string strings = 16;
inline int ListStyleArchive::strings_size() const {
  return strings_.size();
}
inline void ListStyleArchive::clear_strings() {
  strings_.Clear();
}
inline const ::std::string& ListStyleArchive::strings(int index) const {
  return strings_.Get(index);
}
inline ::std::string* ListStyleArchive::mutable_strings(int index) {
  return strings_.Mutable(index);
}
inline void ListStyleArchive::set_strings(int index, const ::std::string& value) {
  strings_.Mutable(index)->assign(value);
}
inline void ListStyleArchive::set_strings(int index, const char* value) {
  strings_.Mutable(index)->assign(value);
}
inline void ListStyleArchive::set_strings(int index, const char* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListStyleArchive::add_strings() {
  return strings_.Add();
}
inline void ListStyleArchive::add_strings(const ::std::string& value) {
  strings_.Add()->assign(value);
}
inline void ListStyleArchive::add_strings(const char* value) {
  strings_.Add()->assign(value);
}
inline void ListStyleArchive::add_strings(const char* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListStyleArchive::strings() const {
  return strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListStyleArchive::mutable_strings() {
  return &strings_;
}

// repeated .TSWP.ListStyleArchive.LabelImage images = 17;
inline int ListStyleArchive::images_size() const {
  return images_.size();
}
inline void ListStyleArchive::clear_images() {
  images_.Clear();
}
inline const ::TSWP::ListStyleArchive_LabelImage& ListStyleArchive::images(int index) const {
  return images_.Get(index);
}
inline ::TSWP::ListStyleArchive_LabelImage* ListStyleArchive::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::TSWP::ListStyleArchive_LabelImage* ListStyleArchive::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelImage >&
ListStyleArchive::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::ListStyleArchive_LabelImage >*
ListStyleArchive::mutable_images() {
  return &images_;
}

// optional bool shadow_null = 18;
inline bool ListStyleArchive::has_shadow_null() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ListStyleArchive::set_has_shadow_null() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ListStyleArchive::clear_has_shadow_null() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ListStyleArchive::clear_shadow_null() {
  shadow_null_ = false;
  clear_has_shadow_null();
}
inline bool ListStyleArchive::shadow_null() const {
  return shadow_null_;
}
inline void ListStyleArchive::set_shadow_null(bool value) {
  set_has_shadow_null();
  shadow_null_ = value;
}

// optional .TSD.ShadowArchive shadow = 19;
inline bool ListStyleArchive::has_shadow() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ListStyleArchive::set_has_shadow() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ListStyleArchive::clear_has_shadow() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ListStyleArchive::clear_shadow() {
  if (shadow_ != NULL) shadow_->::TSD::ShadowArchive::Clear();
  clear_has_shadow();
}
inline const ::TSD::ShadowArchive& ListStyleArchive::shadow() const {
  return shadow_ != NULL ? *shadow_ : *default_instance_->shadow_;
}
inline ::TSD::ShadowArchive* ListStyleArchive::mutable_shadow() {
  set_has_shadow();
  if (shadow_ == NULL) shadow_ = new ::TSD::ShadowArchive;
  return shadow_;
}
inline ::TSD::ShadowArchive* ListStyleArchive::release_shadow() {
  clear_has_shadow();
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = NULL;
  return temp;
}
inline void ListStyleArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  delete shadow_;
  shadow_ = shadow;
  if (shadow) {
    set_has_shadow();
  } else {
    clear_has_shadow();
  }
}

// optional bool font_color_null = 20;
inline bool ListStyleArchive::has_font_color_null() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ListStyleArchive::set_has_font_color_null() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ListStyleArchive::clear_has_font_color_null() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ListStyleArchive::clear_font_color_null() {
  font_color_null_ = false;
  clear_has_font_color_null();
}
inline bool ListStyleArchive::font_color_null() const {
  return font_color_null_;
}
inline void ListStyleArchive::set_font_color_null(bool value) {
  set_has_font_color_null();
  font_color_null_ = value;
}

// optional .TSP.Color font_color = 21;
inline bool ListStyleArchive::has_font_color() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ListStyleArchive::set_has_font_color() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ListStyleArchive::clear_has_font_color() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ListStyleArchive::clear_font_color() {
  if (font_color_ != NULL) font_color_->::TSP::Color::Clear();
  clear_has_font_color();
}
inline const ::TSP::Color& ListStyleArchive::font_color() const {
  return font_color_ != NULL ? *font_color_ : *default_instance_->font_color_;
}
inline ::TSP::Color* ListStyleArchive::mutable_font_color() {
  set_has_font_color();
  if (font_color_ == NULL) font_color_ = new ::TSP::Color;
  return font_color_;
}
inline ::TSP::Color* ListStyleArchive::release_font_color() {
  clear_has_font_color();
  ::TSP::Color* temp = font_color_;
  font_color_ = NULL;
  return temp;
}
inline void ListStyleArchive::set_allocated_font_color(::TSP::Color* font_color) {
  delete font_color_;
  font_color_ = font_color;
  if (font_color) {
    set_has_font_color();
  } else {
    clear_has_font_color();
  }
}

// optional bool font_name_null = 22;
inline bool ListStyleArchive::has_font_name_null() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ListStyleArchive::set_has_font_name_null() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ListStyleArchive::clear_has_font_name_null() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ListStyleArchive::clear_font_name_null() {
  font_name_null_ = false;
  clear_has_font_name_null();
}
inline bool ListStyleArchive::font_name_null() const {
  return font_name_null_;
}
inline void ListStyleArchive::set_font_name_null(bool value) {
  set_has_font_name_null();
  font_name_null_ = value;
}

// optional string font_name = 23;
inline bool ListStyleArchive::has_font_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ListStyleArchive::set_has_font_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ListStyleArchive::clear_has_font_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ListStyleArchive::clear_font_name() {
  if (font_name_ != &::google::protobuf::internal::kEmptyString) {
    font_name_->clear();
  }
  clear_has_font_name();
}
inline const ::std::string& ListStyleArchive::font_name() const {
  return *font_name_;
}
inline void ListStyleArchive::set_font_name(const ::std::string& value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void ListStyleArchive::set_font_name(const char* value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void ListStyleArchive::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListStyleArchive::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  return font_name_;
}
inline ::std::string* ListStyleArchive::release_font_name() {
  clear_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = font_name_;
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListStyleArchive::set_allocated_font_name(::std::string* font_name) {
  if (font_name_ != &::google::protobuf::internal::kEmptyString) {
    delete font_name_;
  }
  if (font_name) {
    set_has_font_name();
    font_name_ = font_name;
  } else {
    clear_has_font_name();
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.WritingDirectionType writing_direction = 24 [default = kWritingDirectionNatural];
inline bool ListStyleArchive::has_writing_direction() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ListStyleArchive::set_has_writing_direction() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ListStyleArchive::clear_has_writing_direction() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ListStyleArchive::clear_writing_direction() {
  writing_direction_ = -1;
  clear_has_writing_direction();
}
inline ::TSWP::WritingDirectionType ListStyleArchive::writing_direction() const {
  return static_cast< ::TSWP::WritingDirectionType >(writing_direction_);
}
inline void ListStyleArchive::set_writing_direction(::TSWP::WritingDirectionType value) {
  assert(::TSWP::WritingDirectionType_IsValid(value));
  set_has_writing_direction();
  writing_direction_ = value;
}

// repeated bool tiered_numbers = 25;
inline int ListStyleArchive::tiered_numbers_size() const {
  return tiered_numbers_.size();
}
inline void ListStyleArchive::clear_tiered_numbers() {
  tiered_numbers_.Clear();
}
inline bool ListStyleArchive::tiered_numbers(int index) const {
  return tiered_numbers_.Get(index);
}
inline void ListStyleArchive::set_tiered_numbers(int index, bool value) {
  tiered_numbers_.Set(index, value);
}
inline void ListStyleArchive::add_tiered_numbers(bool value) {
  tiered_numbers_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
ListStyleArchive::tiered_numbers() const {
  return tiered_numbers_;
}
inline ::google::protobuf::RepeatedField< bool >*
ListStyleArchive::mutable_tiered_numbers() {
  return &tiered_numbers_;
}

// -------------------------------------------------------------------

// TextStylePresetArchive

// optional string preset_identifier = 1;
inline bool TextStylePresetArchive::has_preset_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextStylePresetArchive::set_has_preset_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextStylePresetArchive::clear_has_preset_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextStylePresetArchive::clear_preset_identifier() {
  if (preset_identifier_ != &::google::protobuf::internal::kEmptyString) {
    preset_identifier_->clear();
  }
  clear_has_preset_identifier();
}
inline const ::std::string& TextStylePresetArchive::preset_identifier() const {
  return *preset_identifier_;
}
inline void TextStylePresetArchive::set_preset_identifier(const ::std::string& value) {
  set_has_preset_identifier();
  if (preset_identifier_ == &::google::protobuf::internal::kEmptyString) {
    preset_identifier_ = new ::std::string;
  }
  preset_identifier_->assign(value);
}
inline void TextStylePresetArchive::set_preset_identifier(const char* value) {
  set_has_preset_identifier();
  if (preset_identifier_ == &::google::protobuf::internal::kEmptyString) {
    preset_identifier_ = new ::std::string;
  }
  preset_identifier_->assign(value);
}
inline void TextStylePresetArchive::set_preset_identifier(const char* value, size_t size) {
  set_has_preset_identifier();
  if (preset_identifier_ == &::google::protobuf::internal::kEmptyString) {
    preset_identifier_ = new ::std::string;
  }
  preset_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextStylePresetArchive::mutable_preset_identifier() {
  set_has_preset_identifier();
  if (preset_identifier_ == &::google::protobuf::internal::kEmptyString) {
    preset_identifier_ = new ::std::string;
  }
  return preset_identifier_;
}
inline ::std::string* TextStylePresetArchive::release_preset_identifier() {
  clear_has_preset_identifier();
  if (preset_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preset_identifier_;
    preset_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextStylePresetArchive::set_allocated_preset_identifier(::std::string* preset_identifier) {
  if (preset_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete preset_identifier_;
  }
  if (preset_identifier) {
    set_has_preset_identifier();
    preset_identifier_ = preset_identifier;
  } else {
    clear_has_preset_identifier();
    preset_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference paragraph_style = 2;
inline bool TextStylePresetArchive::has_paragraph_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextStylePresetArchive::set_has_paragraph_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextStylePresetArchive::clear_has_paragraph_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextStylePresetArchive::clear_paragraph_style() {
  if (paragraph_style_ != NULL) paragraph_style_->::TSP::Reference::Clear();
  clear_has_paragraph_style();
}
inline const ::TSP::Reference& TextStylePresetArchive::paragraph_style() const {
  return paragraph_style_ != NULL ? *paragraph_style_ : *default_instance_->paragraph_style_;
}
inline ::TSP::Reference* TextStylePresetArchive::mutable_paragraph_style() {
  set_has_paragraph_style();
  if (paragraph_style_ == NULL) paragraph_style_ = new ::TSP::Reference;
  return paragraph_style_;
}
inline ::TSP::Reference* TextStylePresetArchive::release_paragraph_style() {
  clear_has_paragraph_style();
  ::TSP::Reference* temp = paragraph_style_;
  paragraph_style_ = NULL;
  return temp;
}
inline void TextStylePresetArchive::set_allocated_paragraph_style(::TSP::Reference* paragraph_style) {
  delete paragraph_style_;
  paragraph_style_ = paragraph_style;
  if (paragraph_style) {
    set_has_paragraph_style();
  } else {
    clear_has_paragraph_style();
  }
}

// optional .TSP.Reference list_style = 3;
inline bool TextStylePresetArchive::has_list_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextStylePresetArchive::set_has_list_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextStylePresetArchive::clear_has_list_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextStylePresetArchive::clear_list_style() {
  if (list_style_ != NULL) list_style_->::TSP::Reference::Clear();
  clear_has_list_style();
}
inline const ::TSP::Reference& TextStylePresetArchive::list_style() const {
  return list_style_ != NULL ? *list_style_ : *default_instance_->list_style_;
}
inline ::TSP::Reference* TextStylePresetArchive::mutable_list_style() {
  set_has_list_style();
  if (list_style_ == NULL) list_style_ = new ::TSP::Reference;
  return list_style_;
}
inline ::TSP::Reference* TextStylePresetArchive::release_list_style() {
  clear_has_list_style();
  ::TSP::Reference* temp = list_style_;
  list_style_ = NULL;
  return temp;
}
inline void TextStylePresetArchive::set_allocated_list_style(::TSP::Reference* list_style) {
  delete list_style_;
  list_style_ = list_style;
  if (list_style) {
    set_has_list_style();
  } else {
    clear_has_list_style();
  }
}

// -------------------------------------------------------------------

// ColumnsArchive_EqualColumnsArchive

// optional uint32 count = 1;
inline bool ColumnsArchive_EqualColumnsArchive::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnsArchive_EqualColumnsArchive::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnsArchive_EqualColumnsArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnsArchive_EqualColumnsArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ColumnsArchive_EqualColumnsArchive::count() const {
  return count_;
}
inline void ColumnsArchive_EqualColumnsArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional float gap = 2;
inline bool ColumnsArchive_EqualColumnsArchive::has_gap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnsArchive_EqualColumnsArchive::set_has_gap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnsArchive_EqualColumnsArchive::clear_has_gap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnsArchive_EqualColumnsArchive::clear_gap() {
  gap_ = 0;
  clear_has_gap();
}
inline float ColumnsArchive_EqualColumnsArchive::gap() const {
  return gap_;
}
inline void ColumnsArchive_EqualColumnsArchive::set_gap(float value) {
  set_has_gap();
  gap_ = value;
}

// -------------------------------------------------------------------

// ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive

// required float gap = 1;
inline bool ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::has_gap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::set_has_gap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::clear_has_gap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::clear_gap() {
  gap_ = 0;
  clear_has_gap();
}
inline float ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::gap() const {
  return gap_;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::set_gap(float value) {
  set_has_gap();
  gap_ = value;
}

// required float width = 2;
inline bool ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::width() const {
  return width_;
}
inline void ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive::set_width(float value) {
  set_has_width();
  width_ = value;
}

// -------------------------------------------------------------------

// ColumnsArchive_NonEqualColumnsArchive

// required float first = 1;
inline bool ColumnsArchive_NonEqualColumnsArchive::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnsArchive_NonEqualColumnsArchive::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnsArchive_NonEqualColumnsArchive::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnsArchive_NonEqualColumnsArchive::clear_first() {
  first_ = 0;
  clear_has_first();
}
inline float ColumnsArchive_NonEqualColumnsArchive::first() const {
  return first_;
}
inline void ColumnsArchive_NonEqualColumnsArchive::set_first(float value) {
  set_has_first();
  first_ = value;
}

// repeated .TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive following = 2;
inline int ColumnsArchive_NonEqualColumnsArchive::following_size() const {
  return following_.size();
}
inline void ColumnsArchive_NonEqualColumnsArchive::clear_following() {
  following_.Clear();
}
inline const ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive& ColumnsArchive_NonEqualColumnsArchive::following(int index) const {
  return following_.Get(index);
}
inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* ColumnsArchive_NonEqualColumnsArchive::mutable_following(int index) {
  return following_.Mutable(index);
}
inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive* ColumnsArchive_NonEqualColumnsArchive::add_following() {
  return following_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive >&
ColumnsArchive_NonEqualColumnsArchive::following() const {
  return following_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive >*
ColumnsArchive_NonEqualColumnsArchive::mutable_following() {
  return &following_;
}

// -------------------------------------------------------------------

// ColumnsArchive

// optional .TSWP.ColumnsArchive.EqualColumnsArchive equal_columns = 1;
inline bool ColumnsArchive::has_equal_columns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnsArchive::set_has_equal_columns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnsArchive::clear_has_equal_columns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnsArchive::clear_equal_columns() {
  if (equal_columns_ != NULL) equal_columns_->::TSWP::ColumnsArchive_EqualColumnsArchive::Clear();
  clear_has_equal_columns();
}
inline const ::TSWP::ColumnsArchive_EqualColumnsArchive& ColumnsArchive::equal_columns() const {
  return equal_columns_ != NULL ? *equal_columns_ : *default_instance_->equal_columns_;
}
inline ::TSWP::ColumnsArchive_EqualColumnsArchive* ColumnsArchive::mutable_equal_columns() {
  set_has_equal_columns();
  if (equal_columns_ == NULL) equal_columns_ = new ::TSWP::ColumnsArchive_EqualColumnsArchive;
  return equal_columns_;
}
inline ::TSWP::ColumnsArchive_EqualColumnsArchive* ColumnsArchive::release_equal_columns() {
  clear_has_equal_columns();
  ::TSWP::ColumnsArchive_EqualColumnsArchive* temp = equal_columns_;
  equal_columns_ = NULL;
  return temp;
}
inline void ColumnsArchive::set_allocated_equal_columns(::TSWP::ColumnsArchive_EqualColumnsArchive* equal_columns) {
  delete equal_columns_;
  equal_columns_ = equal_columns;
  if (equal_columns) {
    set_has_equal_columns();
  } else {
    clear_has_equal_columns();
  }
}

// optional .TSWP.ColumnsArchive.NonEqualColumnsArchive non_equal_columns = 2;
inline bool ColumnsArchive::has_non_equal_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnsArchive::set_has_non_equal_columns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnsArchive::clear_has_non_equal_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnsArchive::clear_non_equal_columns() {
  if (non_equal_columns_ != NULL) non_equal_columns_->::TSWP::ColumnsArchive_NonEqualColumnsArchive::Clear();
  clear_has_non_equal_columns();
}
inline const ::TSWP::ColumnsArchive_NonEqualColumnsArchive& ColumnsArchive::non_equal_columns() const {
  return non_equal_columns_ != NULL ? *non_equal_columns_ : *default_instance_->non_equal_columns_;
}
inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive* ColumnsArchive::mutable_non_equal_columns() {
  set_has_non_equal_columns();
  if (non_equal_columns_ == NULL) non_equal_columns_ = new ::TSWP::ColumnsArchive_NonEqualColumnsArchive;
  return non_equal_columns_;
}
inline ::TSWP::ColumnsArchive_NonEqualColumnsArchive* ColumnsArchive::release_non_equal_columns() {
  clear_has_non_equal_columns();
  ::TSWP::ColumnsArchive_NonEqualColumnsArchive* temp = non_equal_columns_;
  non_equal_columns_ = NULL;
  return temp;
}
inline void ColumnsArchive::set_allocated_non_equal_columns(::TSWP::ColumnsArchive_NonEqualColumnsArchive* non_equal_columns) {
  delete non_equal_columns_;
  non_equal_columns_ = non_equal_columns;
  if (non_equal_columns) {
    set_has_non_equal_columns();
  } else {
    clear_has_non_equal_columns();
  }
}

// -------------------------------------------------------------------

// PaddingArchive

// optional float left = 1;
inline bool PaddingArchive::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaddingArchive::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaddingArchive::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaddingArchive::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline float PaddingArchive::left() const {
  return left_;
}
inline void PaddingArchive::set_left(float value) {
  set_has_left();
  left_ = value;
}

// optional float top = 2;
inline bool PaddingArchive::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaddingArchive::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaddingArchive::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaddingArchive::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline float PaddingArchive::top() const {
  return top_;
}
inline void PaddingArchive::set_top(float value) {
  set_has_top();
  top_ = value;
}

// optional float right = 3;
inline bool PaddingArchive::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaddingArchive::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaddingArchive::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaddingArchive::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline float PaddingArchive::right() const {
  return right_;
}
inline void PaddingArchive::set_right(float value) {
  set_has_right();
  right_ = value;
}

// optional float bottom = 4;
inline bool PaddingArchive::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaddingArchive::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaddingArchive::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaddingArchive::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline float PaddingArchive::bottom() const {
  return bottom_;
}
inline void PaddingArchive::set_bottom(float value) {
  set_has_bottom();
  bottom_ = value;
}

// -------------------------------------------------------------------

// ColumnStylePropertiesArchive

// optional bool continuous = 1;
inline bool ColumnStylePropertiesArchive::has_continuous() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_continuous() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnStylePropertiesArchive::clear_has_continuous() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnStylePropertiesArchive::clear_continuous() {
  continuous_ = false;
  clear_has_continuous();
}
inline bool ColumnStylePropertiesArchive::continuous() const {
  return continuous_;
}
inline void ColumnStylePropertiesArchive::set_continuous(bool value) {
  set_has_continuous();
  continuous_ = value;
}

// optional bool shrink_to_fit = 2;
inline bool ColumnStylePropertiesArchive::has_shrink_to_fit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_shrink_to_fit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnStylePropertiesArchive::clear_has_shrink_to_fit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnStylePropertiesArchive::clear_shrink_to_fit() {
  shrink_to_fit_ = false;
  clear_has_shrink_to_fit();
}
inline bool ColumnStylePropertiesArchive::shrink_to_fit() const {
  return shrink_to_fit_;
}
inline void ColumnStylePropertiesArchive::set_shrink_to_fit(bool value) {
  set_has_shrink_to_fit();
  shrink_to_fit_ = value;
}

// optional bool vertical_text = 3;
inline bool ColumnStylePropertiesArchive::has_vertical_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_vertical_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnStylePropertiesArchive::clear_has_vertical_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnStylePropertiesArchive::clear_vertical_text() {
  vertical_text_ = false;
  clear_has_vertical_text();
}
inline bool ColumnStylePropertiesArchive::vertical_text() const {
  return vertical_text_;
}
inline void ColumnStylePropertiesArchive::set_vertical_text(bool value) {
  set_has_vertical_text();
  vertical_text_ = value;
}

// optional float min_horizontal_inset = 4;
inline bool ColumnStylePropertiesArchive::has_min_horizontal_inset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_min_horizontal_inset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnStylePropertiesArchive::clear_has_min_horizontal_inset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnStylePropertiesArchive::clear_min_horizontal_inset() {
  min_horizontal_inset_ = 0;
  clear_has_min_horizontal_inset();
}
inline float ColumnStylePropertiesArchive::min_horizontal_inset() const {
  return min_horizontal_inset_;
}
inline void ColumnStylePropertiesArchive::set_min_horizontal_inset(float value) {
  set_has_min_horizontal_inset();
  min_horizontal_inset_ = value;
}

// optional .TSWP.ColumnStylePropertiesArchive.VerticalAlignmentType vertical_alignment = 5;
inline bool ColumnStylePropertiesArchive::has_vertical_alignment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_vertical_alignment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ColumnStylePropertiesArchive::clear_has_vertical_alignment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ColumnStylePropertiesArchive::clear_vertical_alignment() {
  vertical_alignment_ = 0;
  clear_has_vertical_alignment();
}
inline ::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType ColumnStylePropertiesArchive::vertical_alignment() const {
  return static_cast< ::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType >(vertical_alignment_);
}
inline void ColumnStylePropertiesArchive::set_vertical_alignment(::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType value) {
  assert(::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType_IsValid(value));
  set_has_vertical_alignment();
  vertical_alignment_ = value;
}

// optional bool columns_null = 6;
inline bool ColumnStylePropertiesArchive::has_columns_null() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_columns_null() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ColumnStylePropertiesArchive::clear_has_columns_null() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ColumnStylePropertiesArchive::clear_columns_null() {
  columns_null_ = false;
  clear_has_columns_null();
}
inline bool ColumnStylePropertiesArchive::columns_null() const {
  return columns_null_;
}
inline void ColumnStylePropertiesArchive::set_columns_null(bool value) {
  set_has_columns_null();
  columns_null_ = value;
}

// optional .TSWP.ColumnsArchive columns = 7;
inline bool ColumnStylePropertiesArchive::has_columns() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_columns() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ColumnStylePropertiesArchive::clear_has_columns() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ColumnStylePropertiesArchive::clear_columns() {
  if (columns_ != NULL) columns_->::TSWP::ColumnsArchive::Clear();
  clear_has_columns();
}
inline const ::TSWP::ColumnsArchive& ColumnStylePropertiesArchive::columns() const {
  return columns_ != NULL ? *columns_ : *default_instance_->columns_;
}
inline ::TSWP::ColumnsArchive* ColumnStylePropertiesArchive::mutable_columns() {
  set_has_columns();
  if (columns_ == NULL) columns_ = new ::TSWP::ColumnsArchive;
  return columns_;
}
inline ::TSWP::ColumnsArchive* ColumnStylePropertiesArchive::release_columns() {
  clear_has_columns();
  ::TSWP::ColumnsArchive* temp = columns_;
  columns_ = NULL;
  return temp;
}
inline void ColumnStylePropertiesArchive::set_allocated_columns(::TSWP::ColumnsArchive* columns) {
  delete columns_;
  columns_ = columns;
  if (columns) {
    set_has_columns();
  } else {
    clear_has_columns();
  }
}

// optional bool margins_null = 8;
inline bool ColumnStylePropertiesArchive::has_margins_null() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_margins_null() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ColumnStylePropertiesArchive::clear_has_margins_null() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ColumnStylePropertiesArchive::clear_margins_null() {
  margins_null_ = false;
  clear_has_margins_null();
}
inline bool ColumnStylePropertiesArchive::margins_null() const {
  return margins_null_;
}
inline void ColumnStylePropertiesArchive::set_margins_null(bool value) {
  set_has_margins_null();
  margins_null_ = value;
}

// optional .TSWP.PaddingArchive margins = 9;
inline bool ColumnStylePropertiesArchive::has_margins() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_margins() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ColumnStylePropertiesArchive::clear_has_margins() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ColumnStylePropertiesArchive::clear_margins() {
  if (margins_ != NULL) margins_->::TSWP::PaddingArchive::Clear();
  clear_has_margins();
}
inline const ::TSWP::PaddingArchive& ColumnStylePropertiesArchive::margins() const {
  return margins_ != NULL ? *margins_ : *default_instance_->margins_;
}
inline ::TSWP::PaddingArchive* ColumnStylePropertiesArchive::mutable_margins() {
  set_has_margins();
  if (margins_ == NULL) margins_ = new ::TSWP::PaddingArchive;
  return margins_;
}
inline ::TSWP::PaddingArchive* ColumnStylePropertiesArchive::release_margins() {
  clear_has_margins();
  ::TSWP::PaddingArchive* temp = margins_;
  margins_ = NULL;
  return temp;
}
inline void ColumnStylePropertiesArchive::set_allocated_margins(::TSWP::PaddingArchive* margins) {
  delete margins_;
  margins_ = margins;
  if (margins) {
    set_has_margins();
  } else {
    clear_has_margins();
  }
}

// optional bool padding_null = 10;
inline bool ColumnStylePropertiesArchive::has_padding_null() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_padding_null() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ColumnStylePropertiesArchive::clear_has_padding_null() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ColumnStylePropertiesArchive::clear_padding_null() {
  padding_null_ = false;
  clear_has_padding_null();
}
inline bool ColumnStylePropertiesArchive::padding_null() const {
  return padding_null_;
}
inline void ColumnStylePropertiesArchive::set_padding_null(bool value) {
  set_has_padding_null();
  padding_null_ = value;
}

// optional .TSWP.PaddingArchive padding = 11;
inline bool ColumnStylePropertiesArchive::has_padding() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_padding() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ColumnStylePropertiesArchive::clear_has_padding() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ColumnStylePropertiesArchive::clear_padding() {
  if (padding_ != NULL) padding_->::TSWP::PaddingArchive::Clear();
  clear_has_padding();
}
inline const ::TSWP::PaddingArchive& ColumnStylePropertiesArchive::padding() const {
  return padding_ != NULL ? *padding_ : *default_instance_->padding_;
}
inline ::TSWP::PaddingArchive* ColumnStylePropertiesArchive::mutable_padding() {
  set_has_padding();
  if (padding_ == NULL) padding_ = new ::TSWP::PaddingArchive;
  return padding_;
}
inline ::TSWP::PaddingArchive* ColumnStylePropertiesArchive::release_padding() {
  clear_has_padding();
  ::TSWP::PaddingArchive* temp = padding_;
  padding_ = NULL;
  return temp;
}
inline void ColumnStylePropertiesArchive::set_allocated_padding(::TSWP::PaddingArchive* padding) {
  delete padding_;
  padding_ = padding;
  if (padding) {
    set_has_padding();
  } else {
    clear_has_padding();
  }
}

// optional .TSWP.WritingDirectionType writing_direction = 12 [default = kWritingDirectionNatural];
inline bool ColumnStylePropertiesArchive::has_writing_direction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ColumnStylePropertiesArchive::set_has_writing_direction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ColumnStylePropertiesArchive::clear_has_writing_direction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ColumnStylePropertiesArchive::clear_writing_direction() {
  writing_direction_ = -1;
  clear_has_writing_direction();
}
inline ::TSWP::WritingDirectionType ColumnStylePropertiesArchive::writing_direction() const {
  return static_cast< ::TSWP::WritingDirectionType >(writing_direction_);
}
inline void ColumnStylePropertiesArchive::set_writing_direction(::TSWP::WritingDirectionType value) {
  assert(::TSWP::WritingDirectionType_IsValid(value));
  set_has_writing_direction();
  writing_direction_ = value;
}

// -------------------------------------------------------------------

// ColumnStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool ColumnStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ColumnStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ColumnStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ColumnStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ColumnStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool ColumnStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 ColumnStyleArchive::override_count() const {
  return override_count_;
}
inline void ColumnStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TSWP.ColumnStylePropertiesArchive column_properties = 11;
inline bool ColumnStyleArchive::has_column_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnStyleArchive::set_has_column_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnStyleArchive::clear_has_column_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnStyleArchive::clear_column_properties() {
  if (column_properties_ != NULL) column_properties_->::TSWP::ColumnStylePropertiesArchive::Clear();
  clear_has_column_properties();
}
inline const ::TSWP::ColumnStylePropertiesArchive& ColumnStyleArchive::column_properties() const {
  return column_properties_ != NULL ? *column_properties_ : *default_instance_->column_properties_;
}
inline ::TSWP::ColumnStylePropertiesArchive* ColumnStyleArchive::mutable_column_properties() {
  set_has_column_properties();
  if (column_properties_ == NULL) column_properties_ = new ::TSWP::ColumnStylePropertiesArchive;
  return column_properties_;
}
inline ::TSWP::ColumnStylePropertiesArchive* ColumnStyleArchive::release_column_properties() {
  clear_has_column_properties();
  ::TSWP::ColumnStylePropertiesArchive* temp = column_properties_;
  column_properties_ = NULL;
  return temp;
}
inline void ColumnStyleArchive::set_allocated_column_properties(::TSWP::ColumnStylePropertiesArchive* column_properties) {
  delete column_properties_;
  column_properties_ = column_properties;
  if (column_properties) {
    set_has_column_properties();
  } else {
    clear_has_column_properties();
  }
}

// -------------------------------------------------------------------

// ShapeStylePropertiesArchive

// optional bool shrink_to_fit = 1;
inline bool ShapeStylePropertiesArchive::has_shrink_to_fit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_shrink_to_fit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeStylePropertiesArchive::clear_has_shrink_to_fit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeStylePropertiesArchive::clear_shrink_to_fit() {
  shrink_to_fit_ = false;
  clear_has_shrink_to_fit();
}
inline bool ShapeStylePropertiesArchive::shrink_to_fit() const {
  return shrink_to_fit_;
}
inline void ShapeStylePropertiesArchive::set_shrink_to_fit(bool value) {
  set_has_shrink_to_fit();
  shrink_to_fit_ = value;
}

// optional .TSWP.ShapeStylePropertiesArchive.VerticalAlignmentType vertical_alignment = 2;
inline bool ShapeStylePropertiesArchive::has_vertical_alignment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_vertical_alignment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeStylePropertiesArchive::clear_has_vertical_alignment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeStylePropertiesArchive::clear_vertical_alignment() {
  vertical_alignment_ = 0;
  clear_has_vertical_alignment();
}
inline ::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType ShapeStylePropertiesArchive::vertical_alignment() const {
  return static_cast< ::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType >(vertical_alignment_);
}
inline void ShapeStylePropertiesArchive::set_vertical_alignment(::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType value) {
  assert(::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType_IsValid(value));
  set_has_vertical_alignment();
  vertical_alignment_ = value;
}

// optional bool columns_null = 3;
inline bool ShapeStylePropertiesArchive::has_columns_null() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_columns_null() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeStylePropertiesArchive::clear_has_columns_null() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeStylePropertiesArchive::clear_columns_null() {
  columns_null_ = false;
  clear_has_columns_null();
}
inline bool ShapeStylePropertiesArchive::columns_null() const {
  return columns_null_;
}
inline void ShapeStylePropertiesArchive::set_columns_null(bool value) {
  set_has_columns_null();
  columns_null_ = value;
}

// optional .TSWP.ColumnsArchive columns = 4;
inline bool ShapeStylePropertiesArchive::has_columns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_columns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapeStylePropertiesArchive::clear_has_columns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapeStylePropertiesArchive::clear_columns() {
  if (columns_ != NULL) columns_->::TSWP::ColumnsArchive::Clear();
  clear_has_columns();
}
inline const ::TSWP::ColumnsArchive& ShapeStylePropertiesArchive::columns() const {
  return columns_ != NULL ? *columns_ : *default_instance_->columns_;
}
inline ::TSWP::ColumnsArchive* ShapeStylePropertiesArchive::mutable_columns() {
  set_has_columns();
  if (columns_ == NULL) columns_ = new ::TSWP::ColumnsArchive;
  return columns_;
}
inline ::TSWP::ColumnsArchive* ShapeStylePropertiesArchive::release_columns() {
  clear_has_columns();
  ::TSWP::ColumnsArchive* temp = columns_;
  columns_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_columns(::TSWP::ColumnsArchive* columns) {
  delete columns_;
  columns_ = columns;
  if (columns) {
    set_has_columns();
  } else {
    clear_has_columns();
  }
}

// optional bool padding_null = 5;
inline bool ShapeStylePropertiesArchive::has_padding_null() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_padding_null() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShapeStylePropertiesArchive::clear_has_padding_null() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShapeStylePropertiesArchive::clear_padding_null() {
  padding_null_ = false;
  clear_has_padding_null();
}
inline bool ShapeStylePropertiesArchive::padding_null() const {
  return padding_null_;
}
inline void ShapeStylePropertiesArchive::set_padding_null(bool value) {
  set_has_padding_null();
  padding_null_ = value;
}

// optional .TSWP.PaddingArchive padding = 6;
inline bool ShapeStylePropertiesArchive::has_padding() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_padding() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShapeStylePropertiesArchive::clear_has_padding() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShapeStylePropertiesArchive::clear_padding() {
  if (padding_ != NULL) padding_->::TSWP::PaddingArchive::Clear();
  clear_has_padding();
}
inline const ::TSWP::PaddingArchive& ShapeStylePropertiesArchive::padding() const {
  return padding_ != NULL ? *padding_ : *default_instance_->padding_;
}
inline ::TSWP::PaddingArchive* ShapeStylePropertiesArchive::mutable_padding() {
  set_has_padding();
  if (padding_ == NULL) padding_ = new ::TSWP::PaddingArchive;
  return padding_;
}
inline ::TSWP::PaddingArchive* ShapeStylePropertiesArchive::release_padding() {
  clear_has_padding();
  ::TSWP::PaddingArchive* temp = padding_;
  padding_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_padding(::TSWP::PaddingArchive* padding) {
  delete padding_;
  padding_ = padding;
  if (padding) {
    set_has_padding();
  } else {
    clear_has_padding();
  }
}

// optional uint32 default_text_preset_index = 7;
inline bool ShapeStylePropertiesArchive::has_default_text_preset_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_default_text_preset_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShapeStylePropertiesArchive::clear_has_default_text_preset_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShapeStylePropertiesArchive::clear_default_text_preset_index() {
  default_text_preset_index_ = 0u;
  clear_has_default_text_preset_index();
}
inline ::google::protobuf::uint32 ShapeStylePropertiesArchive::default_text_preset_index() const {
  return default_text_preset_index_;
}
inline void ShapeStylePropertiesArchive::set_default_text_preset_index(::google::protobuf::uint32 value) {
  set_has_default_text_preset_index();
  default_text_preset_index_ = value;
}

// optional bool vertical_text = 8;
inline bool ShapeStylePropertiesArchive::has_vertical_text() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_vertical_text() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShapeStylePropertiesArchive::clear_has_vertical_text() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShapeStylePropertiesArchive::clear_vertical_text() {
  vertical_text_ = false;
  clear_has_vertical_text();
}
inline bool ShapeStylePropertiesArchive::vertical_text() const {
  return vertical_text_;
}
inline void ShapeStylePropertiesArchive::set_vertical_text(bool value) {
  set_has_vertical_text();
  vertical_text_ = value;
}

// optional bool paragraph_style_null = 9;
inline bool ShapeStylePropertiesArchive::has_paragraph_style_null() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_paragraph_style_null() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ShapeStylePropertiesArchive::clear_has_paragraph_style_null() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ShapeStylePropertiesArchive::clear_paragraph_style_null() {
  paragraph_style_null_ = false;
  clear_has_paragraph_style_null();
}
inline bool ShapeStylePropertiesArchive::paragraph_style_null() const {
  return paragraph_style_null_;
}
inline void ShapeStylePropertiesArchive::set_paragraph_style_null(bool value) {
  set_has_paragraph_style_null();
  paragraph_style_null_ = value;
}

// optional .TSP.Reference paragraph_style = 10;
inline bool ShapeStylePropertiesArchive::has_paragraph_style() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_paragraph_style() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ShapeStylePropertiesArchive::clear_has_paragraph_style() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ShapeStylePropertiesArchive::clear_paragraph_style() {
  if (paragraph_style_ != NULL) paragraph_style_->::TSP::Reference::Clear();
  clear_has_paragraph_style();
}
inline const ::TSP::Reference& ShapeStylePropertiesArchive::paragraph_style() const {
  return paragraph_style_ != NULL ? *paragraph_style_ : *default_instance_->paragraph_style_;
}
inline ::TSP::Reference* ShapeStylePropertiesArchive::mutable_paragraph_style() {
  set_has_paragraph_style();
  if (paragraph_style_ == NULL) paragraph_style_ = new ::TSP::Reference;
  return paragraph_style_;
}
inline ::TSP::Reference* ShapeStylePropertiesArchive::release_paragraph_style() {
  clear_has_paragraph_style();
  ::TSP::Reference* temp = paragraph_style_;
  paragraph_style_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_paragraph_style(::TSP::Reference* paragraph_style) {
  delete paragraph_style_;
  paragraph_style_ = paragraph_style;
  if (paragraph_style) {
    set_has_paragraph_style();
  } else {
    clear_has_paragraph_style();
  }
}

// -------------------------------------------------------------------

// ShapeStyleArchive

// required .TSD.ShapeStyleArchive super = 1;
inline bool ShapeStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::ShapeStyleArchive::Clear();
  clear_has_super();
}
inline const ::TSD::ShapeStyleArchive& ShapeStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::ShapeStyleArchive* ShapeStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::ShapeStyleArchive;
  return super_;
}
inline ::TSD::ShapeStyleArchive* ShapeStyleArchive::release_super() {
  clear_has_super();
  ::TSD::ShapeStyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeStyleArchive::set_allocated_super(::TSD::ShapeStyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool ShapeStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 ShapeStyleArchive::override_count() const {
  return override_count_;
}
inline void ShapeStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TSWP.ShapeStylePropertiesArchive shape_properties = 11;
inline bool ShapeStyleArchive::has_shape_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeStyleArchive::set_has_shape_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeStyleArchive::clear_has_shape_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeStyleArchive::clear_shape_properties() {
  if (shape_properties_ != NULL) shape_properties_->::TSWP::ShapeStylePropertiesArchive::Clear();
  clear_has_shape_properties();
}
inline const ::TSWP::ShapeStylePropertiesArchive& ShapeStyleArchive::shape_properties() const {
  return shape_properties_ != NULL ? *shape_properties_ : *default_instance_->shape_properties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* ShapeStyleArchive::mutable_shape_properties() {
  set_has_shape_properties();
  if (shape_properties_ == NULL) shape_properties_ = new ::TSWP::ShapeStylePropertiesArchive;
  return shape_properties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* ShapeStyleArchive::release_shape_properties() {
  clear_has_shape_properties();
  ::TSWP::ShapeStylePropertiesArchive* temp = shape_properties_;
  shape_properties_ = NULL;
  return temp;
}
inline void ShapeStyleArchive::set_allocated_shape_properties(::TSWP::ShapeStylePropertiesArchive* shape_properties) {
  delete shape_properties_;
  shape_properties_ = shape_properties;
  if (shape_properties) {
    set_has_shape_properties();
  } else {
    clear_has_shape_properties();
  }
}

// -------------------------------------------------------------------

// ThemePresetsArchive

// repeated .TSP.Reference list_style_presets = 1;
inline int ThemePresetsArchive::list_style_presets_size() const {
  return list_style_presets_.size();
}
inline void ThemePresetsArchive::clear_list_style_presets() {
  list_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::list_style_presets(int index) const {
  return list_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_list_style_presets(int index) {
  return list_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_list_style_presets() {
  return list_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::list_style_presets() const {
  return list_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_list_style_presets() {
  return &list_style_presets_;
}

// repeated .TSP.Reference text_style_presets = 2;
inline int ThemePresetsArchive::text_style_presets_size() const {
  return text_style_presets_.size();
}
inline void ThemePresetsArchive::clear_text_style_presets() {
  text_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::text_style_presets(int index) const {
  return text_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_text_style_presets(int index) {
  return text_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_text_style_presets() {
  return text_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::text_style_presets() const {
  return text_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_text_style_presets() {
  return &text_style_presets_;
}

// repeated .TSP.Reference imported_text_style_presets = 3;
inline int ThemePresetsArchive::imported_text_style_presets_size() const {
  return imported_text_style_presets_.size();
}
inline void ThemePresetsArchive::clear_imported_text_style_presets() {
  imported_text_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::imported_text_style_presets(int index) const {
  return imported_text_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_imported_text_style_presets(int index) {
  return imported_text_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_imported_text_style_presets() {
  return imported_text_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::imported_text_style_presets() const {
  return imported_text_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_imported_text_style_presets() {
  return &imported_text_style_presets_;
}

// repeated .TSP.Reference toc_entry_style_presets = 4;
inline int ThemePresetsArchive::toc_entry_style_presets_size() const {
  return toc_entry_style_presets_.size();
}
inline void ThemePresetsArchive::clear_toc_entry_style_presets() {
  toc_entry_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::toc_entry_style_presets(int index) const {
  return toc_entry_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_toc_entry_style_presets(int index) {
  return toc_entry_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_toc_entry_style_presets() {
  return toc_entry_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::toc_entry_style_presets() const {
  return toc_entry_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_toc_entry_style_presets() {
  return &toc_entry_style_presets_;
}

// repeated .TSP.Reference toc_settings_presets = 5;
inline int ThemePresetsArchive::toc_settings_presets_size() const {
  return toc_settings_presets_.size();
}
inline void ThemePresetsArchive::clear_toc_settings_presets() {
  toc_settings_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::toc_settings_presets(int index) const {
  return toc_settings_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_toc_settings_presets(int index) {
  return toc_settings_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_toc_settings_presets() {
  return toc_settings_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::toc_settings_presets() const {
  return toc_settings_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_toc_settings_presets() {
  return &toc_settings_presets_;
}

// repeated .TSP.Reference character_style_presets = 6;
inline int ThemePresetsArchive::character_style_presets_size() const {
  return character_style_presets_.size();
}
inline void ThemePresetsArchive::clear_character_style_presets() {
  character_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::character_style_presets(int index) const {
  return character_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_character_style_presets(int index) {
  return character_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_character_style_presets() {
  return character_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::character_style_presets() const {
  return character_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_character_style_presets() {
  return &character_style_presets_;
}

// repeated .TSP.Reference paragraph_style_presets = 7;
inline int ThemePresetsArchive::paragraph_style_presets_size() const {
  return paragraph_style_presets_.size();
}
inline void ThemePresetsArchive::clear_paragraph_style_presets() {
  paragraph_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::paragraph_style_presets(int index) const {
  return paragraph_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_paragraph_style_presets(int index) {
  return paragraph_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_paragraph_style_presets() {
  return paragraph_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::paragraph_style_presets() const {
  return paragraph_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_paragraph_style_presets() {
  return &paragraph_style_presets_;
}

// -------------------------------------------------------------------

// TextPresetDisplayItemArchive

// required .TSP.Reference preset = 1;
inline bool TextPresetDisplayItemArchive::has_preset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextPresetDisplayItemArchive::set_has_preset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextPresetDisplayItemArchive::clear_has_preset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextPresetDisplayItemArchive::clear_preset() {
  if (preset_ != NULL) preset_->::TSP::Reference::Clear();
  clear_has_preset();
}
inline const ::TSP::Reference& TextPresetDisplayItemArchive::preset() const {
  return preset_ != NULL ? *preset_ : *default_instance_->preset_;
}
inline ::TSP::Reference* TextPresetDisplayItemArchive::mutable_preset() {
  set_has_preset();
  if (preset_ == NULL) preset_ = new ::TSP::Reference;
  return preset_;
}
inline ::TSP::Reference* TextPresetDisplayItemArchive::release_preset() {
  clear_has_preset();
  ::TSP::Reference* temp = preset_;
  preset_ = NULL;
  return temp;
}
inline void TextPresetDisplayItemArchive::set_allocated_preset(::TSP::Reference* preset) {
  delete preset_;
  preset_ = preset;
  if (preset) {
    set_has_preset();
  } else {
    clear_has_preset();
  }
}

// required string display_name = 2;
inline bool TextPresetDisplayItemArchive::has_display_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextPresetDisplayItemArchive::set_has_display_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextPresetDisplayItemArchive::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextPresetDisplayItemArchive::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& TextPresetDisplayItemArchive::display_name() const {
  return *display_name_;
}
inline void TextPresetDisplayItemArchive::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void TextPresetDisplayItemArchive::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void TextPresetDisplayItemArchive::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextPresetDisplayItemArchive::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* TextPresetDisplayItemArchive::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextPresetDisplayItemArchive::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TOCEntryStylePropertiesArchive

// optional bool page_number_style_null = 1;
inline bool TOCEntryStylePropertiesArchive::has_page_number_style_null() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCEntryStylePropertiesArchive::set_has_page_number_style_null() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCEntryStylePropertiesArchive::clear_has_page_number_style_null() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCEntryStylePropertiesArchive::clear_page_number_style_null() {
  page_number_style_null_ = false;
  clear_has_page_number_style_null();
}
inline bool TOCEntryStylePropertiesArchive::page_number_style_null() const {
  return page_number_style_null_;
}
inline void TOCEntryStylePropertiesArchive::set_page_number_style_null(bool value) {
  set_has_page_number_style_null();
  page_number_style_null_ = value;
}

// optional .TSP.Reference page_number_style = 2;
inline bool TOCEntryStylePropertiesArchive::has_page_number_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCEntryStylePropertiesArchive::set_has_page_number_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCEntryStylePropertiesArchive::clear_has_page_number_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCEntryStylePropertiesArchive::clear_page_number_style() {
  if (page_number_style_ != NULL) page_number_style_->::TSP::Reference::Clear();
  clear_has_page_number_style();
}
inline const ::TSP::Reference& TOCEntryStylePropertiesArchive::page_number_style() const {
  return page_number_style_ != NULL ? *page_number_style_ : *default_instance_->page_number_style_;
}
inline ::TSP::Reference* TOCEntryStylePropertiesArchive::mutable_page_number_style() {
  set_has_page_number_style();
  if (page_number_style_ == NULL) page_number_style_ = new ::TSP::Reference;
  return page_number_style_;
}
inline ::TSP::Reference* TOCEntryStylePropertiesArchive::release_page_number_style() {
  clear_has_page_number_style();
  ::TSP::Reference* temp = page_number_style_;
  page_number_style_ = NULL;
  return temp;
}
inline void TOCEntryStylePropertiesArchive::set_allocated_page_number_style(::TSP::Reference* page_number_style) {
  delete page_number_style_;
  page_number_style_ = page_number_style;
  if (page_number_style) {
    set_has_page_number_style();
  } else {
    clear_has_page_number_style();
  }
}

// optional bool show_page_number = 3;
inline bool TOCEntryStylePropertiesArchive::has_show_page_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TOCEntryStylePropertiesArchive::set_has_show_page_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TOCEntryStylePropertiesArchive::clear_has_show_page_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TOCEntryStylePropertiesArchive::clear_show_page_number() {
  show_page_number_ = false;
  clear_has_show_page_number();
}
inline bool TOCEntryStylePropertiesArchive::show_page_number() const {
  return show_page_number_;
}
inline void TOCEntryStylePropertiesArchive::set_show_page_number(bool value) {
  set_has_show_page_number();
  show_page_number_ = value;
}

// -------------------------------------------------------------------

// TOCEntryStyleArchive

// required .TSWP.ParagraphStyleArchive super = 1;
inline bool TOCEntryStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCEntryStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCEntryStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCEntryStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::ParagraphStyleArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::ParagraphStyleArchive& TOCEntryStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::ParagraphStyleArchive* TOCEntryStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::ParagraphStyleArchive;
  return super_;
}
inline ::TSWP::ParagraphStyleArchive* TOCEntryStyleArchive::release_super() {
  clear_has_super();
  ::TSWP::ParagraphStyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TOCEntryStyleArchive::set_allocated_super(::TSWP::ParagraphStyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSWP.TOCEntryStylePropertiesArchive toc_properties = 2;
inline bool TOCEntryStyleArchive::has_toc_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCEntryStyleArchive::set_has_toc_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCEntryStyleArchive::clear_has_toc_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCEntryStyleArchive::clear_toc_properties() {
  if (toc_properties_ != NULL) toc_properties_->::TSWP::TOCEntryStylePropertiesArchive::Clear();
  clear_has_toc_properties();
}
inline const ::TSWP::TOCEntryStylePropertiesArchive& TOCEntryStyleArchive::toc_properties() const {
  return toc_properties_ != NULL ? *toc_properties_ : *default_instance_->toc_properties_;
}
inline ::TSWP::TOCEntryStylePropertiesArchive* TOCEntryStyleArchive::mutable_toc_properties() {
  set_has_toc_properties();
  if (toc_properties_ == NULL) toc_properties_ = new ::TSWP::TOCEntryStylePropertiesArchive;
  return toc_properties_;
}
inline ::TSWP::TOCEntryStylePropertiesArchive* TOCEntryStyleArchive::release_toc_properties() {
  clear_has_toc_properties();
  ::TSWP::TOCEntryStylePropertiesArchive* temp = toc_properties_;
  toc_properties_ = NULL;
  return temp;
}
inline void TOCEntryStyleArchive::set_allocated_toc_properties(::TSWP::TOCEntryStylePropertiesArchive* toc_properties) {
  delete toc_properties_;
  toc_properties_ = toc_properties;
  if (toc_properties) {
    set_has_toc_properties();
  } else {
    clear_has_toc_properties();
  }
}

// -------------------------------------------------------------------

// TOCSettingsArchive_TOCEntryData

// optional .TSP.Reference paragraph_style = 1;
inline bool TOCSettingsArchive_TOCEntryData::has_paragraph_style() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCSettingsArchive_TOCEntryData::set_has_paragraph_style() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCSettingsArchive_TOCEntryData::clear_has_paragraph_style() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCSettingsArchive_TOCEntryData::clear_paragraph_style() {
  if (paragraph_style_ != NULL) paragraph_style_->::TSP::Reference::Clear();
  clear_has_paragraph_style();
}
inline const ::TSP::Reference& TOCSettingsArchive_TOCEntryData::paragraph_style() const {
  return paragraph_style_ != NULL ? *paragraph_style_ : *default_instance_->paragraph_style_;
}
inline ::TSP::Reference* TOCSettingsArchive_TOCEntryData::mutable_paragraph_style() {
  set_has_paragraph_style();
  if (paragraph_style_ == NULL) paragraph_style_ = new ::TSP::Reference;
  return paragraph_style_;
}
inline ::TSP::Reference* TOCSettingsArchive_TOCEntryData::release_paragraph_style() {
  clear_has_paragraph_style();
  ::TSP::Reference* temp = paragraph_style_;
  paragraph_style_ = NULL;
  return temp;
}
inline void TOCSettingsArchive_TOCEntryData::set_allocated_paragraph_style(::TSP::Reference* paragraph_style) {
  delete paragraph_style_;
  paragraph_style_ = paragraph_style;
  if (paragraph_style) {
    set_has_paragraph_style();
  } else {
    clear_has_paragraph_style();
  }
}

// optional .TSP.Reference toc_entry_style = 2;
inline bool TOCSettingsArchive_TOCEntryData::has_toc_entry_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCSettingsArchive_TOCEntryData::set_has_toc_entry_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCSettingsArchive_TOCEntryData::clear_has_toc_entry_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCSettingsArchive_TOCEntryData::clear_toc_entry_style() {
  if (toc_entry_style_ != NULL) toc_entry_style_->::TSP::Reference::Clear();
  clear_has_toc_entry_style();
}
inline const ::TSP::Reference& TOCSettingsArchive_TOCEntryData::toc_entry_style() const {
  return toc_entry_style_ != NULL ? *toc_entry_style_ : *default_instance_->toc_entry_style_;
}
inline ::TSP::Reference* TOCSettingsArchive_TOCEntryData::mutable_toc_entry_style() {
  set_has_toc_entry_style();
  if (toc_entry_style_ == NULL) toc_entry_style_ = new ::TSP::Reference;
  return toc_entry_style_;
}
inline ::TSP::Reference* TOCSettingsArchive_TOCEntryData::release_toc_entry_style() {
  clear_has_toc_entry_style();
  ::TSP::Reference* temp = toc_entry_style_;
  toc_entry_style_ = NULL;
  return temp;
}
inline void TOCSettingsArchive_TOCEntryData::set_allocated_toc_entry_style(::TSP::Reference* toc_entry_style) {
  delete toc_entry_style_;
  toc_entry_style_ = toc_entry_style;
  if (toc_entry_style) {
    set_has_toc_entry_style();
  } else {
    clear_has_toc_entry_style();
  }
}

// optional bool show_in_toc = 3;
inline bool TOCSettingsArchive_TOCEntryData::has_show_in_toc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TOCSettingsArchive_TOCEntryData::set_has_show_in_toc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TOCSettingsArchive_TOCEntryData::clear_has_show_in_toc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TOCSettingsArchive_TOCEntryData::clear_show_in_toc() {
  show_in_toc_ = false;
  clear_has_show_in_toc();
}
inline bool TOCSettingsArchive_TOCEntryData::show_in_toc() const {
  return show_in_toc_;
}
inline void TOCSettingsArchive_TOCEntryData::set_show_in_toc(bool value) {
  set_has_show_in_toc();
  show_in_toc_ = value;
}

// -------------------------------------------------------------------

// TOCSettingsArchive

// optional string toc_name = 1;
inline bool TOCSettingsArchive::has_toc_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCSettingsArchive::set_has_toc_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCSettingsArchive::clear_has_toc_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCSettingsArchive::clear_toc_name() {
  if (toc_name_ != &::google::protobuf::internal::kEmptyString) {
    toc_name_->clear();
  }
  clear_has_toc_name();
}
inline const ::std::string& TOCSettingsArchive::toc_name() const {
  return *toc_name_;
}
inline void TOCSettingsArchive::set_toc_name(const ::std::string& value) {
  set_has_toc_name();
  if (toc_name_ == &::google::protobuf::internal::kEmptyString) {
    toc_name_ = new ::std::string;
  }
  toc_name_->assign(value);
}
inline void TOCSettingsArchive::set_toc_name(const char* value) {
  set_has_toc_name();
  if (toc_name_ == &::google::protobuf::internal::kEmptyString) {
    toc_name_ = new ::std::string;
  }
  toc_name_->assign(value);
}
inline void TOCSettingsArchive::set_toc_name(const char* value, size_t size) {
  set_has_toc_name();
  if (toc_name_ == &::google::protobuf::internal::kEmptyString) {
    toc_name_ = new ::std::string;
  }
  toc_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TOCSettingsArchive::mutable_toc_name() {
  set_has_toc_name();
  if (toc_name_ == &::google::protobuf::internal::kEmptyString) {
    toc_name_ = new ::std::string;
  }
  return toc_name_;
}
inline ::std::string* TOCSettingsArchive::release_toc_name() {
  clear_has_toc_name();
  if (toc_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toc_name_;
    toc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TOCSettingsArchive::set_allocated_toc_name(::std::string* toc_name) {
  if (toc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete toc_name_;
  }
  if (toc_name) {
    set_has_toc_name();
    toc_name_ = toc_name;
  } else {
    clear_has_toc_name();
    toc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 toc_scope = 2;
inline bool TOCSettingsArchive::has_toc_scope() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCSettingsArchive::set_has_toc_scope() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCSettingsArchive::clear_has_toc_scope() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCSettingsArchive::clear_toc_scope() {
  toc_scope_ = 0u;
  clear_has_toc_scope();
}
inline ::google::protobuf::uint32 TOCSettingsArchive::toc_scope() const {
  return toc_scope_;
}
inline void TOCSettingsArchive::set_toc_scope(::google::protobuf::uint32 value) {
  set_has_toc_scope();
  toc_scope_ = value;
}

// repeated .TSWP.TOCSettingsArchive.TOCEntryData entries = 3;
inline int TOCSettingsArchive::entries_size() const {
  return entries_.size();
}
inline void TOCSettingsArchive::clear_entries() {
  entries_.Clear();
}
inline const ::TSWP::TOCSettingsArchive_TOCEntryData& TOCSettingsArchive::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSWP::TOCSettingsArchive_TOCEntryData* TOCSettingsArchive::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSWP::TOCSettingsArchive_TOCEntryData* TOCSettingsArchive::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSettingsArchive_TOCEntryData >&
TOCSettingsArchive::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSettingsArchive_TOCEntryData >*
TOCSettingsArchive::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// TOCEntryInstanceArchive

// required uint32 paragraph_index = 1;
inline bool TOCEntryInstanceArchive::has_paragraph_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCEntryInstanceArchive::set_has_paragraph_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCEntryInstanceArchive::clear_has_paragraph_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCEntryInstanceArchive::clear_paragraph_index() {
  paragraph_index_ = 0u;
  clear_has_paragraph_index();
}
inline ::google::protobuf::uint32 TOCEntryInstanceArchive::paragraph_index() const {
  return paragraph_index_;
}
inline void TOCEntryInstanceArchive::set_paragraph_index(::google::protobuf::uint32 value) {
  set_has_paragraph_index();
  paragraph_index_ = value;
}

// required uint32 page_number = 2;
inline bool TOCEntryInstanceArchive::has_page_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCEntryInstanceArchive::set_has_page_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCEntryInstanceArchive::clear_has_page_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCEntryInstanceArchive::clear_page_number() {
  page_number_ = 0u;
  clear_has_page_number();
}
inline ::google::protobuf::uint32 TOCEntryInstanceArchive::page_number() const {
  return page_number_;
}
inline void TOCEntryInstanceArchive::set_page_number(::google::protobuf::uint32 value) {
  set_has_page_number();
  page_number_ = value;
}

// required uint32 number_format = 3;
inline bool TOCEntryInstanceArchive::has_number_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TOCEntryInstanceArchive::set_has_number_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TOCEntryInstanceArchive::clear_has_number_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TOCEntryInstanceArchive::clear_number_format() {
  number_format_ = 0u;
  clear_has_number_format();
}
inline ::google::protobuf::uint32 TOCEntryInstanceArchive::number_format() const {
  return number_format_;
}
inline void TOCEntryInstanceArchive::set_number_format(::google::protobuf::uint32 value) {
  set_has_number_format();
  number_format_ = value;
}

// required string heading = 4;
inline bool TOCEntryInstanceArchive::has_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TOCEntryInstanceArchive::set_has_heading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TOCEntryInstanceArchive::clear_has_heading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TOCEntryInstanceArchive::clear_heading() {
  if (heading_ != &::google::protobuf::internal::kEmptyString) {
    heading_->clear();
  }
  clear_has_heading();
}
inline const ::std::string& TOCEntryInstanceArchive::heading() const {
  return *heading_;
}
inline void TOCEntryInstanceArchive::set_heading(const ::std::string& value) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  heading_->assign(value);
}
inline void TOCEntryInstanceArchive::set_heading(const char* value) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  heading_->assign(value);
}
inline void TOCEntryInstanceArchive::set_heading(const char* value, size_t size) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  heading_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TOCEntryInstanceArchive::mutable_heading() {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  return heading_;
}
inline ::std::string* TOCEntryInstanceArchive::release_heading() {
  clear_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = heading_;
    heading_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TOCEntryInstanceArchive::set_allocated_heading(::std::string* heading) {
  if (heading_ != &::google::protobuf::internal::kEmptyString) {
    delete heading_;
  }
  if (heading) {
    set_has_heading();
    heading_ = heading;
  } else {
    clear_has_heading();
    heading_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSP.Reference indexed_style = 5;
inline bool TOCEntryInstanceArchive::has_indexed_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TOCEntryInstanceArchive::set_has_indexed_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TOCEntryInstanceArchive::clear_has_indexed_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TOCEntryInstanceArchive::clear_indexed_style() {
  if (indexed_style_ != NULL) indexed_style_->::TSP::Reference::Clear();
  clear_has_indexed_style();
}
inline const ::TSP::Reference& TOCEntryInstanceArchive::indexed_style() const {
  return indexed_style_ != NULL ? *indexed_style_ : *default_instance_->indexed_style_;
}
inline ::TSP::Reference* TOCEntryInstanceArchive::mutable_indexed_style() {
  set_has_indexed_style();
  if (indexed_style_ == NULL) indexed_style_ = new ::TSP::Reference;
  return indexed_style_;
}
inline ::TSP::Reference* TOCEntryInstanceArchive::release_indexed_style() {
  clear_has_indexed_style();
  ::TSP::Reference* temp = indexed_style_;
  indexed_style_ = NULL;
  return temp;
}
inline void TOCEntryInstanceArchive::set_allocated_indexed_style(::TSP::Reference* indexed_style) {
  delete indexed_style_;
  indexed_style_ = indexed_style;
  if (indexed_style) {
    set_has_indexed_style();
  } else {
    clear_has_indexed_style();
  }
}

// -------------------------------------------------------------------

// UndoTransaction_GenericTransaction

// required uint32 value1 = 1;
inline bool UndoTransaction_GenericTransaction::has_value1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_GenericTransaction::set_has_value1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_GenericTransaction::clear_has_value1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_GenericTransaction::clear_value1() {
  value1_ = 0u;
  clear_has_value1();
}
inline ::google::protobuf::uint32 UndoTransaction_GenericTransaction::value1() const {
  return value1_;
}
inline void UndoTransaction_GenericTransaction::set_value1(::google::protobuf::uint32 value) {
  set_has_value1();
  value1_ = value;
}

// required uint32 value2 = 2;
inline bool UndoTransaction_GenericTransaction::has_value2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_GenericTransaction::set_has_value2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_GenericTransaction::clear_has_value2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_GenericTransaction::clear_value2() {
  value2_ = 0u;
  clear_has_value2();
}
inline ::google::protobuf::uint32 UndoTransaction_GenericTransaction::value2() const {
  return value2_;
}
inline void UndoTransaction_GenericTransaction::set_value2(::google::protobuf::uint32 value) {
  set_has_value2();
  value2_ = value;
}

// required uint32 value3 = 3;
inline bool UndoTransaction_GenericTransaction::has_value3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_GenericTransaction::set_has_value3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_GenericTransaction::clear_has_value3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_GenericTransaction::clear_value3() {
  value3_ = 0u;
  clear_has_value3();
}
inline ::google::protobuf::uint32 UndoTransaction_GenericTransaction::value3() const {
  return value3_;
}
inline void UndoTransaction_GenericTransaction::set_value3(::google::protobuf::uint32 value) {
  set_has_value3();
  value3_ = value;
}

// -------------------------------------------------------------------

// UndoTransaction_TextTransaction

// required uint32 insert_location = 1;
inline bool UndoTransaction_TextTransaction::has_insert_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_TextTransaction::set_has_insert_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_TextTransaction::clear_has_insert_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_TextTransaction::clear_insert_location() {
  insert_location_ = 0u;
  clear_has_insert_location();
}
inline ::google::protobuf::uint32 UndoTransaction_TextTransaction::insert_location() const {
  return insert_location_;
}
inline void UndoTransaction_TextTransaction::set_insert_location(::google::protobuf::uint32 value) {
  set_has_insert_location();
  insert_location_ = value;
}

// required uint32 insert_length = 2;
inline bool UndoTransaction_TextTransaction::has_insert_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_TextTransaction::set_has_insert_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_TextTransaction::clear_has_insert_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_TextTransaction::clear_insert_length() {
  insert_length_ = 0u;
  clear_has_insert_length();
}
inline ::google::protobuf::uint32 UndoTransaction_TextTransaction::insert_length() const {
  return insert_length_;
}
inline void UndoTransaction_TextTransaction::set_insert_length(::google::protobuf::uint32 value) {
  set_has_insert_length();
  insert_length_ = value;
}

// optional string string_to_delete = 3;
inline bool UndoTransaction_TextTransaction::has_string_to_delete() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_TextTransaction::set_has_string_to_delete() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_TextTransaction::clear_has_string_to_delete() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_TextTransaction::clear_string_to_delete() {
  if (string_to_delete_ != &::google::protobuf::internal::kEmptyString) {
    string_to_delete_->clear();
  }
  clear_has_string_to_delete();
}
inline const ::std::string& UndoTransaction_TextTransaction::string_to_delete() const {
  return *string_to_delete_;
}
inline void UndoTransaction_TextTransaction::set_string_to_delete(const ::std::string& value) {
  set_has_string_to_delete();
  if (string_to_delete_ == &::google::protobuf::internal::kEmptyString) {
    string_to_delete_ = new ::std::string;
  }
  string_to_delete_->assign(value);
}
inline void UndoTransaction_TextTransaction::set_string_to_delete(const char* value) {
  set_has_string_to_delete();
  if (string_to_delete_ == &::google::protobuf::internal::kEmptyString) {
    string_to_delete_ = new ::std::string;
  }
  string_to_delete_->assign(value);
}
inline void UndoTransaction_TextTransaction::set_string_to_delete(const char* value, size_t size) {
  set_has_string_to_delete();
  if (string_to_delete_ == &::google::protobuf::internal::kEmptyString) {
    string_to_delete_ = new ::std::string;
  }
  string_to_delete_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndoTransaction_TextTransaction::mutable_string_to_delete() {
  set_has_string_to_delete();
  if (string_to_delete_ == &::google::protobuf::internal::kEmptyString) {
    string_to_delete_ = new ::std::string;
  }
  return string_to_delete_;
}
inline ::std::string* UndoTransaction_TextTransaction::release_string_to_delete() {
  clear_has_string_to_delete();
  if (string_to_delete_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_to_delete_;
    string_to_delete_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndoTransaction_TextTransaction::set_allocated_string_to_delete(::std::string* string_to_delete) {
  if (string_to_delete_ != &::google::protobuf::internal::kEmptyString) {
    delete string_to_delete_;
  }
  if (string_to_delete) {
    set_has_string_to_delete();
    string_to_delete_ = string_to_delete;
  } else {
    clear_has_string_to_delete();
    string_to_delete_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UndoTransaction_CharIndexTransaction

// required uint32 char_index = 1;
inline bool UndoTransaction_CharIndexTransaction::has_char_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_CharIndexTransaction::set_has_char_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_CharIndexTransaction::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_CharIndexTransaction::clear_char_index() {
  char_index_ = 0u;
  clear_has_char_index();
}
inline ::google::protobuf::uint32 UndoTransaction_CharIndexTransaction::char_index() const {
  return char_index_;
}
inline void UndoTransaction_CharIndexTransaction::set_char_index(::google::protobuf::uint32 value) {
  set_has_char_index();
  char_index_ = value;
}

// required uint32 count = 2;
inline bool UndoTransaction_CharIndexTransaction::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_CharIndexTransaction::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_CharIndexTransaction::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_CharIndexTransaction::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 UndoTransaction_CharIndexTransaction::count() const {
  return count_;
}
inline void UndoTransaction_CharIndexTransaction::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional .TSP.Reference object = 3;
inline bool UndoTransaction_CharIndexTransaction::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_CharIndexTransaction::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_CharIndexTransaction::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_CharIndexTransaction::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& UndoTransaction_CharIndexTransaction::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* UndoTransaction_CharIndexTransaction::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* UndoTransaction_CharIndexTransaction::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void UndoTransaction_CharIndexTransaction::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// -------------------------------------------------------------------

// UndoTransaction_ReplaceCharIndexTransaction

// required uint32 attribute_index = 1;
inline bool UndoTransaction_ReplaceCharIndexTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_ReplaceCharIndexTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// required uint32 char_index = 2;
inline bool UndoTransaction_ReplaceCharIndexTransaction::has_char_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::set_has_char_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::clear_char_index() {
  char_index_ = 0u;
  clear_has_char_index();
}
inline ::google::protobuf::uint32 UndoTransaction_ReplaceCharIndexTransaction::char_index() const {
  return char_index_;
}
inline void UndoTransaction_ReplaceCharIndexTransaction::set_char_index(::google::protobuf::uint32 value) {
  set_has_char_index();
  char_index_ = value;
}

// -------------------------------------------------------------------

// UndoTransaction_AttributeIndexTransaction

// required uint32 attribute_index = 1;
inline bool UndoTransaction_AttributeIndexTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_AttributeIndexTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_AttributeIndexTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_AttributeIndexTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// required uint32 char_index = 2;
inline bool UndoTransaction_AttributeIndexTransaction::has_char_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_AttributeIndexTransaction::set_has_char_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_char_index() {
  char_index_ = 0u;
  clear_has_char_index();
}
inline ::google::protobuf::uint32 UndoTransaction_AttributeIndexTransaction::char_index() const {
  return char_index_;
}
inline void UndoTransaction_AttributeIndexTransaction::set_char_index(::google::protobuf::uint32 value) {
  set_has_char_index();
  char_index_ = value;
}

// optional .TSP.Reference object = 3;
inline bool UndoTransaction_AttributeIndexTransaction::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_AttributeIndexTransaction::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& UndoTransaction_AttributeIndexTransaction::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* UndoTransaction_AttributeIndexTransaction::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* UndoTransaction_AttributeIndexTransaction::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void UndoTransaction_AttributeIndexTransaction::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// optional string string = 4;
inline bool UndoTransaction_AttributeIndexTransaction::has_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UndoTransaction_AttributeIndexTransaction::set_has_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_has_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UndoTransaction_AttributeIndexTransaction::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& UndoTransaction_AttributeIndexTransaction::string() const {
  return *string_;
}
inline void UndoTransaction_AttributeIndexTransaction::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void UndoTransaction_AttributeIndexTransaction::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void UndoTransaction_AttributeIndexTransaction::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndoTransaction_AttributeIndexTransaction::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* UndoTransaction_AttributeIndexTransaction::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndoTransaction_AttributeIndexTransaction::set_allocated_string(::std::string* string) {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (string) {
    set_has_string();
    string_ = string;
  } else {
    clear_has_string();
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UndoTransaction_InsertAttributeTransaction

// required uint32 attribute_index = 1;
inline bool UndoTransaction_InsertAttributeTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_InsertAttributeTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_InsertAttributeTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_InsertAttributeTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// required uint32 attribute_count = 2;
inline bool UndoTransaction_InsertAttributeTransaction::has_attribute_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_InsertAttributeTransaction::set_has_attribute_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_has_attribute_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_attribute_count() {
  attribute_count_ = 0u;
  clear_has_attribute_count();
}
inline ::google::protobuf::uint32 UndoTransaction_InsertAttributeTransaction::attribute_count() const {
  return attribute_count_;
}
inline void UndoTransaction_InsertAttributeTransaction::set_attribute_count(::google::protobuf::uint32 value) {
  set_has_attribute_count();
  attribute_count_ = value;
}

// optional .TSP.Reference object = 3;
inline bool UndoTransaction_InsertAttributeTransaction::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_InsertAttributeTransaction::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& UndoTransaction_InsertAttributeTransaction::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* UndoTransaction_InsertAttributeTransaction::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* UndoTransaction_InsertAttributeTransaction::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void UndoTransaction_InsertAttributeTransaction::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// optional string string = 4;
inline bool UndoTransaction_InsertAttributeTransaction::has_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UndoTransaction_InsertAttributeTransaction::set_has_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_has_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UndoTransaction_InsertAttributeTransaction::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& UndoTransaction_InsertAttributeTransaction::string() const {
  return *string_;
}
inline void UndoTransaction_InsertAttributeTransaction::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void UndoTransaction_InsertAttributeTransaction::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void UndoTransaction_InsertAttributeTransaction::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndoTransaction_InsertAttributeTransaction::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* UndoTransaction_InsertAttributeTransaction::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndoTransaction_InsertAttributeTransaction::set_allocated_string(::std::string* string) {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (string) {
    set_has_string();
    string_ = string;
  } else {
    clear_has_string();
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UndoTransaction_InsertNilTransaction

// required uint32 attribute_index = 1;
inline bool UndoTransaction_InsertNilTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_InsertNilTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_InsertNilTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_InsertNilTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_InsertNilTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_InsertNilTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// required uint32 attribute_count = 2;
inline bool UndoTransaction_InsertNilTransaction::has_attribute_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_InsertNilTransaction::set_has_attribute_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_InsertNilTransaction::clear_has_attribute_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_InsertNilTransaction::clear_attribute_count() {
  attribute_count_ = 0u;
  clear_has_attribute_count();
}
inline ::google::protobuf::uint32 UndoTransaction_InsertNilTransaction::attribute_count() const {
  return attribute_count_;
}
inline void UndoTransaction_InsertNilTransaction::set_attribute_count(::google::protobuf::uint32 value) {
  set_has_attribute_count();
  attribute_count_ = value;
}

// -------------------------------------------------------------------

// UndoTransaction_CharDeltaTransaction

// required uint32 char_index = 1;
inline bool UndoTransaction_CharDeltaTransaction::has_char_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_CharDeltaTransaction::set_has_char_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_CharDeltaTransaction::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_CharDeltaTransaction::clear_char_index() {
  char_index_ = 0u;
  clear_has_char_index();
}
inline ::google::protobuf::uint32 UndoTransaction_CharDeltaTransaction::char_index() const {
  return char_index_;
}
inline void UndoTransaction_CharDeltaTransaction::set_char_index(::google::protobuf::uint32 value) {
  set_has_char_index();
  char_index_ = value;
}

// required uint32 attribute_index = 2;
inline bool UndoTransaction_CharDeltaTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_CharDeltaTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_CharDeltaTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_CharDeltaTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_CharDeltaTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_CharDeltaTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// required sint32 char_delta = 3;
inline bool UndoTransaction_CharDeltaTransaction::has_char_delta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_CharDeltaTransaction::set_has_char_delta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_CharDeltaTransaction::clear_has_char_delta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_CharDeltaTransaction::clear_char_delta() {
  char_delta_ = 0;
  clear_has_char_delta();
}
inline ::google::protobuf::int32 UndoTransaction_CharDeltaTransaction::char_delta() const {
  return char_delta_;
}
inline void UndoTransaction_CharDeltaTransaction::set_char_delta(::google::protobuf::int32 value) {
  set_has_char_delta();
  char_delta_ = value;
}

// -------------------------------------------------------------------

// UndoTransaction_ParagraphDataTransaction

// required uint32 attribute_index = 1;
inline bool UndoTransaction_ParagraphDataTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_ParagraphDataTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_ParagraphDataTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_ParagraphDataTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// required uint32 first = 2;
inline bool UndoTransaction_ParagraphDataTransaction::has_first() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_ParagraphDataTransaction::set_has_first() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_has_first() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_first() {
  first_ = 0u;
  clear_has_first();
}
inline ::google::protobuf::uint32 UndoTransaction_ParagraphDataTransaction::first() const {
  return first_;
}
inline void UndoTransaction_ParagraphDataTransaction::set_first(::google::protobuf::uint32 value) {
  set_has_first();
  first_ = value;
}

// required uint32 second = 3;
inline bool UndoTransaction_ParagraphDataTransaction::has_second() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_ParagraphDataTransaction::set_has_second() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_has_second() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 UndoTransaction_ParagraphDataTransaction::second() const {
  return second_;
}
inline void UndoTransaction_ParagraphDataTransaction::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
}

// required uint32 char_index = 4;
inline bool UndoTransaction_ParagraphDataTransaction::has_char_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UndoTransaction_ParagraphDataTransaction::set_has_char_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UndoTransaction_ParagraphDataTransaction::clear_char_index() {
  char_index_ = 0u;
  clear_has_char_index();
}
inline ::google::protobuf::uint32 UndoTransaction_ParagraphDataTransaction::char_index() const {
  return char_index_;
}
inline void UndoTransaction_ParagraphDataTransaction::set_char_index(::google::protobuf::uint32 value) {
  set_has_char_index();
  char_index_ = value;
}

// -------------------------------------------------------------------

// UndoTransaction_ObjectDOLCTransaction

// required uint32 flags = 1;
inline bool UndoTransaction_ObjectDOLCTransaction::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_ObjectDOLCTransaction::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_ObjectDOLCTransaction::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_ObjectDOLCTransaction::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 UndoTransaction_ObjectDOLCTransaction::flags() const {
  return flags_;
}
inline void UndoTransaction_ObjectDOLCTransaction::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional .TSP.Reference object = 2;
inline bool UndoTransaction_ObjectDOLCTransaction::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_ObjectDOLCTransaction::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_ObjectDOLCTransaction::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_ObjectDOLCTransaction::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& UndoTransaction_ObjectDOLCTransaction::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* UndoTransaction_ObjectDOLCTransaction::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* UndoTransaction_ObjectDOLCTransaction::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void UndoTransaction_ObjectDOLCTransaction::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// -------------------------------------------------------------------

// UndoTransaction_CTDateTransaction

// required uint32 attribute_index = 1;
inline bool UndoTransaction_CTDateTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_CTDateTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_CTDateTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_CTDateTransaction::clear_attribute_index() {
  attribute_index_ = 0u;
  clear_has_attribute_index();
}
inline ::google::protobuf::uint32 UndoTransaction_CTDateTransaction::attribute_index() const {
  return attribute_index_;
}
inline void UndoTransaction_CTDateTransaction::set_attribute_index(::google::protobuf::uint32 value) {
  set_has_attribute_index();
  attribute_index_ = value;
}

// optional .TSP.Date date = 2;
inline bool UndoTransaction_CTDateTransaction::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_CTDateTransaction::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_CTDateTransaction::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_CTDateTransaction::clear_date() {
  if (date_ != NULL) date_->::TSP::Date::Clear();
  clear_has_date();
}
inline const ::TSP::Date& UndoTransaction_CTDateTransaction::date() const {
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::TSP::Date* UndoTransaction_CTDateTransaction::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::TSP::Date;
  return date_;
}
inline ::TSP::Date* UndoTransaction_CTDateTransaction::release_date() {
  clear_has_date();
  ::TSP::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void UndoTransaction_CTDateTransaction::set_allocated_date(::TSP::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
}

// -------------------------------------------------------------------

// UndoTransaction_UnionTransaction

// required .TSWP.UndoTransaction.UndoKind kind = 1;
inline bool UndoTransaction_UnionTransaction::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransaction_UnionTransaction::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransaction_UnionTransaction::clear_kind() {
  kind_ = 1;
  clear_has_kind();
}
inline ::TSWP::UndoTransaction_UndoKind UndoTransaction_UnionTransaction::kind() const {
  return static_cast< ::TSWP::UndoTransaction_UndoKind >(kind_);
}
inline void UndoTransaction_UnionTransaction::set_kind(::TSWP::UndoTransaction_UndoKind value) {
  assert(::TSWP::UndoTransaction_UndoKind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional uint32 table = 2;
inline bool UndoTransaction_UnionTransaction::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoTransaction_UnionTransaction::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoTransaction_UnionTransaction::clear_table() {
  table_ = 0u;
  clear_has_table();
}
inline ::google::protobuf::uint32 UndoTransaction_UnionTransaction::table() const {
  return table_;
}
inline void UndoTransaction_UnionTransaction::set_table(::google::protobuf::uint32 value) {
  set_has_table();
  table_ = value;
}

// optional .TSWP.UndoTransaction.GenericTransaction generic = 5;
inline bool UndoTransaction_UnionTransaction::has_generic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_generic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoTransaction_UnionTransaction::clear_has_generic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoTransaction_UnionTransaction::clear_generic() {
  if (generic_ != NULL) generic_->::TSWP::UndoTransaction_GenericTransaction::Clear();
  clear_has_generic();
}
inline const ::TSWP::UndoTransaction_GenericTransaction& UndoTransaction_UnionTransaction::generic() const {
  return generic_ != NULL ? *generic_ : *default_instance_->generic_;
}
inline ::TSWP::UndoTransaction_GenericTransaction* UndoTransaction_UnionTransaction::mutable_generic() {
  set_has_generic();
  if (generic_ == NULL) generic_ = new ::TSWP::UndoTransaction_GenericTransaction;
  return generic_;
}
inline ::TSWP::UndoTransaction_GenericTransaction* UndoTransaction_UnionTransaction::release_generic() {
  clear_has_generic();
  ::TSWP::UndoTransaction_GenericTransaction* temp = generic_;
  generic_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_generic(::TSWP::UndoTransaction_GenericTransaction* generic) {
  delete generic_;
  generic_ = generic;
  if (generic) {
    set_has_generic();
  } else {
    clear_has_generic();
  }
}

// optional .TSWP.UndoTransaction.TextTransaction text = 6;
inline bool UndoTransaction_UnionTransaction::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UndoTransaction_UnionTransaction::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UndoTransaction_UnionTransaction::clear_text() {
  if (text_ != NULL) text_->::TSWP::UndoTransaction_TextTransaction::Clear();
  clear_has_text();
}
inline const ::TSWP::UndoTransaction_TextTransaction& UndoTransaction_UnionTransaction::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::TSWP::UndoTransaction_TextTransaction* UndoTransaction_UnionTransaction::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::TSWP::UndoTransaction_TextTransaction;
  return text_;
}
inline ::TSWP::UndoTransaction_TextTransaction* UndoTransaction_UnionTransaction::release_text() {
  clear_has_text();
  ::TSWP::UndoTransaction_TextTransaction* temp = text_;
  text_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_text(::TSWP::UndoTransaction_TextTransaction* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// optional .TSWP.UndoTransaction.CharIndexTransaction char_index = 7;
inline bool UndoTransaction_UnionTransaction::has_char_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_char_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UndoTransaction_UnionTransaction::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UndoTransaction_UnionTransaction::clear_char_index() {
  if (char_index_ != NULL) char_index_->::TSWP::UndoTransaction_CharIndexTransaction::Clear();
  clear_has_char_index();
}
inline const ::TSWP::UndoTransaction_CharIndexTransaction& UndoTransaction_UnionTransaction::char_index() const {
  return char_index_ != NULL ? *char_index_ : *default_instance_->char_index_;
}
inline ::TSWP::UndoTransaction_CharIndexTransaction* UndoTransaction_UnionTransaction::mutable_char_index() {
  set_has_char_index();
  if (char_index_ == NULL) char_index_ = new ::TSWP::UndoTransaction_CharIndexTransaction;
  return char_index_;
}
inline ::TSWP::UndoTransaction_CharIndexTransaction* UndoTransaction_UnionTransaction::release_char_index() {
  clear_has_char_index();
  ::TSWP::UndoTransaction_CharIndexTransaction* temp = char_index_;
  char_index_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_char_index(::TSWP::UndoTransaction_CharIndexTransaction* char_index) {
  delete char_index_;
  char_index_ = char_index;
  if (char_index) {
    set_has_char_index();
  } else {
    clear_has_char_index();
  }
}

// optional .TSWP.UndoTransaction.ReplaceCharIndexTransaction replace_char_index = 8;
inline bool UndoTransaction_UnionTransaction::has_replace_char_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_replace_char_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UndoTransaction_UnionTransaction::clear_has_replace_char_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UndoTransaction_UnionTransaction::clear_replace_char_index() {
  if (replace_char_index_ != NULL) replace_char_index_->::TSWP::UndoTransaction_ReplaceCharIndexTransaction::Clear();
  clear_has_replace_char_index();
}
inline const ::TSWP::UndoTransaction_ReplaceCharIndexTransaction& UndoTransaction_UnionTransaction::replace_char_index() const {
  return replace_char_index_ != NULL ? *replace_char_index_ : *default_instance_->replace_char_index_;
}
inline ::TSWP::UndoTransaction_ReplaceCharIndexTransaction* UndoTransaction_UnionTransaction::mutable_replace_char_index() {
  set_has_replace_char_index();
  if (replace_char_index_ == NULL) replace_char_index_ = new ::TSWP::UndoTransaction_ReplaceCharIndexTransaction;
  return replace_char_index_;
}
inline ::TSWP::UndoTransaction_ReplaceCharIndexTransaction* UndoTransaction_UnionTransaction::release_replace_char_index() {
  clear_has_replace_char_index();
  ::TSWP::UndoTransaction_ReplaceCharIndexTransaction* temp = replace_char_index_;
  replace_char_index_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_replace_char_index(::TSWP::UndoTransaction_ReplaceCharIndexTransaction* replace_char_index) {
  delete replace_char_index_;
  replace_char_index_ = replace_char_index;
  if (replace_char_index) {
    set_has_replace_char_index();
  } else {
    clear_has_replace_char_index();
  }
}

// optional .TSWP.UndoTransaction.AttributeIndexTransaction attribute_index = 9;
inline bool UndoTransaction_UnionTransaction::has_attribute_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_attribute_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UndoTransaction_UnionTransaction::clear_has_attribute_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UndoTransaction_UnionTransaction::clear_attribute_index() {
  if (attribute_index_ != NULL) attribute_index_->::TSWP::UndoTransaction_AttributeIndexTransaction::Clear();
  clear_has_attribute_index();
}
inline const ::TSWP::UndoTransaction_AttributeIndexTransaction& UndoTransaction_UnionTransaction::attribute_index() const {
  return attribute_index_ != NULL ? *attribute_index_ : *default_instance_->attribute_index_;
}
inline ::TSWP::UndoTransaction_AttributeIndexTransaction* UndoTransaction_UnionTransaction::mutable_attribute_index() {
  set_has_attribute_index();
  if (attribute_index_ == NULL) attribute_index_ = new ::TSWP::UndoTransaction_AttributeIndexTransaction;
  return attribute_index_;
}
inline ::TSWP::UndoTransaction_AttributeIndexTransaction* UndoTransaction_UnionTransaction::release_attribute_index() {
  clear_has_attribute_index();
  ::TSWP::UndoTransaction_AttributeIndexTransaction* temp = attribute_index_;
  attribute_index_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_attribute_index(::TSWP::UndoTransaction_AttributeIndexTransaction* attribute_index) {
  delete attribute_index_;
  attribute_index_ = attribute_index;
  if (attribute_index) {
    set_has_attribute_index();
  } else {
    clear_has_attribute_index();
  }
}

// optional .TSWP.UndoTransaction.InsertNilTransaction insert_nil = 10;
inline bool UndoTransaction_UnionTransaction::has_insert_nil() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_insert_nil() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UndoTransaction_UnionTransaction::clear_has_insert_nil() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UndoTransaction_UnionTransaction::clear_insert_nil() {
  if (insert_nil_ != NULL) insert_nil_->::TSWP::UndoTransaction_InsertNilTransaction::Clear();
  clear_has_insert_nil();
}
inline const ::TSWP::UndoTransaction_InsertNilTransaction& UndoTransaction_UnionTransaction::insert_nil() const {
  return insert_nil_ != NULL ? *insert_nil_ : *default_instance_->insert_nil_;
}
inline ::TSWP::UndoTransaction_InsertNilTransaction* UndoTransaction_UnionTransaction::mutable_insert_nil() {
  set_has_insert_nil();
  if (insert_nil_ == NULL) insert_nil_ = new ::TSWP::UndoTransaction_InsertNilTransaction;
  return insert_nil_;
}
inline ::TSWP::UndoTransaction_InsertNilTransaction* UndoTransaction_UnionTransaction::release_insert_nil() {
  clear_has_insert_nil();
  ::TSWP::UndoTransaction_InsertNilTransaction* temp = insert_nil_;
  insert_nil_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_insert_nil(::TSWP::UndoTransaction_InsertNilTransaction* insert_nil) {
  delete insert_nil_;
  insert_nil_ = insert_nil;
  if (insert_nil) {
    set_has_insert_nil();
  } else {
    clear_has_insert_nil();
  }
}

// optional .TSWP.UndoTransaction.InsertAttributeTransaction insert_attribute = 11;
inline bool UndoTransaction_UnionTransaction::has_insert_attribute() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_insert_attribute() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UndoTransaction_UnionTransaction::clear_has_insert_attribute() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UndoTransaction_UnionTransaction::clear_insert_attribute() {
  if (insert_attribute_ != NULL) insert_attribute_->::TSWP::UndoTransaction_InsertAttributeTransaction::Clear();
  clear_has_insert_attribute();
}
inline const ::TSWP::UndoTransaction_InsertAttributeTransaction& UndoTransaction_UnionTransaction::insert_attribute() const {
  return insert_attribute_ != NULL ? *insert_attribute_ : *default_instance_->insert_attribute_;
}
inline ::TSWP::UndoTransaction_InsertAttributeTransaction* UndoTransaction_UnionTransaction::mutable_insert_attribute() {
  set_has_insert_attribute();
  if (insert_attribute_ == NULL) insert_attribute_ = new ::TSWP::UndoTransaction_InsertAttributeTransaction;
  return insert_attribute_;
}
inline ::TSWP::UndoTransaction_InsertAttributeTransaction* UndoTransaction_UnionTransaction::release_insert_attribute() {
  clear_has_insert_attribute();
  ::TSWP::UndoTransaction_InsertAttributeTransaction* temp = insert_attribute_;
  insert_attribute_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_insert_attribute(::TSWP::UndoTransaction_InsertAttributeTransaction* insert_attribute) {
  delete insert_attribute_;
  insert_attribute_ = insert_attribute;
  if (insert_attribute) {
    set_has_insert_attribute();
  } else {
    clear_has_insert_attribute();
  }
}

// optional .TSWP.UndoTransaction.CharDeltaTransaction char_delta = 12;
inline bool UndoTransaction_UnionTransaction::has_char_delta() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_char_delta() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UndoTransaction_UnionTransaction::clear_has_char_delta() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UndoTransaction_UnionTransaction::clear_char_delta() {
  if (char_delta_ != NULL) char_delta_->::TSWP::UndoTransaction_CharDeltaTransaction::Clear();
  clear_has_char_delta();
}
inline const ::TSWP::UndoTransaction_CharDeltaTransaction& UndoTransaction_UnionTransaction::char_delta() const {
  return char_delta_ != NULL ? *char_delta_ : *default_instance_->char_delta_;
}
inline ::TSWP::UndoTransaction_CharDeltaTransaction* UndoTransaction_UnionTransaction::mutable_char_delta() {
  set_has_char_delta();
  if (char_delta_ == NULL) char_delta_ = new ::TSWP::UndoTransaction_CharDeltaTransaction;
  return char_delta_;
}
inline ::TSWP::UndoTransaction_CharDeltaTransaction* UndoTransaction_UnionTransaction::release_char_delta() {
  clear_has_char_delta();
  ::TSWP::UndoTransaction_CharDeltaTransaction* temp = char_delta_;
  char_delta_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_char_delta(::TSWP::UndoTransaction_CharDeltaTransaction* char_delta) {
  delete char_delta_;
  char_delta_ = char_delta;
  if (char_delta) {
    set_has_char_delta();
  } else {
    clear_has_char_delta();
  }
}

// optional .TSWP.UndoTransaction.ParagraphDataTransaction paragraph_data = 13;
inline bool UndoTransaction_UnionTransaction::has_paragraph_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_paragraph_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UndoTransaction_UnionTransaction::clear_has_paragraph_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UndoTransaction_UnionTransaction::clear_paragraph_data() {
  if (paragraph_data_ != NULL) paragraph_data_->::TSWP::UndoTransaction_ParagraphDataTransaction::Clear();
  clear_has_paragraph_data();
}
inline const ::TSWP::UndoTransaction_ParagraphDataTransaction& UndoTransaction_UnionTransaction::paragraph_data() const {
  return paragraph_data_ != NULL ? *paragraph_data_ : *default_instance_->paragraph_data_;
}
inline ::TSWP::UndoTransaction_ParagraphDataTransaction* UndoTransaction_UnionTransaction::mutable_paragraph_data() {
  set_has_paragraph_data();
  if (paragraph_data_ == NULL) paragraph_data_ = new ::TSWP::UndoTransaction_ParagraphDataTransaction;
  return paragraph_data_;
}
inline ::TSWP::UndoTransaction_ParagraphDataTransaction* UndoTransaction_UnionTransaction::release_paragraph_data() {
  clear_has_paragraph_data();
  ::TSWP::UndoTransaction_ParagraphDataTransaction* temp = paragraph_data_;
  paragraph_data_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_paragraph_data(::TSWP::UndoTransaction_ParagraphDataTransaction* paragraph_data) {
  delete paragraph_data_;
  paragraph_data_ = paragraph_data;
  if (paragraph_data) {
    set_has_paragraph_data();
  } else {
    clear_has_paragraph_data();
  }
}

// optional .TSWP.UndoTransaction.ObjectDOLCTransaction object_dolc = 14;
inline bool UndoTransaction_UnionTransaction::has_object_dolc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_object_dolc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UndoTransaction_UnionTransaction::clear_has_object_dolc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UndoTransaction_UnionTransaction::clear_object_dolc() {
  if (object_dolc_ != NULL) object_dolc_->::TSWP::UndoTransaction_ObjectDOLCTransaction::Clear();
  clear_has_object_dolc();
}
inline const ::TSWP::UndoTransaction_ObjectDOLCTransaction& UndoTransaction_UnionTransaction::object_dolc() const {
  return object_dolc_ != NULL ? *object_dolc_ : *default_instance_->object_dolc_;
}
inline ::TSWP::UndoTransaction_ObjectDOLCTransaction* UndoTransaction_UnionTransaction::mutable_object_dolc() {
  set_has_object_dolc();
  if (object_dolc_ == NULL) object_dolc_ = new ::TSWP::UndoTransaction_ObjectDOLCTransaction;
  return object_dolc_;
}
inline ::TSWP::UndoTransaction_ObjectDOLCTransaction* UndoTransaction_UnionTransaction::release_object_dolc() {
  clear_has_object_dolc();
  ::TSWP::UndoTransaction_ObjectDOLCTransaction* temp = object_dolc_;
  object_dolc_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_object_dolc(::TSWP::UndoTransaction_ObjectDOLCTransaction* object_dolc) {
  delete object_dolc_;
  object_dolc_ = object_dolc;
  if (object_dolc) {
    set_has_object_dolc();
  } else {
    clear_has_object_dolc();
  }
}

// optional .TSWP.UndoTransaction.CTDateTransaction ct_date = 15;
inline bool UndoTransaction_UnionTransaction::has_ct_date() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UndoTransaction_UnionTransaction::set_has_ct_date() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UndoTransaction_UnionTransaction::clear_has_ct_date() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UndoTransaction_UnionTransaction::clear_ct_date() {
  if (ct_date_ != NULL) ct_date_->::TSWP::UndoTransaction_CTDateTransaction::Clear();
  clear_has_ct_date();
}
inline const ::TSWP::UndoTransaction_CTDateTransaction& UndoTransaction_UnionTransaction::ct_date() const {
  return ct_date_ != NULL ? *ct_date_ : *default_instance_->ct_date_;
}
inline ::TSWP::UndoTransaction_CTDateTransaction* UndoTransaction_UnionTransaction::mutable_ct_date() {
  set_has_ct_date();
  if (ct_date_ == NULL) ct_date_ = new ::TSWP::UndoTransaction_CTDateTransaction;
  return ct_date_;
}
inline ::TSWP::UndoTransaction_CTDateTransaction* UndoTransaction_UnionTransaction::release_ct_date() {
  clear_has_ct_date();
  ::TSWP::UndoTransaction_CTDateTransaction* temp = ct_date_;
  ct_date_ = NULL;
  return temp;
}
inline void UndoTransaction_UnionTransaction::set_allocated_ct_date(::TSWP::UndoTransaction_CTDateTransaction* ct_date) {
  delete ct_date_;
  ct_date_ = ct_date;
  if (ct_date) {
    set_has_ct_date();
  } else {
    clear_has_ct_date();
  }
}

// -------------------------------------------------------------------

// UndoTransaction

// repeated .TSWP.UndoTransaction.UnionTransaction entries = 1;
inline int UndoTransaction::entries_size() const {
  return entries_.size();
}
inline void UndoTransaction::clear_entries() {
  entries_.Clear();
}
inline const ::TSWP::UndoTransaction_UnionTransaction& UndoTransaction::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSWP::UndoTransaction_UnionTransaction* UndoTransaction::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSWP::UndoTransaction_UnionTransaction* UndoTransaction::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::UndoTransaction_UnionTransaction >&
UndoTransaction::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::UndoTransaction_UnionTransaction >*
UndoTransaction::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// UndoTransactionWrapperArchive

// required .TSWP.UndoTransaction undo_transaction = 1;
inline bool UndoTransactionWrapperArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoTransactionWrapperArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoTransactionWrapperArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoTransactionWrapperArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& UndoTransactionWrapperArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* UndoTransactionWrapperArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* UndoTransactionWrapperArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void UndoTransactionWrapperArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ShapeInfoArchive

// required .TSD.ShapeArchive super = 1;
inline bool ShapeInfoArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeInfoArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeInfoArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeInfoArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::ShapeArchive::Clear();
  clear_has_super();
}
inline const ::TSD::ShapeArchive& ShapeInfoArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::ShapeArchive* ShapeInfoArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::ShapeArchive;
  return super_;
}
inline ::TSD::ShapeArchive* ShapeInfoArchive::release_super() {
  clear_has_super();
  ::TSD::ShapeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeInfoArchive::set_allocated_super(::TSD::ShapeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference containedStorage = 2;
inline bool ShapeInfoArchive::has_containedstorage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeInfoArchive::set_has_containedstorage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeInfoArchive::clear_has_containedstorage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeInfoArchive::clear_containedstorage() {
  if (containedstorage_ != NULL) containedstorage_->::TSP::Reference::Clear();
  clear_has_containedstorage();
}
inline const ::TSP::Reference& ShapeInfoArchive::containedstorage() const {
  return containedstorage_ != NULL ? *containedstorage_ : *default_instance_->containedstorage_;
}
inline ::TSP::Reference* ShapeInfoArchive::mutable_containedstorage() {
  set_has_containedstorage();
  if (containedstorage_ == NULL) containedstorage_ = new ::TSP::Reference;
  return containedstorage_;
}
inline ::TSP::Reference* ShapeInfoArchive::release_containedstorage() {
  clear_has_containedstorage();
  ::TSP::Reference* temp = containedstorage_;
  containedstorage_ = NULL;
  return temp;
}
inline void ShapeInfoArchive::set_allocated_containedstorage(::TSP::Reference* containedstorage) {
  delete containedstorage_;
  containedstorage_ = containedstorage;
  if (containedstorage) {
    set_has_containedstorage();
  } else {
    clear_has_containedstorage();
  }
}

// -------------------------------------------------------------------

// CommentInfoArchive

// required .TSWP.ShapeInfoArchive super = 1;
inline bool CommentInfoArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentInfoArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentInfoArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentInfoArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::ShapeInfoArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::ShapeInfoArchive& CommentInfoArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::ShapeInfoArchive* CommentInfoArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::ShapeInfoArchive;
  return super_;
}
inline ::TSWP::ShapeInfoArchive* CommentInfoArchive::release_super() {
  clear_has_super();
  ::TSWP::ShapeInfoArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommentInfoArchive::set_allocated_super(::TSWP::ShapeInfoArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference comment_storage = 2;
inline bool CommentInfoArchive::has_comment_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentInfoArchive::set_has_comment_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentInfoArchive::clear_has_comment_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentInfoArchive::clear_comment_storage() {
  if (comment_storage_ != NULL) comment_storage_->::TSP::Reference::Clear();
  clear_has_comment_storage();
}
inline const ::TSP::Reference& CommentInfoArchive::comment_storage() const {
  return comment_storage_ != NULL ? *comment_storage_ : *default_instance_->comment_storage_;
}
inline ::TSP::Reference* CommentInfoArchive::mutable_comment_storage() {
  set_has_comment_storage();
  if (comment_storage_ == NULL) comment_storage_ = new ::TSP::Reference;
  return comment_storage_;
}
inline ::TSP::Reference* CommentInfoArchive::release_comment_storage() {
  clear_has_comment_storage();
  ::TSP::Reference* temp = comment_storage_;
  comment_storage_ = NULL;
  return temp;
}
inline void CommentInfoArchive::set_allocated_comment_storage(::TSP::Reference* comment_storage) {
  delete comment_storage_;
  comment_storage_ = comment_storage;
  if (comment_storage) {
    set_has_comment_storage();
  } else {
    clear_has_comment_storage();
  }
}

// -------------------------------------------------------------------

// TOCInfoArchive

// required .TSWP.ShapeInfoArchive super = 1;
inline bool TOCInfoArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCInfoArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCInfoArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCInfoArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::ShapeInfoArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::ShapeInfoArchive& TOCInfoArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::ShapeInfoArchive* TOCInfoArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::ShapeInfoArchive;
  return super_;
}
inline ::TSWP::ShapeInfoArchive* TOCInfoArchive::release_super() {
  clear_has_super();
  ::TSWP::ShapeInfoArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TOCInfoArchive::set_allocated_super(::TSWP::ShapeInfoArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference toc_settings = 2;
inline bool TOCInfoArchive::has_toc_settings() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCInfoArchive::set_has_toc_settings() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCInfoArchive::clear_has_toc_settings() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCInfoArchive::clear_toc_settings() {
  if (toc_settings_ != NULL) toc_settings_->::TSP::Reference::Clear();
  clear_has_toc_settings();
}
inline const ::TSP::Reference& TOCInfoArchive::toc_settings() const {
  return toc_settings_ != NULL ? *toc_settings_ : *default_instance_->toc_settings_;
}
inline ::TSP::Reference* TOCInfoArchive::mutable_toc_settings() {
  set_has_toc_settings();
  if (toc_settings_ == NULL) toc_settings_ = new ::TSP::Reference;
  return toc_settings_;
}
inline ::TSP::Reference* TOCInfoArchive::release_toc_settings() {
  clear_has_toc_settings();
  ::TSP::Reference* temp = toc_settings_;
  toc_settings_ = NULL;
  return temp;
}
inline void TOCInfoArchive::set_allocated_toc_settings(::TSP::Reference* toc_settings) {
  delete toc_settings_;
  toc_settings_ = toc_settings;
  if (toc_settings) {
    set_has_toc_settings();
  } else {
    clear_has_toc_settings();
  }
}

// repeated .TSP.Reference toc_entry_data = 3;
inline int TOCInfoArchive::toc_entry_data_size() const {
  return toc_entry_data_.size();
}
inline void TOCInfoArchive::clear_toc_entry_data() {
  toc_entry_data_.Clear();
}
inline const ::TSP::Reference& TOCInfoArchive::toc_entry_data(int index) const {
  return toc_entry_data_.Get(index);
}
inline ::TSP::Reference* TOCInfoArchive::mutable_toc_entry_data(int index) {
  return toc_entry_data_.Mutable(index);
}
inline ::TSP::Reference* TOCInfoArchive::add_toc_entry_data() {
  return toc_entry_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
TOCInfoArchive::toc_entry_data() const {
  return toc_entry_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
TOCInfoArchive::mutable_toc_entry_data() {
  return &toc_entry_data_;
}

// repeated .TSP.Range page_number_ranges = 4;
inline int TOCInfoArchive::page_number_ranges_size() const {
  return page_number_ranges_.size();
}
inline void TOCInfoArchive::clear_page_number_ranges() {
  page_number_ranges_.Clear();
}
inline const ::TSP::Range& TOCInfoArchive::page_number_ranges(int index) const {
  return page_number_ranges_.Get(index);
}
inline ::TSP::Range* TOCInfoArchive::mutable_page_number_ranges(int index) {
  return page_number_ranges_.Mutable(index);
}
inline ::TSP::Range* TOCInfoArchive::add_page_number_ranges() {
  return page_number_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Range >&
TOCInfoArchive::page_number_ranges() const {
  return page_number_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Range >*
TOCInfoArchive::mutable_page_number_ranges() {
  return &page_number_ranges_;
}

// -------------------------------------------------------------------

// TOCLayoutHintArchive

// required .TSP.Range charRange = 1;
inline bool TOCLayoutHintArchive::has_charrange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCLayoutHintArchive::set_has_charrange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCLayoutHintArchive::clear_has_charrange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCLayoutHintArchive::clear_charrange() {
  if (charrange_ != NULL) charrange_->::TSP::Range::Clear();
  clear_has_charrange();
}
inline const ::TSP::Range& TOCLayoutHintArchive::charrange() const {
  return charrange_ != NULL ? *charrange_ : *default_instance_->charrange_;
}
inline ::TSP::Range* TOCLayoutHintArchive::mutable_charrange() {
  set_has_charrange();
  if (charrange_ == NULL) charrange_ = new ::TSP::Range;
  return charrange_;
}
inline ::TSP::Range* TOCLayoutHintArchive::release_charrange() {
  clear_has_charrange();
  ::TSP::Range* temp = charrange_;
  charrange_ = NULL;
  return temp;
}
inline void TOCLayoutHintArchive::set_allocated_charrange(::TSP::Range* charrange) {
  delete charrange_;
  charrange_ = charrange;
  if (charrange) {
    set_has_charrange();
  } else {
    clear_has_charrange();
  }
}

// -------------------------------------------------------------------

// TextualAttachmentArchive

// optional string string_equivalent = 1;
inline bool TextualAttachmentArchive::has_string_equivalent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextualAttachmentArchive::set_has_string_equivalent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextualAttachmentArchive::clear_has_string_equivalent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextualAttachmentArchive::clear_string_equivalent() {
  if (string_equivalent_ != &::google::protobuf::internal::kEmptyString) {
    string_equivalent_->clear();
  }
  clear_has_string_equivalent();
}
inline const ::std::string& TextualAttachmentArchive::string_equivalent() const {
  return *string_equivalent_;
}
inline void TextualAttachmentArchive::set_string_equivalent(const ::std::string& value) {
  set_has_string_equivalent();
  if (string_equivalent_ == &::google::protobuf::internal::kEmptyString) {
    string_equivalent_ = new ::std::string;
  }
  string_equivalent_->assign(value);
}
inline void TextualAttachmentArchive::set_string_equivalent(const char* value) {
  set_has_string_equivalent();
  if (string_equivalent_ == &::google::protobuf::internal::kEmptyString) {
    string_equivalent_ = new ::std::string;
  }
  string_equivalent_->assign(value);
}
inline void TextualAttachmentArchive::set_string_equivalent(const char* value, size_t size) {
  set_has_string_equivalent();
  if (string_equivalent_ == &::google::protobuf::internal::kEmptyString) {
    string_equivalent_ = new ::std::string;
  }
  string_equivalent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextualAttachmentArchive::mutable_string_equivalent() {
  set_has_string_equivalent();
  if (string_equivalent_ == &::google::protobuf::internal::kEmptyString) {
    string_equivalent_ = new ::std::string;
  }
  return string_equivalent_;
}
inline ::std::string* TextualAttachmentArchive::release_string_equivalent() {
  clear_has_string_equivalent();
  if (string_equivalent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_equivalent_;
    string_equivalent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextualAttachmentArchive::set_allocated_string_equivalent(::std::string* string_equivalent) {
  if (string_equivalent_ != &::google::protobuf::internal::kEmptyString) {
    delete string_equivalent_;
  }
  if (string_equivalent) {
    set_has_string_equivalent();
    string_equivalent_ = string_equivalent;
  } else {
    clear_has_string_equivalent();
    string_equivalent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.TextualAttachmentArchive.Kind kind = 2;
inline bool TextualAttachmentArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextualAttachmentArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextualAttachmentArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextualAttachmentArchive::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::TSWP::TextualAttachmentArchive_Kind TextualAttachmentArchive::kind() const {
  return static_cast< ::TSWP::TextualAttachmentArchive_Kind >(kind_);
}
inline void TextualAttachmentArchive::set_kind(::TSWP::TextualAttachmentArchive_Kind value) {
  assert(::TSWP::TextualAttachmentArchive_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// TSWPTOCPageNumberAttachmentArchive

// optional .TSWP.TextualAttachmentArchive super = 1;
inline bool TSWPTOCPageNumberAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSWPTOCPageNumberAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSWPTOCPageNumberAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSWPTOCPageNumberAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextualAttachmentArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextualAttachmentArchive& TSWPTOCPageNumberAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextualAttachmentArchive* TSWPTOCPageNumberAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextualAttachmentArchive;
  return super_;
}
inline ::TSWP::TextualAttachmentArchive* TSWPTOCPageNumberAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::TextualAttachmentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TSWPTOCPageNumberAttachmentArchive::set_allocated_super(::TSWP::TextualAttachmentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string page_number = 2;
inline bool TSWPTOCPageNumberAttachmentArchive::has_page_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSWPTOCPageNumberAttachmentArchive::set_has_page_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSWPTOCPageNumberAttachmentArchive::clear_has_page_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSWPTOCPageNumberAttachmentArchive::clear_page_number() {
  if (page_number_ != &::google::protobuf::internal::kEmptyString) {
    page_number_->clear();
  }
  clear_has_page_number();
}
inline const ::std::string& TSWPTOCPageNumberAttachmentArchive::page_number() const {
  return *page_number_;
}
inline void TSWPTOCPageNumberAttachmentArchive::set_page_number(const ::std::string& value) {
  set_has_page_number();
  if (page_number_ == &::google::protobuf::internal::kEmptyString) {
    page_number_ = new ::std::string;
  }
  page_number_->assign(value);
}
inline void TSWPTOCPageNumberAttachmentArchive::set_page_number(const char* value) {
  set_has_page_number();
  if (page_number_ == &::google::protobuf::internal::kEmptyString) {
    page_number_ = new ::std::string;
  }
  page_number_->assign(value);
}
inline void TSWPTOCPageNumberAttachmentArchive::set_page_number(const char* value, size_t size) {
  set_has_page_number();
  if (page_number_ == &::google::protobuf::internal::kEmptyString) {
    page_number_ = new ::std::string;
  }
  page_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSWPTOCPageNumberAttachmentArchive::mutable_page_number() {
  set_has_page_number();
  if (page_number_ == &::google::protobuf::internal::kEmptyString) {
    page_number_ = new ::std::string;
  }
  return page_number_;
}
inline ::std::string* TSWPTOCPageNumberAttachmentArchive::release_page_number() {
  clear_has_page_number();
  if (page_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_number_;
    page_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSWPTOCPageNumberAttachmentArchive::set_allocated_page_number(::std::string* page_number) {
  if (page_number_ != &::google::protobuf::internal::kEmptyString) {
    delete page_number_;
  }
  if (page_number) {
    set_has_page_number();
    page_number_ = page_number;
  } else {
    clear_has_page_number();
    page_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bookmark_name = 3;
inline bool TSWPTOCPageNumberAttachmentArchive::has_bookmark_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSWPTOCPageNumberAttachmentArchive::set_has_bookmark_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSWPTOCPageNumberAttachmentArchive::clear_has_bookmark_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSWPTOCPageNumberAttachmentArchive::clear_bookmark_name() {
  if (bookmark_name_ != &::google::protobuf::internal::kEmptyString) {
    bookmark_name_->clear();
  }
  clear_has_bookmark_name();
}
inline const ::std::string& TSWPTOCPageNumberAttachmentArchive::bookmark_name() const {
  return *bookmark_name_;
}
inline void TSWPTOCPageNumberAttachmentArchive::set_bookmark_name(const ::std::string& value) {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  bookmark_name_->assign(value);
}
inline void TSWPTOCPageNumberAttachmentArchive::set_bookmark_name(const char* value) {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  bookmark_name_->assign(value);
}
inline void TSWPTOCPageNumberAttachmentArchive::set_bookmark_name(const char* value, size_t size) {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  bookmark_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSWPTOCPageNumberAttachmentArchive::mutable_bookmark_name() {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  return bookmark_name_;
}
inline ::std::string* TSWPTOCPageNumberAttachmentArchive::release_bookmark_name() {
  clear_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bookmark_name_;
    bookmark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSWPTOCPageNumberAttachmentArchive::set_allocated_bookmark_name(::std::string* bookmark_name) {
  if (bookmark_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bookmark_name_;
  }
  if (bookmark_name) {
    set_has_bookmark_name();
    bookmark_name_ = bookmark_name;
  } else {
    clear_has_bookmark_name();
    bookmark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UIGraphicalAttachment

// -------------------------------------------------------------------

// DrawableAttachmentArchive

// optional .TSP.Reference drawable = 1;
inline bool DrawableAttachmentArchive::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableAttachmentArchive::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableAttachmentArchive::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableAttachmentArchive::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& DrawableAttachmentArchive::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* DrawableAttachmentArchive::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* DrawableAttachmentArchive::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void DrawableAttachmentArchive::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional uint32 h_offset_type = 2;
inline bool DrawableAttachmentArchive::has_h_offset_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableAttachmentArchive::set_has_h_offset_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableAttachmentArchive::clear_has_h_offset_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableAttachmentArchive::clear_h_offset_type() {
  h_offset_type_ = 0u;
  clear_has_h_offset_type();
}
inline ::google::protobuf::uint32 DrawableAttachmentArchive::h_offset_type() const {
  return h_offset_type_;
}
inline void DrawableAttachmentArchive::set_h_offset_type(::google::protobuf::uint32 value) {
  set_has_h_offset_type();
  h_offset_type_ = value;
}

// optional float h_offset = 3;
inline bool DrawableAttachmentArchive::has_h_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableAttachmentArchive::set_has_h_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableAttachmentArchive::clear_has_h_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableAttachmentArchive::clear_h_offset() {
  h_offset_ = 0;
  clear_has_h_offset();
}
inline float DrawableAttachmentArchive::h_offset() const {
  return h_offset_;
}
inline void DrawableAttachmentArchive::set_h_offset(float value) {
  set_has_h_offset();
  h_offset_ = value;
}

// optional uint32 v_offset_type = 4;
inline bool DrawableAttachmentArchive::has_v_offset_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawableAttachmentArchive::set_has_v_offset_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawableAttachmentArchive::clear_has_v_offset_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawableAttachmentArchive::clear_v_offset_type() {
  v_offset_type_ = 0u;
  clear_has_v_offset_type();
}
inline ::google::protobuf::uint32 DrawableAttachmentArchive::v_offset_type() const {
  return v_offset_type_;
}
inline void DrawableAttachmentArchive::set_v_offset_type(::google::protobuf::uint32 value) {
  set_has_v_offset_type();
  v_offset_type_ = value;
}

// optional float v_offset = 5;
inline bool DrawableAttachmentArchive::has_v_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DrawableAttachmentArchive::set_has_v_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DrawableAttachmentArchive::clear_has_v_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DrawableAttachmentArchive::clear_v_offset() {
  v_offset_ = 0;
  clear_has_v_offset();
}
inline float DrawableAttachmentArchive::v_offset() const {
  return v_offset_;
}
inline void DrawableAttachmentArchive::set_v_offset(float value) {
  set_has_v_offset();
  v_offset_ = value;
}

// -------------------------------------------------------------------

// TOCAttachmentArchive

// required .TSWP.DrawableAttachmentArchive super = 1;
inline bool TOCAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::DrawableAttachmentArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::DrawableAttachmentArchive& TOCAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::DrawableAttachmentArchive* TOCAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::DrawableAttachmentArchive;
  return super_;
}
inline ::TSWP::DrawableAttachmentArchive* TOCAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::DrawableAttachmentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TOCAttachmentArchive::set_allocated_super(::TSWP::DrawableAttachmentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// FootnoteReferenceAttachmentArchive

// optional .TSWP.TextualAttachmentArchive super = 1;
inline bool FootnoteReferenceAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FootnoteReferenceAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FootnoteReferenceAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FootnoteReferenceAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextualAttachmentArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextualAttachmentArchive& FootnoteReferenceAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextualAttachmentArchive* FootnoteReferenceAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextualAttachmentArchive;
  return super_;
}
inline ::TSWP::TextualAttachmentArchive* FootnoteReferenceAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::TextualAttachmentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FootnoteReferenceAttachmentArchive::set_allocated_super(::TSWP::TextualAttachmentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference contained_storage = 2;
inline bool FootnoteReferenceAttachmentArchive::has_contained_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FootnoteReferenceAttachmentArchive::set_has_contained_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FootnoteReferenceAttachmentArchive::clear_has_contained_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FootnoteReferenceAttachmentArchive::clear_contained_storage() {
  if (contained_storage_ != NULL) contained_storage_->::TSP::Reference::Clear();
  clear_has_contained_storage();
}
inline const ::TSP::Reference& FootnoteReferenceAttachmentArchive::contained_storage() const {
  return contained_storage_ != NULL ? *contained_storage_ : *default_instance_->contained_storage_;
}
inline ::TSP::Reference* FootnoteReferenceAttachmentArchive::mutable_contained_storage() {
  set_has_contained_storage();
  if (contained_storage_ == NULL) contained_storage_ = new ::TSP::Reference;
  return contained_storage_;
}
inline ::TSP::Reference* FootnoteReferenceAttachmentArchive::release_contained_storage() {
  clear_has_contained_storage();
  ::TSP::Reference* temp = contained_storage_;
  contained_storage_ = NULL;
  return temp;
}
inline void FootnoteReferenceAttachmentArchive::set_allocated_contained_storage(::TSP::Reference* contained_storage) {
  delete contained_storage_;
  contained_storage_ = contained_storage;
  if (contained_storage) {
    set_has_contained_storage();
  } else {
    clear_has_contained_storage();
  }
}

// optional string custom_mark_string = 3;
inline bool FootnoteReferenceAttachmentArchive::has_custom_mark_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FootnoteReferenceAttachmentArchive::set_has_custom_mark_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FootnoteReferenceAttachmentArchive::clear_has_custom_mark_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FootnoteReferenceAttachmentArchive::clear_custom_mark_string() {
  if (custom_mark_string_ != &::google::protobuf::internal::kEmptyString) {
    custom_mark_string_->clear();
  }
  clear_has_custom_mark_string();
}
inline const ::std::string& FootnoteReferenceAttachmentArchive::custom_mark_string() const {
  return *custom_mark_string_;
}
inline void FootnoteReferenceAttachmentArchive::set_custom_mark_string(const ::std::string& value) {
  set_has_custom_mark_string();
  if (custom_mark_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_mark_string_ = new ::std::string;
  }
  custom_mark_string_->assign(value);
}
inline void FootnoteReferenceAttachmentArchive::set_custom_mark_string(const char* value) {
  set_has_custom_mark_string();
  if (custom_mark_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_mark_string_ = new ::std::string;
  }
  custom_mark_string_->assign(value);
}
inline void FootnoteReferenceAttachmentArchive::set_custom_mark_string(const char* value, size_t size) {
  set_has_custom_mark_string();
  if (custom_mark_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_mark_string_ = new ::std::string;
  }
  custom_mark_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FootnoteReferenceAttachmentArchive::mutable_custom_mark_string() {
  set_has_custom_mark_string();
  if (custom_mark_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_mark_string_ = new ::std::string;
  }
  return custom_mark_string_;
}
inline ::std::string* FootnoteReferenceAttachmentArchive::release_custom_mark_string() {
  clear_has_custom_mark_string();
  if (custom_mark_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_mark_string_;
    custom_mark_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FootnoteReferenceAttachmentArchive::set_allocated_custom_mark_string(::std::string* custom_mark_string) {
  if (custom_mark_string_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_mark_string_;
  }
  if (custom_mark_string) {
    set_has_custom_mark_string();
    custom_mark_string_ = custom_mark_string;
  } else {
    clear_has_custom_mark_string();
    custom_mark_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NumberAttachmentArchive

// optional .TSWP.TextualAttachmentArchive super = 1;
inline bool NumberAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumberAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumberAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumberAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextualAttachmentArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextualAttachmentArchive& NumberAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextualAttachmentArchive* NumberAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextualAttachmentArchive;
  return super_;
}
inline ::TSWP::TextualAttachmentArchive* NumberAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::TextualAttachmentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void NumberAttachmentArchive::set_allocated_super(::TSWP::TextualAttachmentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 number_format = 2;
inline bool NumberAttachmentArchive::has_number_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NumberAttachmentArchive::set_has_number_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NumberAttachmentArchive::clear_has_number_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NumberAttachmentArchive::clear_number_format() {
  number_format_ = 0u;
  clear_has_number_format();
}
inline ::google::protobuf::uint32 NumberAttachmentArchive::number_format() const {
  return number_format_;
}
inline void NumberAttachmentArchive::set_number_format(::google::protobuf::uint32 value) {
  set_has_number_format();
  number_format_ = value;
}

// optional string string_value = 3;
inline bool NumberAttachmentArchive::has_string_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NumberAttachmentArchive::set_has_string_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NumberAttachmentArchive::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NumberAttachmentArchive::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& NumberAttachmentArchive::string_value() const {
  return *string_value_;
}
inline void NumberAttachmentArchive::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void NumberAttachmentArchive::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void NumberAttachmentArchive::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberAttachmentArchive::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* NumberAttachmentArchive::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NumberAttachmentArchive::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SmartFieldArchive

// -------------------------------------------------------------------

// HyperlinkFieldArchive

// optional .TSWP.SmartFieldArchive super = 1;
inline bool HyperlinkFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HyperlinkFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HyperlinkFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HyperlinkFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& HyperlinkFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* HyperlinkFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* HyperlinkFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void HyperlinkFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string url_ref = 2;
inline bool HyperlinkFieldArchive::has_url_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HyperlinkFieldArchive::set_has_url_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HyperlinkFieldArchive::clear_has_url_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HyperlinkFieldArchive::clear_url_ref() {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    url_ref_->clear();
  }
  clear_has_url_ref();
}
inline const ::std::string& HyperlinkFieldArchive::url_ref() const {
  return *url_ref_;
}
inline void HyperlinkFieldArchive::set_url_ref(const ::std::string& value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void HyperlinkFieldArchive::set_url_ref(const char* value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void HyperlinkFieldArchive::set_url_ref(const char* value, size_t size) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HyperlinkFieldArchive::mutable_url_ref() {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  return url_ref_;
}
inline ::std::string* HyperlinkFieldArchive::release_url_ref() {
  clear_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_ref_;
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HyperlinkFieldArchive::set_allocated_url_ref(::std::string* url_ref) {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    delete url_ref_;
  }
  if (url_ref) {
    set_has_url_ref();
    url_ref_ = url_ref;
  } else {
    clear_has_url_ref();
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlaceholderSmartFieldArchive

// optional .TSWP.SmartFieldArchive super = 1;
inline bool PlaceholderSmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaceholderSmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaceholderSmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaceholderSmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& PlaceholderSmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* PlaceholderSmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* PlaceholderSmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PlaceholderSmartFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool localizable = 2;
inline bool PlaceholderSmartFieldArchive::has_localizable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlaceholderSmartFieldArchive::set_has_localizable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlaceholderSmartFieldArchive::clear_has_localizable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlaceholderSmartFieldArchive::clear_localizable() {
  localizable_ = false;
  clear_has_localizable();
}
inline bool PlaceholderSmartFieldArchive::localizable() const {
  return localizable_;
}
inline void PlaceholderSmartFieldArchive::set_localizable(bool value) {
  set_has_localizable();
  localizable_ = value;
}

// -------------------------------------------------------------------

// UnsupportedHyperlinkFieldArchive

// optional .TSWP.PlaceholderSmartFieldArchive super = 1;
inline bool UnsupportedHyperlinkFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsupportedHyperlinkFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsupportedHyperlinkFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsupportedHyperlinkFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::PlaceholderSmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::PlaceholderSmartFieldArchive& UnsupportedHyperlinkFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* UnsupportedHyperlinkFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::PlaceholderSmartFieldArchive;
  return super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* UnsupportedHyperlinkFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::PlaceholderSmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void UnsupportedHyperlinkFieldArchive::set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string url_ref = 2;
inline bool UnsupportedHyperlinkFieldArchive::has_url_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnsupportedHyperlinkFieldArchive::set_has_url_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnsupportedHyperlinkFieldArchive::clear_has_url_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnsupportedHyperlinkFieldArchive::clear_url_ref() {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    url_ref_->clear();
  }
  clear_has_url_ref();
}
inline const ::std::string& UnsupportedHyperlinkFieldArchive::url_ref() const {
  return *url_ref_;
}
inline void UnsupportedHyperlinkFieldArchive::set_url_ref(const ::std::string& value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void UnsupportedHyperlinkFieldArchive::set_url_ref(const char* value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void UnsupportedHyperlinkFieldArchive::set_url_ref(const char* value, size_t size) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnsupportedHyperlinkFieldArchive::mutable_url_ref() {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  return url_ref_;
}
inline ::std::string* UnsupportedHyperlinkFieldArchive::release_url_ref() {
  clear_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_ref_;
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnsupportedHyperlinkFieldArchive::set_allocated_url_ref(::std::string* url_ref) {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    delete url_ref_;
  }
  if (url_ref) {
    set_has_url_ref();
    url_ref_ = url_ref;
  } else {
    clear_has_url_ref();
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BibliographySmartFieldArchive

// optional .TSWP.SmartFieldArchive super = 3;
inline bool BibliographySmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BibliographySmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BibliographySmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BibliographySmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& BibliographySmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* BibliographySmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* BibliographySmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void BibliographySmartFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference citation_records = 2;
inline int BibliographySmartFieldArchive::citation_records_size() const {
  return citation_records_.size();
}
inline void BibliographySmartFieldArchive::clear_citation_records() {
  citation_records_.Clear();
}
inline const ::TSP::Reference& BibliographySmartFieldArchive::citation_records(int index) const {
  return citation_records_.Get(index);
}
inline ::TSP::Reference* BibliographySmartFieldArchive::mutable_citation_records(int index) {
  return citation_records_.Mutable(index);
}
inline ::TSP::Reference* BibliographySmartFieldArchive::add_citation_records() {
  return citation_records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
BibliographySmartFieldArchive::citation_records() const {
  return citation_records_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
BibliographySmartFieldArchive::mutable_citation_records() {
  return &citation_records_;
}

// optional bool localizable = 4;
inline bool BibliographySmartFieldArchive::has_localizable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BibliographySmartFieldArchive::set_has_localizable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BibliographySmartFieldArchive::clear_has_localizable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BibliographySmartFieldArchive::clear_localizable() {
  localizable_ = false;
  clear_has_localizable();
}
inline bool BibliographySmartFieldArchive::localizable() const {
  return localizable_;
}
inline void BibliographySmartFieldArchive::set_localizable(bool value) {
  set_has_localizable();
  localizable_ = value;
}

// optional .TSWP.PlaceholderSmartFieldArchive old_super = 1;
inline bool BibliographySmartFieldArchive::has_old_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BibliographySmartFieldArchive::set_has_old_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BibliographySmartFieldArchive::clear_has_old_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BibliographySmartFieldArchive::clear_old_super() {
  if (old_super_ != NULL) old_super_->::TSWP::PlaceholderSmartFieldArchive::Clear();
  clear_has_old_super();
}
inline const ::TSWP::PlaceholderSmartFieldArchive& BibliographySmartFieldArchive::old_super() const {
  return old_super_ != NULL ? *old_super_ : *default_instance_->old_super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* BibliographySmartFieldArchive::mutable_old_super() {
  set_has_old_super();
  if (old_super_ == NULL) old_super_ = new ::TSWP::PlaceholderSmartFieldArchive;
  return old_super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* BibliographySmartFieldArchive::release_old_super() {
  clear_has_old_super();
  ::TSWP::PlaceholderSmartFieldArchive* temp = old_super_;
  old_super_ = NULL;
  return temp;
}
inline void BibliographySmartFieldArchive::set_allocated_old_super(::TSWP::PlaceholderSmartFieldArchive* old_super) {
  delete old_super_;
  old_super_ = old_super;
  if (old_super) {
    set_has_old_super();
  } else {
    clear_has_old_super();
  }
}

// -------------------------------------------------------------------

// CitationRecordArchive

// optional string endnote_xml = 1;
inline bool CitationRecordArchive::has_endnote_xml() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CitationRecordArchive::set_has_endnote_xml() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CitationRecordArchive::clear_has_endnote_xml() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CitationRecordArchive::clear_endnote_xml() {
  if (endnote_xml_ != &::google::protobuf::internal::kEmptyString) {
    endnote_xml_->clear();
  }
  clear_has_endnote_xml();
}
inline const ::std::string& CitationRecordArchive::endnote_xml() const {
  return *endnote_xml_;
}
inline void CitationRecordArchive::set_endnote_xml(const ::std::string& value) {
  set_has_endnote_xml();
  if (endnote_xml_ == &::google::protobuf::internal::kEmptyString) {
    endnote_xml_ = new ::std::string;
  }
  endnote_xml_->assign(value);
}
inline void CitationRecordArchive::set_endnote_xml(const char* value) {
  set_has_endnote_xml();
  if (endnote_xml_ == &::google::protobuf::internal::kEmptyString) {
    endnote_xml_ = new ::std::string;
  }
  endnote_xml_->assign(value);
}
inline void CitationRecordArchive::set_endnote_xml(const char* value, size_t size) {
  set_has_endnote_xml();
  if (endnote_xml_ == &::google::protobuf::internal::kEmptyString) {
    endnote_xml_ = new ::std::string;
  }
  endnote_xml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_endnote_xml() {
  set_has_endnote_xml();
  if (endnote_xml_ == &::google::protobuf::internal::kEmptyString) {
    endnote_xml_ = new ::std::string;
  }
  return endnote_xml_;
}
inline ::std::string* CitationRecordArchive::release_endnote_xml() {
  clear_has_endnote_xml();
  if (endnote_xml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endnote_xml_;
    endnote_xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_endnote_xml(::std::string* endnote_xml) {
  if (endnote_xml_ != &::google::protobuf::internal::kEmptyString) {
    delete endnote_xml_;
  }
  if (endnote_xml) {
    set_has_endnote_xml();
    endnote_xml_ = endnote_xml;
  } else {
    clear_has_endnote_xml();
    endnote_xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool hide_author_names = 2;
inline bool CitationRecordArchive::has_hide_author_names() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CitationRecordArchive::set_has_hide_author_names() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CitationRecordArchive::clear_has_hide_author_names() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CitationRecordArchive::clear_hide_author_names() {
  hide_author_names_ = false;
  clear_has_hide_author_names();
}
inline bool CitationRecordArchive::hide_author_names() const {
  return hide_author_names_;
}
inline void CitationRecordArchive::set_hide_author_names(bool value) {
  set_has_hide_author_names();
  hide_author_names_ = value;
}

// optional bool hide_year = 3;
inline bool CitationRecordArchive::has_hide_year() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CitationRecordArchive::set_has_hide_year() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CitationRecordArchive::clear_has_hide_year() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CitationRecordArchive::clear_hide_year() {
  hide_year_ = false;
  clear_has_hide_year();
}
inline bool CitationRecordArchive::hide_year() const {
  return hide_year_;
}
inline void CitationRecordArchive::set_hide_year(bool value) {
  set_has_hide_year();
  hide_year_ = value;
}

// optional string page_range = 4;
inline bool CitationRecordArchive::has_page_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CitationRecordArchive::set_has_page_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CitationRecordArchive::clear_has_page_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CitationRecordArchive::clear_page_range() {
  if (page_range_ != &::google::protobuf::internal::kEmptyString) {
    page_range_->clear();
  }
  clear_has_page_range();
}
inline const ::std::string& CitationRecordArchive::page_range() const {
  return *page_range_;
}
inline void CitationRecordArchive::set_page_range(const ::std::string& value) {
  set_has_page_range();
  if (page_range_ == &::google::protobuf::internal::kEmptyString) {
    page_range_ = new ::std::string;
  }
  page_range_->assign(value);
}
inline void CitationRecordArchive::set_page_range(const char* value) {
  set_has_page_range();
  if (page_range_ == &::google::protobuf::internal::kEmptyString) {
    page_range_ = new ::std::string;
  }
  page_range_->assign(value);
}
inline void CitationRecordArchive::set_page_range(const char* value, size_t size) {
  set_has_page_range();
  if (page_range_ == &::google::protobuf::internal::kEmptyString) {
    page_range_ = new ::std::string;
  }
  page_range_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_page_range() {
  set_has_page_range();
  if (page_range_ == &::google::protobuf::internal::kEmptyString) {
    page_range_ = new ::std::string;
  }
  return page_range_;
}
inline ::std::string* CitationRecordArchive::release_page_range() {
  clear_has_page_range();
  if (page_range_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_range_;
    page_range_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_page_range(::std::string* page_range) {
  if (page_range_ != &::google::protobuf::internal::kEmptyString) {
    delete page_range_;
  }
  if (page_range) {
    set_has_page_range();
    page_range_ = page_range;
  } else {
    clear_has_page_range();
    page_range_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string prefix = 5;
inline bool CitationRecordArchive::has_prefix() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CitationRecordArchive::set_has_prefix() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CitationRecordArchive::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CitationRecordArchive::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& CitationRecordArchive::prefix() const {
  return *prefix_;
}
inline void CitationRecordArchive::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void CitationRecordArchive::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void CitationRecordArchive::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* CitationRecordArchive::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suffix = 6;
inline bool CitationRecordArchive::has_suffix() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CitationRecordArchive::set_has_suffix() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CitationRecordArchive::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CitationRecordArchive::clear_suffix() {
  if (suffix_ != &::google::protobuf::internal::kEmptyString) {
    suffix_->clear();
  }
  clear_has_suffix();
}
inline const ::std::string& CitationRecordArchive::suffix() const {
  return *suffix_;
}
inline void CitationRecordArchive::set_suffix(const ::std::string& value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
}
inline void CitationRecordArchive::set_suffix(const char* value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
}
inline void CitationRecordArchive::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_suffix() {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  return suffix_;
}
inline ::std::string* CitationRecordArchive::release_suffix() {
  clear_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suffix_;
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_suffix(::std::string* suffix) {
  if (suffix_ != &::google::protobuf::internal::kEmptyString) {
    delete suffix_;
  }
  if (suffix) {
    set_has_suffix();
    suffix_ = suffix;
  } else {
    clear_has_suffix();
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authors_string = 7;
inline bool CitationRecordArchive::has_authors_string() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CitationRecordArchive::set_has_authors_string() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CitationRecordArchive::clear_has_authors_string() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CitationRecordArchive::clear_authors_string() {
  if (authors_string_ != &::google::protobuf::internal::kEmptyString) {
    authors_string_->clear();
  }
  clear_has_authors_string();
}
inline const ::std::string& CitationRecordArchive::authors_string() const {
  return *authors_string_;
}
inline void CitationRecordArchive::set_authors_string(const ::std::string& value) {
  set_has_authors_string();
  if (authors_string_ == &::google::protobuf::internal::kEmptyString) {
    authors_string_ = new ::std::string;
  }
  authors_string_->assign(value);
}
inline void CitationRecordArchive::set_authors_string(const char* value) {
  set_has_authors_string();
  if (authors_string_ == &::google::protobuf::internal::kEmptyString) {
    authors_string_ = new ::std::string;
  }
  authors_string_->assign(value);
}
inline void CitationRecordArchive::set_authors_string(const char* value, size_t size) {
  set_has_authors_string();
  if (authors_string_ == &::google::protobuf::internal::kEmptyString) {
    authors_string_ = new ::std::string;
  }
  authors_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_authors_string() {
  set_has_authors_string();
  if (authors_string_ == &::google::protobuf::internal::kEmptyString) {
    authors_string_ = new ::std::string;
  }
  return authors_string_;
}
inline ::std::string* CitationRecordArchive::release_authors_string() {
  clear_has_authors_string();
  if (authors_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authors_string_;
    authors_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_authors_string(::std::string* authors_string) {
  if (authors_string_ != &::google::protobuf::internal::kEmptyString) {
    delete authors_string_;
  }
  if (authors_string) {
    set_has_authors_string();
    authors_string_ = authors_string;
  } else {
    clear_has_authors_string();
    authors_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 8;
inline bool CitationRecordArchive::has_title() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CitationRecordArchive::set_has_title() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CitationRecordArchive::clear_has_title() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CitationRecordArchive::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& CitationRecordArchive::title() const {
  return *title_;
}
inline void CitationRecordArchive::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CitationRecordArchive::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CitationRecordArchive::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* CitationRecordArchive::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string year = 9;
inline bool CitationRecordArchive::has_year() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CitationRecordArchive::set_has_year() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CitationRecordArchive::clear_has_year() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CitationRecordArchive::clear_year() {
  if (year_ != &::google::protobuf::internal::kEmptyString) {
    year_->clear();
  }
  clear_has_year();
}
inline const ::std::string& CitationRecordArchive::year() const {
  return *year_;
}
inline void CitationRecordArchive::set_year(const ::std::string& value) {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  year_->assign(value);
}
inline void CitationRecordArchive::set_year(const char* value) {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  year_->assign(value);
}
inline void CitationRecordArchive::set_year(const char* value, size_t size) {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  year_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_year() {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  return year_;
}
inline ::std::string* CitationRecordArchive::release_year() {
  clear_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = year_;
    year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_year(::std::string* year) {
  if (year_ != &::google::protobuf::internal::kEmptyString) {
    delete year_;
  }
  if (year) {
    set_has_year();
    year_ = year;
  } else {
    clear_has_year();
    year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 10;
inline bool CitationRecordArchive::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CitationRecordArchive::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CitationRecordArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CitationRecordArchive::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& CitationRecordArchive::type() const {
  return *type_;
}
inline void CitationRecordArchive::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CitationRecordArchive::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CitationRecordArchive::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CitationRecordArchive::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* CitationRecordArchive::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CitationRecordArchive::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CitationSmartFieldArchive

// optional .TSWP.SmartFieldArchive super = 3;
inline bool CitationSmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CitationSmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CitationSmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CitationSmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& CitationSmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* CitationSmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* CitationSmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CitationSmartFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference citation_records = 2;
inline int CitationSmartFieldArchive::citation_records_size() const {
  return citation_records_.size();
}
inline void CitationSmartFieldArchive::clear_citation_records() {
  citation_records_.Clear();
}
inline const ::TSP::Reference& CitationSmartFieldArchive::citation_records(int index) const {
  return citation_records_.Get(index);
}
inline ::TSP::Reference* CitationSmartFieldArchive::mutable_citation_records(int index) {
  return citation_records_.Mutable(index);
}
inline ::TSP::Reference* CitationSmartFieldArchive::add_citation_records() {
  return citation_records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CitationSmartFieldArchive::citation_records() const {
  return citation_records_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CitationSmartFieldArchive::mutable_citation_records() {
  return &citation_records_;
}

// optional bool localizable = 4;
inline bool CitationSmartFieldArchive::has_localizable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CitationSmartFieldArchive::set_has_localizable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CitationSmartFieldArchive::clear_has_localizable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CitationSmartFieldArchive::clear_localizable() {
  localizable_ = false;
  clear_has_localizable();
}
inline bool CitationSmartFieldArchive::localizable() const {
  return localizable_;
}
inline void CitationSmartFieldArchive::set_localizable(bool value) {
  set_has_localizable();
  localizable_ = value;
}

// optional .TSWP.PlaceholderSmartFieldArchive old_super = 1;
inline bool CitationSmartFieldArchive::has_old_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CitationSmartFieldArchive::set_has_old_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CitationSmartFieldArchive::clear_has_old_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CitationSmartFieldArchive::clear_old_super() {
  if (old_super_ != NULL) old_super_->::TSWP::PlaceholderSmartFieldArchive::Clear();
  clear_has_old_super();
}
inline const ::TSWP::PlaceholderSmartFieldArchive& CitationSmartFieldArchive::old_super() const {
  return old_super_ != NULL ? *old_super_ : *default_instance_->old_super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* CitationSmartFieldArchive::mutable_old_super() {
  set_has_old_super();
  if (old_super_ == NULL) old_super_ = new ::TSWP::PlaceholderSmartFieldArchive;
  return old_super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* CitationSmartFieldArchive::release_old_super() {
  clear_has_old_super();
  ::TSWP::PlaceholderSmartFieldArchive* temp = old_super_;
  old_super_ = NULL;
  return temp;
}
inline void CitationSmartFieldArchive::set_allocated_old_super(::TSWP::PlaceholderSmartFieldArchive* old_super) {
  delete old_super_;
  old_super_ = old_super;
  if (old_super) {
    set_has_old_super();
  } else {
    clear_has_old_super();
  }
}

// -------------------------------------------------------------------

// DateTimeSmartFieldArchive

// optional .TSWP.SmartFieldArchive super = 1;
inline bool DateTimeSmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTimeSmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTimeSmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& DateTimeSmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* DateTimeSmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* DateTimeSmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DateTimeSmartFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string format = 2;
inline bool DateTimeSmartFieldArchive::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateTimeSmartFieldArchive::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateTimeSmartFieldArchive::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& DateTimeSmartFieldArchive::format() const {
  return *format_;
}
inline void DateTimeSmartFieldArchive::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void DateTimeSmartFieldArchive::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void DateTimeSmartFieldArchive::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DateTimeSmartFieldArchive::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* DateTimeSmartFieldArchive::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DateTimeSmartFieldArchive::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string locale_identifier = 3;
inline bool DateTimeSmartFieldArchive::has_locale_identifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_locale_identifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DateTimeSmartFieldArchive::clear_has_locale_identifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DateTimeSmartFieldArchive::clear_locale_identifier() {
  if (locale_identifier_ != &::google::protobuf::internal::kEmptyString) {
    locale_identifier_->clear();
  }
  clear_has_locale_identifier();
}
inline const ::std::string& DateTimeSmartFieldArchive::locale_identifier() const {
  return *locale_identifier_;
}
inline void DateTimeSmartFieldArchive::set_locale_identifier(const ::std::string& value) {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  locale_identifier_->assign(value);
}
inline void DateTimeSmartFieldArchive::set_locale_identifier(const char* value) {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  locale_identifier_->assign(value);
}
inline void DateTimeSmartFieldArchive::set_locale_identifier(const char* value, size_t size) {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  locale_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DateTimeSmartFieldArchive::mutable_locale_identifier() {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  return locale_identifier_;
}
inline ::std::string* DateTimeSmartFieldArchive::release_locale_identifier() {
  clear_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_identifier_;
    locale_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DateTimeSmartFieldArchive::set_allocated_locale_identifier(::std::string* locale_identifier) {
  if (locale_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete locale_identifier_;
  }
  if (locale_identifier) {
    set_has_locale_identifier();
    locale_identifier_ = locale_identifier;
  } else {
    clear_has_locale_identifier();
    locale_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
inline bool DateTimeSmartFieldArchive::has_date_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_date_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DateTimeSmartFieldArchive::clear_has_date_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DateTimeSmartFieldArchive::clear_date_style() {
  date_style_ = 0;
  clear_has_date_style();
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle DateTimeSmartFieldArchive::date_style() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle >(date_style_);
}
inline void DateTimeSmartFieldArchive::set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value));
  set_has_date_style();
  date_style_ = value;
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
inline bool DateTimeSmartFieldArchive::has_time_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_time_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DateTimeSmartFieldArchive::clear_has_time_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DateTimeSmartFieldArchive::clear_time_style() {
  time_style_ = 0;
  clear_has_time_style();
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle DateTimeSmartFieldArchive::time_style() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle >(time_style_);
}
inline void DateTimeSmartFieldArchive::set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value));
  set_has_time_style();
  time_style_ = value;
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeUpdatePlan update_plan = 6;
inline bool DateTimeSmartFieldArchive::has_update_plan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_update_plan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DateTimeSmartFieldArchive::clear_has_update_plan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DateTimeSmartFieldArchive::clear_update_plan() {
  update_plan_ = 0;
  clear_has_update_plan();
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan DateTimeSmartFieldArchive::update_plan() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan >(update_plan_);
}
inline void DateTimeSmartFieldArchive::set_update_plan(::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan_IsValid(value));
  set_has_update_plan();
  update_plan_ = value;
}

// optional bool needs_update = 7;
inline bool DateTimeSmartFieldArchive::has_needs_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_needs_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DateTimeSmartFieldArchive::clear_has_needs_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DateTimeSmartFieldArchive::clear_needs_update() {
  needs_update_ = false;
  clear_has_needs_update();
}
inline bool DateTimeSmartFieldArchive::needs_update() const {
  return needs_update_;
}
inline void DateTimeSmartFieldArchive::set_needs_update(bool value) {
  set_has_needs_update();
  needs_update_ = value;
}

// optional .TSP.Date date = 8;
inline bool DateTimeSmartFieldArchive::has_date() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DateTimeSmartFieldArchive::set_has_date() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DateTimeSmartFieldArchive::clear_has_date() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DateTimeSmartFieldArchive::clear_date() {
  if (date_ != NULL) date_->::TSP::Date::Clear();
  clear_has_date();
}
inline const ::TSP::Date& DateTimeSmartFieldArchive::date() const {
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::TSP::Date* DateTimeSmartFieldArchive::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::TSP::Date;
  return date_;
}
inline ::TSP::Date* DateTimeSmartFieldArchive::release_date() {
  clear_has_date();
  ::TSP::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void DateTimeSmartFieldArchive::set_allocated_date(::TSP::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
}

// -------------------------------------------------------------------

// BookmarkFieldArchive

// optional .TSWP.SmartFieldArchive super = 1;
inline bool BookmarkFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BookmarkFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BookmarkFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BookmarkFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& BookmarkFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* BookmarkFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* BookmarkFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void BookmarkFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string name = 2;
inline bool BookmarkFieldArchive::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BookmarkFieldArchive::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BookmarkFieldArchive::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BookmarkFieldArchive::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BookmarkFieldArchive::name() const {
  return *name_;
}
inline void BookmarkFieldArchive::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BookmarkFieldArchive::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BookmarkFieldArchive::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BookmarkFieldArchive::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BookmarkFieldArchive::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BookmarkFieldArchive::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ranged = 3;
inline bool BookmarkFieldArchive::has_ranged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BookmarkFieldArchive::set_has_ranged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BookmarkFieldArchive::clear_has_ranged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BookmarkFieldArchive::clear_ranged() {
  ranged_ = 0u;
  clear_has_ranged();
}
inline ::google::protobuf::uint32 BookmarkFieldArchive::ranged() const {
  return ranged_;
}
inline void BookmarkFieldArchive::set_ranged(::google::protobuf::uint32 value) {
  set_has_ranged();
  ranged_ = value;
}

// optional uint32 hidden = 4;
inline bool BookmarkFieldArchive::has_hidden() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BookmarkFieldArchive::set_has_hidden() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BookmarkFieldArchive::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BookmarkFieldArchive::clear_hidden() {
  hidden_ = 0u;
  clear_has_hidden();
}
inline ::google::protobuf::uint32 BookmarkFieldArchive::hidden() const {
  return hidden_;
}
inline void BookmarkFieldArchive::set_hidden(::google::protobuf::uint32 value) {
  set_has_hidden();
  hidden_ = value;
}

// -------------------------------------------------------------------

// FilenameSmartFieldArchive

// optional .TSWP.PlaceholderSmartFieldArchive super = 1;
inline bool FilenameSmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilenameSmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilenameSmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilenameSmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::PlaceholderSmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::PlaceholderSmartFieldArchive& FilenameSmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* FilenameSmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::PlaceholderSmartFieldArchive;
  return super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* FilenameSmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::PlaceholderSmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FilenameSmartFieldArchive::set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 display_flags = 2;
inline bool FilenameSmartFieldArchive::has_display_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilenameSmartFieldArchive::set_has_display_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilenameSmartFieldArchive::clear_has_display_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilenameSmartFieldArchive::clear_display_flags() {
  display_flags_ = 0u;
  clear_has_display_flags();
}
inline ::google::protobuf::uint32 FilenameSmartFieldArchive::display_flags() const {
  return display_flags_;
}
inline void FilenameSmartFieldArchive::set_display_flags(::google::protobuf::uint32 value) {
  set_has_display_flags();
  display_flags_ = value;
}

// -------------------------------------------------------------------

// MergeSmartFieldArchive

// optional .TSWP.PlaceholderSmartFieldArchive super = 1;
inline bool MergeSmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MergeSmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MergeSmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MergeSmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::PlaceholderSmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::PlaceholderSmartFieldArchive& MergeSmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* MergeSmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::PlaceholderSmartFieldArchive;
  return super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* MergeSmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::PlaceholderSmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MergeSmartFieldArchive::set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string property = 2;
inline bool MergeSmartFieldArchive::has_property() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MergeSmartFieldArchive::set_has_property() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MergeSmartFieldArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MergeSmartFieldArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& MergeSmartFieldArchive::property() const {
  return *property_;
}
inline void MergeSmartFieldArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void MergeSmartFieldArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void MergeSmartFieldArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeSmartFieldArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* MergeSmartFieldArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MergeSmartFieldArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string label = 3;
inline bool MergeSmartFieldArchive::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MergeSmartFieldArchive::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MergeSmartFieldArchive::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MergeSmartFieldArchive::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& MergeSmartFieldArchive::label() const {
  return *label_;
}
inline void MergeSmartFieldArchive::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void MergeSmartFieldArchive::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void MergeSmartFieldArchive::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeSmartFieldArchive::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* MergeSmartFieldArchive::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MergeSmartFieldArchive::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 4;
inline bool MergeSmartFieldArchive::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MergeSmartFieldArchive::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MergeSmartFieldArchive::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MergeSmartFieldArchive::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MergeSmartFieldArchive::key() const {
  return *key_;
}
inline void MergeSmartFieldArchive::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MergeSmartFieldArchive::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MergeSmartFieldArchive::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeSmartFieldArchive::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* MergeSmartFieldArchive::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MergeSmartFieldArchive::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.MergeSmartFieldArchive.MergeCategory category = 5;
inline bool MergeSmartFieldArchive::has_category() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MergeSmartFieldArchive::set_has_category() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MergeSmartFieldArchive::clear_has_category() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MergeSmartFieldArchive::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::TSWP::MergeSmartFieldArchive_MergeCategory MergeSmartFieldArchive::category() const {
  return static_cast< ::TSWP::MergeSmartFieldArchive_MergeCategory >(category_);
}
inline void MergeSmartFieldArchive::set_category(::TSWP::MergeSmartFieldArchive_MergeCategory value) {
  assert(::TSWP::MergeSmartFieldArchive_MergeCategory_IsValid(value));
  set_has_category();
  category_ = value;
}

// optional bool requires_following_whitespace = 6;
inline bool MergeSmartFieldArchive::has_requires_following_whitespace() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MergeSmartFieldArchive::set_has_requires_following_whitespace() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MergeSmartFieldArchive::clear_has_requires_following_whitespace() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MergeSmartFieldArchive::clear_requires_following_whitespace() {
  requires_following_whitespace_ = false;
  clear_has_requires_following_whitespace();
}
inline bool MergeSmartFieldArchive::requires_following_whitespace() const {
  return requires_following_whitespace_;
}
inline void MergeSmartFieldArchive::set_requires_following_whitespace(bool value) {
  set_has_requires_following_whitespace();
  requires_following_whitespace_ = value;
}

// optional string whitespace = 7;
inline bool MergeSmartFieldArchive::has_whitespace() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MergeSmartFieldArchive::set_has_whitespace() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MergeSmartFieldArchive::clear_has_whitespace() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MergeSmartFieldArchive::clear_whitespace() {
  if (whitespace_ != &::google::protobuf::internal::kEmptyString) {
    whitespace_->clear();
  }
  clear_has_whitespace();
}
inline const ::std::string& MergeSmartFieldArchive::whitespace() const {
  return *whitespace_;
}
inline void MergeSmartFieldArchive::set_whitespace(const ::std::string& value) {
  set_has_whitespace();
  if (whitespace_ == &::google::protobuf::internal::kEmptyString) {
    whitespace_ = new ::std::string;
  }
  whitespace_->assign(value);
}
inline void MergeSmartFieldArchive::set_whitespace(const char* value) {
  set_has_whitespace();
  if (whitespace_ == &::google::protobuf::internal::kEmptyString) {
    whitespace_ = new ::std::string;
  }
  whitespace_->assign(value);
}
inline void MergeSmartFieldArchive::set_whitespace(const char* value, size_t size) {
  set_has_whitespace();
  if (whitespace_ == &::google::protobuf::internal::kEmptyString) {
    whitespace_ = new ::std::string;
  }
  whitespace_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeSmartFieldArchive::mutable_whitespace() {
  set_has_whitespace();
  if (whitespace_ == &::google::protobuf::internal::kEmptyString) {
    whitespace_ = new ::std::string;
  }
  return whitespace_;
}
inline ::std::string* MergeSmartFieldArchive::release_whitespace() {
  clear_has_whitespace();
  if (whitespace_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = whitespace_;
    whitespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MergeSmartFieldArchive::set_allocated_whitespace(::std::string* whitespace) {
  if (whitespace_ != &::google::protobuf::internal::kEmptyString) {
    delete whitespace_;
  }
  if (whitespace) {
    set_has_whitespace();
    whitespace_ = whitespace;
  } else {
    clear_has_whitespace();
    whitespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string guid = 8;
inline bool MergeSmartFieldArchive::has_guid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MergeSmartFieldArchive::set_has_guid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MergeSmartFieldArchive::clear_has_guid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MergeSmartFieldArchive::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& MergeSmartFieldArchive::guid() const {
  return *guid_;
}
inline void MergeSmartFieldArchive::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void MergeSmartFieldArchive::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void MergeSmartFieldArchive::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeSmartFieldArchive::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* MergeSmartFieldArchive::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MergeSmartFieldArchive::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string table_field = 9;
inline bool MergeSmartFieldArchive::has_table_field() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MergeSmartFieldArchive::set_has_table_field() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MergeSmartFieldArchive::clear_has_table_field() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MergeSmartFieldArchive::clear_table_field() {
  if (table_field_ != &::google::protobuf::internal::kEmptyString) {
    table_field_->clear();
  }
  clear_has_table_field();
}
inline const ::std::string& MergeSmartFieldArchive::table_field() const {
  return *table_field_;
}
inline void MergeSmartFieldArchive::set_table_field(const ::std::string& value) {
  set_has_table_field();
  if (table_field_ == &::google::protobuf::internal::kEmptyString) {
    table_field_ = new ::std::string;
  }
  table_field_->assign(value);
}
inline void MergeSmartFieldArchive::set_table_field(const char* value) {
  set_has_table_field();
  if (table_field_ == &::google::protobuf::internal::kEmptyString) {
    table_field_ = new ::std::string;
  }
  table_field_->assign(value);
}
inline void MergeSmartFieldArchive::set_table_field(const char* value, size_t size) {
  set_has_table_field();
  if (table_field_ == &::google::protobuf::internal::kEmptyString) {
    table_field_ = new ::std::string;
  }
  table_field_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeSmartFieldArchive::mutable_table_field() {
  set_has_table_field();
  if (table_field_ == &::google::protobuf::internal::kEmptyString) {
    table_field_ = new ::std::string;
  }
  return table_field_;
}
inline ::std::string* MergeSmartFieldArchive::release_table_field() {
  clear_has_table_field();
  if (table_field_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_field_;
    table_field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MergeSmartFieldArchive::set_allocated_table_field(::std::string* table_field) {
  if (table_field_ != &::google::protobuf::internal::kEmptyString) {
    delete table_field_;
  }
  if (table_field) {
    set_has_table_field();
    table_field_ = table_field;
  } else {
    clear_has_table_field();
    table_field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TOCSmartFieldArchive_TOCEntry

// optional string bookmark_name = 1;
inline bool TOCSmartFieldArchive_TOCEntry::has_bookmark_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCSmartFieldArchive_TOCEntry::set_has_bookmark_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCSmartFieldArchive_TOCEntry::clear_has_bookmark_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCSmartFieldArchive_TOCEntry::clear_bookmark_name() {
  if (bookmark_name_ != &::google::protobuf::internal::kEmptyString) {
    bookmark_name_->clear();
  }
  clear_has_bookmark_name();
}
inline const ::std::string& TOCSmartFieldArchive_TOCEntry::bookmark_name() const {
  return *bookmark_name_;
}
inline void TOCSmartFieldArchive_TOCEntry::set_bookmark_name(const ::std::string& value) {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  bookmark_name_->assign(value);
}
inline void TOCSmartFieldArchive_TOCEntry::set_bookmark_name(const char* value) {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  bookmark_name_->assign(value);
}
inline void TOCSmartFieldArchive_TOCEntry::set_bookmark_name(const char* value, size_t size) {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  bookmark_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TOCSmartFieldArchive_TOCEntry::mutable_bookmark_name() {
  set_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    bookmark_name_ = new ::std::string;
  }
  return bookmark_name_;
}
inline ::std::string* TOCSmartFieldArchive_TOCEntry::release_bookmark_name() {
  clear_has_bookmark_name();
  if (bookmark_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bookmark_name_;
    bookmark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TOCSmartFieldArchive_TOCEntry::set_allocated_bookmark_name(::std::string* bookmark_name) {
  if (bookmark_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bookmark_name_;
  }
  if (bookmark_name) {
    set_has_bookmark_name();
    bookmark_name_ = bookmark_name;
  } else {
    clear_has_bookmark_name();
    bookmark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference target_style = 2;
inline bool TOCSmartFieldArchive_TOCEntry::has_target_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOCSmartFieldArchive_TOCEntry::set_has_target_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOCSmartFieldArchive_TOCEntry::clear_has_target_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOCSmartFieldArchive_TOCEntry::clear_target_style() {
  if (target_style_ != NULL) target_style_->::TSP::Reference::Clear();
  clear_has_target_style();
}
inline const ::TSP::Reference& TOCSmartFieldArchive_TOCEntry::target_style() const {
  return target_style_ != NULL ? *target_style_ : *default_instance_->target_style_;
}
inline ::TSP::Reference* TOCSmartFieldArchive_TOCEntry::mutable_target_style() {
  set_has_target_style();
  if (target_style_ == NULL) target_style_ = new ::TSP::Reference;
  return target_style_;
}
inline ::TSP::Reference* TOCSmartFieldArchive_TOCEntry::release_target_style() {
  clear_has_target_style();
  ::TSP::Reference* temp = target_style_;
  target_style_ = NULL;
  return temp;
}
inline void TOCSmartFieldArchive_TOCEntry::set_allocated_target_style(::TSP::Reference* target_style) {
  delete target_style_;
  target_style_ = target_style;
  if (target_style) {
    set_has_target_style();
  } else {
    clear_has_target_style();
  }
}

// optional .TSP.Range range = 3;
inline bool TOCSmartFieldArchive_TOCEntry::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TOCSmartFieldArchive_TOCEntry::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TOCSmartFieldArchive_TOCEntry::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TOCSmartFieldArchive_TOCEntry::clear_range() {
  if (range_ != NULL) range_->::TSP::Range::Clear();
  clear_has_range();
}
inline const ::TSP::Range& TOCSmartFieldArchive_TOCEntry::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::TSP::Range* TOCSmartFieldArchive_TOCEntry::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::TSP::Range;
  return range_;
}
inline ::TSP::Range* TOCSmartFieldArchive_TOCEntry::release_range() {
  clear_has_range();
  ::TSP::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void TOCSmartFieldArchive_TOCEntry::set_allocated_range(::TSP::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
}

// -------------------------------------------------------------------

// TOCSmartFieldArchive

// optional .TSWP.PlaceholderSmartFieldArchive super = 1;
inline bool TOCSmartFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOCSmartFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOCSmartFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOCSmartFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::PlaceholderSmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::PlaceholderSmartFieldArchive& TOCSmartFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* TOCSmartFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::PlaceholderSmartFieldArchive;
  return super_;
}
inline ::TSWP::PlaceholderSmartFieldArchive* TOCSmartFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::PlaceholderSmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TOCSmartFieldArchive::set_allocated_super(::TSWP::PlaceholderSmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSWP.TOCSmartFieldArchive.TOCEntry toc_entries = 2;
inline int TOCSmartFieldArchive::toc_entries_size() const {
  return toc_entries_.size();
}
inline void TOCSmartFieldArchive::clear_toc_entries() {
  toc_entries_.Clear();
}
inline const ::TSWP::TOCSmartFieldArchive_TOCEntry& TOCSmartFieldArchive::toc_entries(int index) const {
  return toc_entries_.Get(index);
}
inline ::TSWP::TOCSmartFieldArchive_TOCEntry* TOCSmartFieldArchive::mutable_toc_entries(int index) {
  return toc_entries_.Mutable(index);
}
inline ::TSWP::TOCSmartFieldArchive_TOCEntry* TOCSmartFieldArchive::add_toc_entries() {
  return toc_entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSmartFieldArchive_TOCEntry >&
TOCSmartFieldArchive::toc_entries() const {
  return toc_entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSWP::TOCSmartFieldArchive_TOCEntry >*
TOCSmartFieldArchive::mutable_toc_entries() {
  return &toc_entries_;
}

// -------------------------------------------------------------------

// RubyFieldArchive

// optional .TSWP.SmartFieldArchive super = 1;
inline bool RubyFieldArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RubyFieldArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RubyFieldArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RubyFieldArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::SmartFieldArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::SmartFieldArchive& RubyFieldArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::SmartFieldArchive* RubyFieldArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::SmartFieldArchive;
  return super_;
}
inline ::TSWP::SmartFieldArchive* RubyFieldArchive::release_super() {
  clear_has_super();
  ::TSWP::SmartFieldArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RubyFieldArchive::set_allocated_super(::TSWP::SmartFieldArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string ruby_text = 2;
inline bool RubyFieldArchive::has_ruby_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RubyFieldArchive::set_has_ruby_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RubyFieldArchive::clear_has_ruby_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RubyFieldArchive::clear_ruby_text() {
  if (ruby_text_ != &::google::protobuf::internal::kEmptyString) {
    ruby_text_->clear();
  }
  clear_has_ruby_text();
}
inline const ::std::string& RubyFieldArchive::ruby_text() const {
  return *ruby_text_;
}
inline void RubyFieldArchive::set_ruby_text(const ::std::string& value) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(value);
}
inline void RubyFieldArchive::set_ruby_text(const char* value) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(value);
}
inline void RubyFieldArchive::set_ruby_text(const char* value, size_t size) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RubyFieldArchive::mutable_ruby_text() {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  return ruby_text_;
}
inline ::std::string* RubyFieldArchive::release_ruby_text() {
  clear_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ruby_text_;
    ruby_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RubyFieldArchive::set_allocated_ruby_text(::std::string* ruby_text) {
  if (ruby_text_ != &::google::protobuf::internal::kEmptyString) {
    delete ruby_text_;
  }
  if (ruby_text) {
    set_has_ruby_text();
    ruby_text_ = ruby_text;
  } else {
    clear_has_ruby_text();
    ruby_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeArchive

// optional .TSWP.ChangeArchive.ChangeKind kind = 1;
inline bool ChangeArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeArchive::clear_kind() {
  kind_ = 1;
  clear_has_kind();
}
inline ::TSWP::ChangeArchive_ChangeKind ChangeArchive::kind() const {
  return static_cast< ::TSWP::ChangeArchive_ChangeKind >(kind_);
}
inline void ChangeArchive::set_kind(::TSWP::ChangeArchive_ChangeKind value) {
  assert(::TSWP::ChangeArchive_ChangeKind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional .TSP.Reference session = 2;
inline bool ChangeArchive::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeArchive::set_has_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeArchive::clear_has_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeArchive::clear_session() {
  if (session_ != NULL) session_->::TSP::Reference::Clear();
  clear_has_session();
}
inline const ::TSP::Reference& ChangeArchive::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::TSP::Reference* ChangeArchive::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::TSP::Reference;
  return session_;
}
inline ::TSP::Reference* ChangeArchive::release_session() {
  clear_has_session();
  ::TSP::Reference* temp = session_;
  session_ = NULL;
  return temp;
}
inline void ChangeArchive::set_allocated_session(::TSP::Reference* session) {
  delete session_;
  session_ = session;
  if (session) {
    set_has_session();
  } else {
    clear_has_session();
  }
}

// optional .TSP.Date date = 3;
inline bool ChangeArchive::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeArchive::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeArchive::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeArchive::clear_date() {
  if (date_ != NULL) date_->::TSP::Date::Clear();
  clear_has_date();
}
inline const ::TSP::Date& ChangeArchive::date() const {
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::TSP::Date* ChangeArchive::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::TSP::Date;
  return date_;
}
inline ::TSP::Date* ChangeArchive::release_date() {
  clear_has_date();
  ::TSP::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void ChangeArchive::set_allocated_date(::TSP::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
}

// optional bool hidden = 4;
inline bool ChangeArchive::has_hidden() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeArchive::set_has_hidden() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeArchive::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeArchive::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool ChangeArchive::hidden() const {
  return hidden_;
}
inline void ChangeArchive::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
}

// -------------------------------------------------------------------

// ChangeSessionArchive

// optional uint32 session_uid = 1;
inline bool ChangeSessionArchive::has_session_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeSessionArchive::set_has_session_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeSessionArchive::clear_has_session_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeSessionArchive::clear_session_uid() {
  session_uid_ = 0u;
  clear_has_session_uid();
}
inline ::google::protobuf::uint32 ChangeSessionArchive::session_uid() const {
  return session_uid_;
}
inline void ChangeSessionArchive::set_session_uid(::google::protobuf::uint32 value) {
  set_has_session_uid();
  session_uid_ = value;
}

// optional .TSP.Reference author = 2;
inline bool ChangeSessionArchive::has_author() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeSessionArchive::set_has_author() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeSessionArchive::clear_has_author() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeSessionArchive::clear_author() {
  if (author_ != NULL) author_->::TSP::Reference::Clear();
  clear_has_author();
}
inline const ::TSP::Reference& ChangeSessionArchive::author() const {
  return author_ != NULL ? *author_ : *default_instance_->author_;
}
inline ::TSP::Reference* ChangeSessionArchive::mutable_author() {
  set_has_author();
  if (author_ == NULL) author_ = new ::TSP::Reference;
  return author_;
}
inline ::TSP::Reference* ChangeSessionArchive::release_author() {
  clear_has_author();
  ::TSP::Reference* temp = author_;
  author_ = NULL;
  return temp;
}
inline void ChangeSessionArchive::set_allocated_author(::TSP::Reference* author) {
  delete author_;
  author_ = author;
  if (author) {
    set_has_author();
  } else {
    clear_has_author();
  }
}

// optional .TSP.Date date = 3;
inline bool ChangeSessionArchive::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeSessionArchive::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeSessionArchive::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeSessionArchive::clear_date() {
  if (date_ != NULL) date_->::TSP::Date::Clear();
  clear_has_date();
}
inline const ::TSP::Date& ChangeSessionArchive::date() const {
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::TSP::Date* ChangeSessionArchive::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::TSP::Date;
  return date_;
}
inline ::TSP::Date* ChangeSessionArchive::release_date() {
  clear_has_date();
  ::TSP::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void ChangeSessionArchive::set_allocated_date(::TSP::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
}

// -------------------------------------------------------------------

// SectionPlaceholderArchive


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSWP

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::StorageArchive_KindType>() {
  return ::TSWP::StorageArchive_KindType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::CharacterStylePropertiesArchive_CapitalizationType>() {
  return ::TSWP::CharacterStylePropertiesArchive_CapitalizationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::CharacterStylePropertiesArchive_UnderlineType>() {
  return ::TSWP::CharacterStylePropertiesArchive_UnderlineType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::CharacterStylePropertiesArchive_LigaturesType>() {
  return ::TSWP::CharacterStylePropertiesArchive_LigaturesType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::CharacterStylePropertiesArchive_StrikethruType>() {
  return ::TSWP::CharacterStylePropertiesArchive_StrikethruType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::CharacterStylePropertiesArchive_SuperscriptType>() {
  return ::TSWP::CharacterStylePropertiesArchive_SuperscriptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::TabArchive_TabAlignmentType>() {
  return ::TSWP::TabArchive_TabAlignmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::LineSpacingArchive_LineSpacingModeType>() {
  return ::TSWP::LineSpacingArchive_LineSpacingModeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType>() {
  return ::TSWP::ParagraphStylePropertiesArchive_TextAlignmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType>() {
  return ::TSWP::ParagraphStylePropertiesArchive_ParagraphBorderType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType>() {
  return ::TSWP::ParagraphStylePropertiesArchive_OutlineStyleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ListStyleArchive_LabelType>() {
  return ::TSWP::ListStyleArchive_LabelType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ListStyleArchive_NumberType>() {
  return ::TSWP::ListStyleArchive_NumberType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType>() {
  return ::TSWP::ColumnStylePropertiesArchive_VerticalAlignmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType>() {
  return ::TSWP::ShapeStylePropertiesArchive_VerticalAlignmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::UndoTransaction_UndoKind>() {
  return ::TSWP::UndoTransaction_UndoKind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::TextualAttachmentArchive_Kind>() {
  return ::TSWP::TextualAttachmentArchive_Kind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan>() {
  return ::TSWP::DateTimeSmartFieldArchive_DateTimeUpdatePlan_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle>() {
  return ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::MergeSmartFieldArchive_MergeCategory>() {
  return ::TSWP::MergeSmartFieldArchive_MergeCategory_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::ChangeArchive_ChangeKind>() {
  return ::TSWP::ChangeArchive_ChangeKind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::SelectionType>() {
  return ::TSWP::SelectionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::StyleInsertionBehavior>() {
  return ::TSWP::StyleInsertionBehavior_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::CaretAffinity>() {
  return ::TSWP::CaretAffinity_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::WritingDirectionType>() {
  return ::TSWP::WritingDirectionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSWPArchives_2eproto__INCLUDED
