// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDCommandArchives.proto

#ifndef PROTOBUF_TSDCommandArchives_2eproto__INCLUDED
#define PROTOBUF_TSDCommandArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TSD {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSDCommandArchives_2eproto();
void protobuf_AssignDesc_TSDCommandArchives_2eproto();
void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

class ConnectionLineConnectCommandArchive;
class GroupDrawablesCommandArchive;
class UngroupGroupCommandArchive;
class ContainerRemoveChildrenCommandArchive;
class ContainerInsertChildrenCommandArchive;
class ContainerReorderChildrenCommandArchive;
class InfoGeometryCommandArchive;
class DrawablePathSourceCommandArchive;
class InstantAlphaCommandArchive;
class DrawableShadowCommandArchive;
class DrawableApplyThemeCommandArchive;
class StyledInfoSetStyleCommandArchive;
class ShapePathSourceFlipCommandArchive;
class ShapeStyleSetValueCommandArchive;
class ShapeApplyPresetCommandArchive;
class ShapeSetLineEndCommandArchive;
class MovieSetValueCommandArchive;
class MovieSetValueCommandArchive_PropertyValue;
class MediaStyleSetValueCommandArchive;
class ImageMediaCommandArchive;
class MediaOriginalSizeCommandArchive;
class ImageMaskCommandArchive;
class MediaApplyPresetCommandArchive;
class ImageAdjustmentsCommandArchive;
class MediaFlagsCommandArchive;
class DrawablesCommandGroupArchive;
class ExteriorTextWrapCommandArchive;
class ExteriorTextWrapCommandArchive_InfoAndWrap;
class DrawableHyperlinkCommandArchive;
class CommandSelectionBehaviorArchive;
class ImageReplaceCommandArchive;
class DrawableLockCommandArchive;
class DrawableInfoCommentCommandArchive;
class CommentStorageApplyCommandArchive;
class GuideCommandArchive;
class DrawableAspectRatioLockedCommandArchive;
class DrawableAccessibilityDescriptionCommandArchive;
class PasteStyleCommandArchive;

enum MovieSetValueCommandArchive_LoopOption {
  MovieSetValueCommandArchive_LoopOption_None = 0,
  MovieSetValueCommandArchive_LoopOption_Repeat = 1,
  MovieSetValueCommandArchive_LoopOption_BackAndForth = 2
};
bool MovieSetValueCommandArchive_LoopOption_IsValid(int value);
const MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive_LoopOption_LoopOption_MIN = MovieSetValueCommandArchive_LoopOption_None;
const MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive_LoopOption_LoopOption_MAX = MovieSetValueCommandArchive_LoopOption_BackAndForth;
const int MovieSetValueCommandArchive_LoopOption_LoopOption_ARRAYSIZE = MovieSetValueCommandArchive_LoopOption_LoopOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* MovieSetValueCommandArchive_LoopOption_descriptor();
inline const ::std::string& MovieSetValueCommandArchive_LoopOption_Name(MovieSetValueCommandArchive_LoopOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    MovieSetValueCommandArchive_LoopOption_descriptor(), value);
}
inline bool MovieSetValueCommandArchive_LoopOption_Parse(
    const ::std::string& name, MovieSetValueCommandArchive_LoopOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovieSetValueCommandArchive_LoopOption>(
    MovieSetValueCommandArchive_LoopOption_descriptor(), name, value);
}
enum DrawablesCommandGroupArchive_DrawablesCommandGroupType {
  DrawablesCommandGroupArchive_DrawablesCommandGroupType_Constructive = 1,
  DrawablesCommandGroupArchive_DrawablesCommandGroupType_Destructive = 2,
  DrawablesCommandGroupArchive_DrawablesCommandGroupType_InPlace = 3
};
bool DrawablesCommandGroupArchive_DrawablesCommandGroupType_IsValid(int value);
const DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_MIN = DrawablesCommandGroupArchive_DrawablesCommandGroupType_Constructive;
const DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_MAX = DrawablesCommandGroupArchive_DrawablesCommandGroupType_InPlace;
const int DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_ARRAYSIZE = DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrawablesCommandGroupArchive_DrawablesCommandGroupType_descriptor();
inline const ::std::string& DrawablesCommandGroupArchive_DrawablesCommandGroupType_Name(DrawablesCommandGroupArchive_DrawablesCommandGroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrawablesCommandGroupArchive_DrawablesCommandGroupType_descriptor(), value);
}
inline bool DrawablesCommandGroupArchive_DrawablesCommandGroupType_Parse(
    const ::std::string& name, DrawablesCommandGroupArchive_DrawablesCommandGroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrawablesCommandGroupArchive_DrawablesCommandGroupType>(
    DrawablesCommandGroupArchive_DrawablesCommandGroupType_descriptor(), name, value);
}
enum CommandSelectionBehaviorArchive_CommandSelectionBehaviorType {
  CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Constructive = 1,
  CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Destructive = 2,
  CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_InPlace = 3,
  CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Replace = 4
};
bool CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_IsValid(int value);
const CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_MIN = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Constructive;
const CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_MAX = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Replace;
const int CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_ARRAYSIZE = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_descriptor();
inline const ::std::string& CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Name(CommandSelectionBehaviorArchive_CommandSelectionBehaviorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_descriptor(), value);
}
inline bool CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Parse(
    const ::std::string& name, CommandSelectionBehaviorArchive_CommandSelectionBehaviorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandSelectionBehaviorArchive_CommandSelectionBehaviorType>(
    CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_descriptor(), name, value);
}
enum GuideCommandArchive_GuideCommandMode {
  GuideCommandArchive_GuideCommandMode_Add = 1,
  GuideCommandArchive_GuideCommandMode_Replace = 2,
  GuideCommandArchive_GuideCommandMode_Delete = 3
};
bool GuideCommandArchive_GuideCommandMode_IsValid(int value);
const GuideCommandArchive_GuideCommandMode GuideCommandArchive_GuideCommandMode_GuideCommandMode_MIN = GuideCommandArchive_GuideCommandMode_Add;
const GuideCommandArchive_GuideCommandMode GuideCommandArchive_GuideCommandMode_GuideCommandMode_MAX = GuideCommandArchive_GuideCommandMode_Delete;
const int GuideCommandArchive_GuideCommandMode_GuideCommandMode_ARRAYSIZE = GuideCommandArchive_GuideCommandMode_GuideCommandMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuideCommandArchive_GuideCommandMode_descriptor();
inline const ::std::string& GuideCommandArchive_GuideCommandMode_Name(GuideCommandArchive_GuideCommandMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuideCommandArchive_GuideCommandMode_descriptor(), value);
}
inline bool GuideCommandArchive_GuideCommandMode_Parse(
    const ::std::string& name, GuideCommandArchive_GuideCommandMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuideCommandArchive_GuideCommandMode>(
    GuideCommandArchive_GuideCommandMode_descriptor(), name, value);
}
// ===================================================================

class ConnectionLineConnectCommandArchive : public ::google::protobuf::Message {
 public:
  ConnectionLineConnectCommandArchive();
  virtual ~ConnectionLineConnectCommandArchive();

  ConnectionLineConnectCommandArchive(const ConnectionLineConnectCommandArchive& from);

  inline ConnectionLineConnectCommandArchive& operator=(const ConnectionLineConnectCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionLineConnectCommandArchive& default_instance();

  void Swap(ConnectionLineConnectCommandArchive* other);

  // implements Message ----------------------------------------------

  ConnectionLineConnectCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionLineConnectCommandArchive& from);
  void MergeFrom(const ConnectionLineConnectCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference connection_line = 2;
  inline bool has_connection_line() const;
  inline void clear_connection_line();
  static const int kConnectionLineFieldNumber = 2;
  inline const ::TSP::Reference& connection_line() const;
  inline ::TSP::Reference* mutable_connection_line();
  inline ::TSP::Reference* release_connection_line();
  inline void set_allocated_connection_line(::TSP::Reference* connection_line);

  // optional .TSP.Reference connect_to = 3;
  inline bool has_connect_to() const;
  inline void clear_connect_to();
  static const int kConnectToFieldNumber = 3;
  inline const ::TSP::Reference& connect_to() const;
  inline ::TSP::Reference* mutable_connect_to();
  inline ::TSP::Reference* release_connect_to();
  inline void set_allocated_connect_to(::TSP::Reference* connect_to);

  // optional .TSP.Reference connect_from = 4;
  inline bool has_connect_from() const;
  inline void clear_connect_from();
  static const int kConnectFromFieldNumber = 4;
  inline const ::TSP::Reference& connect_from() const;
  inline ::TSP::Reference* mutable_connect_from();
  inline ::TSP::Reference* release_connect_from();
  inline void set_allocated_connect_from(::TSP::Reference* connect_from);

  // optional .TSP.Reference old_connect_to = 5;
  inline bool has_old_connect_to() const;
  inline void clear_old_connect_to();
  static const int kOldConnectToFieldNumber = 5;
  inline const ::TSP::Reference& old_connect_to() const;
  inline ::TSP::Reference* mutable_old_connect_to();
  inline ::TSP::Reference* release_old_connect_to();
  inline void set_allocated_old_connect_to(::TSP::Reference* old_connect_to);

  // optional .TSP.Reference old_connect_from = 6;
  inline bool has_old_connect_from() const;
  inline void clear_old_connect_from();
  static const int kOldConnectFromFieldNumber = 6;
  inline const ::TSP::Reference& old_connect_from() const;
  inline ::TSP::Reference* mutable_old_connect_from();
  inline ::TSP::Reference* release_old_connect_from();
  inline void set_allocated_old_connect_from(::TSP::Reference* old_connect_from);

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLineConnectCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_connection_line();
  inline void clear_has_connection_line();
  inline void set_has_connect_to();
  inline void clear_has_connect_to();
  inline void set_has_connect_from();
  inline void clear_has_connect_from();
  inline void set_has_old_connect_to();
  inline void clear_has_old_connect_to();
  inline void set_has_old_connect_from();
  inline void clear_has_old_connect_from();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* connection_line_;
  ::TSP::Reference* connect_to_;
  ::TSP::Reference* connect_from_;
  ::TSP::Reference* old_connect_to_;
  ::TSP::Reference* old_connect_from_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ConnectionLineConnectCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class GroupDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  GroupDrawablesCommandArchive();
  virtual ~GroupDrawablesCommandArchive();

  GroupDrawablesCommandArchive(const GroupDrawablesCommandArchive& from);

  inline GroupDrawablesCommandArchive& operator=(const GroupDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupDrawablesCommandArchive& default_instance();

  void Swap(GroupDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  GroupDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupDrawablesCommandArchive& from);
  void MergeFrom(const GroupDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference drawables = 2;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 2;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // optional .TSP.Reference group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline const ::TSP::Reference& group() const;
  inline ::TSP::Reference* mutable_group();
  inline ::TSP::Reference* release_group();
  inline void set_allocated_group(::TSP::Reference* group);

  // @@protoc_insertion_point(class_scope:TSD.GroupDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  ::TSP::Reference* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static GroupDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class UngroupGroupCommandArchive : public ::google::protobuf::Message {
 public:
  UngroupGroupCommandArchive();
  virtual ~UngroupGroupCommandArchive();

  UngroupGroupCommandArchive(const UngroupGroupCommandArchive& from);

  inline UngroupGroupCommandArchive& operator=(const UngroupGroupCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UngroupGroupCommandArchive& default_instance();

  void Swap(UngroupGroupCommandArchive* other);

  // implements Message ----------------------------------------------

  UngroupGroupCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UngroupGroupCommandArchive& from);
  void MergeFrom(const UngroupGroupCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference drawables = 2;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 2;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // optional .TSP.Reference group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline const ::TSP::Reference& group() const;
  inline ::TSP::Reference* mutable_group();
  inline ::TSP::Reference* release_group();
  inline void set_allocated_group(::TSP::Reference* group);

  // @@protoc_insertion_point(class_scope:TSD.UngroupGroupCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  ::TSP::Reference* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static UngroupGroupCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ContainerRemoveChildrenCommandArchive : public ::google::protobuf::Message {
 public:
  ContainerRemoveChildrenCommandArchive();
  virtual ~ContainerRemoveChildrenCommandArchive();

  ContainerRemoveChildrenCommandArchive(const ContainerRemoveChildrenCommandArchive& from);

  inline ContainerRemoveChildrenCommandArchive& operator=(const ContainerRemoveChildrenCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerRemoveChildrenCommandArchive& default_instance();

  void Swap(ContainerRemoveChildrenCommandArchive* other);

  // implements Message ----------------------------------------------

  ContainerRemoveChildrenCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerRemoveChildrenCommandArchive& from);
  void MergeFrom(const ContainerRemoveChildrenCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference container = 2;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 2;
  inline const ::TSP::Reference& container() const;
  inline ::TSP::Reference* mutable_container();
  inline ::TSP::Reference* release_container();
  inline void set_allocated_container(::TSP::Reference* container);

  // repeated .TSP.Reference children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // optional .TSP.IndexSet children_indices = 4;
  inline bool has_children_indices() const;
  inline void clear_children_indices();
  static const int kChildrenIndicesFieldNumber = 4;
  inline const ::TSP::IndexSet& children_indices() const;
  inline ::TSP::IndexSet* mutable_children_indices();
  inline ::TSP::IndexSet* release_children_indices();
  inline void set_allocated_children_indices(::TSP::IndexSet* children_indices);

  // @@protoc_insertion_point(class_scope:TSD.ContainerRemoveChildrenCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_children_indices();
  inline void clear_has_children_indices();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* container_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;
  ::TSP::IndexSet* children_indices_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ContainerRemoveChildrenCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInsertChildrenCommandArchive : public ::google::protobuf::Message {
 public:
  ContainerInsertChildrenCommandArchive();
  virtual ~ContainerInsertChildrenCommandArchive();

  ContainerInsertChildrenCommandArchive(const ContainerInsertChildrenCommandArchive& from);

  inline ContainerInsertChildrenCommandArchive& operator=(const ContainerInsertChildrenCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInsertChildrenCommandArchive& default_instance();

  void Swap(ContainerInsertChildrenCommandArchive* other);

  // implements Message ----------------------------------------------

  ContainerInsertChildrenCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInsertChildrenCommandArchive& from);
  void MergeFrom(const ContainerInsertChildrenCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference container = 2;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 2;
  inline const ::TSP::Reference& container() const;
  inline ::TSP::Reference* mutable_container();
  inline ::TSP::Reference* release_container();
  inline void set_allocated_container(::TSP::Reference* container);

  // repeated .TSP.Reference children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // optional uint64 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TSD.ContainerInsertChildrenCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* container_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;
  ::google::protobuf::uint64 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ContainerInsertChildrenCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ContainerReorderChildrenCommandArchive : public ::google::protobuf::Message {
 public:
  ContainerReorderChildrenCommandArchive();
  virtual ~ContainerReorderChildrenCommandArchive();

  ContainerReorderChildrenCommandArchive(const ContainerReorderChildrenCommandArchive& from);

  inline ContainerReorderChildrenCommandArchive& operator=(const ContainerReorderChildrenCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerReorderChildrenCommandArchive& default_instance();

  void Swap(ContainerReorderChildrenCommandArchive* other);

  // implements Message ----------------------------------------------

  ContainerReorderChildrenCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerReorderChildrenCommandArchive& from);
  void MergeFrom(const ContainerReorderChildrenCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference container = 2;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 2;
  inline const ::TSP::Reference& container() const;
  inline ::TSP::Reference* mutable_container();
  inline ::TSP::Reference* release_container();
  inline void set_allocated_container(::TSP::Reference* container);

  // repeated .TSP.Reference children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // optional .TSP.IndexSet children_indices = 4;
  inline bool has_children_indices() const;
  inline void clear_children_indices();
  static const int kChildrenIndicesFieldNumber = 4;
  inline const ::TSP::IndexSet& children_indices() const;
  inline ::TSP::IndexSet* mutable_children_indices();
  inline ::TSP::IndexSet* release_children_indices();
  inline void set_allocated_children_indices(::TSP::IndexSet* children_indices);

  // @@protoc_insertion_point(class_scope:TSD.ContainerReorderChildrenCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_children_indices();
  inline void clear_has_children_indices();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* container_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;
  ::TSP::IndexSet* children_indices_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ContainerReorderChildrenCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InfoGeometryCommandArchive : public ::google::protobuf::Message {
 public:
  InfoGeometryCommandArchive();
  virtual ~InfoGeometryCommandArchive();

  InfoGeometryCommandArchive(const InfoGeometryCommandArchive& from);

  inline InfoGeometryCommandArchive& operator=(const InfoGeometryCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoGeometryCommandArchive& default_instance();

  void Swap(InfoGeometryCommandArchive* other);

  // implements Message ----------------------------------------------

  InfoGeometryCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoGeometryCommandArchive& from);
  void MergeFrom(const InfoGeometryCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSD.GeometryArchive newGeometry = 3;
  inline bool has_newgeometry() const;
  inline void clear_newgeometry();
  static const int kNewGeometryFieldNumber = 3;
  inline const ::TSD::GeometryArchive& newgeometry() const;
  inline ::TSD::GeometryArchive* mutable_newgeometry();
  inline ::TSD::GeometryArchive* release_newgeometry();
  inline void set_allocated_newgeometry(::TSD::GeometryArchive* newgeometry);

  // optional .TSD.GeometryArchive oldGeometry = 4;
  inline bool has_oldgeometry() const;
  inline void clear_oldgeometry();
  static const int kOldGeometryFieldNumber = 4;
  inline const ::TSD::GeometryArchive& oldgeometry() const;
  inline ::TSD::GeometryArchive* mutable_oldgeometry();
  inline ::TSD::GeometryArchive* release_oldgeometry();
  inline void set_allocated_oldgeometry(::TSD::GeometryArchive* oldgeometry);

  // optional bool shouldClearObjectPlaceholderFlag = 5;
  inline bool has_shouldclearobjectplaceholderflag() const;
  inline void clear_shouldclearobjectplaceholderflag();
  static const int kShouldClearObjectPlaceholderFlagFieldNumber = 5;
  inline bool shouldclearobjectplaceholderflag() const;
  inline void set_shouldclearobjectplaceholderflag(bool value);

  // optional bool didMatchObjectPlaceholderGeometry = 6;
  inline bool has_didmatchobjectplaceholdergeometry() const;
  inline void clear_didmatchobjectplaceholdergeometry();
  static const int kDidMatchObjectPlaceholderGeometryFieldNumber = 6;
  inline bool didmatchobjectplaceholdergeometry() const;
  inline void set_didmatchobjectplaceholdergeometry(bool value);

  // @@protoc_insertion_point(class_scope:TSD.InfoGeometryCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_newgeometry();
  inline void clear_has_newgeometry();
  inline void set_has_oldgeometry();
  inline void clear_has_oldgeometry();
  inline void set_has_shouldclearobjectplaceholderflag();
  inline void clear_has_shouldclearobjectplaceholderflag();
  inline void set_has_didmatchobjectplaceholdergeometry();
  inline void clear_has_didmatchobjectplaceholdergeometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSD::GeometryArchive* newgeometry_;
  ::TSD::GeometryArchive* oldgeometry_;
  bool shouldclearobjectplaceholderflag_;
  bool didmatchobjectplaceholdergeometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InfoGeometryCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawablePathSourceCommandArchive : public ::google::protobuf::Message {
 public:
  DrawablePathSourceCommandArchive();
  virtual ~DrawablePathSourceCommandArchive();

  DrawablePathSourceCommandArchive(const DrawablePathSourceCommandArchive& from);

  inline DrawablePathSourceCommandArchive& operator=(const DrawablePathSourceCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawablePathSourceCommandArchive& default_instance();

  void Swap(DrawablePathSourceCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawablePathSourceCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawablePathSourceCommandArchive& from);
  void MergeFrom(const DrawablePathSourceCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSD.PathSourceArchive oldpathsource = 3;
  inline bool has_oldpathsource() const;
  inline void clear_oldpathsource();
  static const int kOldpathsourceFieldNumber = 3;
  inline const ::TSD::PathSourceArchive& oldpathsource() const;
  inline ::TSD::PathSourceArchive* mutable_oldpathsource();
  inline ::TSD::PathSourceArchive* release_oldpathsource();
  inline void set_allocated_oldpathsource(::TSD::PathSourceArchive* oldpathsource);

  // optional .TSD.PathSourceArchive newpathsource = 4;
  inline bool has_newpathsource() const;
  inline void clear_newpathsource();
  static const int kNewpathsourceFieldNumber = 4;
  inline const ::TSD::PathSourceArchive& newpathsource() const;
  inline ::TSD::PathSourceArchive* mutable_newpathsource();
  inline ::TSD::PathSourceArchive* release_newpathsource();
  inline void set_allocated_newpathsource(::TSD::PathSourceArchive* newpathsource);

  // @@protoc_insertion_point(class_scope:TSD.DrawablePathSourceCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_oldpathsource();
  inline void clear_has_oldpathsource();
  inline void set_has_newpathsource();
  inline void clear_has_newpathsource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSD::PathSourceArchive* oldpathsource_;
  ::TSD::PathSourceArchive* newpathsource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawablePathSourceCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InstantAlphaCommandArchive : public ::google::protobuf::Message {
 public:
  InstantAlphaCommandArchive();
  virtual ~InstantAlphaCommandArchive();

  InstantAlphaCommandArchive(const InstantAlphaCommandArchive& from);

  inline InstantAlphaCommandArchive& operator=(const InstantAlphaCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstantAlphaCommandArchive& default_instance();

  void Swap(InstantAlphaCommandArchive* other);

  // implements Message ----------------------------------------------

  InstantAlphaCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstantAlphaCommandArchive& from);
  void MergeFrom(const InstantAlphaCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference image = 2;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::TSP::Reference& image() const;
  inline ::TSP::Reference* mutable_image();
  inline ::TSP::Reference* release_image();
  inline void set_allocated_image(::TSP::Reference* image);

  // optional .TSP.Path oldpath = 3;
  inline bool has_oldpath() const;
  inline void clear_oldpath();
  static const int kOldpathFieldNumber = 3;
  inline const ::TSP::Path& oldpath() const;
  inline ::TSP::Path* mutable_oldpath();
  inline ::TSP::Path* release_oldpath();
  inline void set_allocated_oldpath(::TSP::Path* oldpath);

  // optional .TSP.Path newpath = 4;
  inline bool has_newpath() const;
  inline void clear_newpath();
  static const int kNewpathFieldNumber = 4;
  inline const ::TSP::Path& newpath() const;
  inline ::TSP::Path* mutable_newpath();
  inline ::TSP::Path* release_newpath();
  inline void set_allocated_newpath(::TSP::Path* newpath);

  // @@protoc_insertion_point(class_scope:TSD.InstantAlphaCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_oldpath();
  inline void clear_has_oldpath();
  inline void set_has_newpath();
  inline void clear_has_newpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* image_;
  ::TSP::Path* oldpath_;
  ::TSP::Path* newpath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InstantAlphaCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableShadowCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableShadowCommandArchive();
  virtual ~DrawableShadowCommandArchive();

  DrawableShadowCommandArchive(const DrawableShadowCommandArchive& from);

  inline DrawableShadowCommandArchive& operator=(const DrawableShadowCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableShadowCommandArchive& default_instance();

  void Swap(DrawableShadowCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableShadowCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableShadowCommandArchive& from);
  void MergeFrom(const DrawableShadowCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSD.ShadowArchive oldshadow = 3;
  inline bool has_oldshadow() const;
  inline void clear_oldshadow();
  static const int kOldshadowFieldNumber = 3;
  inline const ::TSD::ShadowArchive& oldshadow() const;
  inline ::TSD::ShadowArchive* mutable_oldshadow();
  inline ::TSD::ShadowArchive* release_oldshadow();
  inline void set_allocated_oldshadow(::TSD::ShadowArchive* oldshadow);

  // optional .TSD.ShadowArchive newshadow = 4;
  inline bool has_newshadow() const;
  inline void clear_newshadow();
  static const int kNewshadowFieldNumber = 4;
  inline const ::TSD::ShadowArchive& newshadow() const;
  inline ::TSD::ShadowArchive* mutable_newshadow();
  inline ::TSD::ShadowArchive* release_newshadow();
  inline void set_allocated_newshadow(::TSD::ShadowArchive* newshadow);

  // @@protoc_insertion_point(class_scope:TSD.DrawableShadowCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_oldshadow();
  inline void clear_has_oldshadow();
  inline void set_has_newshadow();
  inline void clear_has_newshadow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSD::ShadowArchive* oldshadow_;
  ::TSD::ShadowArchive* newshadow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableShadowCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableApplyThemeCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableApplyThemeCommandArchive();
  virtual ~DrawableApplyThemeCommandArchive();

  DrawableApplyThemeCommandArchive(const DrawableApplyThemeCommandArchive& from);

  inline DrawableApplyThemeCommandArchive& operator=(const DrawableApplyThemeCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableApplyThemeCommandArchive& default_instance();

  void Swap(DrawableApplyThemeCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableApplyThemeCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableApplyThemeCommandArchive& from);
  void MergeFrom(const DrawableApplyThemeCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.ApplyThemeChildCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::ApplyThemeChildCommandArchive& super() const;
  inline ::TSS::ApplyThemeChildCommandArchive* mutable_super();
  inline ::TSS::ApplyThemeChildCommandArchive* release_super();
  inline void set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSP.Reference style = 3;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 3;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // @@protoc_insertion_point(class_scope:TSD.DrawableApplyThemeCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_style();
  inline void clear_has_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::ApplyThemeChildCommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSP::Reference* style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableApplyThemeCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyledInfoSetStyleCommandArchive : public ::google::protobuf::Message {
 public:
  StyledInfoSetStyleCommandArchive();
  virtual ~StyledInfoSetStyleCommandArchive();

  StyledInfoSetStyleCommandArchive(const StyledInfoSetStyleCommandArchive& from);

  inline StyledInfoSetStyleCommandArchive& operator=(const StyledInfoSetStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyledInfoSetStyleCommandArchive& default_instance();

  void Swap(StyledInfoSetStyleCommandArchive* other);

  // implements Message ----------------------------------------------

  StyledInfoSetStyleCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyledInfoSetStyleCommandArchive& from);
  void MergeFrom(const StyledInfoSetStyleCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSP.Reference style = 3;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 3;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // @@protoc_insertion_point(class_scope:TSD.StyledInfoSetStyleCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_style();
  inline void clear_has_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSP::Reference* style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyledInfoSetStyleCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapePathSourceFlipCommandArchive : public ::google::protobuf::Message {
 public:
  ShapePathSourceFlipCommandArchive();
  virtual ~ShapePathSourceFlipCommandArchive();

  ShapePathSourceFlipCommandArchive(const ShapePathSourceFlipCommandArchive& from);

  inline ShapePathSourceFlipCommandArchive& operator=(const ShapePathSourceFlipCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapePathSourceFlipCommandArchive& default_instance();

  void Swap(ShapePathSourceFlipCommandArchive* other);

  // implements Message ----------------------------------------------

  ShapePathSourceFlipCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapePathSourceFlipCommandArchive& from);
  void MergeFrom(const ShapePathSourceFlipCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional bool newHorizontalFlip = 3;
  inline bool has_newhorizontalflip() const;
  inline void clear_newhorizontalflip();
  static const int kNewHorizontalFlipFieldNumber = 3;
  inline bool newhorizontalflip() const;
  inline void set_newhorizontalflip(bool value);

  // optional bool newVerticalFlip = 4;
  inline bool has_newverticalflip() const;
  inline void clear_newverticalflip();
  static const int kNewVerticalFlipFieldNumber = 4;
  inline bool newverticalflip() const;
  inline void set_newverticalflip(bool value);

  // optional bool oldHorizontalFlip = 5;
  inline bool has_oldhorizontalflip() const;
  inline void clear_oldhorizontalflip();
  static const int kOldHorizontalFlipFieldNumber = 5;
  inline bool oldhorizontalflip() const;
  inline void set_oldhorizontalflip(bool value);

  // optional bool oldVerticalFlip = 6;
  inline bool has_oldverticalflip() const;
  inline void clear_oldverticalflip();
  static const int kOldVerticalFlipFieldNumber = 6;
  inline bool oldverticalflip() const;
  inline void set_oldverticalflip(bool value);

  // @@protoc_insertion_point(class_scope:TSD.ShapePathSourceFlipCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_newhorizontalflip();
  inline void clear_has_newhorizontalflip();
  inline void set_has_newverticalflip();
  inline void clear_has_newverticalflip();
  inline void set_has_oldhorizontalflip();
  inline void clear_has_oldhorizontalflip();
  inline void set_has_oldverticalflip();
  inline void clear_has_oldverticalflip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  bool newhorizontalflip_;
  bool newverticalflip_;
  bool oldhorizontalflip_;
  bool oldverticalflip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapePathSourceFlipCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeStyleSetValueCommandArchive : public ::google::protobuf::Message {
 public:
  ShapeStyleSetValueCommandArchive();
  virtual ~ShapeStyleSetValueCommandArchive();

  ShapeStyleSetValueCommandArchive(const ShapeStyleSetValueCommandArchive& from);

  inline ShapeStyleSetValueCommandArchive& operator=(const ShapeStyleSetValueCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeStyleSetValueCommandArchive& default_instance();

  void Swap(ShapeStyleSetValueCommandArchive* other);

  // implements Message ----------------------------------------------

  ShapeStyleSetValueCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeStyleSetValueCommandArchive& from);
  void MergeFrom(const ShapeStyleSetValueCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::StyledInfoSetStyleCommandArchive& super() const;
  inline ::TSD::StyledInfoSetStyleCommandArchive* mutable_super();
  inline ::TSD::StyledInfoSetStyleCommandArchive* release_super();
  inline void set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super);

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 4;
  inline bool has_shape_properties() const;
  inline void clear_shape_properties();
  static const int kShapePropertiesFieldNumber = 4;
  inline const ::TSD::ShapeStylePropertiesArchive& shape_properties() const;
  inline ::TSD::ShapeStylePropertiesArchive* mutable_shape_properties();
  inline ::TSD::ShapeStylePropertiesArchive* release_shape_properties();
  inline void set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties);

  // @@protoc_insertion_point(class_scope:TSD.ShapeStyleSetValueCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_shape_properties();
  inline void clear_has_shape_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::StyledInfoSetStyleCommandArchive* super_;
  ::TSD::ShapeStylePropertiesArchive* shape_properties_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeStyleSetValueCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeApplyPresetCommandArchive : public ::google::protobuf::Message {
 public:
  ShapeApplyPresetCommandArchive();
  virtual ~ShapeApplyPresetCommandArchive();

  ShapeApplyPresetCommandArchive(const ShapeApplyPresetCommandArchive& from);

  inline ShapeApplyPresetCommandArchive& operator=(const ShapeApplyPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeApplyPresetCommandArchive& default_instance();

  void Swap(ShapeApplyPresetCommandArchive* other);

  // implements Message ----------------------------------------------

  ShapeApplyPresetCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeApplyPresetCommandArchive& from);
  void MergeFrom(const ShapeApplyPresetCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::StyledInfoSetStyleCommandArchive& super() const;
  inline ::TSD::StyledInfoSetStyleCommandArchive* mutable_super();
  inline ::TSD::StyledInfoSetStyleCommandArchive* release_super();
  inline void set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super);

  // optional .TSP.Reference stylepreset = 10;
  inline bool has_stylepreset() const;
  inline void clear_stylepreset();
  static const int kStylepresetFieldNumber = 10;
  inline const ::TSP::Reference& stylepreset() const;
  inline ::TSP::Reference* mutable_stylepreset();
  inline ::TSP::Reference* release_stylepreset();
  inline void set_allocated_stylepreset(::TSP::Reference* stylepreset);

  // optional .TSP.Color colorpreset = 11;
  inline bool has_colorpreset() const;
  inline void clear_colorpreset();
  static const int kColorpresetFieldNumber = 11;
  inline const ::TSP::Color& colorpreset() const;
  inline ::TSP::Color* mutable_colorpreset();
  inline ::TSP::Color* release_colorpreset();
  inline void set_allocated_colorpreset(::TSP::Color* colorpreset);

  // optional .TSD.FillArchive fillpreset = 12;
  inline bool has_fillpreset() const;
  inline void clear_fillpreset();
  static const int kFillpresetFieldNumber = 12;
  inline const ::TSD::FillArchive& fillpreset() const;
  inline ::TSD::FillArchive* mutable_fillpreset();
  inline ::TSD::FillArchive* release_fillpreset();
  inline void set_allocated_fillpreset(::TSD::FillArchive* fillpreset);

  // optional .TSD.ShadowArchive shadowpreset = 13;
  inline bool has_shadowpreset() const;
  inline void clear_shadowpreset();
  static const int kShadowpresetFieldNumber = 13;
  inline const ::TSD::ShadowArchive& shadowpreset() const;
  inline ::TSD::ShadowArchive* mutable_shadowpreset();
  inline ::TSD::ShadowArchive* release_shadowpreset();
  inline void set_allocated_shadowpreset(::TSD::ShadowArchive* shadowpreset);

  // @@protoc_insertion_point(class_scope:TSD.ShapeApplyPresetCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_stylepreset();
  inline void clear_has_stylepreset();
  inline void set_has_colorpreset();
  inline void clear_has_colorpreset();
  inline void set_has_fillpreset();
  inline void clear_has_fillpreset();
  inline void set_has_shadowpreset();
  inline void clear_has_shadowpreset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::StyledInfoSetStyleCommandArchive* super_;
  ::TSP::Reference* stylepreset_;
  ::TSP::Color* colorpreset_;
  ::TSD::FillArchive* fillpreset_;
  ::TSD::ShadowArchive* shadowpreset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeApplyPresetCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeSetLineEndCommandArchive : public ::google::protobuf::Message {
 public:
  ShapeSetLineEndCommandArchive();
  virtual ~ShapeSetLineEndCommandArchive();

  ShapeSetLineEndCommandArchive(const ShapeSetLineEndCommandArchive& from);

  inline ShapeSetLineEndCommandArchive& operator=(const ShapeSetLineEndCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeSetLineEndCommandArchive& default_instance();

  void Swap(ShapeSetLineEndCommandArchive* other);

  // implements Message ----------------------------------------------

  ShapeSetLineEndCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeSetLineEndCommandArchive& from);
  void MergeFrom(const ShapeSetLineEndCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference shape = 2;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 2;
  inline const ::TSP::Reference& shape() const;
  inline ::TSP::Reference* mutable_shape();
  inline ::TSP::Reference* release_shape();
  inline void set_allocated_shape(::TSP::Reference* shape);

  // optional .TSD.LineEndArchive line_end = 3;
  inline bool has_line_end() const;
  inline void clear_line_end();
  static const int kLineEndFieldNumber = 3;
  inline const ::TSD::LineEndArchive& line_end() const;
  inline ::TSD::LineEndArchive* mutable_line_end();
  inline ::TSD::LineEndArchive* release_line_end();
  inline void set_allocated_line_end(::TSD::LineEndArchive* line_end);

  // optional bool is_head_line_end = 4;
  inline bool has_is_head_line_end() const;
  inline void clear_is_head_line_end();
  static const int kIsHeadLineEndFieldNumber = 4;
  inline bool is_head_line_end() const;
  inline void set_is_head_line_end(bool value);

  // @@protoc_insertion_point(class_scope:TSD.ShapeSetLineEndCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_line_end();
  inline void clear_has_line_end();
  inline void set_has_is_head_line_end();
  inline void clear_has_is_head_line_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* shape_;
  ::TSD::LineEndArchive* line_end_;
  bool is_head_line_end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeSetLineEndCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MovieSetValueCommandArchive_PropertyValue : public ::google::protobuf::Message {
 public:
  MovieSetValueCommandArchive_PropertyValue();
  virtual ~MovieSetValueCommandArchive_PropertyValue();

  MovieSetValueCommandArchive_PropertyValue(const MovieSetValueCommandArchive_PropertyValue& from);

  inline MovieSetValueCommandArchive_PropertyValue& operator=(const MovieSetValueCommandArchive_PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieSetValueCommandArchive_PropertyValue& default_instance();

  void Swap(MovieSetValueCommandArchive_PropertyValue* other);

  // implements Message ----------------------------------------------

  MovieSetValueCommandArchive_PropertyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MovieSetValueCommandArchive_PropertyValue& from);
  void MergeFrom(const MovieSetValueCommandArchive_PropertyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double starttime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 1;
  inline double starttime() const;
  inline void set_starttime(double value);

  // optional double endtime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 2;
  inline double endtime() const;
  inline void set_endtime(double value);

  // optional double postertime = 3;
  inline bool has_postertime() const;
  inline void clear_postertime();
  static const int kPostertimeFieldNumber = 3;
  inline double postertime() const;
  inline void set_postertime(double value);

  // optional .TSP.DataReference posterimagedata = 4;
  inline bool has_posterimagedata() const;
  inline void clear_posterimagedata();
  static const int kPosterimagedataFieldNumber = 4;
  inline const ::TSP::DataReference& posterimagedata() const;
  inline ::TSP::DataReference* mutable_posterimagedata();
  inline ::TSP::DataReference* release_posterimagedata();
  inline void set_allocated_posterimagedata(::TSP::DataReference* posterimagedata);

  // optional bool autoplay = 5;
  inline bool has_autoplay() const;
  inline void clear_autoplay();
  static const int kAutoplayFieldNumber = 5;
  inline bool autoplay() const;
  inline void set_autoplay(bool value);

  // optional .TSD.MovieSetValueCommandArchive.LoopOption loopOption = 6;
  inline bool has_loopoption() const;
  inline void clear_loopoption();
  static const int kLoopOptionFieldNumber = 6;
  inline ::TSD::MovieSetValueCommandArchive_LoopOption loopoption() const;
  inline void set_loopoption(::TSD::MovieSetValueCommandArchive_LoopOption value);

  // optional float volume = 7;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 7;
  inline float volume() const;
  inline void set_volume(float value);

  // optional .TSP.DataReference media = 8;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 8;
  inline const ::TSP::DataReference& media() const;
  inline ::TSP::DataReference* mutable_media();
  inline ::TSP::DataReference* release_media();
  inline void set_allocated_media(::TSP::DataReference* media);

  // optional .TSP.DataReference importedauxiliarymedia = 9;
  inline bool has_importedauxiliarymedia() const;
  inline void clear_importedauxiliarymedia();
  static const int kImportedauxiliarymediaFieldNumber = 9;
  inline const ::TSP::DataReference& importedauxiliarymedia() const;
  inline ::TSP::DataReference* mutable_importedauxiliarymedia();
  inline ::TSP::DataReference* release_importedauxiliarymedia();
  inline void set_allocated_importedauxiliarymedia(::TSP::DataReference* importedauxiliarymedia);

  // @@protoc_insertion_point(class_scope:TSD.MovieSetValueCommandArchive.PropertyValue)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_postertime();
  inline void clear_has_postertime();
  inline void set_has_posterimagedata();
  inline void clear_has_posterimagedata();
  inline void set_has_autoplay();
  inline void clear_has_autoplay();
  inline void set_has_loopoption();
  inline void clear_has_loopoption();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_media();
  inline void clear_has_media();
  inline void set_has_importedauxiliarymedia();
  inline void clear_has_importedauxiliarymedia();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double starttime_;
  double endtime_;
  double postertime_;
  ::TSP::DataReference* posterimagedata_;
  bool autoplay_;
  int loopoption_;
  ::TSP::DataReference* media_;
  ::TSP::DataReference* importedauxiliarymedia_;
  float volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MovieSetValueCommandArchive_PropertyValue* default_instance_;
};
// -------------------------------------------------------------------

class MovieSetValueCommandArchive : public ::google::protobuf::Message {
 public:
  MovieSetValueCommandArchive();
  virtual ~MovieSetValueCommandArchive();

  MovieSetValueCommandArchive(const MovieSetValueCommandArchive& from);

  inline MovieSetValueCommandArchive& operator=(const MovieSetValueCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieSetValueCommandArchive& default_instance();

  void Swap(MovieSetValueCommandArchive* other);

  // implements Message ----------------------------------------------

  MovieSetValueCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MovieSetValueCommandArchive& from);
  void MergeFrom(const MovieSetValueCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MovieSetValueCommandArchive_PropertyValue PropertyValue;

  typedef MovieSetValueCommandArchive_LoopOption LoopOption;
  static const LoopOption None = MovieSetValueCommandArchive_LoopOption_None;
  static const LoopOption Repeat = MovieSetValueCommandArchive_LoopOption_Repeat;
  static const LoopOption BackAndForth = MovieSetValueCommandArchive_LoopOption_BackAndForth;
  static inline bool LoopOption_IsValid(int value) {
    return MovieSetValueCommandArchive_LoopOption_IsValid(value);
  }
  static const LoopOption LoopOption_MIN =
    MovieSetValueCommandArchive_LoopOption_LoopOption_MIN;
  static const LoopOption LoopOption_MAX =
    MovieSetValueCommandArchive_LoopOption_LoopOption_MAX;
  static const int LoopOption_ARRAYSIZE =
    MovieSetValueCommandArchive_LoopOption_LoopOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoopOption_descriptor() {
    return MovieSetValueCommandArchive_LoopOption_descriptor();
  }
  static inline const ::std::string& LoopOption_Name(LoopOption value) {
    return MovieSetValueCommandArchive_LoopOption_Name(value);
  }
  static inline bool LoopOption_Parse(const ::std::string& name,
      LoopOption* value) {
    return MovieSetValueCommandArchive_LoopOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference movie = 2;
  inline bool has_movie() const;
  inline void clear_movie();
  static const int kMovieFieldNumber = 2;
  inline const ::TSP::Reference& movie() const;
  inline ::TSP::Reference* mutable_movie();
  inline ::TSP::Reference* release_movie();
  inline void set_allocated_movie(::TSP::Reference* movie);

  // optional string deprecated_property = 3;
  inline bool has_deprecated_property() const;
  inline void clear_deprecated_property();
  static const int kDeprecatedPropertyFieldNumber = 3;
  inline const ::std::string& deprecated_property() const;
  inline void set_deprecated_property(const ::std::string& value);
  inline void set_deprecated_property(const char* value);
  inline void set_deprecated_property(const char* value, size_t size);
  inline ::std::string* mutable_deprecated_property();
  inline ::std::string* release_deprecated_property();
  inline void set_allocated_deprecated_property(::std::string* deprecated_property);

  // optional int32 property = 4;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 4;
  inline ::google::protobuf::int32 property() const;
  inline void set_property(::google::protobuf::int32 value);

  // optional .TSD.MovieSetValueCommandArchive.PropertyValue value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::TSD::MovieSetValueCommandArchive_PropertyValue& value() const;
  inline ::TSD::MovieSetValueCommandArchive_PropertyValue* mutable_value();
  inline ::TSD::MovieSetValueCommandArchive_PropertyValue* release_value();
  inline void set_allocated_value(::TSD::MovieSetValueCommandArchive_PropertyValue* value);

  // @@protoc_insertion_point(class_scope:TSD.MovieSetValueCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_movie();
  inline void clear_has_movie();
  inline void set_has_deprecated_property();
  inline void clear_has_deprecated_property();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* movie_;
  ::std::string* deprecated_property_;
  ::TSD::MovieSetValueCommandArchive_PropertyValue* value_;
  ::google::protobuf::int32 property_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MovieSetValueCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MediaStyleSetValueCommandArchive : public ::google::protobuf::Message {
 public:
  MediaStyleSetValueCommandArchive();
  virtual ~MediaStyleSetValueCommandArchive();

  MediaStyleSetValueCommandArchive(const MediaStyleSetValueCommandArchive& from);

  inline MediaStyleSetValueCommandArchive& operator=(const MediaStyleSetValueCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaStyleSetValueCommandArchive& default_instance();

  void Swap(MediaStyleSetValueCommandArchive* other);

  // implements Message ----------------------------------------------

  MediaStyleSetValueCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaStyleSetValueCommandArchive& from);
  void MergeFrom(const MediaStyleSetValueCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::StyledInfoSetStyleCommandArchive& super() const;
  inline ::TSD::StyledInfoSetStyleCommandArchive* mutable_super();
  inline ::TSD::StyledInfoSetStyleCommandArchive* release_super();
  inline void set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super);

  // optional .TSD.MediaStylePropertiesArchive media_properties = 4;
  inline bool has_media_properties() const;
  inline void clear_media_properties();
  static const int kMediaPropertiesFieldNumber = 4;
  inline const ::TSD::MediaStylePropertiesArchive& media_properties() const;
  inline ::TSD::MediaStylePropertiesArchive* mutable_media_properties();
  inline ::TSD::MediaStylePropertiesArchive* release_media_properties();
  inline void set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties);

  // @@protoc_insertion_point(class_scope:TSD.MediaStyleSetValueCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_media_properties();
  inline void clear_has_media_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::StyledInfoSetStyleCommandArchive* super_;
  ::TSD::MediaStylePropertiesArchive* media_properties_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MediaStyleSetValueCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageMediaCommandArchive : public ::google::protobuf::Message {
 public:
  ImageMediaCommandArchive();
  virtual ~ImageMediaCommandArchive();

  ImageMediaCommandArchive(const ImageMediaCommandArchive& from);

  inline ImageMediaCommandArchive& operator=(const ImageMediaCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageMediaCommandArchive& default_instance();

  void Swap(ImageMediaCommandArchive* other);

  // implements Message ----------------------------------------------

  ImageMediaCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageMediaCommandArchive& from);
  void MergeFrom(const ImageMediaCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSP.DataReference newImageData = 8;
  inline bool has_newimagedata() const;
  inline void clear_newimagedata();
  static const int kNewImageDataFieldNumber = 8;
  inline const ::TSP::DataReference& newimagedata() const;
  inline ::TSP::DataReference* mutable_newimagedata();
  inline ::TSP::DataReference* release_newimagedata();
  inline void set_allocated_newimagedata(::TSP::DataReference* newimagedata);

  // optional .TSP.DataReference oldImageData = 9;
  inline bool has_oldimagedata() const;
  inline void clear_oldimagedata();
  static const int kOldImageDataFieldNumber = 9;
  inline const ::TSP::DataReference& oldimagedata() const;
  inline ::TSP::DataReference* mutable_oldimagedata();
  inline ::TSP::DataReference* release_oldimagedata();
  inline void set_allocated_oldimagedata(::TSP::DataReference* oldimagedata);

  // optional .TSP.DataReference oldOriginalImageData = 10;
  inline bool has_oldoriginalimagedata() const;
  inline void clear_oldoriginalimagedata();
  static const int kOldOriginalImageDataFieldNumber = 10;
  inline const ::TSP::DataReference& oldoriginalimagedata() const;
  inline ::TSP::DataReference* mutable_oldoriginalimagedata();
  inline ::TSP::DataReference* release_oldoriginalimagedata();
  inline void set_allocated_oldoriginalimagedata(::TSP::DataReference* oldoriginalimagedata);

  // optional .TSP.Size oldNaturalSize = 6;
  inline bool has_oldnaturalsize() const;
  inline void clear_oldnaturalsize();
  static const int kOldNaturalSizeFieldNumber = 6;
  inline const ::TSP::Size& oldnaturalsize() const;
  inline ::TSP::Size* mutable_oldnaturalsize();
  inline ::TSP::Size* release_oldnaturalsize();
  inline void set_allocated_oldnaturalsize(::TSP::Size* oldnaturalsize);

  // optional .TSP.DataReference newOriginalImageData = 11;
  inline bool has_neworiginalimagedata() const;
  inline void clear_neworiginalimagedata();
  static const int kNewOriginalImageDataFieldNumber = 11;
  inline const ::TSP::DataReference& neworiginalimagedata() const;
  inline ::TSP::DataReference* mutable_neworiginalimagedata();
  inline ::TSP::DataReference* release_neworiginalimagedata();
  inline void set_allocated_neworiginalimagedata(::TSP::DataReference* neworiginalimagedata);

  // optional .TSD.ImageAdjustmentsArchive oldImageAdjustments = 12;
  inline bool has_oldimageadjustments() const;
  inline void clear_oldimageadjustments();
  static const int kOldImageAdjustmentsFieldNumber = 12;
  inline const ::TSD::ImageAdjustmentsArchive& oldimageadjustments() const;
  inline ::TSD::ImageAdjustmentsArchive* mutable_oldimageadjustments();
  inline ::TSD::ImageAdjustmentsArchive* release_oldimageadjustments();
  inline void set_allocated_oldimageadjustments(::TSD::ImageAdjustmentsArchive* oldimageadjustments);

  // optional .TSP.DataReference oldAdjustedImageData = 13;
  inline bool has_oldadjustedimagedata() const;
  inline void clear_oldadjustedimagedata();
  static const int kOldAdjustedImageDataFieldNumber = 13;
  inline const ::TSP::DataReference& oldadjustedimagedata() const;
  inline ::TSP::DataReference* mutable_oldadjustedimagedata();
  inline ::TSP::DataReference* release_oldadjustedimagedata();
  inline void set_allocated_oldadjustedimagedata(::TSP::DataReference* oldadjustedimagedata);

  // optional .TSP.DataReference oldEnhancedImageData = 14;
  inline bool has_oldenhancedimagedata() const;
  inline void clear_oldenhancedimagedata();
  static const int kOldEnhancedImageDataFieldNumber = 14;
  inline const ::TSP::DataReference& oldenhancedimagedata() const;
  inline ::TSP::DataReference* mutable_oldenhancedimagedata();
  inline ::TSP::DataReference* release_oldenhancedimagedata();
  inline void set_allocated_oldenhancedimagedata(::TSP::DataReference* oldenhancedimagedata);

  // optional .TSP.Reference database_newImageData = 3;
  inline bool has_database_newimagedata() const;
  inline void clear_database_newimagedata();
  static const int kDatabaseNewImageDataFieldNumber = 3;
  inline const ::TSP::Reference& database_newimagedata() const;
  inline ::TSP::Reference* mutable_database_newimagedata();
  inline ::TSP::Reference* release_database_newimagedata();
  inline void set_allocated_database_newimagedata(::TSP::Reference* database_newimagedata);

  // optional .TSP.Reference database_oldImageData = 4;
  inline bool has_database_oldimagedata() const;
  inline void clear_database_oldimagedata();
  static const int kDatabaseOldImageDataFieldNumber = 4;
  inline const ::TSP::Reference& database_oldimagedata() const;
  inline ::TSP::Reference* mutable_database_oldimagedata();
  inline ::TSP::Reference* release_database_oldimagedata();
  inline void set_allocated_database_oldimagedata(::TSP::Reference* database_oldimagedata);

  // optional .TSP.Reference database_oldOriginalImageData = 5;
  inline bool has_database_oldoriginalimagedata() const;
  inline void clear_database_oldoriginalimagedata();
  static const int kDatabaseOldOriginalImageDataFieldNumber = 5;
  inline const ::TSP::Reference& database_oldoriginalimagedata() const;
  inline ::TSP::Reference* mutable_database_oldoriginalimagedata();
  inline ::TSP::Reference* release_database_oldoriginalimagedata();
  inline void set_allocated_database_oldoriginalimagedata(::TSP::Reference* database_oldoriginalimagedata);

  // optional .TSP.Reference database_newOriginalImageData = 7;
  inline bool has_database_neworiginalimagedata() const;
  inline void clear_database_neworiginalimagedata();
  static const int kDatabaseNewOriginalImageDataFieldNumber = 7;
  inline const ::TSP::Reference& database_neworiginalimagedata() const;
  inline ::TSP::Reference* mutable_database_neworiginalimagedata();
  inline ::TSP::Reference* release_database_neworiginalimagedata();
  inline void set_allocated_database_neworiginalimagedata(::TSP::Reference* database_neworiginalimagedata);

  // @@protoc_insertion_point(class_scope:TSD.ImageMediaCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_newimagedata();
  inline void clear_has_newimagedata();
  inline void set_has_oldimagedata();
  inline void clear_has_oldimagedata();
  inline void set_has_oldoriginalimagedata();
  inline void clear_has_oldoriginalimagedata();
  inline void set_has_oldnaturalsize();
  inline void clear_has_oldnaturalsize();
  inline void set_has_neworiginalimagedata();
  inline void clear_has_neworiginalimagedata();
  inline void set_has_oldimageadjustments();
  inline void clear_has_oldimageadjustments();
  inline void set_has_oldadjustedimagedata();
  inline void clear_has_oldadjustedimagedata();
  inline void set_has_oldenhancedimagedata();
  inline void clear_has_oldenhancedimagedata();
  inline void set_has_database_newimagedata();
  inline void clear_has_database_newimagedata();
  inline void set_has_database_oldimagedata();
  inline void clear_has_database_oldimagedata();
  inline void set_has_database_oldoriginalimagedata();
  inline void clear_has_database_oldoriginalimagedata();
  inline void set_has_database_neworiginalimagedata();
  inline void clear_has_database_neworiginalimagedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSP::DataReference* newimagedata_;
  ::TSP::DataReference* oldimagedata_;
  ::TSP::DataReference* oldoriginalimagedata_;
  ::TSP::Size* oldnaturalsize_;
  ::TSP::DataReference* neworiginalimagedata_;
  ::TSD::ImageAdjustmentsArchive* oldimageadjustments_;
  ::TSP::DataReference* oldadjustedimagedata_;
  ::TSP::DataReference* oldenhancedimagedata_;
  ::TSP::Reference* database_newimagedata_;
  ::TSP::Reference* database_oldimagedata_;
  ::TSP::Reference* database_oldoriginalimagedata_;
  ::TSP::Reference* database_neworiginalimagedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageMediaCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MediaOriginalSizeCommandArchive : public ::google::protobuf::Message {
 public:
  MediaOriginalSizeCommandArchive();
  virtual ~MediaOriginalSizeCommandArchive();

  MediaOriginalSizeCommandArchive(const MediaOriginalSizeCommandArchive& from);

  inline MediaOriginalSizeCommandArchive& operator=(const MediaOriginalSizeCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaOriginalSizeCommandArchive& default_instance();

  void Swap(MediaOriginalSizeCommandArchive* other);

  // implements Message ----------------------------------------------

  MediaOriginalSizeCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaOriginalSizeCommandArchive& from);
  void MergeFrom(const MediaOriginalSizeCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSP.Size newOriginalSize = 3;
  inline bool has_neworiginalsize() const;
  inline void clear_neworiginalsize();
  static const int kNewOriginalSizeFieldNumber = 3;
  inline const ::TSP::Size& neworiginalsize() const;
  inline ::TSP::Size* mutable_neworiginalsize();
  inline ::TSP::Size* release_neworiginalsize();
  inline void set_allocated_neworiginalsize(::TSP::Size* neworiginalsize);

  // optional .TSP.Size oldOriginalSize = 4;
  inline bool has_oldoriginalsize() const;
  inline void clear_oldoriginalsize();
  static const int kOldOriginalSizeFieldNumber = 4;
  inline const ::TSP::Size& oldoriginalsize() const;
  inline ::TSP::Size* mutable_oldoriginalsize();
  inline ::TSP::Size* release_oldoriginalsize();
  inline void set_allocated_oldoriginalsize(::TSP::Size* oldoriginalsize);

  // @@protoc_insertion_point(class_scope:TSD.MediaOriginalSizeCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_neworiginalsize();
  inline void clear_has_neworiginalsize();
  inline void set_has_oldoriginalsize();
  inline void clear_has_oldoriginalsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSP::Size* neworiginalsize_;
  ::TSP::Size* oldoriginalsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MediaOriginalSizeCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageMaskCommandArchive : public ::google::protobuf::Message {
 public:
  ImageMaskCommandArchive();
  virtual ~ImageMaskCommandArchive();

  ImageMaskCommandArchive(const ImageMaskCommandArchive& from);

  inline ImageMaskCommandArchive& operator=(const ImageMaskCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageMaskCommandArchive& default_instance();

  void Swap(ImageMaskCommandArchive* other);

  // implements Message ----------------------------------------------

  ImageMaskCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageMaskCommandArchive& from);
  void MergeFrom(const ImageMaskCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSP.Reference newMaskInfo = 3;
  inline bool has_newmaskinfo() const;
  inline void clear_newmaskinfo();
  static const int kNewMaskInfoFieldNumber = 3;
  inline const ::TSP::Reference& newmaskinfo() const;
  inline ::TSP::Reference* mutable_newmaskinfo();
  inline ::TSP::Reference* release_newmaskinfo();
  inline void set_allocated_newmaskinfo(::TSP::Reference* newmaskinfo);

  // optional .TSP.Reference oldMaskInfo = 4;
  inline bool has_oldmaskinfo() const;
  inline void clear_oldmaskinfo();
  static const int kOldMaskInfoFieldNumber = 4;
  inline const ::TSP::Reference& oldmaskinfo() const;
  inline ::TSP::Reference* mutable_oldmaskinfo();
  inline ::TSP::Reference* release_oldmaskinfo();
  inline void set_allocated_oldmaskinfo(::TSP::Reference* oldmaskinfo);

  // @@protoc_insertion_point(class_scope:TSD.ImageMaskCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_newmaskinfo();
  inline void clear_has_newmaskinfo();
  inline void set_has_oldmaskinfo();
  inline void clear_has_oldmaskinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSP::Reference* newmaskinfo_;
  ::TSP::Reference* oldmaskinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageMaskCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MediaApplyPresetCommandArchive : public ::google::protobuf::Message {
 public:
  MediaApplyPresetCommandArchive();
  virtual ~MediaApplyPresetCommandArchive();

  MediaApplyPresetCommandArchive(const MediaApplyPresetCommandArchive& from);

  inline MediaApplyPresetCommandArchive& operator=(const MediaApplyPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaApplyPresetCommandArchive& default_instance();

  void Swap(MediaApplyPresetCommandArchive* other);

  // implements Message ----------------------------------------------

  MediaApplyPresetCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaApplyPresetCommandArchive& from);
  void MergeFrom(const MediaApplyPresetCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::StyledInfoSetStyleCommandArchive& super() const;
  inline ::TSD::StyledInfoSetStyleCommandArchive* mutable_super();
  inline ::TSD::StyledInfoSetStyleCommandArchive* release_super();
  inline void set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super);

  // optional .TSP.Reference stylepreset = 10;
  inline bool has_stylepreset() const;
  inline void clear_stylepreset();
  static const int kStylepresetFieldNumber = 10;
  inline const ::TSP::Reference& stylepreset() const;
  inline ::TSP::Reference* mutable_stylepreset();
  inline ::TSP::Reference* release_stylepreset();
  inline void set_allocated_stylepreset(::TSP::Reference* stylepreset);

  // optional .TSD.ShadowArchive shadowpreset = 11;
  inline bool has_shadowpreset() const;
  inline void clear_shadowpreset();
  static const int kShadowpresetFieldNumber = 11;
  inline const ::TSD::ShadowArchive& shadowpreset() const;
  inline ::TSD::ShadowArchive* mutable_shadowpreset();
  inline ::TSD::ShadowArchive* release_shadowpreset();
  inline void set_allocated_shadowpreset(::TSD::ShadowArchive* shadowpreset);

  // @@protoc_insertion_point(class_scope:TSD.MediaApplyPresetCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_stylepreset();
  inline void clear_has_stylepreset();
  inline void set_has_shadowpreset();
  inline void clear_has_shadowpreset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::StyledInfoSetStyleCommandArchive* super_;
  ::TSP::Reference* stylepreset_;
  ::TSD::ShadowArchive* shadowpreset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MediaApplyPresetCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageAdjustmentsCommandArchive : public ::google::protobuf::Message {
 public:
  ImageAdjustmentsCommandArchive();
  virtual ~ImageAdjustmentsCommandArchive();

  ImageAdjustmentsCommandArchive(const ImageAdjustmentsCommandArchive& from);

  inline ImageAdjustmentsCommandArchive& operator=(const ImageAdjustmentsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageAdjustmentsCommandArchive& default_instance();

  void Swap(ImageAdjustmentsCommandArchive* other);

  // implements Message ----------------------------------------------

  ImageAdjustmentsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageAdjustmentsCommandArchive& from);
  void MergeFrom(const ImageAdjustmentsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSD.ImageAdjustmentsArchive old_image_adjustments = 2;
  inline bool has_old_image_adjustments() const;
  inline void clear_old_image_adjustments();
  static const int kOldImageAdjustmentsFieldNumber = 2;
  inline const ::TSD::ImageAdjustmentsArchive& old_image_adjustments() const;
  inline ::TSD::ImageAdjustmentsArchive* mutable_old_image_adjustments();
  inline ::TSD::ImageAdjustmentsArchive* release_old_image_adjustments();
  inline void set_allocated_old_image_adjustments(::TSD::ImageAdjustmentsArchive* old_image_adjustments);

  // optional .TSD.ImageAdjustmentsArchive new_image_adjustments = 3;
  inline bool has_new_image_adjustments() const;
  inline void clear_new_image_adjustments();
  static const int kNewImageAdjustmentsFieldNumber = 3;
  inline const ::TSD::ImageAdjustmentsArchive& new_image_adjustments() const;
  inline ::TSD::ImageAdjustmentsArchive* mutable_new_image_adjustments();
  inline ::TSD::ImageAdjustmentsArchive* release_new_image_adjustments();
  inline void set_allocated_new_image_adjustments(::TSD::ImageAdjustmentsArchive* new_image_adjustments);

  // optional .TSP.DataReference adjustedImageData = 4;
  inline bool has_adjustedimagedata() const;
  inline void clear_adjustedimagedata();
  static const int kAdjustedImageDataFieldNumber = 4;
  inline const ::TSP::DataReference& adjustedimagedata() const;
  inline ::TSP::DataReference* mutable_adjustedimagedata();
  inline ::TSP::DataReference* release_adjustedimagedata();
  inline void set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata);

  // optional .TSP.DataReference replacedAdjustedImageData = 5;
  inline bool has_replacedadjustedimagedata() const;
  inline void clear_replacedadjustedimagedata();
  static const int kReplacedAdjustedImageDataFieldNumber = 5;
  inline const ::TSP::DataReference& replacedadjustedimagedata() const;
  inline ::TSP::DataReference* mutable_replacedadjustedimagedata();
  inline ::TSP::DataReference* release_replacedadjustedimagedata();
  inline void set_allocated_replacedadjustedimagedata(::TSP::DataReference* replacedadjustedimagedata);

  // optional .TSP.DataReference enhancedImageData = 6;
  inline bool has_enhancedimagedata() const;
  inline void clear_enhancedimagedata();
  static const int kEnhancedImageDataFieldNumber = 6;
  inline const ::TSP::DataReference& enhancedimagedata() const;
  inline ::TSP::DataReference* mutable_enhancedimagedata();
  inline ::TSP::DataReference* release_enhancedimagedata();
  inline void set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata);

  // optional .TSP.DataReference replacedEnhancedImageData = 7;
  inline bool has_replacedenhancedimagedata() const;
  inline void clear_replacedenhancedimagedata();
  static const int kReplacedEnhancedImageDataFieldNumber = 7;
  inline const ::TSP::DataReference& replacedenhancedimagedata() const;
  inline ::TSP::DataReference* mutable_replacedenhancedimagedata();
  inline ::TSP::DataReference* release_replacedenhancedimagedata();
  inline void set_allocated_replacedenhancedimagedata(::TSP::DataReference* replacedenhancedimagedata);

  // @@protoc_insertion_point(class_scope:TSD.ImageAdjustmentsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_image_adjustments();
  inline void clear_has_old_image_adjustments();
  inline void set_has_new_image_adjustments();
  inline void clear_has_new_image_adjustments();
  inline void set_has_adjustedimagedata();
  inline void clear_has_adjustedimagedata();
  inline void set_has_replacedadjustedimagedata();
  inline void clear_has_replacedadjustedimagedata();
  inline void set_has_enhancedimagedata();
  inline void clear_has_enhancedimagedata();
  inline void set_has_replacedenhancedimagedata();
  inline void clear_has_replacedenhancedimagedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSD::ImageAdjustmentsArchive* old_image_adjustments_;
  ::TSD::ImageAdjustmentsArchive* new_image_adjustments_;
  ::TSP::DataReference* adjustedimagedata_;
  ::TSP::DataReference* replacedadjustedimagedata_;
  ::TSP::DataReference* enhancedimagedata_;
  ::TSP::DataReference* replacedenhancedimagedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageAdjustmentsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MediaFlagsCommandArchive : public ::google::protobuf::Message {
 public:
  MediaFlagsCommandArchive();
  virtual ~MediaFlagsCommandArchive();

  MediaFlagsCommandArchive(const MediaFlagsCommandArchive& from);

  inline MediaFlagsCommandArchive& operator=(const MediaFlagsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaFlagsCommandArchive& default_instance();

  void Swap(MediaFlagsCommandArchive* other);

  // implements Message ----------------------------------------------

  MediaFlagsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaFlagsCommandArchive& from);
  void MergeFrom(const MediaFlagsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional uint32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSD.MediaFlagsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MediaFlagsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawablesCommandGroupArchive : public ::google::protobuf::Message {
 public:
  DrawablesCommandGroupArchive();
  virtual ~DrawablesCommandGroupArchive();

  DrawablesCommandGroupArchive(const DrawablesCommandGroupArchive& from);

  inline DrawablesCommandGroupArchive& operator=(const DrawablesCommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawablesCommandGroupArchive& default_instance();

  void Swap(DrawablesCommandGroupArchive* other);

  // implements Message ----------------------------------------------

  DrawablesCommandGroupArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawablesCommandGroupArchive& from);
  void MergeFrom(const DrawablesCommandGroupArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupType;
  static const DrawablesCommandGroupType Constructive = DrawablesCommandGroupArchive_DrawablesCommandGroupType_Constructive;
  static const DrawablesCommandGroupType Destructive = DrawablesCommandGroupArchive_DrawablesCommandGroupType_Destructive;
  static const DrawablesCommandGroupType InPlace = DrawablesCommandGroupArchive_DrawablesCommandGroupType_InPlace;
  static inline bool DrawablesCommandGroupType_IsValid(int value) {
    return DrawablesCommandGroupArchive_DrawablesCommandGroupType_IsValid(value);
  }
  static const DrawablesCommandGroupType DrawablesCommandGroupType_MIN =
    DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_MIN;
  static const DrawablesCommandGroupType DrawablesCommandGroupType_MAX =
    DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_MAX;
  static const int DrawablesCommandGroupType_ARRAYSIZE =
    DrawablesCommandGroupArchive_DrawablesCommandGroupType_DrawablesCommandGroupType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DrawablesCommandGroupType_descriptor() {
    return DrawablesCommandGroupArchive_DrawablesCommandGroupType_descriptor();
  }
  static inline const ::std::string& DrawablesCommandGroupType_Name(DrawablesCommandGroupType value) {
    return DrawablesCommandGroupArchive_DrawablesCommandGroupType_Name(value);
  }
  static inline bool DrawablesCommandGroupType_Parse(const ::std::string& name,
      DrawablesCommandGroupType* value) {
    return DrawablesCommandGroupArchive_DrawablesCommandGroupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandGroupArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandGroupArchive& super() const;
  inline ::TSK::CommandGroupArchive* mutable_super();
  inline ::TSK::CommandGroupArchive* release_super();
  inline void set_allocated_super(::TSK::CommandGroupArchive* super);

  // optional .TSD.CanvasSelectionArchive obsolete_selection = 2;
  inline bool has_obsolete_selection() const;
  inline void clear_obsolete_selection();
  static const int kObsoleteSelectionFieldNumber = 2;
  inline const ::TSD::CanvasSelectionArchive& obsolete_selection() const;
  inline ::TSD::CanvasSelectionArchive* mutable_obsolete_selection();
  inline ::TSD::CanvasSelectionArchive* release_obsolete_selection();
  inline void set_allocated_obsolete_selection(::TSD::CanvasSelectionArchive* obsolete_selection);

  // optional .TSP.Reference modelforselection = 3;
  inline bool has_modelforselection() const;
  inline void clear_modelforselection();
  static const int kModelforselectionFieldNumber = 3;
  inline const ::TSP::Reference& modelforselection() const;
  inline ::TSP::Reference* mutable_modelforselection();
  inline ::TSP::Reference* release_modelforselection();
  inline void set_allocated_modelforselection(::TSP::Reference* modelforselection);

  // optional .TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType type() const;
  inline void set_type(::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType value);

  // optional bool forDrag = 5;
  inline bool has_fordrag() const;
  inline void clear_fordrag();
  static const int kForDragFieldNumber = 5;
  inline bool fordrag() const;
  inline void set_fordrag(bool value);

  // optional .TSP.Reference archivedselection = 6;
  inline bool has_archivedselection() const;
  inline void clear_archivedselection();
  static const int kArchivedselectionFieldNumber = 6;
  inline const ::TSP::Reference& archivedselection() const;
  inline ::TSP::Reference* mutable_archivedselection();
  inline ::TSP::Reference* release_archivedselection();
  inline void set_allocated_archivedselection(::TSP::Reference* archivedselection);

  // @@protoc_insertion_point(class_scope:TSD.DrawablesCommandGroupArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_obsolete_selection();
  inline void clear_has_obsolete_selection();
  inline void set_has_modelforselection();
  inline void clear_has_modelforselection();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_fordrag();
  inline void clear_has_fordrag();
  inline void set_has_archivedselection();
  inline void clear_has_archivedselection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandGroupArchive* super_;
  ::TSD::CanvasSelectionArchive* obsolete_selection_;
  ::TSP::Reference* modelforselection_;
  int type_;
  bool fordrag_;
  ::TSP::Reference* archivedselection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawablesCommandGroupArchive* default_instance_;
};
// -------------------------------------------------------------------

class ExteriorTextWrapCommandArchive_InfoAndWrap : public ::google::protobuf::Message {
 public:
  ExteriorTextWrapCommandArchive_InfoAndWrap();
  virtual ~ExteriorTextWrapCommandArchive_InfoAndWrap();

  ExteriorTextWrapCommandArchive_InfoAndWrap(const ExteriorTextWrapCommandArchive_InfoAndWrap& from);

  inline ExteriorTextWrapCommandArchive_InfoAndWrap& operator=(const ExteriorTextWrapCommandArchive_InfoAndWrap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExteriorTextWrapCommandArchive_InfoAndWrap& default_instance();

  void Swap(ExteriorTextWrapCommandArchive_InfoAndWrap* other);

  // implements Message ----------------------------------------------

  ExteriorTextWrapCommandArchive_InfoAndWrap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExteriorTextWrapCommandArchive_InfoAndWrap& from);
  void MergeFrom(const ExteriorTextWrapCommandArchive_InfoAndWrap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 2;
  inline bool has_exterior_text_wrap() const;
  inline void clear_exterior_text_wrap();
  static const int kExteriorTextWrapFieldNumber = 2;
  inline const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap() const;
  inline ::TSD::ExteriorTextWrapArchive* mutable_exterior_text_wrap();
  inline ::TSD::ExteriorTextWrapArchive* release_exterior_text_wrap();
  inline void set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap);

  // @@protoc_insertion_point(class_scope:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_exterior_text_wrap();
  inline void clear_has_exterior_text_wrap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* info_;
  ::TSD::ExteriorTextWrapArchive* exterior_text_wrap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ExteriorTextWrapCommandArchive_InfoAndWrap* default_instance_;
};
// -------------------------------------------------------------------

class ExteriorTextWrapCommandArchive : public ::google::protobuf::Message {
 public:
  ExteriorTextWrapCommandArchive();
  virtual ~ExteriorTextWrapCommandArchive();

  ExteriorTextWrapCommandArchive(const ExteriorTextWrapCommandArchive& from);

  inline ExteriorTextWrapCommandArchive& operator=(const ExteriorTextWrapCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExteriorTextWrapCommandArchive& default_instance();

  void Swap(ExteriorTextWrapCommandArchive* other);

  // implements Message ----------------------------------------------

  ExteriorTextWrapCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExteriorTextWrapCommandArchive& from);
  void MergeFrom(const ExteriorTextWrapCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExteriorTextWrapCommandArchive_InfoAndWrap InfoAndWrap;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSD.ExteriorTextWrapCommandArchive.InfoAndWrap info_and_wrap = 2;
  inline int info_and_wrap_size() const;
  inline void clear_info_and_wrap();
  static const int kInfoAndWrapFieldNumber = 2;
  inline const ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap& info_and_wrap(int index) const;
  inline ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap* mutable_info_and_wrap(int index);
  inline ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap* add_info_and_wrap();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap >&
      info_and_wrap() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap >*
      mutable_info_and_wrap();

  // @@protoc_insertion_point(class_scope:TSD.ExteriorTextWrapCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap > info_and_wrap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ExteriorTextWrapCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableHyperlinkCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableHyperlinkCommandArchive();
  virtual ~DrawableHyperlinkCommandArchive();

  DrawableHyperlinkCommandArchive(const DrawableHyperlinkCommandArchive& from);

  inline DrawableHyperlinkCommandArchive& operator=(const DrawableHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableHyperlinkCommandArchive& default_instance();

  void Swap(DrawableHyperlinkCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableHyperlinkCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableHyperlinkCommandArchive& from);
  void MergeFrom(const DrawableHyperlinkCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional string oldhyperlink_url = 3;
  inline bool has_oldhyperlink_url() const;
  inline void clear_oldhyperlink_url();
  static const int kOldhyperlinkUrlFieldNumber = 3;
  inline const ::std::string& oldhyperlink_url() const;
  inline void set_oldhyperlink_url(const ::std::string& value);
  inline void set_oldhyperlink_url(const char* value);
  inline void set_oldhyperlink_url(const char* value, size_t size);
  inline ::std::string* mutable_oldhyperlink_url();
  inline ::std::string* release_oldhyperlink_url();
  inline void set_allocated_oldhyperlink_url(::std::string* oldhyperlink_url);

  // optional string newhyperlink_url = 4;
  inline bool has_newhyperlink_url() const;
  inline void clear_newhyperlink_url();
  static const int kNewhyperlinkUrlFieldNumber = 4;
  inline const ::std::string& newhyperlink_url() const;
  inline void set_newhyperlink_url(const ::std::string& value);
  inline void set_newhyperlink_url(const char* value);
  inline void set_newhyperlink_url(const char* value, size_t size);
  inline ::std::string* mutable_newhyperlink_url();
  inline ::std::string* release_newhyperlink_url();
  inline void set_allocated_newhyperlink_url(::std::string* newhyperlink_url);

  // @@protoc_insertion_point(class_scope:TSD.DrawableHyperlinkCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_oldhyperlink_url();
  inline void clear_has_oldhyperlink_url();
  inline void set_has_newhyperlink_url();
  inline void clear_has_newhyperlink_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::std::string* oldhyperlink_url_;
  ::std::string* newhyperlink_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableHyperlinkCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  CommandSelectionBehaviorArchive();
  virtual ~CommandSelectionBehaviorArchive();

  CommandSelectionBehaviorArchive(const CommandSelectionBehaviorArchive& from);

  inline CommandSelectionBehaviorArchive& operator=(const CommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSelectionBehaviorArchive& default_instance();

  void Swap(CommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  CommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSelectionBehaviorArchive& from);
  void MergeFrom(const CommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorType;
  static const CommandSelectionBehaviorType Constructive = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Constructive;
  static const CommandSelectionBehaviorType Destructive = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Destructive;
  static const CommandSelectionBehaviorType InPlace = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_InPlace;
  static const CommandSelectionBehaviorType Replace = CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Replace;
  static inline bool CommandSelectionBehaviorType_IsValid(int value) {
    return CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_IsValid(value);
  }
  static const CommandSelectionBehaviorType CommandSelectionBehaviorType_MIN =
    CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_MIN;
  static const CommandSelectionBehaviorType CommandSelectionBehaviorType_MAX =
    CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_MAX;
  static const int CommandSelectionBehaviorType_ARRAYSIZE =
    CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_CommandSelectionBehaviorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandSelectionBehaviorType_descriptor() {
    return CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_descriptor();
  }
  static inline const ::std::string& CommandSelectionBehaviorType_Name(CommandSelectionBehaviorType value) {
    return CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Name(value);
  }
  static inline bool CommandSelectionBehaviorType_Parse(const ::std::string& name,
      CommandSelectionBehaviorType* value) {
    return CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Reference model_for_selection = 2;
  inline bool has_model_for_selection() const;
  inline void clear_model_for_selection();
  static const int kModelForSelectionFieldNumber = 2;
  inline const ::TSP::Reference& model_for_selection() const;
  inline ::TSP::Reference* mutable_model_for_selection();
  inline ::TSP::Reference* release_model_for_selection();
  inline void set_allocated_model_for_selection(::TSP::Reference* model_for_selection);

  // optional .TSD.CommandSelectionBehaviorArchive.CommandSelectionBehaviorType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType type() const;
  inline void set_type(::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType value);

  // optional .TSP.Reference archived_selection = 4;
  inline bool has_archived_selection() const;
  inline void clear_archived_selection();
  static const int kArchivedSelectionFieldNumber = 4;
  inline const ::TSP::Reference& archived_selection() const;
  inline ::TSP::Reference* mutable_archived_selection();
  inline ::TSP::Reference* release_archived_selection();
  inline void set_allocated_archived_selection(::TSP::Reference* archived_selection);

  // optional .TSP.Reference archived_new_selection = 5;
  inline bool has_archived_new_selection() const;
  inline void clear_archived_new_selection();
  static const int kArchivedNewSelectionFieldNumber = 5;
  inline const ::TSP::Reference& archived_new_selection() const;
  inline ::TSP::Reference* mutable_archived_new_selection();
  inline ::TSP::Reference* release_archived_new_selection();
  inline void set_allocated_archived_new_selection(::TSP::Reference* archived_new_selection);

  // @@protoc_insertion_point(class_scope:TSD.CommandSelectionBehaviorArchive)
 private:
  inline void set_has_model_for_selection();
  inline void clear_has_model_for_selection();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_archived_selection();
  inline void clear_has_archived_selection();
  inline void set_has_archived_new_selection();
  inline void clear_has_archived_new_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* model_for_selection_;
  ::TSP::Reference* archived_selection_;
  ::TSP::Reference* archived_new_selection_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageReplaceCommandArchive : public ::google::protobuf::Message {
 public:
  ImageReplaceCommandArchive();
  virtual ~ImageReplaceCommandArchive();

  ImageReplaceCommandArchive(const ImageReplaceCommandArchive& from);

  inline ImageReplaceCommandArchive& operator=(const ImageReplaceCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageReplaceCommandArchive& default_instance();

  void Swap(ImageReplaceCommandArchive* other);

  // implements Message ----------------------------------------------

  ImageReplaceCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageReplaceCommandArchive& from);
  void MergeFrom(const ImageReplaceCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TSD.ImageReplaceCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageReplaceCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableLockCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableLockCommandArchive();
  virtual ~DrawableLockCommandArchive();

  DrawableLockCommandArchive(const DrawableLockCommandArchive& from);

  inline DrawableLockCommandArchive& operator=(const DrawableLockCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableLockCommandArchive& default_instance();

  void Swap(DrawableLockCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableLockCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableLockCommandArchive& from);
  void MergeFrom(const DrawableLockCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional bool lock = 3;
  inline bool has_lock() const;
  inline void clear_lock();
  static const int kLockFieldNumber = 3;
  inline bool lock() const;
  inline void set_lock(bool value);

  // @@protoc_insertion_point(class_scope:TSD.DrawableLockCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_lock();
  inline void clear_has_lock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  bool lock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableLockCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableInfoCommentCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableInfoCommentCommandArchive();
  virtual ~DrawableInfoCommentCommandArchive();

  DrawableInfoCommentCommandArchive(const DrawableInfoCommentCommandArchive& from);

  inline DrawableInfoCommentCommandArchive& operator=(const DrawableInfoCommentCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableInfoCommentCommandArchive& default_instance();

  void Swap(DrawableInfoCommentCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableInfoCommentCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableInfoCommentCommandArchive& from);
  void MergeFrom(const DrawableInfoCommentCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional .TSP.Reference old_comment = 3;
  inline bool has_old_comment() const;
  inline void clear_old_comment();
  static const int kOldCommentFieldNumber = 3;
  inline const ::TSP::Reference& old_comment() const;
  inline ::TSP::Reference* mutable_old_comment();
  inline ::TSP::Reference* release_old_comment();
  inline void set_allocated_old_comment(::TSP::Reference* old_comment);

  // optional .TSP.Reference new_comment = 4;
  inline bool has_new_comment() const;
  inline void clear_new_comment();
  static const int kNewCommentFieldNumber = 4;
  inline const ::TSP::Reference& new_comment() const;
  inline ::TSP::Reference* mutable_new_comment();
  inline ::TSP::Reference* release_new_comment();
  inline void set_allocated_new_comment(::TSP::Reference* new_comment);

  // @@protoc_insertion_point(class_scope:TSD.DrawableInfoCommentCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_old_comment();
  inline void clear_has_old_comment();
  inline void set_has_new_comment();
  inline void clear_has_new_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::TSP::Reference* old_comment_;
  ::TSP::Reference* new_comment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableInfoCommentCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommentStorageApplyCommandArchive : public ::google::protobuf::Message {
 public:
  CommentStorageApplyCommandArchive();
  virtual ~CommentStorageApplyCommandArchive();

  CommentStorageApplyCommandArchive(const CommentStorageApplyCommandArchive& from);

  inline CommentStorageApplyCommandArchive& operator=(const CommentStorageApplyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentStorageApplyCommandArchive& default_instance();

  void Swap(CommentStorageApplyCommandArchive* other);

  // implements Message ----------------------------------------------

  CommentStorageApplyCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentStorageApplyCommandArchive& from);
  void MergeFrom(const CommentStorageApplyCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference comment_storage = 2;
  inline bool has_comment_storage() const;
  inline void clear_comment_storage();
  static const int kCommentStorageFieldNumber = 2;
  inline const ::TSP::Reference& comment_storage() const;
  inline ::TSP::Reference* mutable_comment_storage();
  inline ::TSP::Reference* release_comment_storage();
  inline void set_allocated_comment_storage(::TSP::Reference* comment_storage);

  // required string comment_string = 3;
  inline bool has_comment_string() const;
  inline void clear_comment_string();
  static const int kCommentStringFieldNumber = 3;
  inline const ::std::string& comment_string() const;
  inline void set_comment_string(const ::std::string& value);
  inline void set_comment_string(const char* value);
  inline void set_comment_string(const char* value, size_t size);
  inline ::std::string* mutable_comment_string();
  inline ::std::string* release_comment_string();
  inline void set_allocated_comment_string(::std::string* comment_string);

  // required string old_comment_string = 4;
  inline bool has_old_comment_string() const;
  inline void clear_old_comment_string();
  static const int kOldCommentStringFieldNumber = 4;
  inline const ::std::string& old_comment_string() const;
  inline void set_old_comment_string(const ::std::string& value);
  inline void set_old_comment_string(const char* value);
  inline void set_old_comment_string(const char* value, size_t size);
  inline ::std::string* mutable_old_comment_string();
  inline ::std::string* release_old_comment_string();
  inline void set_allocated_old_comment_string(::std::string* old_comment_string);

  // @@protoc_insertion_point(class_scope:TSD.CommentStorageApplyCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_comment_storage();
  inline void clear_has_comment_storage();
  inline void set_has_comment_string();
  inline void clear_has_comment_string();
  inline void set_has_old_comment_string();
  inline void clear_has_old_comment_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* comment_storage_;
  ::std::string* comment_string_;
  ::std::string* old_comment_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommentStorageApplyCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class GuideCommandArchive : public ::google::protobuf::Message {
 public:
  GuideCommandArchive();
  virtual ~GuideCommandArchive();

  GuideCommandArchive(const GuideCommandArchive& from);

  inline GuideCommandArchive& operator=(const GuideCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideCommandArchive& default_instance();

  void Swap(GuideCommandArchive* other);

  // implements Message ----------------------------------------------

  GuideCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideCommandArchive& from);
  void MergeFrom(const GuideCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GuideCommandArchive_GuideCommandMode GuideCommandMode;
  static const GuideCommandMode Add = GuideCommandArchive_GuideCommandMode_Add;
  static const GuideCommandMode Replace = GuideCommandArchive_GuideCommandMode_Replace;
  static const GuideCommandMode Delete = GuideCommandArchive_GuideCommandMode_Delete;
  static inline bool GuideCommandMode_IsValid(int value) {
    return GuideCommandArchive_GuideCommandMode_IsValid(value);
  }
  static const GuideCommandMode GuideCommandMode_MIN =
    GuideCommandArchive_GuideCommandMode_GuideCommandMode_MIN;
  static const GuideCommandMode GuideCommandMode_MAX =
    GuideCommandArchive_GuideCommandMode_GuideCommandMode_MAX;
  static const int GuideCommandMode_ARRAYSIZE =
    GuideCommandArchive_GuideCommandMode_GuideCommandMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GuideCommandMode_descriptor() {
    return GuideCommandArchive_GuideCommandMode_descriptor();
  }
  static inline const ::std::string& GuideCommandMode_Name(GuideCommandMode value) {
    return GuideCommandArchive_GuideCommandMode_Name(value);
  }
  static inline bool GuideCommandMode_Parse(const ::std::string& name,
      GuideCommandMode* value) {
    return GuideCommandArchive_GuideCommandMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSD.UserDefinedGuideArchive old_guide = 3;
  inline bool has_old_guide() const;
  inline void clear_old_guide();
  static const int kOldGuideFieldNumber = 3;
  inline const ::TSD::UserDefinedGuideArchive& old_guide() const;
  inline ::TSD::UserDefinedGuideArchive* mutable_old_guide();
  inline ::TSD::UserDefinedGuideArchive* release_old_guide();
  inline void set_allocated_old_guide(::TSD::UserDefinedGuideArchive* old_guide);

  // optional .TSD.UserDefinedGuideArchive new_guide = 4;
  inline bool has_new_guide() const;
  inline void clear_new_guide();
  static const int kNewGuideFieldNumber = 4;
  inline const ::TSD::UserDefinedGuideArchive& new_guide() const;
  inline ::TSD::UserDefinedGuideArchive* mutable_new_guide();
  inline ::TSD::UserDefinedGuideArchive* release_new_guide();
  inline void set_allocated_new_guide(::TSD::UserDefinedGuideArchive* new_guide);

  // optional .TSD.GuideCommandArchive.GuideCommandMode mode = 5;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline ::TSD::GuideCommandArchive_GuideCommandMode mode() const;
  inline void set_mode(::TSD::GuideCommandArchive_GuideCommandMode value);

  // @@protoc_insertion_point(class_scope:TSD.GuideCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_old_guide();
  inline void clear_has_old_guide();
  inline void set_has_new_guide();
  inline void clear_has_new_guide();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSD::UserDefinedGuideArchive* old_guide_;
  ::TSD::UserDefinedGuideArchive* new_guide_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static GuideCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableAspectRatioLockedCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableAspectRatioLockedCommandArchive();
  virtual ~DrawableAspectRatioLockedCommandArchive();

  DrawableAspectRatioLockedCommandArchive(const DrawableAspectRatioLockedCommandArchive& from);

  inline DrawableAspectRatioLockedCommandArchive& operator=(const DrawableAspectRatioLockedCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableAspectRatioLockedCommandArchive& default_instance();

  void Swap(DrawableAspectRatioLockedCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableAspectRatioLockedCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableAspectRatioLockedCommandArchive& from);
  void MergeFrom(const DrawableAspectRatioLockedCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional bool aspect_ratio_locked = 3;
  inline bool has_aspect_ratio_locked() const;
  inline void clear_aspect_ratio_locked();
  static const int kAspectRatioLockedFieldNumber = 3;
  inline bool aspect_ratio_locked() const;
  inline void set_aspect_ratio_locked(bool value);

  // @@protoc_insertion_point(class_scope:TSD.DrawableAspectRatioLockedCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_aspect_ratio_locked();
  inline void clear_has_aspect_ratio_locked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  bool aspect_ratio_locked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableAspectRatioLockedCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableAccessibilityDescriptionCommandArchive : public ::google::protobuf::Message {
 public:
  DrawableAccessibilityDescriptionCommandArchive();
  virtual ~DrawableAccessibilityDescriptionCommandArchive();

  DrawableAccessibilityDescriptionCommandArchive(const DrawableAccessibilityDescriptionCommandArchive& from);

  inline DrawableAccessibilityDescriptionCommandArchive& operator=(const DrawableAccessibilityDescriptionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableAccessibilityDescriptionCommandArchive& default_instance();

  void Swap(DrawableAccessibilityDescriptionCommandArchive* other);

  // implements Message ----------------------------------------------

  DrawableAccessibilityDescriptionCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableAccessibilityDescriptionCommandArchive& from);
  void MergeFrom(const DrawableAccessibilityDescriptionCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // optional string accessibility_description = 3;
  inline bool has_accessibility_description() const;
  inline void clear_accessibility_description();
  static const int kAccessibilityDescriptionFieldNumber = 3;
  inline const ::std::string& accessibility_description() const;
  inline void set_accessibility_description(const ::std::string& value);
  inline void set_accessibility_description(const char* value);
  inline void set_accessibility_description(const char* value, size_t size);
  inline ::std::string* mutable_accessibility_description();
  inline ::std::string* release_accessibility_description();
  inline void set_allocated_accessibility_description(::std::string* accessibility_description);

  // @@protoc_insertion_point(class_scope:TSD.DrawableAccessibilityDescriptionCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_accessibility_description();
  inline void clear_has_accessibility_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* info_;
  ::std::string* accessibility_description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableAccessibilityDescriptionCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class PasteStyleCommandArchive : public ::google::protobuf::Message {
 public:
  PasteStyleCommandArchive();
  virtual ~PasteStyleCommandArchive();

  PasteStyleCommandArchive(const PasteStyleCommandArchive& from);

  inline PasteStyleCommandArchive& operator=(const PasteStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PasteStyleCommandArchive& default_instance();

  void Swap(PasteStyleCommandArchive* other);

  // implements Message ----------------------------------------------

  PasteStyleCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PasteStyleCommandArchive& from);
  void MergeFrom(const PasteStyleCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference dest_info = 2;
  inline bool has_dest_info() const;
  inline void clear_dest_info();
  static const int kDestInfoFieldNumber = 2;
  inline const ::TSP::Reference& dest_info() const;
  inline ::TSP::Reference* mutable_dest_info();
  inline ::TSP::Reference* release_dest_info();
  inline void set_allocated_dest_info(::TSP::Reference* dest_info);

  // optional .TSP.Reference shape_style = 3;
  inline bool has_shape_style() const;
  inline void clear_shape_style();
  static const int kShapeStyleFieldNumber = 3;
  inline const ::TSP::Reference& shape_style() const;
  inline ::TSP::Reference* mutable_shape_style();
  inline ::TSP::Reference* release_shape_style();
  inline void set_allocated_shape_style(::TSP::Reference* shape_style);

  // @@protoc_insertion_point(class_scope:TSD.PasteStyleCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_dest_info();
  inline void clear_has_dest_info();
  inline void set_has_shape_style();
  inline void clear_has_shape_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* dest_info_;
  ::TSP::Reference* shape_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSDCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static PasteStyleCommandArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// ConnectionLineConnectCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ConnectionLineConnectCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionLineConnectCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionLineConnectCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionLineConnectCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ConnectionLineConnectCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ConnectionLineConnectCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ConnectionLineConnectCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ConnectionLineConnectCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference connection_line = 2;
inline bool ConnectionLineConnectCommandArchive::has_connection_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionLineConnectCommandArchive::set_has_connection_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionLineConnectCommandArchive::clear_has_connection_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionLineConnectCommandArchive::clear_connection_line() {
  if (connection_line_ != NULL) connection_line_->::TSP::Reference::Clear();
  clear_has_connection_line();
}
inline const ::TSP::Reference& ConnectionLineConnectCommandArchive::connection_line() const {
  return connection_line_ != NULL ? *connection_line_ : *default_instance_->connection_line_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::mutable_connection_line() {
  set_has_connection_line();
  if (connection_line_ == NULL) connection_line_ = new ::TSP::Reference;
  return connection_line_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::release_connection_line() {
  clear_has_connection_line();
  ::TSP::Reference* temp = connection_line_;
  connection_line_ = NULL;
  return temp;
}
inline void ConnectionLineConnectCommandArchive::set_allocated_connection_line(::TSP::Reference* connection_line) {
  delete connection_line_;
  connection_line_ = connection_line;
  if (connection_line) {
    set_has_connection_line();
  } else {
    clear_has_connection_line();
  }
}

// optional .TSP.Reference connect_to = 3;
inline bool ConnectionLineConnectCommandArchive::has_connect_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectionLineConnectCommandArchive::set_has_connect_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectionLineConnectCommandArchive::clear_has_connect_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectionLineConnectCommandArchive::clear_connect_to() {
  if (connect_to_ != NULL) connect_to_->::TSP::Reference::Clear();
  clear_has_connect_to();
}
inline const ::TSP::Reference& ConnectionLineConnectCommandArchive::connect_to() const {
  return connect_to_ != NULL ? *connect_to_ : *default_instance_->connect_to_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::mutable_connect_to() {
  set_has_connect_to();
  if (connect_to_ == NULL) connect_to_ = new ::TSP::Reference;
  return connect_to_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::release_connect_to() {
  clear_has_connect_to();
  ::TSP::Reference* temp = connect_to_;
  connect_to_ = NULL;
  return temp;
}
inline void ConnectionLineConnectCommandArchive::set_allocated_connect_to(::TSP::Reference* connect_to) {
  delete connect_to_;
  connect_to_ = connect_to;
  if (connect_to) {
    set_has_connect_to();
  } else {
    clear_has_connect_to();
  }
}

// optional .TSP.Reference connect_from = 4;
inline bool ConnectionLineConnectCommandArchive::has_connect_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectionLineConnectCommandArchive::set_has_connect_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectionLineConnectCommandArchive::clear_has_connect_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectionLineConnectCommandArchive::clear_connect_from() {
  if (connect_from_ != NULL) connect_from_->::TSP::Reference::Clear();
  clear_has_connect_from();
}
inline const ::TSP::Reference& ConnectionLineConnectCommandArchive::connect_from() const {
  return connect_from_ != NULL ? *connect_from_ : *default_instance_->connect_from_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::mutable_connect_from() {
  set_has_connect_from();
  if (connect_from_ == NULL) connect_from_ = new ::TSP::Reference;
  return connect_from_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::release_connect_from() {
  clear_has_connect_from();
  ::TSP::Reference* temp = connect_from_;
  connect_from_ = NULL;
  return temp;
}
inline void ConnectionLineConnectCommandArchive::set_allocated_connect_from(::TSP::Reference* connect_from) {
  delete connect_from_;
  connect_from_ = connect_from;
  if (connect_from) {
    set_has_connect_from();
  } else {
    clear_has_connect_from();
  }
}

// optional .TSP.Reference old_connect_to = 5;
inline bool ConnectionLineConnectCommandArchive::has_old_connect_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectionLineConnectCommandArchive::set_has_old_connect_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectionLineConnectCommandArchive::clear_has_old_connect_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectionLineConnectCommandArchive::clear_old_connect_to() {
  if (old_connect_to_ != NULL) old_connect_to_->::TSP::Reference::Clear();
  clear_has_old_connect_to();
}
inline const ::TSP::Reference& ConnectionLineConnectCommandArchive::old_connect_to() const {
  return old_connect_to_ != NULL ? *old_connect_to_ : *default_instance_->old_connect_to_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::mutable_old_connect_to() {
  set_has_old_connect_to();
  if (old_connect_to_ == NULL) old_connect_to_ = new ::TSP::Reference;
  return old_connect_to_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::release_old_connect_to() {
  clear_has_old_connect_to();
  ::TSP::Reference* temp = old_connect_to_;
  old_connect_to_ = NULL;
  return temp;
}
inline void ConnectionLineConnectCommandArchive::set_allocated_old_connect_to(::TSP::Reference* old_connect_to) {
  delete old_connect_to_;
  old_connect_to_ = old_connect_to;
  if (old_connect_to) {
    set_has_old_connect_to();
  } else {
    clear_has_old_connect_to();
  }
}

// optional .TSP.Reference old_connect_from = 6;
inline bool ConnectionLineConnectCommandArchive::has_old_connect_from() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConnectionLineConnectCommandArchive::set_has_old_connect_from() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConnectionLineConnectCommandArchive::clear_has_old_connect_from() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConnectionLineConnectCommandArchive::clear_old_connect_from() {
  if (old_connect_from_ != NULL) old_connect_from_->::TSP::Reference::Clear();
  clear_has_old_connect_from();
}
inline const ::TSP::Reference& ConnectionLineConnectCommandArchive::old_connect_from() const {
  return old_connect_from_ != NULL ? *old_connect_from_ : *default_instance_->old_connect_from_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::mutable_old_connect_from() {
  set_has_old_connect_from();
  if (old_connect_from_ == NULL) old_connect_from_ = new ::TSP::Reference;
  return old_connect_from_;
}
inline ::TSP::Reference* ConnectionLineConnectCommandArchive::release_old_connect_from() {
  clear_has_old_connect_from();
  ::TSP::Reference* temp = old_connect_from_;
  old_connect_from_ = NULL;
  return temp;
}
inline void ConnectionLineConnectCommandArchive::set_allocated_old_connect_from(::TSP::Reference* old_connect_from) {
  delete old_connect_from_;
  old_connect_from_ = old_connect_from;
  if (old_connect_from) {
    set_has_old_connect_from();
  } else {
    clear_has_old_connect_from();
  }
}

// -------------------------------------------------------------------

// GroupDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool GroupDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& GroupDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* GroupDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* GroupDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void GroupDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference drawables = 2;
inline int GroupDrawablesCommandArchive::drawables_size() const {
  return drawables_.size();
}
inline void GroupDrawablesCommandArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& GroupDrawablesCommandArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* GroupDrawablesCommandArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* GroupDrawablesCommandArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
GroupDrawablesCommandArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
GroupDrawablesCommandArchive::mutable_drawables() {
  return &drawables_;
}

// optional .TSP.Reference group = 3;
inline bool GroupDrawablesCommandArchive::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupDrawablesCommandArchive::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupDrawablesCommandArchive::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupDrawablesCommandArchive::clear_group() {
  if (group_ != NULL) group_->::TSP::Reference::Clear();
  clear_has_group();
}
inline const ::TSP::Reference& GroupDrawablesCommandArchive::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::TSP::Reference* GroupDrawablesCommandArchive::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::TSP::Reference;
  return group_;
}
inline ::TSP::Reference* GroupDrawablesCommandArchive::release_group() {
  clear_has_group();
  ::TSP::Reference* temp = group_;
  group_ = NULL;
  return temp;
}
inline void GroupDrawablesCommandArchive::set_allocated_group(::TSP::Reference* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// UngroupGroupCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool UngroupGroupCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UngroupGroupCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UngroupGroupCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UngroupGroupCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& UngroupGroupCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* UngroupGroupCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* UngroupGroupCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void UngroupGroupCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference drawables = 2;
inline int UngroupGroupCommandArchive::drawables_size() const {
  return drawables_.size();
}
inline void UngroupGroupCommandArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& UngroupGroupCommandArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* UngroupGroupCommandArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* UngroupGroupCommandArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UngroupGroupCommandArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UngroupGroupCommandArchive::mutable_drawables() {
  return &drawables_;
}

// optional .TSP.Reference group = 3;
inline bool UngroupGroupCommandArchive::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UngroupGroupCommandArchive::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UngroupGroupCommandArchive::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UngroupGroupCommandArchive::clear_group() {
  if (group_ != NULL) group_->::TSP::Reference::Clear();
  clear_has_group();
}
inline const ::TSP::Reference& UngroupGroupCommandArchive::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::TSP::Reference* UngroupGroupCommandArchive::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::TSP::Reference;
  return group_;
}
inline ::TSP::Reference* UngroupGroupCommandArchive::release_group() {
  clear_has_group();
  ::TSP::Reference* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UngroupGroupCommandArchive::set_allocated_group(::TSP::Reference* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// ContainerRemoveChildrenCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ContainerRemoveChildrenCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerRemoveChildrenCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerRemoveChildrenCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerRemoveChildrenCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ContainerRemoveChildrenCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ContainerRemoveChildrenCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ContainerRemoveChildrenCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ContainerRemoveChildrenCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference container = 2;
inline bool ContainerRemoveChildrenCommandArchive::has_container() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerRemoveChildrenCommandArchive::set_has_container() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerRemoveChildrenCommandArchive::clear_has_container() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerRemoveChildrenCommandArchive::clear_container() {
  if (container_ != NULL) container_->::TSP::Reference::Clear();
  clear_has_container();
}
inline const ::TSP::Reference& ContainerRemoveChildrenCommandArchive::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::TSP::Reference* ContainerRemoveChildrenCommandArchive::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::TSP::Reference;
  return container_;
}
inline ::TSP::Reference* ContainerRemoveChildrenCommandArchive::release_container() {
  clear_has_container();
  ::TSP::Reference* temp = container_;
  container_ = NULL;
  return temp;
}
inline void ContainerRemoveChildrenCommandArchive::set_allocated_container(::TSP::Reference* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// repeated .TSP.Reference children = 3;
inline int ContainerRemoveChildrenCommandArchive::children_size() const {
  return children_.size();
}
inline void ContainerRemoveChildrenCommandArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& ContainerRemoveChildrenCommandArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* ContainerRemoveChildrenCommandArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* ContainerRemoveChildrenCommandArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ContainerRemoveChildrenCommandArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ContainerRemoveChildrenCommandArchive::mutable_children() {
  return &children_;
}

// optional .TSP.IndexSet children_indices = 4;
inline bool ContainerRemoveChildrenCommandArchive::has_children_indices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerRemoveChildrenCommandArchive::set_has_children_indices() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerRemoveChildrenCommandArchive::clear_has_children_indices() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerRemoveChildrenCommandArchive::clear_children_indices() {
  if (children_indices_ != NULL) children_indices_->::TSP::IndexSet::Clear();
  clear_has_children_indices();
}
inline const ::TSP::IndexSet& ContainerRemoveChildrenCommandArchive::children_indices() const {
  return children_indices_ != NULL ? *children_indices_ : *default_instance_->children_indices_;
}
inline ::TSP::IndexSet* ContainerRemoveChildrenCommandArchive::mutable_children_indices() {
  set_has_children_indices();
  if (children_indices_ == NULL) children_indices_ = new ::TSP::IndexSet;
  return children_indices_;
}
inline ::TSP::IndexSet* ContainerRemoveChildrenCommandArchive::release_children_indices() {
  clear_has_children_indices();
  ::TSP::IndexSet* temp = children_indices_;
  children_indices_ = NULL;
  return temp;
}
inline void ContainerRemoveChildrenCommandArchive::set_allocated_children_indices(::TSP::IndexSet* children_indices) {
  delete children_indices_;
  children_indices_ = children_indices;
  if (children_indices) {
    set_has_children_indices();
  } else {
    clear_has_children_indices();
  }
}

// -------------------------------------------------------------------

// ContainerInsertChildrenCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ContainerInsertChildrenCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInsertChildrenCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInsertChildrenCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInsertChildrenCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ContainerInsertChildrenCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ContainerInsertChildrenCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ContainerInsertChildrenCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ContainerInsertChildrenCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference container = 2;
inline bool ContainerInsertChildrenCommandArchive::has_container() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInsertChildrenCommandArchive::set_has_container() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInsertChildrenCommandArchive::clear_has_container() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInsertChildrenCommandArchive::clear_container() {
  if (container_ != NULL) container_->::TSP::Reference::Clear();
  clear_has_container();
}
inline const ::TSP::Reference& ContainerInsertChildrenCommandArchive::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::TSP::Reference* ContainerInsertChildrenCommandArchive::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::TSP::Reference;
  return container_;
}
inline ::TSP::Reference* ContainerInsertChildrenCommandArchive::release_container() {
  clear_has_container();
  ::TSP::Reference* temp = container_;
  container_ = NULL;
  return temp;
}
inline void ContainerInsertChildrenCommandArchive::set_allocated_container(::TSP::Reference* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// repeated .TSP.Reference children = 3;
inline int ContainerInsertChildrenCommandArchive::children_size() const {
  return children_.size();
}
inline void ContainerInsertChildrenCommandArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& ContainerInsertChildrenCommandArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* ContainerInsertChildrenCommandArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* ContainerInsertChildrenCommandArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ContainerInsertChildrenCommandArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ContainerInsertChildrenCommandArchive::mutable_children() {
  return &children_;
}

// optional uint64 index = 4;
inline bool ContainerInsertChildrenCommandArchive::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInsertChildrenCommandArchive::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInsertChildrenCommandArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInsertChildrenCommandArchive::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 ContainerInsertChildrenCommandArchive::index() const {
  return index_;
}
inline void ContainerInsertChildrenCommandArchive::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ContainerReorderChildrenCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ContainerReorderChildrenCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerReorderChildrenCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerReorderChildrenCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerReorderChildrenCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ContainerReorderChildrenCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ContainerReorderChildrenCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ContainerReorderChildrenCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ContainerReorderChildrenCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference container = 2;
inline bool ContainerReorderChildrenCommandArchive::has_container() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerReorderChildrenCommandArchive::set_has_container() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerReorderChildrenCommandArchive::clear_has_container() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerReorderChildrenCommandArchive::clear_container() {
  if (container_ != NULL) container_->::TSP::Reference::Clear();
  clear_has_container();
}
inline const ::TSP::Reference& ContainerReorderChildrenCommandArchive::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::TSP::Reference* ContainerReorderChildrenCommandArchive::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::TSP::Reference;
  return container_;
}
inline ::TSP::Reference* ContainerReorderChildrenCommandArchive::release_container() {
  clear_has_container();
  ::TSP::Reference* temp = container_;
  container_ = NULL;
  return temp;
}
inline void ContainerReorderChildrenCommandArchive::set_allocated_container(::TSP::Reference* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// repeated .TSP.Reference children = 3;
inline int ContainerReorderChildrenCommandArchive::children_size() const {
  return children_.size();
}
inline void ContainerReorderChildrenCommandArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& ContainerReorderChildrenCommandArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* ContainerReorderChildrenCommandArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* ContainerReorderChildrenCommandArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ContainerReorderChildrenCommandArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ContainerReorderChildrenCommandArchive::mutable_children() {
  return &children_;
}

// optional .TSP.IndexSet children_indices = 4;
inline bool ContainerReorderChildrenCommandArchive::has_children_indices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerReorderChildrenCommandArchive::set_has_children_indices() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerReorderChildrenCommandArchive::clear_has_children_indices() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerReorderChildrenCommandArchive::clear_children_indices() {
  if (children_indices_ != NULL) children_indices_->::TSP::IndexSet::Clear();
  clear_has_children_indices();
}
inline const ::TSP::IndexSet& ContainerReorderChildrenCommandArchive::children_indices() const {
  return children_indices_ != NULL ? *children_indices_ : *default_instance_->children_indices_;
}
inline ::TSP::IndexSet* ContainerReorderChildrenCommandArchive::mutable_children_indices() {
  set_has_children_indices();
  if (children_indices_ == NULL) children_indices_ = new ::TSP::IndexSet;
  return children_indices_;
}
inline ::TSP::IndexSet* ContainerReorderChildrenCommandArchive::release_children_indices() {
  clear_has_children_indices();
  ::TSP::IndexSet* temp = children_indices_;
  children_indices_ = NULL;
  return temp;
}
inline void ContainerReorderChildrenCommandArchive::set_allocated_children_indices(::TSP::IndexSet* children_indices) {
  delete children_indices_;
  children_indices_ = children_indices;
  if (children_indices) {
    set_has_children_indices();
  } else {
    clear_has_children_indices();
  }
}

// -------------------------------------------------------------------

// InfoGeometryCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool InfoGeometryCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoGeometryCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoGeometryCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoGeometryCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InfoGeometryCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InfoGeometryCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InfoGeometryCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InfoGeometryCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool InfoGeometryCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoGeometryCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoGeometryCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoGeometryCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& InfoGeometryCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* InfoGeometryCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* InfoGeometryCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void InfoGeometryCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSD.GeometryArchive newGeometry = 3;
inline bool InfoGeometryCommandArchive::has_newgeometry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoGeometryCommandArchive::set_has_newgeometry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfoGeometryCommandArchive::clear_has_newgeometry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfoGeometryCommandArchive::clear_newgeometry() {
  if (newgeometry_ != NULL) newgeometry_->::TSD::GeometryArchive::Clear();
  clear_has_newgeometry();
}
inline const ::TSD::GeometryArchive& InfoGeometryCommandArchive::newgeometry() const {
  return newgeometry_ != NULL ? *newgeometry_ : *default_instance_->newgeometry_;
}
inline ::TSD::GeometryArchive* InfoGeometryCommandArchive::mutable_newgeometry() {
  set_has_newgeometry();
  if (newgeometry_ == NULL) newgeometry_ = new ::TSD::GeometryArchive;
  return newgeometry_;
}
inline ::TSD::GeometryArchive* InfoGeometryCommandArchive::release_newgeometry() {
  clear_has_newgeometry();
  ::TSD::GeometryArchive* temp = newgeometry_;
  newgeometry_ = NULL;
  return temp;
}
inline void InfoGeometryCommandArchive::set_allocated_newgeometry(::TSD::GeometryArchive* newgeometry) {
  delete newgeometry_;
  newgeometry_ = newgeometry;
  if (newgeometry) {
    set_has_newgeometry();
  } else {
    clear_has_newgeometry();
  }
}

// optional .TSD.GeometryArchive oldGeometry = 4;
inline bool InfoGeometryCommandArchive::has_oldgeometry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InfoGeometryCommandArchive::set_has_oldgeometry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InfoGeometryCommandArchive::clear_has_oldgeometry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InfoGeometryCommandArchive::clear_oldgeometry() {
  if (oldgeometry_ != NULL) oldgeometry_->::TSD::GeometryArchive::Clear();
  clear_has_oldgeometry();
}
inline const ::TSD::GeometryArchive& InfoGeometryCommandArchive::oldgeometry() const {
  return oldgeometry_ != NULL ? *oldgeometry_ : *default_instance_->oldgeometry_;
}
inline ::TSD::GeometryArchive* InfoGeometryCommandArchive::mutable_oldgeometry() {
  set_has_oldgeometry();
  if (oldgeometry_ == NULL) oldgeometry_ = new ::TSD::GeometryArchive;
  return oldgeometry_;
}
inline ::TSD::GeometryArchive* InfoGeometryCommandArchive::release_oldgeometry() {
  clear_has_oldgeometry();
  ::TSD::GeometryArchive* temp = oldgeometry_;
  oldgeometry_ = NULL;
  return temp;
}
inline void InfoGeometryCommandArchive::set_allocated_oldgeometry(::TSD::GeometryArchive* oldgeometry) {
  delete oldgeometry_;
  oldgeometry_ = oldgeometry;
  if (oldgeometry) {
    set_has_oldgeometry();
  } else {
    clear_has_oldgeometry();
  }
}

// optional bool shouldClearObjectPlaceholderFlag = 5;
inline bool InfoGeometryCommandArchive::has_shouldclearobjectplaceholderflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InfoGeometryCommandArchive::set_has_shouldclearobjectplaceholderflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InfoGeometryCommandArchive::clear_has_shouldclearobjectplaceholderflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InfoGeometryCommandArchive::clear_shouldclearobjectplaceholderflag() {
  shouldclearobjectplaceholderflag_ = false;
  clear_has_shouldclearobjectplaceholderflag();
}
inline bool InfoGeometryCommandArchive::shouldclearobjectplaceholderflag() const {
  return shouldclearobjectplaceholderflag_;
}
inline void InfoGeometryCommandArchive::set_shouldclearobjectplaceholderflag(bool value) {
  set_has_shouldclearobjectplaceholderflag();
  shouldclearobjectplaceholderflag_ = value;
}

// optional bool didMatchObjectPlaceholderGeometry = 6;
inline bool InfoGeometryCommandArchive::has_didmatchobjectplaceholdergeometry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InfoGeometryCommandArchive::set_has_didmatchobjectplaceholdergeometry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InfoGeometryCommandArchive::clear_has_didmatchobjectplaceholdergeometry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InfoGeometryCommandArchive::clear_didmatchobjectplaceholdergeometry() {
  didmatchobjectplaceholdergeometry_ = false;
  clear_has_didmatchobjectplaceholdergeometry();
}
inline bool InfoGeometryCommandArchive::didmatchobjectplaceholdergeometry() const {
  return didmatchobjectplaceholdergeometry_;
}
inline void InfoGeometryCommandArchive::set_didmatchobjectplaceholdergeometry(bool value) {
  set_has_didmatchobjectplaceholdergeometry();
  didmatchobjectplaceholdergeometry_ = value;
}

// -------------------------------------------------------------------

// DrawablePathSourceCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawablePathSourceCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawablePathSourceCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawablePathSourceCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawablePathSourceCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawablePathSourceCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawablePathSourceCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawablePathSourceCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawablePathSourceCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawablePathSourceCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawablePathSourceCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawablePathSourceCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawablePathSourceCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawablePathSourceCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawablePathSourceCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawablePathSourceCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawablePathSourceCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSD.PathSourceArchive oldpathsource = 3;
inline bool DrawablePathSourceCommandArchive::has_oldpathsource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawablePathSourceCommandArchive::set_has_oldpathsource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawablePathSourceCommandArchive::clear_has_oldpathsource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawablePathSourceCommandArchive::clear_oldpathsource() {
  if (oldpathsource_ != NULL) oldpathsource_->::TSD::PathSourceArchive::Clear();
  clear_has_oldpathsource();
}
inline const ::TSD::PathSourceArchive& DrawablePathSourceCommandArchive::oldpathsource() const {
  return oldpathsource_ != NULL ? *oldpathsource_ : *default_instance_->oldpathsource_;
}
inline ::TSD::PathSourceArchive* DrawablePathSourceCommandArchive::mutable_oldpathsource() {
  set_has_oldpathsource();
  if (oldpathsource_ == NULL) oldpathsource_ = new ::TSD::PathSourceArchive;
  return oldpathsource_;
}
inline ::TSD::PathSourceArchive* DrawablePathSourceCommandArchive::release_oldpathsource() {
  clear_has_oldpathsource();
  ::TSD::PathSourceArchive* temp = oldpathsource_;
  oldpathsource_ = NULL;
  return temp;
}
inline void DrawablePathSourceCommandArchive::set_allocated_oldpathsource(::TSD::PathSourceArchive* oldpathsource) {
  delete oldpathsource_;
  oldpathsource_ = oldpathsource;
  if (oldpathsource) {
    set_has_oldpathsource();
  } else {
    clear_has_oldpathsource();
  }
}

// optional .TSD.PathSourceArchive newpathsource = 4;
inline bool DrawablePathSourceCommandArchive::has_newpathsource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawablePathSourceCommandArchive::set_has_newpathsource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawablePathSourceCommandArchive::clear_has_newpathsource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawablePathSourceCommandArchive::clear_newpathsource() {
  if (newpathsource_ != NULL) newpathsource_->::TSD::PathSourceArchive::Clear();
  clear_has_newpathsource();
}
inline const ::TSD::PathSourceArchive& DrawablePathSourceCommandArchive::newpathsource() const {
  return newpathsource_ != NULL ? *newpathsource_ : *default_instance_->newpathsource_;
}
inline ::TSD::PathSourceArchive* DrawablePathSourceCommandArchive::mutable_newpathsource() {
  set_has_newpathsource();
  if (newpathsource_ == NULL) newpathsource_ = new ::TSD::PathSourceArchive;
  return newpathsource_;
}
inline ::TSD::PathSourceArchive* DrawablePathSourceCommandArchive::release_newpathsource() {
  clear_has_newpathsource();
  ::TSD::PathSourceArchive* temp = newpathsource_;
  newpathsource_ = NULL;
  return temp;
}
inline void DrawablePathSourceCommandArchive::set_allocated_newpathsource(::TSD::PathSourceArchive* newpathsource) {
  delete newpathsource_;
  newpathsource_ = newpathsource;
  if (newpathsource) {
    set_has_newpathsource();
  } else {
    clear_has_newpathsource();
  }
}

// -------------------------------------------------------------------

// InstantAlphaCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool InstantAlphaCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantAlphaCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantAlphaCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantAlphaCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InstantAlphaCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InstantAlphaCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InstantAlphaCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InstantAlphaCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference image = 2;
inline bool InstantAlphaCommandArchive::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstantAlphaCommandArchive::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstantAlphaCommandArchive::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstantAlphaCommandArchive::clear_image() {
  if (image_ != NULL) image_->::TSP::Reference::Clear();
  clear_has_image();
}
inline const ::TSP::Reference& InstantAlphaCommandArchive::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::TSP::Reference* InstantAlphaCommandArchive::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::TSP::Reference;
  return image_;
}
inline ::TSP::Reference* InstantAlphaCommandArchive::release_image() {
  clear_has_image();
  ::TSP::Reference* temp = image_;
  image_ = NULL;
  return temp;
}
inline void InstantAlphaCommandArchive::set_allocated_image(::TSP::Reference* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// optional .TSP.Path oldpath = 3;
inline bool InstantAlphaCommandArchive::has_oldpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstantAlphaCommandArchive::set_has_oldpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstantAlphaCommandArchive::clear_has_oldpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstantAlphaCommandArchive::clear_oldpath() {
  if (oldpath_ != NULL) oldpath_->::TSP::Path::Clear();
  clear_has_oldpath();
}
inline const ::TSP::Path& InstantAlphaCommandArchive::oldpath() const {
  return oldpath_ != NULL ? *oldpath_ : *default_instance_->oldpath_;
}
inline ::TSP::Path* InstantAlphaCommandArchive::mutable_oldpath() {
  set_has_oldpath();
  if (oldpath_ == NULL) oldpath_ = new ::TSP::Path;
  return oldpath_;
}
inline ::TSP::Path* InstantAlphaCommandArchive::release_oldpath() {
  clear_has_oldpath();
  ::TSP::Path* temp = oldpath_;
  oldpath_ = NULL;
  return temp;
}
inline void InstantAlphaCommandArchive::set_allocated_oldpath(::TSP::Path* oldpath) {
  delete oldpath_;
  oldpath_ = oldpath;
  if (oldpath) {
    set_has_oldpath();
  } else {
    clear_has_oldpath();
  }
}

// optional .TSP.Path newpath = 4;
inline bool InstantAlphaCommandArchive::has_newpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstantAlphaCommandArchive::set_has_newpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstantAlphaCommandArchive::clear_has_newpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstantAlphaCommandArchive::clear_newpath() {
  if (newpath_ != NULL) newpath_->::TSP::Path::Clear();
  clear_has_newpath();
}
inline const ::TSP::Path& InstantAlphaCommandArchive::newpath() const {
  return newpath_ != NULL ? *newpath_ : *default_instance_->newpath_;
}
inline ::TSP::Path* InstantAlphaCommandArchive::mutable_newpath() {
  set_has_newpath();
  if (newpath_ == NULL) newpath_ = new ::TSP::Path;
  return newpath_;
}
inline ::TSP::Path* InstantAlphaCommandArchive::release_newpath() {
  clear_has_newpath();
  ::TSP::Path* temp = newpath_;
  newpath_ = NULL;
  return temp;
}
inline void InstantAlphaCommandArchive::set_allocated_newpath(::TSP::Path* newpath) {
  delete newpath_;
  newpath_ = newpath;
  if (newpath) {
    set_has_newpath();
  } else {
    clear_has_newpath();
  }
}

// -------------------------------------------------------------------

// DrawableShadowCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawableShadowCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableShadowCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableShadowCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableShadowCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawableShadowCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawableShadowCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawableShadowCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableShadowCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableShadowCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableShadowCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableShadowCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableShadowCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableShadowCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableShadowCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableShadowCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableShadowCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSD.ShadowArchive oldshadow = 3;
inline bool DrawableShadowCommandArchive::has_oldshadow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableShadowCommandArchive::set_has_oldshadow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableShadowCommandArchive::clear_has_oldshadow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableShadowCommandArchive::clear_oldshadow() {
  if (oldshadow_ != NULL) oldshadow_->::TSD::ShadowArchive::Clear();
  clear_has_oldshadow();
}
inline const ::TSD::ShadowArchive& DrawableShadowCommandArchive::oldshadow() const {
  return oldshadow_ != NULL ? *oldshadow_ : *default_instance_->oldshadow_;
}
inline ::TSD::ShadowArchive* DrawableShadowCommandArchive::mutable_oldshadow() {
  set_has_oldshadow();
  if (oldshadow_ == NULL) oldshadow_ = new ::TSD::ShadowArchive;
  return oldshadow_;
}
inline ::TSD::ShadowArchive* DrawableShadowCommandArchive::release_oldshadow() {
  clear_has_oldshadow();
  ::TSD::ShadowArchive* temp = oldshadow_;
  oldshadow_ = NULL;
  return temp;
}
inline void DrawableShadowCommandArchive::set_allocated_oldshadow(::TSD::ShadowArchive* oldshadow) {
  delete oldshadow_;
  oldshadow_ = oldshadow;
  if (oldshadow) {
    set_has_oldshadow();
  } else {
    clear_has_oldshadow();
  }
}

// optional .TSD.ShadowArchive newshadow = 4;
inline bool DrawableShadowCommandArchive::has_newshadow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawableShadowCommandArchive::set_has_newshadow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawableShadowCommandArchive::clear_has_newshadow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawableShadowCommandArchive::clear_newshadow() {
  if (newshadow_ != NULL) newshadow_->::TSD::ShadowArchive::Clear();
  clear_has_newshadow();
}
inline const ::TSD::ShadowArchive& DrawableShadowCommandArchive::newshadow() const {
  return newshadow_ != NULL ? *newshadow_ : *default_instance_->newshadow_;
}
inline ::TSD::ShadowArchive* DrawableShadowCommandArchive::mutable_newshadow() {
  set_has_newshadow();
  if (newshadow_ == NULL) newshadow_ = new ::TSD::ShadowArchive;
  return newshadow_;
}
inline ::TSD::ShadowArchive* DrawableShadowCommandArchive::release_newshadow() {
  clear_has_newshadow();
  ::TSD::ShadowArchive* temp = newshadow_;
  newshadow_ = NULL;
  return temp;
}
inline void DrawableShadowCommandArchive::set_allocated_newshadow(::TSD::ShadowArchive* newshadow) {
  delete newshadow_;
  newshadow_ = newshadow;
  if (newshadow) {
    set_has_newshadow();
  } else {
    clear_has_newshadow();
  }
}

// -------------------------------------------------------------------

// DrawableApplyThemeCommandArchive

// required .TSS.ApplyThemeChildCommandArchive super = 1;
inline bool DrawableApplyThemeCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableApplyThemeCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableApplyThemeCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableApplyThemeCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::ApplyThemeChildCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSS::ApplyThemeChildCommandArchive& DrawableApplyThemeCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* DrawableApplyThemeCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::ApplyThemeChildCommandArchive;
  return super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* DrawableApplyThemeCommandArchive::release_super() {
  clear_has_super();
  ::TSS::ApplyThemeChildCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableApplyThemeCommandArchive::set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableApplyThemeCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableApplyThemeCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableApplyThemeCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableApplyThemeCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableApplyThemeCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableApplyThemeCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableApplyThemeCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableApplyThemeCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSP.Reference style = 3;
inline bool DrawableApplyThemeCommandArchive::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableApplyThemeCommandArchive::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableApplyThemeCommandArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableApplyThemeCommandArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& DrawableApplyThemeCommandArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* DrawableApplyThemeCommandArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* DrawableApplyThemeCommandArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void DrawableApplyThemeCommandArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// -------------------------------------------------------------------

// StyledInfoSetStyleCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool StyledInfoSetStyleCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyledInfoSetStyleCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyledInfoSetStyleCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyledInfoSetStyleCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& StyledInfoSetStyleCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* StyledInfoSetStyleCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* StyledInfoSetStyleCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyledInfoSetStyleCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool StyledInfoSetStyleCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyledInfoSetStyleCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyledInfoSetStyleCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyledInfoSetStyleCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& StyledInfoSetStyleCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* StyledInfoSetStyleCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* StyledInfoSetStyleCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void StyledInfoSetStyleCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSP.Reference style = 3;
inline bool StyledInfoSetStyleCommandArchive::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyledInfoSetStyleCommandArchive::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyledInfoSetStyleCommandArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyledInfoSetStyleCommandArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& StyledInfoSetStyleCommandArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* StyledInfoSetStyleCommandArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* StyledInfoSetStyleCommandArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void StyledInfoSetStyleCommandArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// -------------------------------------------------------------------

// ShapePathSourceFlipCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ShapePathSourceFlipCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapePathSourceFlipCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapePathSourceFlipCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapePathSourceFlipCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ShapePathSourceFlipCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ShapePathSourceFlipCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ShapePathSourceFlipCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapePathSourceFlipCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool ShapePathSourceFlipCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapePathSourceFlipCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapePathSourceFlipCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapePathSourceFlipCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& ShapePathSourceFlipCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* ShapePathSourceFlipCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* ShapePathSourceFlipCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void ShapePathSourceFlipCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional bool newHorizontalFlip = 3;
inline bool ShapePathSourceFlipCommandArchive::has_newhorizontalflip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapePathSourceFlipCommandArchive::set_has_newhorizontalflip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapePathSourceFlipCommandArchive::clear_has_newhorizontalflip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapePathSourceFlipCommandArchive::clear_newhorizontalflip() {
  newhorizontalflip_ = false;
  clear_has_newhorizontalflip();
}
inline bool ShapePathSourceFlipCommandArchive::newhorizontalflip() const {
  return newhorizontalflip_;
}
inline void ShapePathSourceFlipCommandArchive::set_newhorizontalflip(bool value) {
  set_has_newhorizontalflip();
  newhorizontalflip_ = value;
}

// optional bool newVerticalFlip = 4;
inline bool ShapePathSourceFlipCommandArchive::has_newverticalflip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapePathSourceFlipCommandArchive::set_has_newverticalflip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapePathSourceFlipCommandArchive::clear_has_newverticalflip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapePathSourceFlipCommandArchive::clear_newverticalflip() {
  newverticalflip_ = false;
  clear_has_newverticalflip();
}
inline bool ShapePathSourceFlipCommandArchive::newverticalflip() const {
  return newverticalflip_;
}
inline void ShapePathSourceFlipCommandArchive::set_newverticalflip(bool value) {
  set_has_newverticalflip();
  newverticalflip_ = value;
}

// optional bool oldHorizontalFlip = 5;
inline bool ShapePathSourceFlipCommandArchive::has_oldhorizontalflip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShapePathSourceFlipCommandArchive::set_has_oldhorizontalflip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShapePathSourceFlipCommandArchive::clear_has_oldhorizontalflip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShapePathSourceFlipCommandArchive::clear_oldhorizontalflip() {
  oldhorizontalflip_ = false;
  clear_has_oldhorizontalflip();
}
inline bool ShapePathSourceFlipCommandArchive::oldhorizontalflip() const {
  return oldhorizontalflip_;
}
inline void ShapePathSourceFlipCommandArchive::set_oldhorizontalflip(bool value) {
  set_has_oldhorizontalflip();
  oldhorizontalflip_ = value;
}

// optional bool oldVerticalFlip = 6;
inline bool ShapePathSourceFlipCommandArchive::has_oldverticalflip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShapePathSourceFlipCommandArchive::set_has_oldverticalflip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShapePathSourceFlipCommandArchive::clear_has_oldverticalflip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShapePathSourceFlipCommandArchive::clear_oldverticalflip() {
  oldverticalflip_ = false;
  clear_has_oldverticalflip();
}
inline bool ShapePathSourceFlipCommandArchive::oldverticalflip() const {
  return oldverticalflip_;
}
inline void ShapePathSourceFlipCommandArchive::set_oldverticalflip(bool value) {
  set_has_oldverticalflip();
  oldverticalflip_ = value;
}

// -------------------------------------------------------------------

// ShapeStyleSetValueCommandArchive

// required .TSD.StyledInfoSetStyleCommandArchive super = 1;
inline bool ShapeStyleSetValueCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeStyleSetValueCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeStyleSetValueCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeStyleSetValueCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::StyledInfoSetStyleCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSD::StyledInfoSetStyleCommandArchive& ShapeStyleSetValueCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* ShapeStyleSetValueCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::StyledInfoSetStyleCommandArchive;
  return super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* ShapeStyleSetValueCommandArchive::release_super() {
  clear_has_super();
  ::TSD::StyledInfoSetStyleCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeStyleSetValueCommandArchive::set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.ShapeStylePropertiesArchive shape_properties = 4;
inline bool ShapeStyleSetValueCommandArchive::has_shape_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeStyleSetValueCommandArchive::set_has_shape_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeStyleSetValueCommandArchive::clear_has_shape_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeStyleSetValueCommandArchive::clear_shape_properties() {
  if (shape_properties_ != NULL) shape_properties_->::TSD::ShapeStylePropertiesArchive::Clear();
  clear_has_shape_properties();
}
inline const ::TSD::ShapeStylePropertiesArchive& ShapeStyleSetValueCommandArchive::shape_properties() const {
  return shape_properties_ != NULL ? *shape_properties_ : *default_instance_->shape_properties_;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleSetValueCommandArchive::mutable_shape_properties() {
  set_has_shape_properties();
  if (shape_properties_ == NULL) shape_properties_ = new ::TSD::ShapeStylePropertiesArchive;
  return shape_properties_;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleSetValueCommandArchive::release_shape_properties() {
  clear_has_shape_properties();
  ::TSD::ShapeStylePropertiesArchive* temp = shape_properties_;
  shape_properties_ = NULL;
  return temp;
}
inline void ShapeStyleSetValueCommandArchive::set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties) {
  delete shape_properties_;
  shape_properties_ = shape_properties;
  if (shape_properties) {
    set_has_shape_properties();
  } else {
    clear_has_shape_properties();
  }
}

// -------------------------------------------------------------------

// ShapeApplyPresetCommandArchive

// required .TSD.StyledInfoSetStyleCommandArchive super = 1;
inline bool ShapeApplyPresetCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeApplyPresetCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeApplyPresetCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeApplyPresetCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::StyledInfoSetStyleCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSD::StyledInfoSetStyleCommandArchive& ShapeApplyPresetCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* ShapeApplyPresetCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::StyledInfoSetStyleCommandArchive;
  return super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* ShapeApplyPresetCommandArchive::release_super() {
  clear_has_super();
  ::TSD::StyledInfoSetStyleCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference stylepreset = 10;
inline bool ShapeApplyPresetCommandArchive::has_stylepreset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeApplyPresetCommandArchive::set_has_stylepreset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeApplyPresetCommandArchive::clear_has_stylepreset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeApplyPresetCommandArchive::clear_stylepreset() {
  if (stylepreset_ != NULL) stylepreset_->::TSP::Reference::Clear();
  clear_has_stylepreset();
}
inline const ::TSP::Reference& ShapeApplyPresetCommandArchive::stylepreset() const {
  return stylepreset_ != NULL ? *stylepreset_ : *default_instance_->stylepreset_;
}
inline ::TSP::Reference* ShapeApplyPresetCommandArchive::mutable_stylepreset() {
  set_has_stylepreset();
  if (stylepreset_ == NULL) stylepreset_ = new ::TSP::Reference;
  return stylepreset_;
}
inline ::TSP::Reference* ShapeApplyPresetCommandArchive::release_stylepreset() {
  clear_has_stylepreset();
  ::TSP::Reference* temp = stylepreset_;
  stylepreset_ = NULL;
  return temp;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_stylepreset(::TSP::Reference* stylepreset) {
  delete stylepreset_;
  stylepreset_ = stylepreset;
  if (stylepreset) {
    set_has_stylepreset();
  } else {
    clear_has_stylepreset();
  }
}

// optional .TSP.Color colorpreset = 11;
inline bool ShapeApplyPresetCommandArchive::has_colorpreset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeApplyPresetCommandArchive::set_has_colorpreset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeApplyPresetCommandArchive::clear_has_colorpreset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeApplyPresetCommandArchive::clear_colorpreset() {
  if (colorpreset_ != NULL) colorpreset_->::TSP::Color::Clear();
  clear_has_colorpreset();
}
inline const ::TSP::Color& ShapeApplyPresetCommandArchive::colorpreset() const {
  return colorpreset_ != NULL ? *colorpreset_ : *default_instance_->colorpreset_;
}
inline ::TSP::Color* ShapeApplyPresetCommandArchive::mutable_colorpreset() {
  set_has_colorpreset();
  if (colorpreset_ == NULL) colorpreset_ = new ::TSP::Color;
  return colorpreset_;
}
inline ::TSP::Color* ShapeApplyPresetCommandArchive::release_colorpreset() {
  clear_has_colorpreset();
  ::TSP::Color* temp = colorpreset_;
  colorpreset_ = NULL;
  return temp;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_colorpreset(::TSP::Color* colorpreset) {
  delete colorpreset_;
  colorpreset_ = colorpreset;
  if (colorpreset) {
    set_has_colorpreset();
  } else {
    clear_has_colorpreset();
  }
}

// optional .TSD.FillArchive fillpreset = 12;
inline bool ShapeApplyPresetCommandArchive::has_fillpreset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapeApplyPresetCommandArchive::set_has_fillpreset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapeApplyPresetCommandArchive::clear_has_fillpreset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapeApplyPresetCommandArchive::clear_fillpreset() {
  if (fillpreset_ != NULL) fillpreset_->::TSD::FillArchive::Clear();
  clear_has_fillpreset();
}
inline const ::TSD::FillArchive& ShapeApplyPresetCommandArchive::fillpreset() const {
  return fillpreset_ != NULL ? *fillpreset_ : *default_instance_->fillpreset_;
}
inline ::TSD::FillArchive* ShapeApplyPresetCommandArchive::mutable_fillpreset() {
  set_has_fillpreset();
  if (fillpreset_ == NULL) fillpreset_ = new ::TSD::FillArchive;
  return fillpreset_;
}
inline ::TSD::FillArchive* ShapeApplyPresetCommandArchive::release_fillpreset() {
  clear_has_fillpreset();
  ::TSD::FillArchive* temp = fillpreset_;
  fillpreset_ = NULL;
  return temp;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_fillpreset(::TSD::FillArchive* fillpreset) {
  delete fillpreset_;
  fillpreset_ = fillpreset;
  if (fillpreset) {
    set_has_fillpreset();
  } else {
    clear_has_fillpreset();
  }
}

// optional .TSD.ShadowArchive shadowpreset = 13;
inline bool ShapeApplyPresetCommandArchive::has_shadowpreset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShapeApplyPresetCommandArchive::set_has_shadowpreset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShapeApplyPresetCommandArchive::clear_has_shadowpreset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShapeApplyPresetCommandArchive::clear_shadowpreset() {
  if (shadowpreset_ != NULL) shadowpreset_->::TSD::ShadowArchive::Clear();
  clear_has_shadowpreset();
}
inline const ::TSD::ShadowArchive& ShapeApplyPresetCommandArchive::shadowpreset() const {
  return shadowpreset_ != NULL ? *shadowpreset_ : *default_instance_->shadowpreset_;
}
inline ::TSD::ShadowArchive* ShapeApplyPresetCommandArchive::mutable_shadowpreset() {
  set_has_shadowpreset();
  if (shadowpreset_ == NULL) shadowpreset_ = new ::TSD::ShadowArchive;
  return shadowpreset_;
}
inline ::TSD::ShadowArchive* ShapeApplyPresetCommandArchive::release_shadowpreset() {
  clear_has_shadowpreset();
  ::TSD::ShadowArchive* temp = shadowpreset_;
  shadowpreset_ = NULL;
  return temp;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_shadowpreset(::TSD::ShadowArchive* shadowpreset) {
  delete shadowpreset_;
  shadowpreset_ = shadowpreset;
  if (shadowpreset) {
    set_has_shadowpreset();
  } else {
    clear_has_shadowpreset();
  }
}

// -------------------------------------------------------------------

// ShapeSetLineEndCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ShapeSetLineEndCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeSetLineEndCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeSetLineEndCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeSetLineEndCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ShapeSetLineEndCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ShapeSetLineEndCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ShapeSetLineEndCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeSetLineEndCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference shape = 2;
inline bool ShapeSetLineEndCommandArchive::has_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeSetLineEndCommandArchive::set_has_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeSetLineEndCommandArchive::clear_has_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeSetLineEndCommandArchive::clear_shape() {
  if (shape_ != NULL) shape_->::TSP::Reference::Clear();
  clear_has_shape();
}
inline const ::TSP::Reference& ShapeSetLineEndCommandArchive::shape() const {
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
inline ::TSP::Reference* ShapeSetLineEndCommandArchive::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) shape_ = new ::TSP::Reference;
  return shape_;
}
inline ::TSP::Reference* ShapeSetLineEndCommandArchive::release_shape() {
  clear_has_shape();
  ::TSP::Reference* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void ShapeSetLineEndCommandArchive::set_allocated_shape(::TSP::Reference* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    set_has_shape();
  } else {
    clear_has_shape();
  }
}

// optional .TSD.LineEndArchive line_end = 3;
inline bool ShapeSetLineEndCommandArchive::has_line_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeSetLineEndCommandArchive::set_has_line_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeSetLineEndCommandArchive::clear_has_line_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeSetLineEndCommandArchive::clear_line_end() {
  if (line_end_ != NULL) line_end_->::TSD::LineEndArchive::Clear();
  clear_has_line_end();
}
inline const ::TSD::LineEndArchive& ShapeSetLineEndCommandArchive::line_end() const {
  return line_end_ != NULL ? *line_end_ : *default_instance_->line_end_;
}
inline ::TSD::LineEndArchive* ShapeSetLineEndCommandArchive::mutable_line_end() {
  set_has_line_end();
  if (line_end_ == NULL) line_end_ = new ::TSD::LineEndArchive;
  return line_end_;
}
inline ::TSD::LineEndArchive* ShapeSetLineEndCommandArchive::release_line_end() {
  clear_has_line_end();
  ::TSD::LineEndArchive* temp = line_end_;
  line_end_ = NULL;
  return temp;
}
inline void ShapeSetLineEndCommandArchive::set_allocated_line_end(::TSD::LineEndArchive* line_end) {
  delete line_end_;
  line_end_ = line_end;
  if (line_end) {
    set_has_line_end();
  } else {
    clear_has_line_end();
  }
}

// optional bool is_head_line_end = 4;
inline bool ShapeSetLineEndCommandArchive::has_is_head_line_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapeSetLineEndCommandArchive::set_has_is_head_line_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapeSetLineEndCommandArchive::clear_has_is_head_line_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapeSetLineEndCommandArchive::clear_is_head_line_end() {
  is_head_line_end_ = false;
  clear_has_is_head_line_end();
}
inline bool ShapeSetLineEndCommandArchive::is_head_line_end() const {
  return is_head_line_end_;
}
inline void ShapeSetLineEndCommandArchive::set_is_head_line_end(bool value) {
  set_has_is_head_line_end();
  is_head_line_end_ = value;
}

// -------------------------------------------------------------------

// MovieSetValueCommandArchive_PropertyValue

// optional double starttime = 1;
inline bool MovieSetValueCommandArchive_PropertyValue::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline double MovieSetValueCommandArchive_PropertyValue::starttime() const {
  return starttime_;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_starttime(double value) {
  set_has_starttime();
  starttime_ = value;
}

// optional double endtime = 2;
inline bool MovieSetValueCommandArchive_PropertyValue::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline double MovieSetValueCommandArchive_PropertyValue::endtime() const {
  return endtime_;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_endtime(double value) {
  set_has_endtime();
  endtime_ = value;
}

// optional double postertime = 3;
inline bool MovieSetValueCommandArchive_PropertyValue::has_postertime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_postertime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_postertime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_postertime() {
  postertime_ = 0;
  clear_has_postertime();
}
inline double MovieSetValueCommandArchive_PropertyValue::postertime() const {
  return postertime_;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_postertime(double value) {
  set_has_postertime();
  postertime_ = value;
}

// optional .TSP.DataReference posterimagedata = 4;
inline bool MovieSetValueCommandArchive_PropertyValue::has_posterimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_posterimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_posterimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_posterimagedata() {
  if (posterimagedata_ != NULL) posterimagedata_->::TSP::DataReference::Clear();
  clear_has_posterimagedata();
}
inline const ::TSP::DataReference& MovieSetValueCommandArchive_PropertyValue::posterimagedata() const {
  return posterimagedata_ != NULL ? *posterimagedata_ : *default_instance_->posterimagedata_;
}
inline ::TSP::DataReference* MovieSetValueCommandArchive_PropertyValue::mutable_posterimagedata() {
  set_has_posterimagedata();
  if (posterimagedata_ == NULL) posterimagedata_ = new ::TSP::DataReference;
  return posterimagedata_;
}
inline ::TSP::DataReference* MovieSetValueCommandArchive_PropertyValue::release_posterimagedata() {
  clear_has_posterimagedata();
  ::TSP::DataReference* temp = posterimagedata_;
  posterimagedata_ = NULL;
  return temp;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_allocated_posterimagedata(::TSP::DataReference* posterimagedata) {
  delete posterimagedata_;
  posterimagedata_ = posterimagedata;
  if (posterimagedata) {
    set_has_posterimagedata();
  } else {
    clear_has_posterimagedata();
  }
}

// optional bool autoplay = 5;
inline bool MovieSetValueCommandArchive_PropertyValue::has_autoplay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_autoplay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_autoplay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_autoplay() {
  autoplay_ = false;
  clear_has_autoplay();
}
inline bool MovieSetValueCommandArchive_PropertyValue::autoplay() const {
  return autoplay_;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_autoplay(bool value) {
  set_has_autoplay();
  autoplay_ = value;
}

// optional .TSD.MovieSetValueCommandArchive.LoopOption loopOption = 6;
inline bool MovieSetValueCommandArchive_PropertyValue::has_loopoption() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_loopoption() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_loopoption() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_loopoption() {
  loopoption_ = 0;
  clear_has_loopoption();
}
inline ::TSD::MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive_PropertyValue::loopoption() const {
  return static_cast< ::TSD::MovieSetValueCommandArchive_LoopOption >(loopoption_);
}
inline void MovieSetValueCommandArchive_PropertyValue::set_loopoption(::TSD::MovieSetValueCommandArchive_LoopOption value) {
  assert(::TSD::MovieSetValueCommandArchive_LoopOption_IsValid(value));
  set_has_loopoption();
  loopoption_ = value;
}

// optional float volume = 7;
inline bool MovieSetValueCommandArchive_PropertyValue::has_volume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_volume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_volume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline float MovieSetValueCommandArchive_PropertyValue::volume() const {
  return volume_;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_volume(float value) {
  set_has_volume();
  volume_ = value;
}

// optional .TSP.DataReference media = 8;
inline bool MovieSetValueCommandArchive_PropertyValue::has_media() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_media() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_media() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_media() {
  if (media_ != NULL) media_->::TSP::DataReference::Clear();
  clear_has_media();
}
inline const ::TSP::DataReference& MovieSetValueCommandArchive_PropertyValue::media() const {
  return media_ != NULL ? *media_ : *default_instance_->media_;
}
inline ::TSP::DataReference* MovieSetValueCommandArchive_PropertyValue::mutable_media() {
  set_has_media();
  if (media_ == NULL) media_ = new ::TSP::DataReference;
  return media_;
}
inline ::TSP::DataReference* MovieSetValueCommandArchive_PropertyValue::release_media() {
  clear_has_media();
  ::TSP::DataReference* temp = media_;
  media_ = NULL;
  return temp;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_allocated_media(::TSP::DataReference* media) {
  delete media_;
  media_ = media;
  if (media) {
    set_has_media();
  } else {
    clear_has_media();
  }
}

// optional .TSP.DataReference importedauxiliarymedia = 9;
inline bool MovieSetValueCommandArchive_PropertyValue::has_importedauxiliarymedia() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_has_importedauxiliarymedia() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_has_importedauxiliarymedia() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MovieSetValueCommandArchive_PropertyValue::clear_importedauxiliarymedia() {
  if (importedauxiliarymedia_ != NULL) importedauxiliarymedia_->::TSP::DataReference::Clear();
  clear_has_importedauxiliarymedia();
}
inline const ::TSP::DataReference& MovieSetValueCommandArchive_PropertyValue::importedauxiliarymedia() const {
  return importedauxiliarymedia_ != NULL ? *importedauxiliarymedia_ : *default_instance_->importedauxiliarymedia_;
}
inline ::TSP::DataReference* MovieSetValueCommandArchive_PropertyValue::mutable_importedauxiliarymedia() {
  set_has_importedauxiliarymedia();
  if (importedauxiliarymedia_ == NULL) importedauxiliarymedia_ = new ::TSP::DataReference;
  return importedauxiliarymedia_;
}
inline ::TSP::DataReference* MovieSetValueCommandArchive_PropertyValue::release_importedauxiliarymedia() {
  clear_has_importedauxiliarymedia();
  ::TSP::DataReference* temp = importedauxiliarymedia_;
  importedauxiliarymedia_ = NULL;
  return temp;
}
inline void MovieSetValueCommandArchive_PropertyValue::set_allocated_importedauxiliarymedia(::TSP::DataReference* importedauxiliarymedia) {
  delete importedauxiliarymedia_;
  importedauxiliarymedia_ = importedauxiliarymedia;
  if (importedauxiliarymedia) {
    set_has_importedauxiliarymedia();
  } else {
    clear_has_importedauxiliarymedia();
  }
}

// -------------------------------------------------------------------

// MovieSetValueCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MovieSetValueCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MovieSetValueCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MovieSetValueCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MovieSetValueCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MovieSetValueCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MovieSetValueCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MovieSetValueCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MovieSetValueCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference movie = 2;
inline bool MovieSetValueCommandArchive::has_movie() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MovieSetValueCommandArchive::set_has_movie() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MovieSetValueCommandArchive::clear_has_movie() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MovieSetValueCommandArchive::clear_movie() {
  if (movie_ != NULL) movie_->::TSP::Reference::Clear();
  clear_has_movie();
}
inline const ::TSP::Reference& MovieSetValueCommandArchive::movie() const {
  return movie_ != NULL ? *movie_ : *default_instance_->movie_;
}
inline ::TSP::Reference* MovieSetValueCommandArchive::mutable_movie() {
  set_has_movie();
  if (movie_ == NULL) movie_ = new ::TSP::Reference;
  return movie_;
}
inline ::TSP::Reference* MovieSetValueCommandArchive::release_movie() {
  clear_has_movie();
  ::TSP::Reference* temp = movie_;
  movie_ = NULL;
  return temp;
}
inline void MovieSetValueCommandArchive::set_allocated_movie(::TSP::Reference* movie) {
  delete movie_;
  movie_ = movie;
  if (movie) {
    set_has_movie();
  } else {
    clear_has_movie();
  }
}

// optional string deprecated_property = 3;
inline bool MovieSetValueCommandArchive::has_deprecated_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MovieSetValueCommandArchive::set_has_deprecated_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MovieSetValueCommandArchive::clear_has_deprecated_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MovieSetValueCommandArchive::clear_deprecated_property() {
  if (deprecated_property_ != &::google::protobuf::internal::kEmptyString) {
    deprecated_property_->clear();
  }
  clear_has_deprecated_property();
}
inline const ::std::string& MovieSetValueCommandArchive::deprecated_property() const {
  return *deprecated_property_;
}
inline void MovieSetValueCommandArchive::set_deprecated_property(const ::std::string& value) {
  set_has_deprecated_property();
  if (deprecated_property_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_property_ = new ::std::string;
  }
  deprecated_property_->assign(value);
}
inline void MovieSetValueCommandArchive::set_deprecated_property(const char* value) {
  set_has_deprecated_property();
  if (deprecated_property_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_property_ = new ::std::string;
  }
  deprecated_property_->assign(value);
}
inline void MovieSetValueCommandArchive::set_deprecated_property(const char* value, size_t size) {
  set_has_deprecated_property();
  if (deprecated_property_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_property_ = new ::std::string;
  }
  deprecated_property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MovieSetValueCommandArchive::mutable_deprecated_property() {
  set_has_deprecated_property();
  if (deprecated_property_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_property_ = new ::std::string;
  }
  return deprecated_property_;
}
inline ::std::string* MovieSetValueCommandArchive::release_deprecated_property() {
  clear_has_deprecated_property();
  if (deprecated_property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deprecated_property_;
    deprecated_property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MovieSetValueCommandArchive::set_allocated_deprecated_property(::std::string* deprecated_property) {
  if (deprecated_property_ != &::google::protobuf::internal::kEmptyString) {
    delete deprecated_property_;
  }
  if (deprecated_property) {
    set_has_deprecated_property();
    deprecated_property_ = deprecated_property;
  } else {
    clear_has_deprecated_property();
    deprecated_property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 property = 4;
inline bool MovieSetValueCommandArchive::has_property() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MovieSetValueCommandArchive::set_has_property() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MovieSetValueCommandArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MovieSetValueCommandArchive::clear_property() {
  property_ = 0;
  clear_has_property();
}
inline ::google::protobuf::int32 MovieSetValueCommandArchive::property() const {
  return property_;
}
inline void MovieSetValueCommandArchive::set_property(::google::protobuf::int32 value) {
  set_has_property();
  property_ = value;
}

// optional .TSD.MovieSetValueCommandArchive.PropertyValue value = 5;
inline bool MovieSetValueCommandArchive::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MovieSetValueCommandArchive::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MovieSetValueCommandArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MovieSetValueCommandArchive::clear_value() {
  if (value_ != NULL) value_->::TSD::MovieSetValueCommandArchive_PropertyValue::Clear();
  clear_has_value();
}
inline const ::TSD::MovieSetValueCommandArchive_PropertyValue& MovieSetValueCommandArchive::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::TSD::MovieSetValueCommandArchive_PropertyValue* MovieSetValueCommandArchive::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::TSD::MovieSetValueCommandArchive_PropertyValue;
  return value_;
}
inline ::TSD::MovieSetValueCommandArchive_PropertyValue* MovieSetValueCommandArchive::release_value() {
  clear_has_value();
  ::TSD::MovieSetValueCommandArchive_PropertyValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void MovieSetValueCommandArchive::set_allocated_value(::TSD::MovieSetValueCommandArchive_PropertyValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// MediaStyleSetValueCommandArchive

// required .TSD.StyledInfoSetStyleCommandArchive super = 1;
inline bool MediaStyleSetValueCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaStyleSetValueCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaStyleSetValueCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaStyleSetValueCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::StyledInfoSetStyleCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSD::StyledInfoSetStyleCommandArchive& MediaStyleSetValueCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* MediaStyleSetValueCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::StyledInfoSetStyleCommandArchive;
  return super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* MediaStyleSetValueCommandArchive::release_super() {
  clear_has_super();
  ::TSD::StyledInfoSetStyleCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MediaStyleSetValueCommandArchive::set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.MediaStylePropertiesArchive media_properties = 4;
inline bool MediaStyleSetValueCommandArchive::has_media_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaStyleSetValueCommandArchive::set_has_media_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaStyleSetValueCommandArchive::clear_has_media_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaStyleSetValueCommandArchive::clear_media_properties() {
  if (media_properties_ != NULL) media_properties_->::TSD::MediaStylePropertiesArchive::Clear();
  clear_has_media_properties();
}
inline const ::TSD::MediaStylePropertiesArchive& MediaStyleSetValueCommandArchive::media_properties() const {
  return media_properties_ != NULL ? *media_properties_ : *default_instance_->media_properties_;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleSetValueCommandArchive::mutable_media_properties() {
  set_has_media_properties();
  if (media_properties_ == NULL) media_properties_ = new ::TSD::MediaStylePropertiesArchive;
  return media_properties_;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleSetValueCommandArchive::release_media_properties() {
  clear_has_media_properties();
  ::TSD::MediaStylePropertiesArchive* temp = media_properties_;
  media_properties_ = NULL;
  return temp;
}
inline void MediaStyleSetValueCommandArchive::set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties) {
  delete media_properties_;
  media_properties_ = media_properties;
  if (media_properties) {
    set_has_media_properties();
  } else {
    clear_has_media_properties();
  }
}

// -------------------------------------------------------------------

// ImageMediaCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ImageMediaCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageMediaCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageMediaCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageMediaCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ImageMediaCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ImageMediaCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ImageMediaCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool ImageMediaCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageMediaCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageMediaCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageMediaCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& ImageMediaCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSP.DataReference newImageData = 8;
inline bool ImageMediaCommandArchive::has_newimagedata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageMediaCommandArchive::set_has_newimagedata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageMediaCommandArchive::clear_has_newimagedata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageMediaCommandArchive::clear_newimagedata() {
  if (newimagedata_ != NULL) newimagedata_->::TSP::DataReference::Clear();
  clear_has_newimagedata();
}
inline const ::TSP::DataReference& ImageMediaCommandArchive::newimagedata() const {
  return newimagedata_ != NULL ? *newimagedata_ : *default_instance_->newimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::mutable_newimagedata() {
  set_has_newimagedata();
  if (newimagedata_ == NULL) newimagedata_ = new ::TSP::DataReference;
  return newimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::release_newimagedata() {
  clear_has_newimagedata();
  ::TSP::DataReference* temp = newimagedata_;
  newimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_newimagedata(::TSP::DataReference* newimagedata) {
  delete newimagedata_;
  newimagedata_ = newimagedata;
  if (newimagedata) {
    set_has_newimagedata();
  } else {
    clear_has_newimagedata();
  }
}

// optional .TSP.DataReference oldImageData = 9;
inline bool ImageMediaCommandArchive::has_oldimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageMediaCommandArchive::set_has_oldimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageMediaCommandArchive::clear_has_oldimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageMediaCommandArchive::clear_oldimagedata() {
  if (oldimagedata_ != NULL) oldimagedata_->::TSP::DataReference::Clear();
  clear_has_oldimagedata();
}
inline const ::TSP::DataReference& ImageMediaCommandArchive::oldimagedata() const {
  return oldimagedata_ != NULL ? *oldimagedata_ : *default_instance_->oldimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::mutable_oldimagedata() {
  set_has_oldimagedata();
  if (oldimagedata_ == NULL) oldimagedata_ = new ::TSP::DataReference;
  return oldimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::release_oldimagedata() {
  clear_has_oldimagedata();
  ::TSP::DataReference* temp = oldimagedata_;
  oldimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_oldimagedata(::TSP::DataReference* oldimagedata) {
  delete oldimagedata_;
  oldimagedata_ = oldimagedata;
  if (oldimagedata) {
    set_has_oldimagedata();
  } else {
    clear_has_oldimagedata();
  }
}

// optional .TSP.DataReference oldOriginalImageData = 10;
inline bool ImageMediaCommandArchive::has_oldoriginalimagedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageMediaCommandArchive::set_has_oldoriginalimagedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageMediaCommandArchive::clear_has_oldoriginalimagedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageMediaCommandArchive::clear_oldoriginalimagedata() {
  if (oldoriginalimagedata_ != NULL) oldoriginalimagedata_->::TSP::DataReference::Clear();
  clear_has_oldoriginalimagedata();
}
inline const ::TSP::DataReference& ImageMediaCommandArchive::oldoriginalimagedata() const {
  return oldoriginalimagedata_ != NULL ? *oldoriginalimagedata_ : *default_instance_->oldoriginalimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::mutable_oldoriginalimagedata() {
  set_has_oldoriginalimagedata();
  if (oldoriginalimagedata_ == NULL) oldoriginalimagedata_ = new ::TSP::DataReference;
  return oldoriginalimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::release_oldoriginalimagedata() {
  clear_has_oldoriginalimagedata();
  ::TSP::DataReference* temp = oldoriginalimagedata_;
  oldoriginalimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_oldoriginalimagedata(::TSP::DataReference* oldoriginalimagedata) {
  delete oldoriginalimagedata_;
  oldoriginalimagedata_ = oldoriginalimagedata;
  if (oldoriginalimagedata) {
    set_has_oldoriginalimagedata();
  } else {
    clear_has_oldoriginalimagedata();
  }
}

// optional .TSP.Size oldNaturalSize = 6;
inline bool ImageMediaCommandArchive::has_oldnaturalsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageMediaCommandArchive::set_has_oldnaturalsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageMediaCommandArchive::clear_has_oldnaturalsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageMediaCommandArchive::clear_oldnaturalsize() {
  if (oldnaturalsize_ != NULL) oldnaturalsize_->::TSP::Size::Clear();
  clear_has_oldnaturalsize();
}
inline const ::TSP::Size& ImageMediaCommandArchive::oldnaturalsize() const {
  return oldnaturalsize_ != NULL ? *oldnaturalsize_ : *default_instance_->oldnaturalsize_;
}
inline ::TSP::Size* ImageMediaCommandArchive::mutable_oldnaturalsize() {
  set_has_oldnaturalsize();
  if (oldnaturalsize_ == NULL) oldnaturalsize_ = new ::TSP::Size;
  return oldnaturalsize_;
}
inline ::TSP::Size* ImageMediaCommandArchive::release_oldnaturalsize() {
  clear_has_oldnaturalsize();
  ::TSP::Size* temp = oldnaturalsize_;
  oldnaturalsize_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_oldnaturalsize(::TSP::Size* oldnaturalsize) {
  delete oldnaturalsize_;
  oldnaturalsize_ = oldnaturalsize;
  if (oldnaturalsize) {
    set_has_oldnaturalsize();
  } else {
    clear_has_oldnaturalsize();
  }
}

// optional .TSP.DataReference newOriginalImageData = 11;
inline bool ImageMediaCommandArchive::has_neworiginalimagedata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageMediaCommandArchive::set_has_neworiginalimagedata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageMediaCommandArchive::clear_has_neworiginalimagedata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageMediaCommandArchive::clear_neworiginalimagedata() {
  if (neworiginalimagedata_ != NULL) neworiginalimagedata_->::TSP::DataReference::Clear();
  clear_has_neworiginalimagedata();
}
inline const ::TSP::DataReference& ImageMediaCommandArchive::neworiginalimagedata() const {
  return neworiginalimagedata_ != NULL ? *neworiginalimagedata_ : *default_instance_->neworiginalimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::mutable_neworiginalimagedata() {
  set_has_neworiginalimagedata();
  if (neworiginalimagedata_ == NULL) neworiginalimagedata_ = new ::TSP::DataReference;
  return neworiginalimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::release_neworiginalimagedata() {
  clear_has_neworiginalimagedata();
  ::TSP::DataReference* temp = neworiginalimagedata_;
  neworiginalimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_neworiginalimagedata(::TSP::DataReference* neworiginalimagedata) {
  delete neworiginalimagedata_;
  neworiginalimagedata_ = neworiginalimagedata;
  if (neworiginalimagedata) {
    set_has_neworiginalimagedata();
  } else {
    clear_has_neworiginalimagedata();
  }
}

// optional .TSD.ImageAdjustmentsArchive oldImageAdjustments = 12;
inline bool ImageMediaCommandArchive::has_oldimageadjustments() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageMediaCommandArchive::set_has_oldimageadjustments() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageMediaCommandArchive::clear_has_oldimageadjustments() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageMediaCommandArchive::clear_oldimageadjustments() {
  if (oldimageadjustments_ != NULL) oldimageadjustments_->::TSD::ImageAdjustmentsArchive::Clear();
  clear_has_oldimageadjustments();
}
inline const ::TSD::ImageAdjustmentsArchive& ImageMediaCommandArchive::oldimageadjustments() const {
  return oldimageadjustments_ != NULL ? *oldimageadjustments_ : *default_instance_->oldimageadjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageMediaCommandArchive::mutable_oldimageadjustments() {
  set_has_oldimageadjustments();
  if (oldimageadjustments_ == NULL) oldimageadjustments_ = new ::TSD::ImageAdjustmentsArchive;
  return oldimageadjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageMediaCommandArchive::release_oldimageadjustments() {
  clear_has_oldimageadjustments();
  ::TSD::ImageAdjustmentsArchive* temp = oldimageadjustments_;
  oldimageadjustments_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_oldimageadjustments(::TSD::ImageAdjustmentsArchive* oldimageadjustments) {
  delete oldimageadjustments_;
  oldimageadjustments_ = oldimageadjustments;
  if (oldimageadjustments) {
    set_has_oldimageadjustments();
  } else {
    clear_has_oldimageadjustments();
  }
}

// optional .TSP.DataReference oldAdjustedImageData = 13;
inline bool ImageMediaCommandArchive::has_oldadjustedimagedata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageMediaCommandArchive::set_has_oldadjustedimagedata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageMediaCommandArchive::clear_has_oldadjustedimagedata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageMediaCommandArchive::clear_oldadjustedimagedata() {
  if (oldadjustedimagedata_ != NULL) oldadjustedimagedata_->::TSP::DataReference::Clear();
  clear_has_oldadjustedimagedata();
}
inline const ::TSP::DataReference& ImageMediaCommandArchive::oldadjustedimagedata() const {
  return oldadjustedimagedata_ != NULL ? *oldadjustedimagedata_ : *default_instance_->oldadjustedimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::mutable_oldadjustedimagedata() {
  set_has_oldadjustedimagedata();
  if (oldadjustedimagedata_ == NULL) oldadjustedimagedata_ = new ::TSP::DataReference;
  return oldadjustedimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::release_oldadjustedimagedata() {
  clear_has_oldadjustedimagedata();
  ::TSP::DataReference* temp = oldadjustedimagedata_;
  oldadjustedimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_oldadjustedimagedata(::TSP::DataReference* oldadjustedimagedata) {
  delete oldadjustedimagedata_;
  oldadjustedimagedata_ = oldadjustedimagedata;
  if (oldadjustedimagedata) {
    set_has_oldadjustedimagedata();
  } else {
    clear_has_oldadjustedimagedata();
  }
}

// optional .TSP.DataReference oldEnhancedImageData = 14;
inline bool ImageMediaCommandArchive::has_oldenhancedimagedata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageMediaCommandArchive::set_has_oldenhancedimagedata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageMediaCommandArchive::clear_has_oldenhancedimagedata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageMediaCommandArchive::clear_oldenhancedimagedata() {
  if (oldenhancedimagedata_ != NULL) oldenhancedimagedata_->::TSP::DataReference::Clear();
  clear_has_oldenhancedimagedata();
}
inline const ::TSP::DataReference& ImageMediaCommandArchive::oldenhancedimagedata() const {
  return oldenhancedimagedata_ != NULL ? *oldenhancedimagedata_ : *default_instance_->oldenhancedimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::mutable_oldenhancedimagedata() {
  set_has_oldenhancedimagedata();
  if (oldenhancedimagedata_ == NULL) oldenhancedimagedata_ = new ::TSP::DataReference;
  return oldenhancedimagedata_;
}
inline ::TSP::DataReference* ImageMediaCommandArchive::release_oldenhancedimagedata() {
  clear_has_oldenhancedimagedata();
  ::TSP::DataReference* temp = oldenhancedimagedata_;
  oldenhancedimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_oldenhancedimagedata(::TSP::DataReference* oldenhancedimagedata) {
  delete oldenhancedimagedata_;
  oldenhancedimagedata_ = oldenhancedimagedata;
  if (oldenhancedimagedata) {
    set_has_oldenhancedimagedata();
  } else {
    clear_has_oldenhancedimagedata();
  }
}

// optional .TSP.Reference database_newImageData = 3;
inline bool ImageMediaCommandArchive::has_database_newimagedata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageMediaCommandArchive::set_has_database_newimagedata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageMediaCommandArchive::clear_has_database_newimagedata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageMediaCommandArchive::clear_database_newimagedata() {
  if (database_newimagedata_ != NULL) database_newimagedata_->::TSP::Reference::Clear();
  clear_has_database_newimagedata();
}
inline const ::TSP::Reference& ImageMediaCommandArchive::database_newimagedata() const {
  return database_newimagedata_ != NULL ? *database_newimagedata_ : *default_instance_->database_newimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::mutable_database_newimagedata() {
  set_has_database_newimagedata();
  if (database_newimagedata_ == NULL) database_newimagedata_ = new ::TSP::Reference;
  return database_newimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::release_database_newimagedata() {
  clear_has_database_newimagedata();
  ::TSP::Reference* temp = database_newimagedata_;
  database_newimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_database_newimagedata(::TSP::Reference* database_newimagedata) {
  delete database_newimagedata_;
  database_newimagedata_ = database_newimagedata;
  if (database_newimagedata) {
    set_has_database_newimagedata();
  } else {
    clear_has_database_newimagedata();
  }
}

// optional .TSP.Reference database_oldImageData = 4;
inline bool ImageMediaCommandArchive::has_database_oldimagedata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageMediaCommandArchive::set_has_database_oldimagedata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageMediaCommandArchive::clear_has_database_oldimagedata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageMediaCommandArchive::clear_database_oldimagedata() {
  if (database_oldimagedata_ != NULL) database_oldimagedata_->::TSP::Reference::Clear();
  clear_has_database_oldimagedata();
}
inline const ::TSP::Reference& ImageMediaCommandArchive::database_oldimagedata() const {
  return database_oldimagedata_ != NULL ? *database_oldimagedata_ : *default_instance_->database_oldimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::mutable_database_oldimagedata() {
  set_has_database_oldimagedata();
  if (database_oldimagedata_ == NULL) database_oldimagedata_ = new ::TSP::Reference;
  return database_oldimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::release_database_oldimagedata() {
  clear_has_database_oldimagedata();
  ::TSP::Reference* temp = database_oldimagedata_;
  database_oldimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_database_oldimagedata(::TSP::Reference* database_oldimagedata) {
  delete database_oldimagedata_;
  database_oldimagedata_ = database_oldimagedata;
  if (database_oldimagedata) {
    set_has_database_oldimagedata();
  } else {
    clear_has_database_oldimagedata();
  }
}

// optional .TSP.Reference database_oldOriginalImageData = 5;
inline bool ImageMediaCommandArchive::has_database_oldoriginalimagedata() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImageMediaCommandArchive::set_has_database_oldoriginalimagedata() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImageMediaCommandArchive::clear_has_database_oldoriginalimagedata() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImageMediaCommandArchive::clear_database_oldoriginalimagedata() {
  if (database_oldoriginalimagedata_ != NULL) database_oldoriginalimagedata_->::TSP::Reference::Clear();
  clear_has_database_oldoriginalimagedata();
}
inline const ::TSP::Reference& ImageMediaCommandArchive::database_oldoriginalimagedata() const {
  return database_oldoriginalimagedata_ != NULL ? *database_oldoriginalimagedata_ : *default_instance_->database_oldoriginalimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::mutable_database_oldoriginalimagedata() {
  set_has_database_oldoriginalimagedata();
  if (database_oldoriginalimagedata_ == NULL) database_oldoriginalimagedata_ = new ::TSP::Reference;
  return database_oldoriginalimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::release_database_oldoriginalimagedata() {
  clear_has_database_oldoriginalimagedata();
  ::TSP::Reference* temp = database_oldoriginalimagedata_;
  database_oldoriginalimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_database_oldoriginalimagedata(::TSP::Reference* database_oldoriginalimagedata) {
  delete database_oldoriginalimagedata_;
  database_oldoriginalimagedata_ = database_oldoriginalimagedata;
  if (database_oldoriginalimagedata) {
    set_has_database_oldoriginalimagedata();
  } else {
    clear_has_database_oldoriginalimagedata();
  }
}

// optional .TSP.Reference database_newOriginalImageData = 7;
inline bool ImageMediaCommandArchive::has_database_neworiginalimagedata() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ImageMediaCommandArchive::set_has_database_neworiginalimagedata() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ImageMediaCommandArchive::clear_has_database_neworiginalimagedata() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ImageMediaCommandArchive::clear_database_neworiginalimagedata() {
  if (database_neworiginalimagedata_ != NULL) database_neworiginalimagedata_->::TSP::Reference::Clear();
  clear_has_database_neworiginalimagedata();
}
inline const ::TSP::Reference& ImageMediaCommandArchive::database_neworiginalimagedata() const {
  return database_neworiginalimagedata_ != NULL ? *database_neworiginalimagedata_ : *default_instance_->database_neworiginalimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::mutable_database_neworiginalimagedata() {
  set_has_database_neworiginalimagedata();
  if (database_neworiginalimagedata_ == NULL) database_neworiginalimagedata_ = new ::TSP::Reference;
  return database_neworiginalimagedata_;
}
inline ::TSP::Reference* ImageMediaCommandArchive::release_database_neworiginalimagedata() {
  clear_has_database_neworiginalimagedata();
  ::TSP::Reference* temp = database_neworiginalimagedata_;
  database_neworiginalimagedata_ = NULL;
  return temp;
}
inline void ImageMediaCommandArchive::set_allocated_database_neworiginalimagedata(::TSP::Reference* database_neworiginalimagedata) {
  delete database_neworiginalimagedata_;
  database_neworiginalimagedata_ = database_neworiginalimagedata;
  if (database_neworiginalimagedata) {
    set_has_database_neworiginalimagedata();
  } else {
    clear_has_database_neworiginalimagedata();
  }
}

// -------------------------------------------------------------------

// MediaOriginalSizeCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MediaOriginalSizeCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaOriginalSizeCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaOriginalSizeCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaOriginalSizeCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MediaOriginalSizeCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MediaOriginalSizeCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MediaOriginalSizeCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MediaOriginalSizeCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool MediaOriginalSizeCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaOriginalSizeCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaOriginalSizeCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaOriginalSizeCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& MediaOriginalSizeCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* MediaOriginalSizeCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* MediaOriginalSizeCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void MediaOriginalSizeCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSP.Size newOriginalSize = 3;
inline bool MediaOriginalSizeCommandArchive::has_neworiginalsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaOriginalSizeCommandArchive::set_has_neworiginalsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaOriginalSizeCommandArchive::clear_has_neworiginalsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaOriginalSizeCommandArchive::clear_neworiginalsize() {
  if (neworiginalsize_ != NULL) neworiginalsize_->::TSP::Size::Clear();
  clear_has_neworiginalsize();
}
inline const ::TSP::Size& MediaOriginalSizeCommandArchive::neworiginalsize() const {
  return neworiginalsize_ != NULL ? *neworiginalsize_ : *default_instance_->neworiginalsize_;
}
inline ::TSP::Size* MediaOriginalSizeCommandArchive::mutable_neworiginalsize() {
  set_has_neworiginalsize();
  if (neworiginalsize_ == NULL) neworiginalsize_ = new ::TSP::Size;
  return neworiginalsize_;
}
inline ::TSP::Size* MediaOriginalSizeCommandArchive::release_neworiginalsize() {
  clear_has_neworiginalsize();
  ::TSP::Size* temp = neworiginalsize_;
  neworiginalsize_ = NULL;
  return temp;
}
inline void MediaOriginalSizeCommandArchive::set_allocated_neworiginalsize(::TSP::Size* neworiginalsize) {
  delete neworiginalsize_;
  neworiginalsize_ = neworiginalsize;
  if (neworiginalsize) {
    set_has_neworiginalsize();
  } else {
    clear_has_neworiginalsize();
  }
}

// optional .TSP.Size oldOriginalSize = 4;
inline bool MediaOriginalSizeCommandArchive::has_oldoriginalsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MediaOriginalSizeCommandArchive::set_has_oldoriginalsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MediaOriginalSizeCommandArchive::clear_has_oldoriginalsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MediaOriginalSizeCommandArchive::clear_oldoriginalsize() {
  if (oldoriginalsize_ != NULL) oldoriginalsize_->::TSP::Size::Clear();
  clear_has_oldoriginalsize();
}
inline const ::TSP::Size& MediaOriginalSizeCommandArchive::oldoriginalsize() const {
  return oldoriginalsize_ != NULL ? *oldoriginalsize_ : *default_instance_->oldoriginalsize_;
}
inline ::TSP::Size* MediaOriginalSizeCommandArchive::mutable_oldoriginalsize() {
  set_has_oldoriginalsize();
  if (oldoriginalsize_ == NULL) oldoriginalsize_ = new ::TSP::Size;
  return oldoriginalsize_;
}
inline ::TSP::Size* MediaOriginalSizeCommandArchive::release_oldoriginalsize() {
  clear_has_oldoriginalsize();
  ::TSP::Size* temp = oldoriginalsize_;
  oldoriginalsize_ = NULL;
  return temp;
}
inline void MediaOriginalSizeCommandArchive::set_allocated_oldoriginalsize(::TSP::Size* oldoriginalsize) {
  delete oldoriginalsize_;
  oldoriginalsize_ = oldoriginalsize;
  if (oldoriginalsize) {
    set_has_oldoriginalsize();
  } else {
    clear_has_oldoriginalsize();
  }
}

// -------------------------------------------------------------------

// ImageMaskCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ImageMaskCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageMaskCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageMaskCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageMaskCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ImageMaskCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ImageMaskCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ImageMaskCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ImageMaskCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool ImageMaskCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageMaskCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageMaskCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageMaskCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& ImageMaskCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* ImageMaskCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* ImageMaskCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void ImageMaskCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSP.Reference newMaskInfo = 3;
inline bool ImageMaskCommandArchive::has_newmaskinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageMaskCommandArchive::set_has_newmaskinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageMaskCommandArchive::clear_has_newmaskinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageMaskCommandArchive::clear_newmaskinfo() {
  if (newmaskinfo_ != NULL) newmaskinfo_->::TSP::Reference::Clear();
  clear_has_newmaskinfo();
}
inline const ::TSP::Reference& ImageMaskCommandArchive::newmaskinfo() const {
  return newmaskinfo_ != NULL ? *newmaskinfo_ : *default_instance_->newmaskinfo_;
}
inline ::TSP::Reference* ImageMaskCommandArchive::mutable_newmaskinfo() {
  set_has_newmaskinfo();
  if (newmaskinfo_ == NULL) newmaskinfo_ = new ::TSP::Reference;
  return newmaskinfo_;
}
inline ::TSP::Reference* ImageMaskCommandArchive::release_newmaskinfo() {
  clear_has_newmaskinfo();
  ::TSP::Reference* temp = newmaskinfo_;
  newmaskinfo_ = NULL;
  return temp;
}
inline void ImageMaskCommandArchive::set_allocated_newmaskinfo(::TSP::Reference* newmaskinfo) {
  delete newmaskinfo_;
  newmaskinfo_ = newmaskinfo;
  if (newmaskinfo) {
    set_has_newmaskinfo();
  } else {
    clear_has_newmaskinfo();
  }
}

// optional .TSP.Reference oldMaskInfo = 4;
inline bool ImageMaskCommandArchive::has_oldmaskinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageMaskCommandArchive::set_has_oldmaskinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageMaskCommandArchive::clear_has_oldmaskinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageMaskCommandArchive::clear_oldmaskinfo() {
  if (oldmaskinfo_ != NULL) oldmaskinfo_->::TSP::Reference::Clear();
  clear_has_oldmaskinfo();
}
inline const ::TSP::Reference& ImageMaskCommandArchive::oldmaskinfo() const {
  return oldmaskinfo_ != NULL ? *oldmaskinfo_ : *default_instance_->oldmaskinfo_;
}
inline ::TSP::Reference* ImageMaskCommandArchive::mutable_oldmaskinfo() {
  set_has_oldmaskinfo();
  if (oldmaskinfo_ == NULL) oldmaskinfo_ = new ::TSP::Reference;
  return oldmaskinfo_;
}
inline ::TSP::Reference* ImageMaskCommandArchive::release_oldmaskinfo() {
  clear_has_oldmaskinfo();
  ::TSP::Reference* temp = oldmaskinfo_;
  oldmaskinfo_ = NULL;
  return temp;
}
inline void ImageMaskCommandArchive::set_allocated_oldmaskinfo(::TSP::Reference* oldmaskinfo) {
  delete oldmaskinfo_;
  oldmaskinfo_ = oldmaskinfo;
  if (oldmaskinfo) {
    set_has_oldmaskinfo();
  } else {
    clear_has_oldmaskinfo();
  }
}

// -------------------------------------------------------------------

// MediaApplyPresetCommandArchive

// required .TSD.StyledInfoSetStyleCommandArchive super = 1;
inline bool MediaApplyPresetCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaApplyPresetCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaApplyPresetCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaApplyPresetCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::StyledInfoSetStyleCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSD::StyledInfoSetStyleCommandArchive& MediaApplyPresetCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* MediaApplyPresetCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::StyledInfoSetStyleCommandArchive;
  return super_;
}
inline ::TSD::StyledInfoSetStyleCommandArchive* MediaApplyPresetCommandArchive::release_super() {
  clear_has_super();
  ::TSD::StyledInfoSetStyleCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MediaApplyPresetCommandArchive::set_allocated_super(::TSD::StyledInfoSetStyleCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference stylepreset = 10;
inline bool MediaApplyPresetCommandArchive::has_stylepreset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaApplyPresetCommandArchive::set_has_stylepreset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaApplyPresetCommandArchive::clear_has_stylepreset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaApplyPresetCommandArchive::clear_stylepreset() {
  if (stylepreset_ != NULL) stylepreset_->::TSP::Reference::Clear();
  clear_has_stylepreset();
}
inline const ::TSP::Reference& MediaApplyPresetCommandArchive::stylepreset() const {
  return stylepreset_ != NULL ? *stylepreset_ : *default_instance_->stylepreset_;
}
inline ::TSP::Reference* MediaApplyPresetCommandArchive::mutable_stylepreset() {
  set_has_stylepreset();
  if (stylepreset_ == NULL) stylepreset_ = new ::TSP::Reference;
  return stylepreset_;
}
inline ::TSP::Reference* MediaApplyPresetCommandArchive::release_stylepreset() {
  clear_has_stylepreset();
  ::TSP::Reference* temp = stylepreset_;
  stylepreset_ = NULL;
  return temp;
}
inline void MediaApplyPresetCommandArchive::set_allocated_stylepreset(::TSP::Reference* stylepreset) {
  delete stylepreset_;
  stylepreset_ = stylepreset;
  if (stylepreset) {
    set_has_stylepreset();
  } else {
    clear_has_stylepreset();
  }
}

// optional .TSD.ShadowArchive shadowpreset = 11;
inline bool MediaApplyPresetCommandArchive::has_shadowpreset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaApplyPresetCommandArchive::set_has_shadowpreset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaApplyPresetCommandArchive::clear_has_shadowpreset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaApplyPresetCommandArchive::clear_shadowpreset() {
  if (shadowpreset_ != NULL) shadowpreset_->::TSD::ShadowArchive::Clear();
  clear_has_shadowpreset();
}
inline const ::TSD::ShadowArchive& MediaApplyPresetCommandArchive::shadowpreset() const {
  return shadowpreset_ != NULL ? *shadowpreset_ : *default_instance_->shadowpreset_;
}
inline ::TSD::ShadowArchive* MediaApplyPresetCommandArchive::mutable_shadowpreset() {
  set_has_shadowpreset();
  if (shadowpreset_ == NULL) shadowpreset_ = new ::TSD::ShadowArchive;
  return shadowpreset_;
}
inline ::TSD::ShadowArchive* MediaApplyPresetCommandArchive::release_shadowpreset() {
  clear_has_shadowpreset();
  ::TSD::ShadowArchive* temp = shadowpreset_;
  shadowpreset_ = NULL;
  return temp;
}
inline void MediaApplyPresetCommandArchive::set_allocated_shadowpreset(::TSD::ShadowArchive* shadowpreset) {
  delete shadowpreset_;
  shadowpreset_ = shadowpreset;
  if (shadowpreset) {
    set_has_shadowpreset();
  } else {
    clear_has_shadowpreset();
  }
}

// -------------------------------------------------------------------

// ImageAdjustmentsCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ImageAdjustmentsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageAdjustmentsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ImageAdjustmentsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ImageAdjustmentsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ImageAdjustmentsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.ImageAdjustmentsArchive old_image_adjustments = 2;
inline bool ImageAdjustmentsCommandArchive::has_old_image_adjustments() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_old_image_adjustments() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_old_image_adjustments() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageAdjustmentsCommandArchive::clear_old_image_adjustments() {
  if (old_image_adjustments_ != NULL) old_image_adjustments_->::TSD::ImageAdjustmentsArchive::Clear();
  clear_has_old_image_adjustments();
}
inline const ::TSD::ImageAdjustmentsArchive& ImageAdjustmentsCommandArchive::old_image_adjustments() const {
  return old_image_adjustments_ != NULL ? *old_image_adjustments_ : *default_instance_->old_image_adjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageAdjustmentsCommandArchive::mutable_old_image_adjustments() {
  set_has_old_image_adjustments();
  if (old_image_adjustments_ == NULL) old_image_adjustments_ = new ::TSD::ImageAdjustmentsArchive;
  return old_image_adjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageAdjustmentsCommandArchive::release_old_image_adjustments() {
  clear_has_old_image_adjustments();
  ::TSD::ImageAdjustmentsArchive* temp = old_image_adjustments_;
  old_image_adjustments_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_old_image_adjustments(::TSD::ImageAdjustmentsArchive* old_image_adjustments) {
  delete old_image_adjustments_;
  old_image_adjustments_ = old_image_adjustments;
  if (old_image_adjustments) {
    set_has_old_image_adjustments();
  } else {
    clear_has_old_image_adjustments();
  }
}

// optional .TSD.ImageAdjustmentsArchive new_image_adjustments = 3;
inline bool ImageAdjustmentsCommandArchive::has_new_image_adjustments() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_new_image_adjustments() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_new_image_adjustments() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageAdjustmentsCommandArchive::clear_new_image_adjustments() {
  if (new_image_adjustments_ != NULL) new_image_adjustments_->::TSD::ImageAdjustmentsArchive::Clear();
  clear_has_new_image_adjustments();
}
inline const ::TSD::ImageAdjustmentsArchive& ImageAdjustmentsCommandArchive::new_image_adjustments() const {
  return new_image_adjustments_ != NULL ? *new_image_adjustments_ : *default_instance_->new_image_adjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageAdjustmentsCommandArchive::mutable_new_image_adjustments() {
  set_has_new_image_adjustments();
  if (new_image_adjustments_ == NULL) new_image_adjustments_ = new ::TSD::ImageAdjustmentsArchive;
  return new_image_adjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageAdjustmentsCommandArchive::release_new_image_adjustments() {
  clear_has_new_image_adjustments();
  ::TSD::ImageAdjustmentsArchive* temp = new_image_adjustments_;
  new_image_adjustments_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_new_image_adjustments(::TSD::ImageAdjustmentsArchive* new_image_adjustments) {
  delete new_image_adjustments_;
  new_image_adjustments_ = new_image_adjustments;
  if (new_image_adjustments) {
    set_has_new_image_adjustments();
  } else {
    clear_has_new_image_adjustments();
  }
}

// optional .TSP.DataReference adjustedImageData = 4;
inline bool ImageAdjustmentsCommandArchive::has_adjustedimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_adjustedimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_adjustedimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageAdjustmentsCommandArchive::clear_adjustedimagedata() {
  if (adjustedimagedata_ != NULL) adjustedimagedata_->::TSP::DataReference::Clear();
  clear_has_adjustedimagedata();
}
inline const ::TSP::DataReference& ImageAdjustmentsCommandArchive::adjustedimagedata() const {
  return adjustedimagedata_ != NULL ? *adjustedimagedata_ : *default_instance_->adjustedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::mutable_adjustedimagedata() {
  set_has_adjustedimagedata();
  if (adjustedimagedata_ == NULL) adjustedimagedata_ = new ::TSP::DataReference;
  return adjustedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::release_adjustedimagedata() {
  clear_has_adjustedimagedata();
  ::TSP::DataReference* temp = adjustedimagedata_;
  adjustedimagedata_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata) {
  delete adjustedimagedata_;
  adjustedimagedata_ = adjustedimagedata;
  if (adjustedimagedata) {
    set_has_adjustedimagedata();
  } else {
    clear_has_adjustedimagedata();
  }
}

// optional .TSP.DataReference replacedAdjustedImageData = 5;
inline bool ImageAdjustmentsCommandArchive::has_replacedadjustedimagedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_replacedadjustedimagedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_replacedadjustedimagedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageAdjustmentsCommandArchive::clear_replacedadjustedimagedata() {
  if (replacedadjustedimagedata_ != NULL) replacedadjustedimagedata_->::TSP::DataReference::Clear();
  clear_has_replacedadjustedimagedata();
}
inline const ::TSP::DataReference& ImageAdjustmentsCommandArchive::replacedadjustedimagedata() const {
  return replacedadjustedimagedata_ != NULL ? *replacedadjustedimagedata_ : *default_instance_->replacedadjustedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::mutable_replacedadjustedimagedata() {
  set_has_replacedadjustedimagedata();
  if (replacedadjustedimagedata_ == NULL) replacedadjustedimagedata_ = new ::TSP::DataReference;
  return replacedadjustedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::release_replacedadjustedimagedata() {
  clear_has_replacedadjustedimagedata();
  ::TSP::DataReference* temp = replacedadjustedimagedata_;
  replacedadjustedimagedata_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_replacedadjustedimagedata(::TSP::DataReference* replacedadjustedimagedata) {
  delete replacedadjustedimagedata_;
  replacedadjustedimagedata_ = replacedadjustedimagedata;
  if (replacedadjustedimagedata) {
    set_has_replacedadjustedimagedata();
  } else {
    clear_has_replacedadjustedimagedata();
  }
}

// optional .TSP.DataReference enhancedImageData = 6;
inline bool ImageAdjustmentsCommandArchive::has_enhancedimagedata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_enhancedimagedata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_enhancedimagedata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageAdjustmentsCommandArchive::clear_enhancedimagedata() {
  if (enhancedimagedata_ != NULL) enhancedimagedata_->::TSP::DataReference::Clear();
  clear_has_enhancedimagedata();
}
inline const ::TSP::DataReference& ImageAdjustmentsCommandArchive::enhancedimagedata() const {
  return enhancedimagedata_ != NULL ? *enhancedimagedata_ : *default_instance_->enhancedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::mutable_enhancedimagedata() {
  set_has_enhancedimagedata();
  if (enhancedimagedata_ == NULL) enhancedimagedata_ = new ::TSP::DataReference;
  return enhancedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::release_enhancedimagedata() {
  clear_has_enhancedimagedata();
  ::TSP::DataReference* temp = enhancedimagedata_;
  enhancedimagedata_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata) {
  delete enhancedimagedata_;
  enhancedimagedata_ = enhancedimagedata;
  if (enhancedimagedata) {
    set_has_enhancedimagedata();
  } else {
    clear_has_enhancedimagedata();
  }
}

// optional .TSP.DataReference replacedEnhancedImageData = 7;
inline bool ImageAdjustmentsCommandArchive::has_replacedenhancedimagedata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageAdjustmentsCommandArchive::set_has_replacedenhancedimagedata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageAdjustmentsCommandArchive::clear_has_replacedenhancedimagedata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageAdjustmentsCommandArchive::clear_replacedenhancedimagedata() {
  if (replacedenhancedimagedata_ != NULL) replacedenhancedimagedata_->::TSP::DataReference::Clear();
  clear_has_replacedenhancedimagedata();
}
inline const ::TSP::DataReference& ImageAdjustmentsCommandArchive::replacedenhancedimagedata() const {
  return replacedenhancedimagedata_ != NULL ? *replacedenhancedimagedata_ : *default_instance_->replacedenhancedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::mutable_replacedenhancedimagedata() {
  set_has_replacedenhancedimagedata();
  if (replacedenhancedimagedata_ == NULL) replacedenhancedimagedata_ = new ::TSP::DataReference;
  return replacedenhancedimagedata_;
}
inline ::TSP::DataReference* ImageAdjustmentsCommandArchive::release_replacedenhancedimagedata() {
  clear_has_replacedenhancedimagedata();
  ::TSP::DataReference* temp = replacedenhancedimagedata_;
  replacedenhancedimagedata_ = NULL;
  return temp;
}
inline void ImageAdjustmentsCommandArchive::set_allocated_replacedenhancedimagedata(::TSP::DataReference* replacedenhancedimagedata) {
  delete replacedenhancedimagedata_;
  replacedenhancedimagedata_ = replacedenhancedimagedata;
  if (replacedenhancedimagedata) {
    set_has_replacedenhancedimagedata();
  } else {
    clear_has_replacedenhancedimagedata();
  }
}

// -------------------------------------------------------------------

// MediaFlagsCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MediaFlagsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaFlagsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaFlagsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaFlagsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MediaFlagsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MediaFlagsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MediaFlagsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MediaFlagsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool MediaFlagsCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaFlagsCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaFlagsCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaFlagsCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& MediaFlagsCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* MediaFlagsCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* MediaFlagsCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void MediaFlagsCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 flags = 3;
inline bool MediaFlagsCommandArchive::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaFlagsCommandArchive::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaFlagsCommandArchive::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaFlagsCommandArchive::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MediaFlagsCommandArchive::flags() const {
  return flags_;
}
inline void MediaFlagsCommandArchive::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// DrawablesCommandGroupArchive

// required .TSK.CommandGroupArchive super = 1;
inline bool DrawablesCommandGroupArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawablesCommandGroupArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawablesCommandGroupArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawablesCommandGroupArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandGroupArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandGroupArchive& DrawablesCommandGroupArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandGroupArchive* DrawablesCommandGroupArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandGroupArchive;
  return super_;
}
inline ::TSK::CommandGroupArchive* DrawablesCommandGroupArchive::release_super() {
  clear_has_super();
  ::TSK::CommandGroupArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawablesCommandGroupArchive::set_allocated_super(::TSK::CommandGroupArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.CanvasSelectionArchive obsolete_selection = 2;
inline bool DrawablesCommandGroupArchive::has_obsolete_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawablesCommandGroupArchive::set_has_obsolete_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawablesCommandGroupArchive::clear_has_obsolete_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawablesCommandGroupArchive::clear_obsolete_selection() {
  if (obsolete_selection_ != NULL) obsolete_selection_->::TSD::CanvasSelectionArchive::Clear();
  clear_has_obsolete_selection();
}
inline const ::TSD::CanvasSelectionArchive& DrawablesCommandGroupArchive::obsolete_selection() const {
  return obsolete_selection_ != NULL ? *obsolete_selection_ : *default_instance_->obsolete_selection_;
}
inline ::TSD::CanvasSelectionArchive* DrawablesCommandGroupArchive::mutable_obsolete_selection() {
  set_has_obsolete_selection();
  if (obsolete_selection_ == NULL) obsolete_selection_ = new ::TSD::CanvasSelectionArchive;
  return obsolete_selection_;
}
inline ::TSD::CanvasSelectionArchive* DrawablesCommandGroupArchive::release_obsolete_selection() {
  clear_has_obsolete_selection();
  ::TSD::CanvasSelectionArchive* temp = obsolete_selection_;
  obsolete_selection_ = NULL;
  return temp;
}
inline void DrawablesCommandGroupArchive::set_allocated_obsolete_selection(::TSD::CanvasSelectionArchive* obsolete_selection) {
  delete obsolete_selection_;
  obsolete_selection_ = obsolete_selection;
  if (obsolete_selection) {
    set_has_obsolete_selection();
  } else {
    clear_has_obsolete_selection();
  }
}

// optional .TSP.Reference modelforselection = 3;
inline bool DrawablesCommandGroupArchive::has_modelforselection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawablesCommandGroupArchive::set_has_modelforselection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawablesCommandGroupArchive::clear_has_modelforselection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawablesCommandGroupArchive::clear_modelforselection() {
  if (modelforselection_ != NULL) modelforselection_->::TSP::Reference::Clear();
  clear_has_modelforselection();
}
inline const ::TSP::Reference& DrawablesCommandGroupArchive::modelforselection() const {
  return modelforselection_ != NULL ? *modelforselection_ : *default_instance_->modelforselection_;
}
inline ::TSP::Reference* DrawablesCommandGroupArchive::mutable_modelforselection() {
  set_has_modelforselection();
  if (modelforselection_ == NULL) modelforselection_ = new ::TSP::Reference;
  return modelforselection_;
}
inline ::TSP::Reference* DrawablesCommandGroupArchive::release_modelforselection() {
  clear_has_modelforselection();
  ::TSP::Reference* temp = modelforselection_;
  modelforselection_ = NULL;
  return temp;
}
inline void DrawablesCommandGroupArchive::set_allocated_modelforselection(::TSP::Reference* modelforselection) {
  delete modelforselection_;
  modelforselection_ = modelforselection;
  if (modelforselection) {
    set_has_modelforselection();
  } else {
    clear_has_modelforselection();
  }
}

// optional .TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type = 4;
inline bool DrawablesCommandGroupArchive::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawablesCommandGroupArchive::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawablesCommandGroupArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawablesCommandGroupArchive::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive::type() const {
  return static_cast< ::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType >(type_);
}
inline void DrawablesCommandGroupArchive::set_type(::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType value) {
  assert(::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool forDrag = 5;
inline bool DrawablesCommandGroupArchive::has_fordrag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DrawablesCommandGroupArchive::set_has_fordrag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DrawablesCommandGroupArchive::clear_has_fordrag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DrawablesCommandGroupArchive::clear_fordrag() {
  fordrag_ = false;
  clear_has_fordrag();
}
inline bool DrawablesCommandGroupArchive::fordrag() const {
  return fordrag_;
}
inline void DrawablesCommandGroupArchive::set_fordrag(bool value) {
  set_has_fordrag();
  fordrag_ = value;
}

// optional .TSP.Reference archivedselection = 6;
inline bool DrawablesCommandGroupArchive::has_archivedselection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DrawablesCommandGroupArchive::set_has_archivedselection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DrawablesCommandGroupArchive::clear_has_archivedselection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DrawablesCommandGroupArchive::clear_archivedselection() {
  if (archivedselection_ != NULL) archivedselection_->::TSP::Reference::Clear();
  clear_has_archivedselection();
}
inline const ::TSP::Reference& DrawablesCommandGroupArchive::archivedselection() const {
  return archivedselection_ != NULL ? *archivedselection_ : *default_instance_->archivedselection_;
}
inline ::TSP::Reference* DrawablesCommandGroupArchive::mutable_archivedselection() {
  set_has_archivedselection();
  if (archivedselection_ == NULL) archivedselection_ = new ::TSP::Reference;
  return archivedselection_;
}
inline ::TSP::Reference* DrawablesCommandGroupArchive::release_archivedselection() {
  clear_has_archivedselection();
  ::TSP::Reference* temp = archivedselection_;
  archivedselection_ = NULL;
  return temp;
}
inline void DrawablesCommandGroupArchive::set_allocated_archivedselection(::TSP::Reference* archivedselection) {
  delete archivedselection_;
  archivedselection_ = archivedselection;
  if (archivedselection) {
    set_has_archivedselection();
  } else {
    clear_has_archivedselection();
  }
}

// -------------------------------------------------------------------

// ExteriorTextWrapCommandArchive_InfoAndWrap

// optional .TSP.Reference info = 1;
inline bool ExteriorTextWrapCommandArchive_InfoAndWrap::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& ExteriorTextWrapCommandArchive_InfoAndWrap::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* ExteriorTextWrapCommandArchive_InfoAndWrap::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* ExteriorTextWrapCommandArchive_InfoAndWrap::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 2;
inline bool ExteriorTextWrapCommandArchive_InfoAndWrap::has_exterior_text_wrap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::set_has_exterior_text_wrap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::clear_has_exterior_text_wrap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::clear_exterior_text_wrap() {
  if (exterior_text_wrap_ != NULL) exterior_text_wrap_->::TSD::ExteriorTextWrapArchive::Clear();
  clear_has_exterior_text_wrap();
}
inline const ::TSD::ExteriorTextWrapArchive& ExteriorTextWrapCommandArchive_InfoAndWrap::exterior_text_wrap() const {
  return exterior_text_wrap_ != NULL ? *exterior_text_wrap_ : *default_instance_->exterior_text_wrap_;
}
inline ::TSD::ExteriorTextWrapArchive* ExteriorTextWrapCommandArchive_InfoAndWrap::mutable_exterior_text_wrap() {
  set_has_exterior_text_wrap();
  if (exterior_text_wrap_ == NULL) exterior_text_wrap_ = new ::TSD::ExteriorTextWrapArchive;
  return exterior_text_wrap_;
}
inline ::TSD::ExteriorTextWrapArchive* ExteriorTextWrapCommandArchive_InfoAndWrap::release_exterior_text_wrap() {
  clear_has_exterior_text_wrap();
  ::TSD::ExteriorTextWrapArchive* temp = exterior_text_wrap_;
  exterior_text_wrap_ = NULL;
  return temp;
}
inline void ExteriorTextWrapCommandArchive_InfoAndWrap::set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap) {
  delete exterior_text_wrap_;
  exterior_text_wrap_ = exterior_text_wrap;
  if (exterior_text_wrap) {
    set_has_exterior_text_wrap();
  } else {
    clear_has_exterior_text_wrap();
  }
}

// -------------------------------------------------------------------

// ExteriorTextWrapCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ExteriorTextWrapCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExteriorTextWrapCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExteriorTextWrapCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExteriorTextWrapCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ExteriorTextWrapCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ExteriorTextWrapCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ExteriorTextWrapCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ExteriorTextWrapCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSD.ExteriorTextWrapCommandArchive.InfoAndWrap info_and_wrap = 2;
inline int ExteriorTextWrapCommandArchive::info_and_wrap_size() const {
  return info_and_wrap_.size();
}
inline void ExteriorTextWrapCommandArchive::clear_info_and_wrap() {
  info_and_wrap_.Clear();
}
inline const ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap& ExteriorTextWrapCommandArchive::info_and_wrap(int index) const {
  return info_and_wrap_.Get(index);
}
inline ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap* ExteriorTextWrapCommandArchive::mutable_info_and_wrap(int index) {
  return info_and_wrap_.Mutable(index);
}
inline ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap* ExteriorTextWrapCommandArchive::add_info_and_wrap() {
  return info_and_wrap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap >&
ExteriorTextWrapCommandArchive::info_and_wrap() const {
  return info_and_wrap_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap >*
ExteriorTextWrapCommandArchive::mutable_info_and_wrap() {
  return &info_and_wrap_;
}

// -------------------------------------------------------------------

// DrawableHyperlinkCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawableHyperlinkCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableHyperlinkCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableHyperlinkCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableHyperlinkCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawableHyperlinkCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawableHyperlinkCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawableHyperlinkCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableHyperlinkCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableHyperlinkCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableHyperlinkCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableHyperlinkCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableHyperlinkCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableHyperlinkCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableHyperlinkCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableHyperlinkCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional string oldhyperlink_url = 3;
inline bool DrawableHyperlinkCommandArchive::has_oldhyperlink_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableHyperlinkCommandArchive::set_has_oldhyperlink_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableHyperlinkCommandArchive::clear_has_oldhyperlink_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableHyperlinkCommandArchive::clear_oldhyperlink_url() {
  if (oldhyperlink_url_ != &::google::protobuf::internal::kEmptyString) {
    oldhyperlink_url_->clear();
  }
  clear_has_oldhyperlink_url();
}
inline const ::std::string& DrawableHyperlinkCommandArchive::oldhyperlink_url() const {
  return *oldhyperlink_url_;
}
inline void DrawableHyperlinkCommandArchive::set_oldhyperlink_url(const ::std::string& value) {
  set_has_oldhyperlink_url();
  if (oldhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    oldhyperlink_url_ = new ::std::string;
  }
  oldhyperlink_url_->assign(value);
}
inline void DrawableHyperlinkCommandArchive::set_oldhyperlink_url(const char* value) {
  set_has_oldhyperlink_url();
  if (oldhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    oldhyperlink_url_ = new ::std::string;
  }
  oldhyperlink_url_->assign(value);
}
inline void DrawableHyperlinkCommandArchive::set_oldhyperlink_url(const char* value, size_t size) {
  set_has_oldhyperlink_url();
  if (oldhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    oldhyperlink_url_ = new ::std::string;
  }
  oldhyperlink_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawableHyperlinkCommandArchive::mutable_oldhyperlink_url() {
  set_has_oldhyperlink_url();
  if (oldhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    oldhyperlink_url_ = new ::std::string;
  }
  return oldhyperlink_url_;
}
inline ::std::string* DrawableHyperlinkCommandArchive::release_oldhyperlink_url() {
  clear_has_oldhyperlink_url();
  if (oldhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldhyperlink_url_;
    oldhyperlink_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrawableHyperlinkCommandArchive::set_allocated_oldhyperlink_url(::std::string* oldhyperlink_url) {
  if (oldhyperlink_url_ != &::google::protobuf::internal::kEmptyString) {
    delete oldhyperlink_url_;
  }
  if (oldhyperlink_url) {
    set_has_oldhyperlink_url();
    oldhyperlink_url_ = oldhyperlink_url;
  } else {
    clear_has_oldhyperlink_url();
    oldhyperlink_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string newhyperlink_url = 4;
inline bool DrawableHyperlinkCommandArchive::has_newhyperlink_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawableHyperlinkCommandArchive::set_has_newhyperlink_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawableHyperlinkCommandArchive::clear_has_newhyperlink_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawableHyperlinkCommandArchive::clear_newhyperlink_url() {
  if (newhyperlink_url_ != &::google::protobuf::internal::kEmptyString) {
    newhyperlink_url_->clear();
  }
  clear_has_newhyperlink_url();
}
inline const ::std::string& DrawableHyperlinkCommandArchive::newhyperlink_url() const {
  return *newhyperlink_url_;
}
inline void DrawableHyperlinkCommandArchive::set_newhyperlink_url(const ::std::string& value) {
  set_has_newhyperlink_url();
  if (newhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    newhyperlink_url_ = new ::std::string;
  }
  newhyperlink_url_->assign(value);
}
inline void DrawableHyperlinkCommandArchive::set_newhyperlink_url(const char* value) {
  set_has_newhyperlink_url();
  if (newhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    newhyperlink_url_ = new ::std::string;
  }
  newhyperlink_url_->assign(value);
}
inline void DrawableHyperlinkCommandArchive::set_newhyperlink_url(const char* value, size_t size) {
  set_has_newhyperlink_url();
  if (newhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    newhyperlink_url_ = new ::std::string;
  }
  newhyperlink_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawableHyperlinkCommandArchive::mutable_newhyperlink_url() {
  set_has_newhyperlink_url();
  if (newhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    newhyperlink_url_ = new ::std::string;
  }
  return newhyperlink_url_;
}
inline ::std::string* DrawableHyperlinkCommandArchive::release_newhyperlink_url() {
  clear_has_newhyperlink_url();
  if (newhyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newhyperlink_url_;
    newhyperlink_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrawableHyperlinkCommandArchive::set_allocated_newhyperlink_url(::std::string* newhyperlink_url) {
  if (newhyperlink_url_ != &::google::protobuf::internal::kEmptyString) {
    delete newhyperlink_url_;
  }
  if (newhyperlink_url) {
    set_has_newhyperlink_url();
    newhyperlink_url_ = newhyperlink_url;
  } else {
    clear_has_newhyperlink_url();
    newhyperlink_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandSelectionBehaviorArchive

// optional .TSP.Reference model_for_selection = 2;
inline bool CommandSelectionBehaviorArchive::has_model_for_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSelectionBehaviorArchive::set_has_model_for_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSelectionBehaviorArchive::clear_has_model_for_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSelectionBehaviorArchive::clear_model_for_selection() {
  if (model_for_selection_ != NULL) model_for_selection_->::TSP::Reference::Clear();
  clear_has_model_for_selection();
}
inline const ::TSP::Reference& CommandSelectionBehaviorArchive::model_for_selection() const {
  return model_for_selection_ != NULL ? *model_for_selection_ : *default_instance_->model_for_selection_;
}
inline ::TSP::Reference* CommandSelectionBehaviorArchive::mutable_model_for_selection() {
  set_has_model_for_selection();
  if (model_for_selection_ == NULL) model_for_selection_ = new ::TSP::Reference;
  return model_for_selection_;
}
inline ::TSP::Reference* CommandSelectionBehaviorArchive::release_model_for_selection() {
  clear_has_model_for_selection();
  ::TSP::Reference* temp = model_for_selection_;
  model_for_selection_ = NULL;
  return temp;
}
inline void CommandSelectionBehaviorArchive::set_allocated_model_for_selection(::TSP::Reference* model_for_selection) {
  delete model_for_selection_;
  model_for_selection_ = model_for_selection;
  if (model_for_selection) {
    set_has_model_for_selection();
  } else {
    clear_has_model_for_selection();
  }
}

// optional .TSD.CommandSelectionBehaviorArchive.CommandSelectionBehaviorType type = 3;
inline bool CommandSelectionBehaviorArchive::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSelectionBehaviorArchive::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSelectionBehaviorArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSelectionBehaviorArchive::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::type() const {
  return static_cast< ::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType >(type_);
}
inline void CommandSelectionBehaviorArchive::set_type(::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType value) {
  assert(::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TSP.Reference archived_selection = 4;
inline bool CommandSelectionBehaviorArchive::has_archived_selection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSelectionBehaviorArchive::set_has_archived_selection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSelectionBehaviorArchive::clear_has_archived_selection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSelectionBehaviorArchive::clear_archived_selection() {
  if (archived_selection_ != NULL) archived_selection_->::TSP::Reference::Clear();
  clear_has_archived_selection();
}
inline const ::TSP::Reference& CommandSelectionBehaviorArchive::archived_selection() const {
  return archived_selection_ != NULL ? *archived_selection_ : *default_instance_->archived_selection_;
}
inline ::TSP::Reference* CommandSelectionBehaviorArchive::mutable_archived_selection() {
  set_has_archived_selection();
  if (archived_selection_ == NULL) archived_selection_ = new ::TSP::Reference;
  return archived_selection_;
}
inline ::TSP::Reference* CommandSelectionBehaviorArchive::release_archived_selection() {
  clear_has_archived_selection();
  ::TSP::Reference* temp = archived_selection_;
  archived_selection_ = NULL;
  return temp;
}
inline void CommandSelectionBehaviorArchive::set_allocated_archived_selection(::TSP::Reference* archived_selection) {
  delete archived_selection_;
  archived_selection_ = archived_selection;
  if (archived_selection) {
    set_has_archived_selection();
  } else {
    clear_has_archived_selection();
  }
}

// optional .TSP.Reference archived_new_selection = 5;
inline bool CommandSelectionBehaviorArchive::has_archived_new_selection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSelectionBehaviorArchive::set_has_archived_new_selection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSelectionBehaviorArchive::clear_has_archived_new_selection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSelectionBehaviorArchive::clear_archived_new_selection() {
  if (archived_new_selection_ != NULL) archived_new_selection_->::TSP::Reference::Clear();
  clear_has_archived_new_selection();
}
inline const ::TSP::Reference& CommandSelectionBehaviorArchive::archived_new_selection() const {
  return archived_new_selection_ != NULL ? *archived_new_selection_ : *default_instance_->archived_new_selection_;
}
inline ::TSP::Reference* CommandSelectionBehaviorArchive::mutable_archived_new_selection() {
  set_has_archived_new_selection();
  if (archived_new_selection_ == NULL) archived_new_selection_ = new ::TSP::Reference;
  return archived_new_selection_;
}
inline ::TSP::Reference* CommandSelectionBehaviorArchive::release_archived_new_selection() {
  clear_has_archived_new_selection();
  ::TSP::Reference* temp = archived_new_selection_;
  archived_new_selection_ = NULL;
  return temp;
}
inline void CommandSelectionBehaviorArchive::set_allocated_archived_new_selection(::TSP::Reference* archived_new_selection) {
  delete archived_new_selection_;
  archived_new_selection_ = archived_new_selection;
  if (archived_new_selection) {
    set_has_archived_new_selection();
  } else {
    clear_has_archived_new_selection();
  }
}

// -------------------------------------------------------------------

// ImageReplaceCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ImageReplaceCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageReplaceCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageReplaceCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageReplaceCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ImageReplaceCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ImageReplaceCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ImageReplaceCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ImageReplaceCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// DrawableLockCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawableLockCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableLockCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableLockCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableLockCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawableLockCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawableLockCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawableLockCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableLockCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableLockCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableLockCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableLockCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableLockCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableLockCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableLockCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableLockCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableLockCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional bool lock = 3;
inline bool DrawableLockCommandArchive::has_lock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableLockCommandArchive::set_has_lock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableLockCommandArchive::clear_has_lock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableLockCommandArchive::clear_lock() {
  lock_ = false;
  clear_has_lock();
}
inline bool DrawableLockCommandArchive::lock() const {
  return lock_;
}
inline void DrawableLockCommandArchive::set_lock(bool value) {
  set_has_lock();
  lock_ = value;
}

// -------------------------------------------------------------------

// DrawableInfoCommentCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawableInfoCommentCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableInfoCommentCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableInfoCommentCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableInfoCommentCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawableInfoCommentCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawableInfoCommentCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawableInfoCommentCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableInfoCommentCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableInfoCommentCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableInfoCommentCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableInfoCommentCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableInfoCommentCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableInfoCommentCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableInfoCommentCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableInfoCommentCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableInfoCommentCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .TSP.Reference old_comment = 3;
inline bool DrawableInfoCommentCommandArchive::has_old_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableInfoCommentCommandArchive::set_has_old_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableInfoCommentCommandArchive::clear_has_old_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableInfoCommentCommandArchive::clear_old_comment() {
  if (old_comment_ != NULL) old_comment_->::TSP::Reference::Clear();
  clear_has_old_comment();
}
inline const ::TSP::Reference& DrawableInfoCommentCommandArchive::old_comment() const {
  return old_comment_ != NULL ? *old_comment_ : *default_instance_->old_comment_;
}
inline ::TSP::Reference* DrawableInfoCommentCommandArchive::mutable_old_comment() {
  set_has_old_comment();
  if (old_comment_ == NULL) old_comment_ = new ::TSP::Reference;
  return old_comment_;
}
inline ::TSP::Reference* DrawableInfoCommentCommandArchive::release_old_comment() {
  clear_has_old_comment();
  ::TSP::Reference* temp = old_comment_;
  old_comment_ = NULL;
  return temp;
}
inline void DrawableInfoCommentCommandArchive::set_allocated_old_comment(::TSP::Reference* old_comment) {
  delete old_comment_;
  old_comment_ = old_comment;
  if (old_comment) {
    set_has_old_comment();
  } else {
    clear_has_old_comment();
  }
}

// optional .TSP.Reference new_comment = 4;
inline bool DrawableInfoCommentCommandArchive::has_new_comment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawableInfoCommentCommandArchive::set_has_new_comment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawableInfoCommentCommandArchive::clear_has_new_comment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawableInfoCommentCommandArchive::clear_new_comment() {
  if (new_comment_ != NULL) new_comment_->::TSP::Reference::Clear();
  clear_has_new_comment();
}
inline const ::TSP::Reference& DrawableInfoCommentCommandArchive::new_comment() const {
  return new_comment_ != NULL ? *new_comment_ : *default_instance_->new_comment_;
}
inline ::TSP::Reference* DrawableInfoCommentCommandArchive::mutable_new_comment() {
  set_has_new_comment();
  if (new_comment_ == NULL) new_comment_ = new ::TSP::Reference;
  return new_comment_;
}
inline ::TSP::Reference* DrawableInfoCommentCommandArchive::release_new_comment() {
  clear_has_new_comment();
  ::TSP::Reference* temp = new_comment_;
  new_comment_ = NULL;
  return temp;
}
inline void DrawableInfoCommentCommandArchive::set_allocated_new_comment(::TSP::Reference* new_comment) {
  delete new_comment_;
  new_comment_ = new_comment;
  if (new_comment) {
    set_has_new_comment();
  } else {
    clear_has_new_comment();
  }
}

// -------------------------------------------------------------------

// CommentStorageApplyCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool CommentStorageApplyCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentStorageApplyCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentStorageApplyCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentStorageApplyCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommentStorageApplyCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommentStorageApplyCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommentStorageApplyCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommentStorageApplyCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference comment_storage = 2;
inline bool CommentStorageApplyCommandArchive::has_comment_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentStorageApplyCommandArchive::set_has_comment_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentStorageApplyCommandArchive::clear_has_comment_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentStorageApplyCommandArchive::clear_comment_storage() {
  if (comment_storage_ != NULL) comment_storage_->::TSP::Reference::Clear();
  clear_has_comment_storage();
}
inline const ::TSP::Reference& CommentStorageApplyCommandArchive::comment_storage() const {
  return comment_storage_ != NULL ? *comment_storage_ : *default_instance_->comment_storage_;
}
inline ::TSP::Reference* CommentStorageApplyCommandArchive::mutable_comment_storage() {
  set_has_comment_storage();
  if (comment_storage_ == NULL) comment_storage_ = new ::TSP::Reference;
  return comment_storage_;
}
inline ::TSP::Reference* CommentStorageApplyCommandArchive::release_comment_storage() {
  clear_has_comment_storage();
  ::TSP::Reference* temp = comment_storage_;
  comment_storage_ = NULL;
  return temp;
}
inline void CommentStorageApplyCommandArchive::set_allocated_comment_storage(::TSP::Reference* comment_storage) {
  delete comment_storage_;
  comment_storage_ = comment_storage;
  if (comment_storage) {
    set_has_comment_storage();
  } else {
    clear_has_comment_storage();
  }
}

// required string comment_string = 3;
inline bool CommentStorageApplyCommandArchive::has_comment_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommentStorageApplyCommandArchive::set_has_comment_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommentStorageApplyCommandArchive::clear_has_comment_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommentStorageApplyCommandArchive::clear_comment_string() {
  if (comment_string_ != &::google::protobuf::internal::kEmptyString) {
    comment_string_->clear();
  }
  clear_has_comment_string();
}
inline const ::std::string& CommentStorageApplyCommandArchive::comment_string() const {
  return *comment_string_;
}
inline void CommentStorageApplyCommandArchive::set_comment_string(const ::std::string& value) {
  set_has_comment_string();
  if (comment_string_ == &::google::protobuf::internal::kEmptyString) {
    comment_string_ = new ::std::string;
  }
  comment_string_->assign(value);
}
inline void CommentStorageApplyCommandArchive::set_comment_string(const char* value) {
  set_has_comment_string();
  if (comment_string_ == &::google::protobuf::internal::kEmptyString) {
    comment_string_ = new ::std::string;
  }
  comment_string_->assign(value);
}
inline void CommentStorageApplyCommandArchive::set_comment_string(const char* value, size_t size) {
  set_has_comment_string();
  if (comment_string_ == &::google::protobuf::internal::kEmptyString) {
    comment_string_ = new ::std::string;
  }
  comment_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommentStorageApplyCommandArchive::mutable_comment_string() {
  set_has_comment_string();
  if (comment_string_ == &::google::protobuf::internal::kEmptyString) {
    comment_string_ = new ::std::string;
  }
  return comment_string_;
}
inline ::std::string* CommentStorageApplyCommandArchive::release_comment_string() {
  clear_has_comment_string();
  if (comment_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_string_;
    comment_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommentStorageApplyCommandArchive::set_allocated_comment_string(::std::string* comment_string) {
  if (comment_string_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_string_;
  }
  if (comment_string) {
    set_has_comment_string();
    comment_string_ = comment_string;
  } else {
    clear_has_comment_string();
    comment_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string old_comment_string = 4;
inline bool CommentStorageApplyCommandArchive::has_old_comment_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommentStorageApplyCommandArchive::set_has_old_comment_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommentStorageApplyCommandArchive::clear_has_old_comment_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommentStorageApplyCommandArchive::clear_old_comment_string() {
  if (old_comment_string_ != &::google::protobuf::internal::kEmptyString) {
    old_comment_string_->clear();
  }
  clear_has_old_comment_string();
}
inline const ::std::string& CommentStorageApplyCommandArchive::old_comment_string() const {
  return *old_comment_string_;
}
inline void CommentStorageApplyCommandArchive::set_old_comment_string(const ::std::string& value) {
  set_has_old_comment_string();
  if (old_comment_string_ == &::google::protobuf::internal::kEmptyString) {
    old_comment_string_ = new ::std::string;
  }
  old_comment_string_->assign(value);
}
inline void CommentStorageApplyCommandArchive::set_old_comment_string(const char* value) {
  set_has_old_comment_string();
  if (old_comment_string_ == &::google::protobuf::internal::kEmptyString) {
    old_comment_string_ = new ::std::string;
  }
  old_comment_string_->assign(value);
}
inline void CommentStorageApplyCommandArchive::set_old_comment_string(const char* value, size_t size) {
  set_has_old_comment_string();
  if (old_comment_string_ == &::google::protobuf::internal::kEmptyString) {
    old_comment_string_ = new ::std::string;
  }
  old_comment_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommentStorageApplyCommandArchive::mutable_old_comment_string() {
  set_has_old_comment_string();
  if (old_comment_string_ == &::google::protobuf::internal::kEmptyString) {
    old_comment_string_ = new ::std::string;
  }
  return old_comment_string_;
}
inline ::std::string* CommentStorageApplyCommandArchive::release_old_comment_string() {
  clear_has_old_comment_string();
  if (old_comment_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_comment_string_;
    old_comment_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommentStorageApplyCommandArchive::set_allocated_old_comment_string(::std::string* old_comment_string) {
  if (old_comment_string_ != &::google::protobuf::internal::kEmptyString) {
    delete old_comment_string_;
  }
  if (old_comment_string) {
    set_has_old_comment_string();
    old_comment_string_ = old_comment_string;
  } else {
    clear_has_old_comment_string();
    old_comment_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GuideCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool GuideCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& GuideCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* GuideCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* GuideCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void GuideCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool GuideCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& GuideCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* GuideCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* GuideCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void GuideCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSD.UserDefinedGuideArchive old_guide = 3;
inline bool GuideCommandArchive::has_old_guide() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideCommandArchive::set_has_old_guide() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideCommandArchive::clear_has_old_guide() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideCommandArchive::clear_old_guide() {
  if (old_guide_ != NULL) old_guide_->::TSD::UserDefinedGuideArchive::Clear();
  clear_has_old_guide();
}
inline const ::TSD::UserDefinedGuideArchive& GuideCommandArchive::old_guide() const {
  return old_guide_ != NULL ? *old_guide_ : *default_instance_->old_guide_;
}
inline ::TSD::UserDefinedGuideArchive* GuideCommandArchive::mutable_old_guide() {
  set_has_old_guide();
  if (old_guide_ == NULL) old_guide_ = new ::TSD::UserDefinedGuideArchive;
  return old_guide_;
}
inline ::TSD::UserDefinedGuideArchive* GuideCommandArchive::release_old_guide() {
  clear_has_old_guide();
  ::TSD::UserDefinedGuideArchive* temp = old_guide_;
  old_guide_ = NULL;
  return temp;
}
inline void GuideCommandArchive::set_allocated_old_guide(::TSD::UserDefinedGuideArchive* old_guide) {
  delete old_guide_;
  old_guide_ = old_guide;
  if (old_guide) {
    set_has_old_guide();
  } else {
    clear_has_old_guide();
  }
}

// optional .TSD.UserDefinedGuideArchive new_guide = 4;
inline bool GuideCommandArchive::has_new_guide() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideCommandArchive::set_has_new_guide() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideCommandArchive::clear_has_new_guide() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideCommandArchive::clear_new_guide() {
  if (new_guide_ != NULL) new_guide_->::TSD::UserDefinedGuideArchive::Clear();
  clear_has_new_guide();
}
inline const ::TSD::UserDefinedGuideArchive& GuideCommandArchive::new_guide() const {
  return new_guide_ != NULL ? *new_guide_ : *default_instance_->new_guide_;
}
inline ::TSD::UserDefinedGuideArchive* GuideCommandArchive::mutable_new_guide() {
  set_has_new_guide();
  if (new_guide_ == NULL) new_guide_ = new ::TSD::UserDefinedGuideArchive;
  return new_guide_;
}
inline ::TSD::UserDefinedGuideArchive* GuideCommandArchive::release_new_guide() {
  clear_has_new_guide();
  ::TSD::UserDefinedGuideArchive* temp = new_guide_;
  new_guide_ = NULL;
  return temp;
}
inline void GuideCommandArchive::set_allocated_new_guide(::TSD::UserDefinedGuideArchive* new_guide) {
  delete new_guide_;
  new_guide_ = new_guide;
  if (new_guide) {
    set_has_new_guide();
  } else {
    clear_has_new_guide();
  }
}

// optional .TSD.GuideCommandArchive.GuideCommandMode mode = 5;
inline bool GuideCommandArchive::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideCommandArchive::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideCommandArchive::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideCommandArchive::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::TSD::GuideCommandArchive_GuideCommandMode GuideCommandArchive::mode() const {
  return static_cast< ::TSD::GuideCommandArchive_GuideCommandMode >(mode_);
}
inline void GuideCommandArchive::set_mode(::TSD::GuideCommandArchive_GuideCommandMode value) {
  assert(::TSD::GuideCommandArchive_GuideCommandMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// DrawableAspectRatioLockedCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawableAspectRatioLockedCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableAspectRatioLockedCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableAspectRatioLockedCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableAspectRatioLockedCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawableAspectRatioLockedCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawableAspectRatioLockedCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawableAspectRatioLockedCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableAspectRatioLockedCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableAspectRatioLockedCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableAspectRatioLockedCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableAspectRatioLockedCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableAspectRatioLockedCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableAspectRatioLockedCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableAspectRatioLockedCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableAspectRatioLockedCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableAspectRatioLockedCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional bool aspect_ratio_locked = 3;
inline bool DrawableAspectRatioLockedCommandArchive::has_aspect_ratio_locked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableAspectRatioLockedCommandArchive::set_has_aspect_ratio_locked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableAspectRatioLockedCommandArchive::clear_has_aspect_ratio_locked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableAspectRatioLockedCommandArchive::clear_aspect_ratio_locked() {
  aspect_ratio_locked_ = false;
  clear_has_aspect_ratio_locked();
}
inline bool DrawableAspectRatioLockedCommandArchive::aspect_ratio_locked() const {
  return aspect_ratio_locked_;
}
inline void DrawableAspectRatioLockedCommandArchive::set_aspect_ratio_locked(bool value) {
  set_has_aspect_ratio_locked();
  aspect_ratio_locked_ = value;
}

// -------------------------------------------------------------------

// DrawableAccessibilityDescriptionCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DrawableAccessibilityDescriptionCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableAccessibilityDescriptionCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableAccessibilityDescriptionCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DrawableAccessibilityDescriptionCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DrawableAccessibilityDescriptionCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DrawableAccessibilityDescriptionCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference info = 2;
inline bool DrawableAccessibilityDescriptionCommandArchive::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableAccessibilityDescriptionCommandArchive::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableAccessibilityDescriptionCommandArchive::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& DrawableAccessibilityDescriptionCommandArchive::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* DrawableAccessibilityDescriptionCommandArchive::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* DrawableAccessibilityDescriptionCommandArchive::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional string accessibility_description = 3;
inline bool DrawableAccessibilityDescriptionCommandArchive::has_accessibility_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_has_accessibility_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableAccessibilityDescriptionCommandArchive::clear_has_accessibility_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableAccessibilityDescriptionCommandArchive::clear_accessibility_description() {
  if (accessibility_description_ != &::google::protobuf::internal::kEmptyString) {
    accessibility_description_->clear();
  }
  clear_has_accessibility_description();
}
inline const ::std::string& DrawableAccessibilityDescriptionCommandArchive::accessibility_description() const {
  return *accessibility_description_;
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_accessibility_description(const ::std::string& value) {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  accessibility_description_->assign(value);
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_accessibility_description(const char* value) {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  accessibility_description_->assign(value);
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_accessibility_description(const char* value, size_t size) {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  accessibility_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawableAccessibilityDescriptionCommandArchive::mutable_accessibility_description() {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  return accessibility_description_;
}
inline ::std::string* DrawableAccessibilityDescriptionCommandArchive::release_accessibility_description() {
  clear_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessibility_description_;
    accessibility_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrawableAccessibilityDescriptionCommandArchive::set_allocated_accessibility_description(::std::string* accessibility_description) {
  if (accessibility_description_ != &::google::protobuf::internal::kEmptyString) {
    delete accessibility_description_;
  }
  if (accessibility_description) {
    set_has_accessibility_description();
    accessibility_description_ = accessibility_description;
  } else {
    clear_has_accessibility_description();
    accessibility_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PasteStyleCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PasteStyleCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PasteStyleCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PasteStyleCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PasteStyleCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& PasteStyleCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* PasteStyleCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* PasteStyleCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PasteStyleCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference dest_info = 2;
inline bool PasteStyleCommandArchive::has_dest_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PasteStyleCommandArchive::set_has_dest_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PasteStyleCommandArchive::clear_has_dest_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PasteStyleCommandArchive::clear_dest_info() {
  if (dest_info_ != NULL) dest_info_->::TSP::Reference::Clear();
  clear_has_dest_info();
}
inline const ::TSP::Reference& PasteStyleCommandArchive::dest_info() const {
  return dest_info_ != NULL ? *dest_info_ : *default_instance_->dest_info_;
}
inline ::TSP::Reference* PasteStyleCommandArchive::mutable_dest_info() {
  set_has_dest_info();
  if (dest_info_ == NULL) dest_info_ = new ::TSP::Reference;
  return dest_info_;
}
inline ::TSP::Reference* PasteStyleCommandArchive::release_dest_info() {
  clear_has_dest_info();
  ::TSP::Reference* temp = dest_info_;
  dest_info_ = NULL;
  return temp;
}
inline void PasteStyleCommandArchive::set_allocated_dest_info(::TSP::Reference* dest_info) {
  delete dest_info_;
  dest_info_ = dest_info;
  if (dest_info) {
    set_has_dest_info();
  } else {
    clear_has_dest_info();
  }
}

// optional .TSP.Reference shape_style = 3;
inline bool PasteStyleCommandArchive::has_shape_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PasteStyleCommandArchive::set_has_shape_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PasteStyleCommandArchive::clear_has_shape_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PasteStyleCommandArchive::clear_shape_style() {
  if (shape_style_ != NULL) shape_style_->::TSP::Reference::Clear();
  clear_has_shape_style();
}
inline const ::TSP::Reference& PasteStyleCommandArchive::shape_style() const {
  return shape_style_ != NULL ? *shape_style_ : *default_instance_->shape_style_;
}
inline ::TSP::Reference* PasteStyleCommandArchive::mutable_shape_style() {
  set_has_shape_style();
  if (shape_style_ == NULL) shape_style_ = new ::TSP::Reference;
  return shape_style_;
}
inline ::TSP::Reference* PasteStyleCommandArchive::release_shape_style() {
  clear_has_shape_style();
  ::TSP::Reference* temp = shape_style_;
  shape_style_ = NULL;
  return temp;
}
inline void PasteStyleCommandArchive::set_allocated_shape_style(::TSP::Reference* shape_style) {
  delete shape_style_;
  shape_style_ = shape_style;
  if (shape_style) {
    set_has_shape_style();
  } else {
    clear_has_shape_style();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSD

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::MovieSetValueCommandArchive_LoopOption>() {
  return ::TSD::MovieSetValueCommandArchive_LoopOption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType>() {
  return ::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType>() {
  return ::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GuideCommandArchive_GuideCommandMode>() {
  return ::TSD::GuideCommandArchive_GuideCommandMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSDCommandArchives_2eproto__INCLUDED
