// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KNCommandArchives.proto

#ifndef PROTOBUF_KNCommandArchives_2eproto__INCLUDED
#define PROTOBUF_KNCommandArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSWPArchives.pb.h"
#include "TSAArchives.pb.h"
#include "KNArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace KN {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_KNCommandArchives_2eproto();
void protobuf_AssignDesc_KNCommandArchives_2eproto();
void protobuf_ShutdownFile_KNCommandArchives_2eproto();

class UIStateCommandGroupArchive;
class CommandSlideInsertDrawablesArchive;
class CommandSlideSetPlaceholdersForTagsArchive;
class CommandSlideRemoveDrawableArchive;
class CommandSlideMoveDrawableZOrderArchive;
class CommandSlidePasteDrawablesArchive;
class CommandSlideNodeSetPropertyArchive;
class CommandSlideNodeSetPropertyArchive_PropertyValue;
class CommandSlideSetValueArchive;
class CommandSlideSetValueArchive_PropertyValue;
class CommandSlideSetStyleArchive;
class CommandShowMarkOutOfSyncRecordingArchive;
class CommandShowRemoveRecordingArchive;
class CommandShowReplaceRecordingArchive;
class CommandShowSetValueArchive;
class CommandShowSetValueArchive_PropertyValue;
class CommandShowInsertSlideArchive;
class CommandShowMoveSlideArchive;
class CommandShowRemoveSlideArchive;
class CommandShowChangeThemeArchive;
class CommandMoveMastersArchive;
class CommandInsertMasterArchive;
class CommandRemoveMasterArchive;
class CommandRenameMasterArchive;
class CommandSlideInsertBuildArchive;
class CommandSlideRemoveBuildArchive;
class CommandSlideMoveBuildWithoutMovingChunksArchive;
class CommandSlideMoveBuildsArchive;
class CommandSlideInsertBuildChunkArchive;
class CommandSlideRemoveBuildChunkArchive;
class CommandSlideMoveBuildChunkArchive;
class CommandSlideMoveBuildChunksArchive;
class CommandBuildSetValueArchive;
class CommandBuildChunkSetValueArchive;
class CommandTransitionSetValueArchive;
class CommandShowSetSlideNumberVisibilityArchive;
class CommandMasterRescaleArchive;
class CommandMasterSetThumbnailTextArchive;
class CommandMasterSetBodyStylesArchive;
class CommandSlideApplyThemeArchive;
class CommandChangeMasterSlideArchive;
class CommandSlidePrimitiveSetMasterArchive;
class CommandSlideReapplyMasterArchive;
class CommandShowSetSoundtrack;
class CommandSoundtrackSetValue;
class CommandSoundtrackSetValue_PropertyValue;
class SlideCollectionCommandSelectionBehaviorArchive;
class ChartInfoGeometryCommandArchive;

enum CommandShowInsertSlideArchive_Kind {
  CommandShowInsertSlideArchive_Kind_kKindInsertSlide = 0,
  CommandShowInsertSlideArchive_Kind_kKindInsertSlideForPaste = 1,
  CommandShowInsertSlideArchive_Kind_kKindInsertSlideForDuplicate = 2
};
bool CommandShowInsertSlideArchive_Kind_IsValid(int value);
const CommandShowInsertSlideArchive_Kind CommandShowInsertSlideArchive_Kind_Kind_MIN = CommandShowInsertSlideArchive_Kind_kKindInsertSlide;
const CommandShowInsertSlideArchive_Kind CommandShowInsertSlideArchive_Kind_Kind_MAX = CommandShowInsertSlideArchive_Kind_kKindInsertSlideForDuplicate;
const int CommandShowInsertSlideArchive_Kind_Kind_ARRAYSIZE = CommandShowInsertSlideArchive_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandShowInsertSlideArchive_Kind_descriptor();
inline const ::std::string& CommandShowInsertSlideArchive_Kind_Name(CommandShowInsertSlideArchive_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandShowInsertSlideArchive_Kind_descriptor(), value);
}
inline bool CommandShowInsertSlideArchive_Kind_Parse(
    const ::std::string& name, CommandShowInsertSlideArchive_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandShowInsertSlideArchive_Kind>(
    CommandShowInsertSlideArchive_Kind_descriptor(), name, value);
}
enum SlideCollectionCommandSelectionBehaviorArchive_Type {
  SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeGeneral = 0,
  SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeInsertion = 1,
  SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeDeletion = 2,
  SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeMove = 3
};
bool SlideCollectionCommandSelectionBehaviorArchive_Type_IsValid(int value);
const SlideCollectionCommandSelectionBehaviorArchive_Type SlideCollectionCommandSelectionBehaviorArchive_Type_Type_MIN = SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeGeneral;
const SlideCollectionCommandSelectionBehaviorArchive_Type SlideCollectionCommandSelectionBehaviorArchive_Type_Type_MAX = SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeMove;
const int SlideCollectionCommandSelectionBehaviorArchive_Type_Type_ARRAYSIZE = SlideCollectionCommandSelectionBehaviorArchive_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlideCollectionCommandSelectionBehaviorArchive_Type_descriptor();
inline const ::std::string& SlideCollectionCommandSelectionBehaviorArchive_Type_Name(SlideCollectionCommandSelectionBehaviorArchive_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlideCollectionCommandSelectionBehaviorArchive_Type_descriptor(), value);
}
inline bool SlideCollectionCommandSelectionBehaviorArchive_Type_Parse(
    const ::std::string& name, SlideCollectionCommandSelectionBehaviorArchive_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlideCollectionCommandSelectionBehaviorArchive_Type>(
    SlideCollectionCommandSelectionBehaviorArchive_Type_descriptor(), name, value);
}
// ===================================================================

class UIStateCommandGroupArchive : public ::google::protobuf::Message {
 public:
  UIStateCommandGroupArchive();
  virtual ~UIStateCommandGroupArchive();

  UIStateCommandGroupArchive(const UIStateCommandGroupArchive& from);

  inline UIStateCommandGroupArchive& operator=(const UIStateCommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIStateCommandGroupArchive& default_instance();

  void Swap(UIStateCommandGroupArchive* other);

  // implements Message ----------------------------------------------

  UIStateCommandGroupArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIStateCommandGroupArchive& from);
  void MergeFrom(const UIStateCommandGroupArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandGroupArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandGroupArchive& super() const;
  inline ::TSK::CommandGroupArchive* mutable_super();
  inline ::TSK::CommandGroupArchive* release_super();
  inline void set_allocated_super(::TSK::CommandGroupArchive* super);

  // required .TSP.Reference uiState = 2;
  inline bool has_uistate() const;
  inline void clear_uistate();
  static const int kUiStateFieldNumber = 2;
  inline const ::TSP::Reference& uistate() const;
  inline ::TSP::Reference* mutable_uistate();
  inline ::TSP::Reference* release_uistate();
  inline void set_allocated_uistate(::TSP::Reference* uistate);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // repeated .TSP.Reference slideNodesToEdit = 4;
  inline int slidenodestoedit_size() const;
  inline void clear_slidenodestoedit();
  static const int kSlideNodesToEditFieldNumber = 4;
  inline const ::TSP::Reference& slidenodestoedit(int index) const;
  inline ::TSP::Reference* mutable_slidenodestoedit(int index);
  inline ::TSP::Reference* add_slidenodestoedit();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      slidenodestoedit() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_slidenodestoedit();

  // repeated .TSP.Reference masterSlideNodesToApply = 5;
  inline int masterslidenodestoapply_size() const;
  inline void clear_masterslidenodestoapply();
  static const int kMasterSlideNodesToApplyFieldNumber = 5;
  inline const ::TSP::Reference& masterslidenodestoapply(int index) const;
  inline ::TSP::Reference* mutable_masterslidenodestoapply(int index);
  inline ::TSP::Reference* add_masterslidenodestoapply();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      masterslidenodestoapply() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_masterslidenodestoapply();

  // repeated .TSP.Size thumbnailSizes = 6;
  inline int thumbnailsizes_size() const;
  inline void clear_thumbnailsizes();
  static const int kThumbnailSizesFieldNumber = 6;
  inline const ::TSP::Size& thumbnailsizes(int index) const;
  inline ::TSP::Size* mutable_thumbnailsizes(int index);
  inline ::TSP::Size* add_thumbnailsizes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Size >&
      thumbnailsizes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Size >*
      mutable_thumbnailsizes();

  // repeated .TSP.Reference selectedSlideNodes = 7;
  inline int selectedslidenodes_size() const;
  inline void clear_selectedslidenodes();
  static const int kSelectedSlideNodesFieldNumber = 7;
  inline const ::TSP::Reference& selectedslidenodes(int index) const;
  inline ::TSP::Reference* mutable_selectedslidenodes(int index);
  inline ::TSP::Reference* add_selectedslidenodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      selectedslidenodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_selectedslidenodes();

  // repeated .TSP.Reference restoreSelectedSlideNodes = 8;
  inline int restoreselectedslidenodes_size() const;
  inline void clear_restoreselectedslidenodes();
  static const int kRestoreSelectedSlideNodesFieldNumber = 8;
  inline const ::TSP::Reference& restoreselectedslidenodes(int index) const;
  inline ::TSP::Reference* mutable_restoreselectedslidenodes(int index);
  inline ::TSP::Reference* add_restoreselectedslidenodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      restoreselectedslidenodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_restoreselectedslidenodes();

  // @@protoc_insertion_point(class_scope:KN.UIStateCommandGroupArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_uistate();
  inline void clear_has_uistate();
  inline void set_has_property();
  inline void clear_has_property();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandGroupArchive* super_;
  ::TSP::Reference* uistate_;
  ::std::string* property_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > slidenodestoedit_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > masterslidenodestoapply_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Size > thumbnailsizes_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > selectedslidenodes_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > restoreselectedslidenodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static UIStateCommandGroupArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideInsertDrawablesArchive : public ::google::protobuf::Message {
 public:
  CommandSlideInsertDrawablesArchive();
  virtual ~CommandSlideInsertDrawablesArchive();

  CommandSlideInsertDrawablesArchive(const CommandSlideInsertDrawablesArchive& from);

  inline CommandSlideInsertDrawablesArchive& operator=(const CommandSlideInsertDrawablesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideInsertDrawablesArchive& default_instance();

  void Swap(CommandSlideInsertDrawablesArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideInsertDrawablesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideInsertDrawablesArchive& from);
  void MergeFrom(const CommandSlideInsertDrawablesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // repeated .TSP.Reference drawables = 3;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // optional bool forDrag = 4;
  inline bool has_fordrag() const;
  inline void clear_fordrag();
  static const int kForDragFieldNumber = 4;
  inline bool fordrag() const;
  inline void set_fordrag(bool value);

  // optional int32 atIndex = 5;
  inline bool has_atindex() const;
  inline void clear_atindex();
  static const int kAtIndexFieldNumber = 5;
  inline ::google::protobuf::int32 atindex() const;
  inline void set_atindex(::google::protobuf::int32 value);

  // required bool use_object_placeholder_geometry = 6;
  inline bool has_use_object_placeholder_geometry() const;
  inline void clear_use_object_placeholder_geometry();
  static const int kUseObjectPlaceholderGeometryFieldNumber = 6;
  inline bool use_object_placeholder_geometry() const;
  inline void set_use_object_placeholder_geometry(bool value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideInsertDrawablesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_fordrag();
  inline void clear_has_fordrag();
  inline void set_has_atindex();
  inline void clear_has_atindex();
  inline void set_has_use_object_placeholder_geometry();
  inline void clear_has_use_object_placeholder_geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  ::google::protobuf::int32 atindex_;
  bool fordrag_;
  bool use_object_placeholder_geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideInsertDrawablesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideSetPlaceholdersForTagsArchive : public ::google::protobuf::Message {
 public:
  CommandSlideSetPlaceholdersForTagsArchive();
  virtual ~CommandSlideSetPlaceholdersForTagsArchive();

  CommandSlideSetPlaceholdersForTagsArchive(const CommandSlideSetPlaceholdersForTagsArchive& from);

  inline CommandSlideSetPlaceholdersForTagsArchive& operator=(const CommandSlideSetPlaceholdersForTagsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideSetPlaceholdersForTagsArchive& default_instance();

  void Swap(CommandSlideSetPlaceholdersForTagsArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideSetPlaceholdersForTagsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideSetPlaceholdersForTagsArchive& from);
  void MergeFrom(const CommandSlideSetPlaceholdersForTagsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // repeated .TSP.Reference infos = 3;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::TSP::Reference& infos(int index) const;
  inline ::TSP::Reference* mutable_infos(int index);
  inline ::TSP::Reference* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();

  // repeated string tags = 4;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 4;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .TSP.Reference old_infos = 6;
  inline int old_infos_size() const;
  inline void clear_old_infos();
  static const int kOldInfosFieldNumber = 6;
  inline const ::TSP::Reference& old_infos(int index) const;
  inline ::TSP::Reference* mutable_old_infos(int index);
  inline ::TSP::Reference* add_old_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_infos();

  // repeated string old_tags = 5;
  inline int old_tags_size() const;
  inline void clear_old_tags();
  static const int kOldTagsFieldNumber = 5;
  inline const ::std::string& old_tags(int index) const;
  inline ::std::string* mutable_old_tags(int index);
  inline void set_old_tags(int index, const ::std::string& value);
  inline void set_old_tags(int index, const char* value);
  inline void set_old_tags(int index, const char* value, size_t size);
  inline ::std::string* add_old_tags();
  inline void add_old_tags(const ::std::string& value);
  inline void add_old_tags(const char* value);
  inline void add_old_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& old_tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_old_tags();

  // @@protoc_insertion_point(class_scope:KN.CommandSlideSetPlaceholdersForTagsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > infos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_infos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> old_tags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideSetPlaceholdersForTagsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideRemoveDrawableArchive : public ::google::protobuf::Message {
 public:
  CommandSlideRemoveDrawableArchive();
  virtual ~CommandSlideRemoveDrawableArchive();

  CommandSlideRemoveDrawableArchive(const CommandSlideRemoveDrawableArchive& from);

  inline CommandSlideRemoveDrawableArchive& operator=(const CommandSlideRemoveDrawableArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideRemoveDrawableArchive& default_instance();

  void Swap(CommandSlideRemoveDrawableArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideRemoveDrawableArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideRemoveDrawableArchive& from);
  void MergeFrom(const CommandSlideRemoveDrawableArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // repeated .TSP.Reference sortedDrawables = 3;
  inline int sorteddrawables_size() const;
  inline void clear_sorteddrawables();
  static const int kSortedDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& sorteddrawables(int index) const;
  inline ::TSP::Reference* mutable_sorteddrawables(int index);
  inline ::TSP::Reference* add_sorteddrawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      sorteddrawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_sorteddrawables();

  // required .TSP.IndexSet drawableIndices = 4;
  inline bool has_drawableindices() const;
  inline void clear_drawableindices();
  static const int kDrawableIndicesFieldNumber = 4;
  inline const ::TSP::IndexSet& drawableindices() const;
  inline ::TSP::IndexSet* mutable_drawableindices();
  inline ::TSP::IndexSet* release_drawableindices();
  inline void set_allocated_drawableindices(::TSP::IndexSet* drawableindices);

  // repeated string placeholderTags = 5;
  inline int placeholdertags_size() const;
  inline void clear_placeholdertags();
  static const int kPlaceholderTagsFieldNumber = 5;
  inline const ::std::string& placeholdertags(int index) const;
  inline ::std::string* mutable_placeholdertags(int index);
  inline void set_placeholdertags(int index, const ::std::string& value);
  inline void set_placeholdertags(int index, const char* value);
  inline void set_placeholdertags(int index, const char* value, size_t size);
  inline ::std::string* add_placeholdertags();
  inline void add_placeholdertags(const ::std::string& value);
  inline void add_placeholdertags(const char* value);
  inline void add_placeholdertags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& placeholdertags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_placeholdertags();

  // optional .TSP.Reference info_using_object_placeholder_geometry = 6;
  inline bool has_info_using_object_placeholder_geometry() const;
  inline void clear_info_using_object_placeholder_geometry();
  static const int kInfoUsingObjectPlaceholderGeometryFieldNumber = 6;
  inline const ::TSP::Reference& info_using_object_placeholder_geometry() const;
  inline ::TSP::Reference* mutable_info_using_object_placeholder_geometry();
  inline ::TSP::Reference* release_info_using_object_placeholder_geometry();
  inline void set_allocated_info_using_object_placeholder_geometry(::TSP::Reference* info_using_object_placeholder_geometry);

  // optional bool did_match_object_placeholder_geometry = 7;
  inline bool has_did_match_object_placeholder_geometry() const;
  inline void clear_did_match_object_placeholder_geometry();
  static const int kDidMatchObjectPlaceholderGeometryFieldNumber = 7;
  inline bool did_match_object_placeholder_geometry() const;
  inline void set_did_match_object_placeholder_geometry(bool value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideRemoveDrawableArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_drawableindices();
  inline void clear_has_drawableindices();
  inline void set_has_info_using_object_placeholder_geometry();
  inline void clear_has_info_using_object_placeholder_geometry();
  inline void set_has_did_match_object_placeholder_geometry();
  inline void clear_has_did_match_object_placeholder_geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > sorteddrawables_;
  ::TSP::IndexSet* drawableindices_;
  ::google::protobuf::RepeatedPtrField< ::std::string> placeholdertags_;
  ::TSP::Reference* info_using_object_placeholder_geometry_;
  bool did_match_object_placeholder_geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideRemoveDrawableArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideMoveDrawableZOrderArchive : public ::google::protobuf::Message {
 public:
  CommandSlideMoveDrawableZOrderArchive();
  virtual ~CommandSlideMoveDrawableZOrderArchive();

  CommandSlideMoveDrawableZOrderArchive(const CommandSlideMoveDrawableZOrderArchive& from);

  inline CommandSlideMoveDrawableZOrderArchive& operator=(const CommandSlideMoveDrawableZOrderArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideMoveDrawableZOrderArchive& default_instance();

  void Swap(CommandSlideMoveDrawableZOrderArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideMoveDrawableZOrderArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideMoveDrawableZOrderArchive& from);
  void MergeFrom(const CommandSlideMoveDrawableZOrderArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // repeated .TSP.Reference infos = 3;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::TSP::Reference& infos(int index) const;
  inline ::TSP::Reference* mutable_infos(int index);
  inline ::TSP::Reference* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();

  // repeated .TSP.Reference old_ordered_infos = 4;
  inline int old_ordered_infos_size() const;
  inline void clear_old_ordered_infos();
  static const int kOldOrderedInfosFieldNumber = 4;
  inline const ::TSP::Reference& old_ordered_infos(int index) const;
  inline ::TSP::Reference* mutable_old_ordered_infos(int index);
  inline ::TSP::Reference* add_old_ordered_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_ordered_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_ordered_infos();

  // required .TSP.IndexSet indexes = 5;
  inline bool has_indexes() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 5;
  inline const ::TSP::IndexSet& indexes() const;
  inline ::TSP::IndexSet* mutable_indexes();
  inline ::TSP::IndexSet* release_indexes();
  inline void set_allocated_indexes(::TSP::IndexSet* indexes);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideMoveDrawableZOrderArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_indexes();
  inline void clear_has_indexes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > infos_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_ordered_infos_;
  ::TSP::IndexSet* indexes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideMoveDrawableZOrderArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlidePasteDrawablesArchive : public ::google::protobuf::Message {
 public:
  CommandSlidePasteDrawablesArchive();
  virtual ~CommandSlidePasteDrawablesArchive();

  CommandSlidePasteDrawablesArchive(const CommandSlidePasteDrawablesArchive& from);

  inline CommandSlidePasteDrawablesArchive& operator=(const CommandSlidePasteDrawablesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlidePasteDrawablesArchive& default_instance();

  void Swap(CommandSlidePasteDrawablesArchive* other);

  // implements Message ----------------------------------------------

  CommandSlidePasteDrawablesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlidePasteDrawablesArchive& from);
  void MergeFrom(const CommandSlidePasteDrawablesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference commands = 2;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 2;
  inline const ::TSP::Reference& commands(int index) const;
  inline ::TSP::Reference* mutable_commands(int index);
  inline ::TSP::Reference* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();

  // required .TSP.Reference slide = 3;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 3;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // repeated .TSP.Reference drawables = 4;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 4;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // optional bool has_builds = 5 [default = false];
  inline bool has_has_builds() const;
  inline void clear_has_builds();
  static const int kHasBuildsFieldNumber = 5;
  inline bool has_builds() const;
  inline void set_has_builds(bool value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlidePasteDrawablesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_has_builds();
  inline void clear_has_has_builds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > commands_;
  ::TSP::Reference* slide_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  bool has_builds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlidePasteDrawablesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideNodeSetPropertyArchive_PropertyValue : public ::google::protobuf::Message {
 public:
  CommandSlideNodeSetPropertyArchive_PropertyValue();
  virtual ~CommandSlideNodeSetPropertyArchive_PropertyValue();

  CommandSlideNodeSetPropertyArchive_PropertyValue(const CommandSlideNodeSetPropertyArchive_PropertyValue& from);

  inline CommandSlideNodeSetPropertyArchive_PropertyValue& operator=(const CommandSlideNodeSetPropertyArchive_PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideNodeSetPropertyArchive_PropertyValue& default_instance();

  void Swap(CommandSlideNodeSetPropertyArchive_PropertyValue* other);

  // implements Message ----------------------------------------------

  CommandSlideNodeSetPropertyArchive_PropertyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideNodeSetPropertyArchive_PropertyValue& from);
  void MergeFrom(const CommandSlideNodeSetPropertyArchive_PropertyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool boolValue = 1;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 1;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  // optional .TSP.DataReference image = 3;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 3;
  inline const ::TSP::DataReference& image() const;
  inline ::TSP::DataReference* mutable_image();
  inline ::TSP::DataReference* release_image();
  inline void set_allocated_image(::TSP::DataReference* image);

  // optional .TSP.Reference database_image = 2;
  inline bool has_database_image() const;
  inline void clear_database_image();
  static const int kDatabaseImageFieldNumber = 2;
  inline const ::TSP::Reference& database_image() const;
  inline ::TSP::Reference* mutable_database_image();
  inline ::TSP::Reference* release_database_image();
  inline void set_allocated_database_image(::TSP::Reference* database_image);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideNodeSetPropertyArchive.PropertyValue)
 private:
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_database_image();
  inline void clear_has_database_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::DataReference* image_;
  ::TSP::Reference* database_image_;
  bool boolvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideNodeSetPropertyArchive_PropertyValue* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideNodeSetPropertyArchive : public ::google::protobuf::Message {
 public:
  CommandSlideNodeSetPropertyArchive();
  virtual ~CommandSlideNodeSetPropertyArchive();

  CommandSlideNodeSetPropertyArchive(const CommandSlideNodeSetPropertyArchive& from);

  inline CommandSlideNodeSetPropertyArchive& operator=(const CommandSlideNodeSetPropertyArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideNodeSetPropertyArchive& default_instance();

  void Swap(CommandSlideNodeSetPropertyArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideNodeSetPropertyArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideNodeSetPropertyArchive& from);
  void MergeFrom(const CommandSlideNodeSetPropertyArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandSlideNodeSetPropertyArchive_PropertyValue PropertyValue;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // required .KN.CommandSlideNodeSetPropertyArchive.PropertyValue oldValue = 4;
  inline bool has_oldvalue() const;
  inline void clear_oldvalue();
  static const int kOldValueFieldNumber = 4;
  inline const ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue& oldvalue() const;
  inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* mutable_oldvalue();
  inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* release_oldvalue();
  inline void set_allocated_oldvalue(::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* oldvalue);

  // required .KN.CommandSlideNodeSetPropertyArchive.PropertyValue newValue = 5;
  inline bool has_newvalue() const;
  inline void clear_newvalue();
  static const int kNewValueFieldNumber = 5;
  inline const ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue& newvalue() const;
  inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* mutable_newvalue();
  inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* release_newvalue();
  inline void set_allocated_newvalue(::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* newvalue);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideNodeSetPropertyArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_oldvalue();
  inline void clear_has_oldvalue();
  inline void set_has_newvalue();
  inline void clear_has_newvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::std::string* property_;
  ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* oldvalue_;
  ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* newvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideNodeSetPropertyArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideSetValueArchive_PropertyValue : public ::google::protobuf::Message {
 public:
  CommandSlideSetValueArchive_PropertyValue();
  virtual ~CommandSlideSetValueArchive_PropertyValue();

  CommandSlideSetValueArchive_PropertyValue(const CommandSlideSetValueArchive_PropertyValue& from);

  inline CommandSlideSetValueArchive_PropertyValue& operator=(const CommandSlideSetValueArchive_PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideSetValueArchive_PropertyValue& default_instance();

  void Swap(CommandSlideSetValueArchive_PropertyValue* other);

  // implements Message ----------------------------------------------

  CommandSlideSetValueArchive_PropertyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideSetValueArchive_PropertyValue& from);
  void MergeFrom(const CommandSlideSetValueArchive_PropertyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool boolValue = 1;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 1;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  // optional .TSP.Reference objectValue = 2;
  inline bool has_objectvalue() const;
  inline void clear_objectvalue();
  static const int kObjectValueFieldNumber = 2;
  inline const ::TSP::Reference& objectvalue() const;
  inline ::TSP::Reference* mutable_objectvalue();
  inline ::TSP::Reference* release_objectvalue();
  inline void set_allocated_objectvalue(::TSP::Reference* objectvalue);

  // optional .TSD.FillArchive fill = 3;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 3;
  inline const ::TSD::FillArchive& fill() const;
  inline ::TSD::FillArchive* mutable_fill();
  inline ::TSD::FillArchive* release_fill();
  inline void set_allocated_fill(::TSD::FillArchive* fill);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideSetValueArchive.PropertyValue)
 private:
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();
  inline void set_has_objectvalue();
  inline void clear_has_objectvalue();
  inline void set_has_fill();
  inline void clear_has_fill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* objectvalue_;
  ::TSD::FillArchive* fill_;
  bool boolvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideSetValueArchive_PropertyValue* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideSetValueArchive : public ::google::protobuf::Message {
 public:
  CommandSlideSetValueArchive();
  virtual ~CommandSlideSetValueArchive();

  CommandSlideSetValueArchive(const CommandSlideSetValueArchive& from);

  inline CommandSlideSetValueArchive& operator=(const CommandSlideSetValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideSetValueArchive& default_instance();

  void Swap(CommandSlideSetValueArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideSetValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideSetValueArchive& from);
  void MergeFrom(const CommandSlideSetValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandSlideSetValueArchive_PropertyValue PropertyValue;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // required .KN.CommandSlideSetValueArchive.PropertyValue oldValue = 4;
  inline bool has_oldvalue() const;
  inline void clear_oldvalue();
  static const int kOldValueFieldNumber = 4;
  inline const ::KN::CommandSlideSetValueArchive_PropertyValue& oldvalue() const;
  inline ::KN::CommandSlideSetValueArchive_PropertyValue* mutable_oldvalue();
  inline ::KN::CommandSlideSetValueArchive_PropertyValue* release_oldvalue();
  inline void set_allocated_oldvalue(::KN::CommandSlideSetValueArchive_PropertyValue* oldvalue);

  // required .KN.CommandSlideSetValueArchive.PropertyValue newValue = 5;
  inline bool has_newvalue() const;
  inline void clear_newvalue();
  static const int kNewValueFieldNumber = 5;
  inline const ::KN::CommandSlideSetValueArchive_PropertyValue& newvalue() const;
  inline ::KN::CommandSlideSetValueArchive_PropertyValue* mutable_newvalue();
  inline ::KN::CommandSlideSetValueArchive_PropertyValue* release_newvalue();
  inline void set_allocated_newvalue(::KN::CommandSlideSetValueArchive_PropertyValue* newvalue);

  // required .TSP.Reference oldSlideStyle = 6;
  inline bool has_oldslidestyle() const;
  inline void clear_oldslidestyle();
  static const int kOldSlideStyleFieldNumber = 6;
  inline const ::TSP::Reference& oldslidestyle() const;
  inline ::TSP::Reference* mutable_oldslidestyle();
  inline ::TSP::Reference* release_oldslidestyle();
  inline void set_allocated_oldslidestyle(::TSP::Reference* oldslidestyle);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideSetValueArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_oldvalue();
  inline void clear_has_oldvalue();
  inline void set_has_newvalue();
  inline void clear_has_newvalue();
  inline void set_has_oldslidestyle();
  inline void clear_has_oldslidestyle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::std::string* property_;
  ::KN::CommandSlideSetValueArchive_PropertyValue* oldvalue_;
  ::KN::CommandSlideSetValueArchive_PropertyValue* newvalue_;
  ::TSP::Reference* oldslidestyle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideSetValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideSetStyleArchive : public ::google::protobuf::Message {
 public:
  CommandSlideSetStyleArchive();
  virtual ~CommandSlideSetStyleArchive();

  CommandSlideSetStyleArchive(const CommandSlideSetStyleArchive& from);

  inline CommandSlideSetStyleArchive& operator=(const CommandSlideSetStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideSetStyleArchive& default_instance();

  void Swap(CommandSlideSetStyleArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideSetStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideSetStyleArchive& from);
  void MergeFrom(const CommandSlideSetStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required .TSP.Reference slide_style = 3;
  inline bool has_slide_style() const;
  inline void clear_slide_style();
  static const int kSlideStyleFieldNumber = 3;
  inline const ::TSP::Reference& slide_style() const;
  inline ::TSP::Reference* mutable_slide_style();
  inline ::TSP::Reference* release_slide_style();
  inline void set_allocated_slide_style(::TSP::Reference* slide_style);

  // required .TSP.Reference old_slide_style = 4;
  inline bool has_old_slide_style() const;
  inline void clear_old_slide_style();
  static const int kOldSlideStyleFieldNumber = 4;
  inline const ::TSP::Reference& old_slide_style() const;
  inline ::TSP::Reference* mutable_old_slide_style();
  inline ::TSP::Reference* release_old_slide_style();
  inline void set_allocated_old_slide_style(::TSP::Reference* old_slide_style);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideSetStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_slide_style();
  inline void clear_has_slide_style();
  inline void set_has_old_slide_style();
  inline void clear_has_old_slide_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::TSP::Reference* slide_style_;
  ::TSP::Reference* old_slide_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideSetStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowMarkOutOfSyncRecordingArchive : public ::google::protobuf::Message {
 public:
  CommandShowMarkOutOfSyncRecordingArchive();
  virtual ~CommandShowMarkOutOfSyncRecordingArchive();

  CommandShowMarkOutOfSyncRecordingArchive(const CommandShowMarkOutOfSyncRecordingArchive& from);

  inline CommandShowMarkOutOfSyncRecordingArchive& operator=(const CommandShowMarkOutOfSyncRecordingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowMarkOutOfSyncRecordingArchive& default_instance();

  void Swap(CommandShowMarkOutOfSyncRecordingArchive* other);

  // implements Message ----------------------------------------------

  CommandShowMarkOutOfSyncRecordingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowMarkOutOfSyncRecordingArchive& from);
  void MergeFrom(const CommandShowMarkOutOfSyncRecordingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // optional .TSP.Reference old_recording = 3;
  inline bool has_old_recording() const;
  inline void clear_old_recording();
  static const int kOldRecordingFieldNumber = 3;
  inline const ::TSP::Reference& old_recording() const;
  inline ::TSP::Reference* mutable_old_recording();
  inline ::TSP::Reference* release_old_recording();
  inline void set_allocated_old_recording(::TSP::Reference* old_recording);

  // @@protoc_insertion_point(class_scope:KN.CommandShowMarkOutOfSyncRecordingArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_old_recording();
  inline void clear_has_old_recording();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* old_recording_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowMarkOutOfSyncRecordingArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowRemoveRecordingArchive : public ::google::protobuf::Message {
 public:
  CommandShowRemoveRecordingArchive();
  virtual ~CommandShowRemoveRecordingArchive();

  CommandShowRemoveRecordingArchive(const CommandShowRemoveRecordingArchive& from);

  inline CommandShowRemoveRecordingArchive& operator=(const CommandShowRemoveRecordingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowRemoveRecordingArchive& default_instance();

  void Swap(CommandShowRemoveRecordingArchive* other);

  // implements Message ----------------------------------------------

  CommandShowRemoveRecordingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowRemoveRecordingArchive& from);
  void MergeFrom(const CommandShowRemoveRecordingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // optional .TSP.Reference old_recording = 3;
  inline bool has_old_recording() const;
  inline void clear_old_recording();
  static const int kOldRecordingFieldNumber = 3;
  inline const ::TSP::Reference& old_recording() const;
  inline ::TSP::Reference* mutable_old_recording();
  inline ::TSP::Reference* release_old_recording();
  inline void set_allocated_old_recording(::TSP::Reference* old_recording);

  // @@protoc_insertion_point(class_scope:KN.CommandShowRemoveRecordingArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_old_recording();
  inline void clear_has_old_recording();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* old_recording_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowRemoveRecordingArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowReplaceRecordingArchive : public ::google::protobuf::Message {
 public:
  CommandShowReplaceRecordingArchive();
  virtual ~CommandShowReplaceRecordingArchive();

  CommandShowReplaceRecordingArchive(const CommandShowReplaceRecordingArchive& from);

  inline CommandShowReplaceRecordingArchive& operator=(const CommandShowReplaceRecordingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowReplaceRecordingArchive& default_instance();

  void Swap(CommandShowReplaceRecordingArchive* other);

  // implements Message ----------------------------------------------

  CommandShowReplaceRecordingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowReplaceRecordingArchive& from);
  void MergeFrom(const CommandShowReplaceRecordingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required .TSP.Reference replacement_recording = 3;
  inline bool has_replacement_recording() const;
  inline void clear_replacement_recording();
  static const int kReplacementRecordingFieldNumber = 3;
  inline const ::TSP::Reference& replacement_recording() const;
  inline ::TSP::Reference* mutable_replacement_recording();
  inline ::TSP::Reference* release_replacement_recording();
  inline void set_allocated_replacement_recording(::TSP::Reference* replacement_recording);

  // required double replacement_start_time = 4;
  inline bool has_replacement_start_time() const;
  inline void clear_replacement_start_time();
  static const int kReplacementStartTimeFieldNumber = 4;
  inline double replacement_start_time() const;
  inline void set_replacement_start_time(double value);

  // optional .TSP.Reference old_recording = 5;
  inline bool has_old_recording() const;
  inline void clear_old_recording();
  static const int kOldRecordingFieldNumber = 5;
  inline const ::TSP::Reference& old_recording() const;
  inline ::TSP::Reference* mutable_old_recording();
  inline ::TSP::Reference* release_old_recording();
  inline void set_allocated_old_recording(::TSP::Reference* old_recording);

  // @@protoc_insertion_point(class_scope:KN.CommandShowReplaceRecordingArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_replacement_recording();
  inline void clear_has_replacement_recording();
  inline void set_has_replacement_start_time();
  inline void clear_has_replacement_start_time();
  inline void set_has_old_recording();
  inline void clear_has_old_recording();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* replacement_recording_;
  double replacement_start_time_;
  ::TSP::Reference* old_recording_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowReplaceRecordingArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowSetValueArchive_PropertyValue : public ::google::protobuf::Message {
 public:
  CommandShowSetValueArchive_PropertyValue();
  virtual ~CommandShowSetValueArchive_PropertyValue();

  CommandShowSetValueArchive_PropertyValue(const CommandShowSetValueArchive_PropertyValue& from);

  inline CommandShowSetValueArchive_PropertyValue& operator=(const CommandShowSetValueArchive_PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowSetValueArchive_PropertyValue& default_instance();

  void Swap(CommandShowSetValueArchive_PropertyValue* other);

  // implements Message ----------------------------------------------

  CommandShowSetValueArchive_PropertyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowSetValueArchive_PropertyValue& from);
  void MergeFrom(const CommandShowSetValueArchive_PropertyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bool_value = 1;
  inline bool has_bool_value() const;
  inline void clear_bool_value();
  static const int kBoolValueFieldNumber = 1;
  inline bool bool_value() const;
  inline void set_bool_value(bool value);

  // optional double double_value = 2;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 2;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional .KN.ShowArchive.KNShowMode show_mode_value = 3;
  inline bool has_show_mode_value() const;
  inline void clear_show_mode_value();
  static const int kShowModeValueFieldNumber = 3;
  inline ::KN::ShowArchive_KNShowMode show_mode_value() const;
  inline void set_show_mode_value(::KN::ShowArchive_KNShowMode value);

  // optional .TSP.Size size_value = 4;
  inline bool has_size_value() const;
  inline void clear_size_value();
  static const int kSizeValueFieldNumber = 4;
  inline const ::TSP::Size& size_value() const;
  inline ::TSP::Size* mutable_size_value();
  inline ::TSP::Size* release_size_value();
  inline void set_allocated_size_value(::TSP::Size* size_value);

  // @@protoc_insertion_point(class_scope:KN.CommandShowSetValueArchive.PropertyValue)
 private:
  inline void set_has_bool_value();
  inline void clear_has_bool_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_show_mode_value();
  inline void clear_has_show_mode_value();
  inline void set_has_size_value();
  inline void clear_has_size_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double double_value_;
  bool bool_value_;
  int show_mode_value_;
  ::TSP::Size* size_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowSetValueArchive_PropertyValue* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowSetValueArchive : public ::google::protobuf::Message {
 public:
  CommandShowSetValueArchive();
  virtual ~CommandShowSetValueArchive();

  CommandShowSetValueArchive(const CommandShowSetValueArchive& from);

  inline CommandShowSetValueArchive& operator=(const CommandShowSetValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowSetValueArchive& default_instance();

  void Swap(CommandShowSetValueArchive* other);

  // implements Message ----------------------------------------------

  CommandShowSetValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowSetValueArchive& from);
  void MergeFrom(const CommandShowSetValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandShowSetValueArchive_PropertyValue PropertyValue;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // required .KN.CommandShowSetValueArchive.PropertyValue old_value = 4;
  inline bool has_old_value() const;
  inline void clear_old_value();
  static const int kOldValueFieldNumber = 4;
  inline const ::KN::CommandShowSetValueArchive_PropertyValue& old_value() const;
  inline ::KN::CommandShowSetValueArchive_PropertyValue* mutable_old_value();
  inline ::KN::CommandShowSetValueArchive_PropertyValue* release_old_value();
  inline void set_allocated_old_value(::KN::CommandShowSetValueArchive_PropertyValue* old_value);

  // required .KN.CommandShowSetValueArchive.PropertyValue new_value = 5;
  inline bool has_new_value() const;
  inline void clear_new_value();
  static const int kNewValueFieldNumber = 5;
  inline const ::KN::CommandShowSetValueArchive_PropertyValue& new_value() const;
  inline ::KN::CommandShowSetValueArchive_PropertyValue* mutable_new_value();
  inline ::KN::CommandShowSetValueArchive_PropertyValue* release_new_value();
  inline void set_allocated_new_value(::KN::CommandShowSetValueArchive_PropertyValue* new_value);

  // @@protoc_insertion_point(class_scope:KN.CommandShowSetValueArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_old_value();
  inline void clear_has_old_value();
  inline void set_has_new_value();
  inline void clear_has_new_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::std::string* property_;
  ::KN::CommandShowSetValueArchive_PropertyValue* old_value_;
  ::KN::CommandShowSetValueArchive_PropertyValue* new_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowSetValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowInsertSlideArchive : public ::google::protobuf::Message {
 public:
  CommandShowInsertSlideArchive();
  virtual ~CommandShowInsertSlideArchive();

  CommandShowInsertSlideArchive(const CommandShowInsertSlideArchive& from);

  inline CommandShowInsertSlideArchive& operator=(const CommandShowInsertSlideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowInsertSlideArchive& default_instance();

  void Swap(CommandShowInsertSlideArchive* other);

  // implements Message ----------------------------------------------

  CommandShowInsertSlideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowInsertSlideArchive& from);
  void MergeFrom(const CommandShowInsertSlideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandShowInsertSlideArchive_Kind Kind;
  static const Kind kKindInsertSlide = CommandShowInsertSlideArchive_Kind_kKindInsertSlide;
  static const Kind kKindInsertSlideForPaste = CommandShowInsertSlideArchive_Kind_kKindInsertSlideForPaste;
  static const Kind kKindInsertSlideForDuplicate = CommandShowInsertSlideArchive_Kind_kKindInsertSlideForDuplicate;
  static inline bool Kind_IsValid(int value) {
    return CommandShowInsertSlideArchive_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    CommandShowInsertSlideArchive_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    CommandShowInsertSlideArchive_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    CommandShowInsertSlideArchive_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return CommandShowInsertSlideArchive_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return CommandShowInsertSlideArchive_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return CommandShowInsertSlideArchive_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required .TSP.Reference slideNode = 3;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 3;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required uint32 childIndex = 4;
  inline bool has_childindex() const;
  inline void clear_childindex();
  static const int kChildIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 childindex() const;
  inline void set_childindex(::google::protobuf::uint32 value);

  // required .TSP.Reference parentSlideNode = 5;
  inline bool has_parentslidenode() const;
  inline void clear_parentslidenode();
  static const int kParentSlideNodeFieldNumber = 5;
  inline const ::TSP::Reference& parentslidenode() const;
  inline ::TSP::Reference* mutable_parentslidenode();
  inline ::TSP::Reference* release_parentslidenode();
  inline void set_allocated_parentslidenode(::TSP::Reference* parentslidenode);

  // optional .KN.CommandShowInsertSlideArchive.Kind kind = 6 [default = kKindInsertSlide];
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 6;
  inline ::KN::CommandShowInsertSlideArchive_Kind kind() const;
  inline void set_kind(::KN::CommandShowInsertSlideArchive_Kind value);

  // @@protoc_insertion_point(class_scope:KN.CommandShowInsertSlideArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_childindex();
  inline void clear_has_childindex();
  inline void set_has_parentslidenode();
  inline void clear_has_parentslidenode();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* slidenode_;
  ::TSP::Reference* parentslidenode_;
  ::google::protobuf::uint32 childindex_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowInsertSlideArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowMoveSlideArchive : public ::google::protobuf::Message {
 public:
  CommandShowMoveSlideArchive();
  virtual ~CommandShowMoveSlideArchive();

  CommandShowMoveSlideArchive(const CommandShowMoveSlideArchive& from);

  inline CommandShowMoveSlideArchive& operator=(const CommandShowMoveSlideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowMoveSlideArchive& default_instance();

  void Swap(CommandShowMoveSlideArchive* other);

  // implements Message ----------------------------------------------

  CommandShowMoveSlideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowMoveSlideArchive& from);
  void MergeFrom(const CommandShowMoveSlideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required .TSP.Reference slideNode = 3;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 3;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // repeated .TSP.Reference parentSlideNodes = 4;
  inline int parentslidenodes_size() const;
  inline void clear_parentslidenodes();
  static const int kParentSlideNodesFieldNumber = 4;
  inline const ::TSP::Reference& parentslidenodes(int index) const;
  inline ::TSP::Reference* mutable_parentslidenodes(int index);
  inline ::TSP::Reference* add_parentslidenodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      parentslidenodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_parentslidenodes();

  // repeated uint32 childIndices = 5;
  inline int childindices_size() const;
  inline void clear_childindices();
  static const int kChildIndicesFieldNumber = 5;
  inline ::google::protobuf::uint32 childindices(int index) const;
  inline void set_childindices(int index, ::google::protobuf::uint32 value);
  inline void add_childindices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      childindices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_childindices();

  // @@protoc_insertion_point(class_scope:KN.CommandShowMoveSlideArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* slidenode_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > parentslidenodes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > childindices_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowMoveSlideArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowRemoveSlideArchive : public ::google::protobuf::Message {
 public:
  CommandShowRemoveSlideArchive();
  virtual ~CommandShowRemoveSlideArchive();

  CommandShowRemoveSlideArchive(const CommandShowRemoveSlideArchive& from);

  inline CommandShowRemoveSlideArchive& operator=(const CommandShowRemoveSlideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowRemoveSlideArchive& default_instance();

  void Swap(CommandShowRemoveSlideArchive* other);

  // implements Message ----------------------------------------------

  CommandShowRemoveSlideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowRemoveSlideArchive& from);
  void MergeFrom(const CommandShowRemoveSlideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required .TSP.Reference slideNode = 3;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 3;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required .TSP.Reference parentSlideNode = 4;
  inline bool has_parentslidenode() const;
  inline void clear_parentslidenode();
  static const int kParentSlideNodeFieldNumber = 4;
  inline const ::TSP::Reference& parentslidenode() const;
  inline ::TSP::Reference* mutable_parentslidenode();
  inline ::TSP::Reference* release_parentslidenode();
  inline void set_allocated_parentslidenode(::TSP::Reference* parentslidenode);

  // required uint32 childIndex = 5;
  inline bool has_childindex() const;
  inline void clear_childindex();
  static const int kChildIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 childindex() const;
  inline void set_childindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandShowRemoveSlideArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_parentslidenode();
  inline void clear_has_parentslidenode();
  inline void set_has_childindex();
  inline void clear_has_childindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* slidenode_;
  ::TSP::Reference* parentslidenode_;
  ::google::protobuf::uint32 childindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowRemoveSlideArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowChangeThemeArchive : public ::google::protobuf::Message {
 public:
  CommandShowChangeThemeArchive();
  virtual ~CommandShowChangeThemeArchive();

  CommandShowChangeThemeArchive(const CommandShowChangeThemeArchive& from);

  inline CommandShowChangeThemeArchive& operator=(const CommandShowChangeThemeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowChangeThemeArchive& default_instance();

  void Swap(CommandShowChangeThemeArchive* other);

  // implements Message ----------------------------------------------

  CommandShowChangeThemeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowChangeThemeArchive& from);
  void MergeFrom(const CommandShowChangeThemeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required .TSP.Reference theme = 3;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 3;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .TSP.Reference old_theme = 4;
  inline bool has_old_theme() const;
  inline void clear_old_theme();
  static const int kOldThemeFieldNumber = 4;
  inline const ::TSP::Reference& old_theme() const;
  inline ::TSP::Reference* mutable_old_theme();
  inline ::TSP::Reference* release_old_theme();
  inline void set_allocated_old_theme(::TSP::Reference* old_theme);

  // optional string template_identifier = 5;
  inline bool has_template_identifier() const;
  inline void clear_template_identifier();
  static const int kTemplateIdentifierFieldNumber = 5;
  inline const ::std::string& template_identifier() const;
  inline void set_template_identifier(const ::std::string& value);
  inline void set_template_identifier(const char* value);
  inline void set_template_identifier(const char* value, size_t size);
  inline ::std::string* mutable_template_identifier();
  inline ::std::string* release_template_identifier();
  inline void set_allocated_template_identifier(::std::string* template_identifier);

  // optional string old_template_identifier = 6;
  inline bool has_old_template_identifier() const;
  inline void clear_old_template_identifier();
  static const int kOldTemplateIdentifierFieldNumber = 6;
  inline const ::std::string& old_template_identifier() const;
  inline void set_old_template_identifier(const ::std::string& value);
  inline void set_old_template_identifier(const char* value);
  inline void set_old_template_identifier(const char* value, size_t size);
  inline ::std::string* mutable_old_template_identifier();
  inline ::std::string* release_old_template_identifier();
  inline void set_allocated_old_template_identifier(::std::string* old_template_identifier);

  // @@protoc_insertion_point(class_scope:KN.CommandShowChangeThemeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_old_theme();
  inline void clear_has_old_theme();
  inline void set_has_template_identifier();
  inline void clear_has_template_identifier();
  inline void set_has_old_template_identifier();
  inline void clear_has_old_template_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* theme_;
  ::TSP::Reference* old_theme_;
  ::std::string* template_identifier_;
  ::std::string* old_template_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowChangeThemeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMoveMastersArchive : public ::google::protobuf::Message {
 public:
  CommandMoveMastersArchive();
  virtual ~CommandMoveMastersArchive();

  CommandMoveMastersArchive(const CommandMoveMastersArchive& from);

  inline CommandMoveMastersArchive& operator=(const CommandMoveMastersArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMoveMastersArchive& default_instance();

  void Swap(CommandMoveMastersArchive* other);

  // implements Message ----------------------------------------------

  CommandMoveMastersArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMoveMastersArchive& from);
  void MergeFrom(const CommandMoveMastersArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // repeated .TSP.Reference master_slides = 3;
  inline int master_slides_size() const;
  inline void clear_master_slides();
  static const int kMasterSlidesFieldNumber = 3;
  inline const ::TSP::Reference& master_slides(int index) const;
  inline ::TSP::Reference* mutable_master_slides(int index);
  inline ::TSP::Reference* add_master_slides();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      master_slides() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_slides();

  // repeated .TSP.Reference previous_indexes_keys = 4;
  inline int previous_indexes_keys_size() const;
  inline void clear_previous_indexes_keys();
  static const int kPreviousIndexesKeysFieldNumber = 4;
  inline const ::TSP::Reference& previous_indexes_keys(int index) const;
  inline ::TSP::Reference* mutable_previous_indexes_keys(int index);
  inline ::TSP::Reference* add_previous_indexes_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      previous_indexes_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_previous_indexes_keys();

  // repeated uint32 previous_indexes_values = 5;
  inline int previous_indexes_values_size() const;
  inline void clear_previous_indexes_values();
  static const int kPreviousIndexesValuesFieldNumber = 5;
  inline ::google::protobuf::uint32 previous_indexes_values(int index) const;
  inline void set_previous_indexes_values(int index, ::google::protobuf::uint32 value);
  inline void add_previous_indexes_values(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      previous_indexes_values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_previous_indexes_values();

  // repeated .TSP.Reference final_master_arrangement = 6;
  inline int final_master_arrangement_size() const;
  inline void clear_final_master_arrangement();
  static const int kFinalMasterArrangementFieldNumber = 6;
  inline const ::TSP::Reference& final_master_arrangement(int index) const;
  inline ::TSP::Reference* mutable_final_master_arrangement(int index);
  inline ::TSP::Reference* add_final_master_arrangement();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      final_master_arrangement() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_final_master_arrangement();

  // @@protoc_insertion_point(class_scope:KN.CommandMoveMastersArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > master_slides_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > previous_indexes_keys_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > previous_indexes_values_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > final_master_arrangement_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMoveMastersArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandInsertMasterArchive : public ::google::protobuf::Message {
 public:
  CommandInsertMasterArchive();
  virtual ~CommandInsertMasterArchive();

  CommandInsertMasterArchive(const CommandInsertMasterArchive& from);

  inline CommandInsertMasterArchive& operator=(const CommandInsertMasterArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInsertMasterArchive& default_instance();

  void Swap(CommandInsertMasterArchive* other);

  // implements Message ----------------------------------------------

  CommandInsertMasterArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInsertMasterArchive& from);
  void MergeFrom(const CommandInsertMasterArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .TSP.Reference master_slide_node = 3;
  inline bool has_master_slide_node() const;
  inline void clear_master_slide_node();
  static const int kMasterSlideNodeFieldNumber = 3;
  inline const ::TSP::Reference& master_slide_node() const;
  inline ::TSP::Reference* mutable_master_slide_node();
  inline ::TSP::Reference* release_master_slide_node();
  inline void set_allocated_master_slide_node(::TSP::Reference* master_slide_node);

  // required uint32 insertion_index = 4;
  inline bool has_insertion_index() const;
  inline void clear_insertion_index();
  static const int kInsertionIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 insertion_index() const;
  inline void set_insertion_index(::google::protobuf::uint32 value);

  // required bool was_inserted_with_drop = 5;
  inline bool has_was_inserted_with_drop() const;
  inline void clear_was_inserted_with_drop();
  static const int kWasInsertedWithDropFieldNumber = 5;
  inline bool was_inserted_with_drop() const;
  inline void set_was_inserted_with_drop(bool value);

  // @@protoc_insertion_point(class_scope:KN.CommandInsertMasterArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_master_slide_node();
  inline void clear_has_master_slide_node();
  inline void set_has_insertion_index();
  inline void clear_has_insertion_index();
  inline void set_has_was_inserted_with_drop();
  inline void clear_has_was_inserted_with_drop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TSP::Reference* master_slide_node_;
  ::google::protobuf::uint32 insertion_index_;
  bool was_inserted_with_drop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandInsertMasterArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRemoveMasterArchive : public ::google::protobuf::Message {
 public:
  CommandRemoveMasterArchive();
  virtual ~CommandRemoveMasterArchive();

  CommandRemoveMasterArchive(const CommandRemoveMasterArchive& from);

  inline CommandRemoveMasterArchive& operator=(const CommandRemoveMasterArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRemoveMasterArchive& default_instance();

  void Swap(CommandRemoveMasterArchive* other);

  // implements Message ----------------------------------------------

  CommandRemoveMasterArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRemoveMasterArchive& from);
  void MergeFrom(const CommandRemoveMasterArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .TSP.Reference master_slide_node = 3;
  inline bool has_master_slide_node() const;
  inline void clear_master_slide_node();
  static const int kMasterSlideNodeFieldNumber = 3;
  inline const ::TSP::Reference& master_slide_node() const;
  inline ::TSP::Reference* mutable_master_slide_node();
  inline ::TSP::Reference* release_master_slide_node();
  inline void set_allocated_master_slide_node(::TSP::Reference* master_slide_node);

  // required uint32 previous_index = 4;
  inline bool has_previous_index() const;
  inline void clear_previous_index();
  static const int kPreviousIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 previous_index() const;
  inline void set_previous_index(::google::protobuf::uint32 value);

  // optional .TSP.Reference master_change_commands = 5;
  inline bool has_master_change_commands() const;
  inline void clear_master_change_commands();
  static const int kMasterChangeCommandsFieldNumber = 5;
  inline const ::TSP::Reference& master_change_commands() const;
  inline ::TSP::Reference* mutable_master_change_commands();
  inline ::TSP::Reference* release_master_change_commands();
  inline void set_allocated_master_change_commands(::TSP::Reference* master_change_commands);

  // @@protoc_insertion_point(class_scope:KN.CommandRemoveMasterArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_master_slide_node();
  inline void clear_has_master_slide_node();
  inline void set_has_previous_index();
  inline void clear_has_previous_index();
  inline void set_has_master_change_commands();
  inline void clear_has_master_change_commands();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TSP::Reference* master_slide_node_;
  ::TSP::Reference* master_change_commands_;
  ::google::protobuf::uint32 previous_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRemoveMasterArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRenameMasterArchive : public ::google::protobuf::Message {
 public:
  CommandRenameMasterArchive();
  virtual ~CommandRenameMasterArchive();

  CommandRenameMasterArchive(const CommandRenameMasterArchive& from);

  inline CommandRenameMasterArchive& operator=(const CommandRenameMasterArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRenameMasterArchive& default_instance();

  void Swap(CommandRenameMasterArchive* other);

  // implements Message ----------------------------------------------

  CommandRenameMasterArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRenameMasterArchive& from);
  void MergeFrom(const CommandRenameMasterArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference master_slide = 2;
  inline bool has_master_slide() const;
  inline void clear_master_slide();
  static const int kMasterSlideFieldNumber = 2;
  inline const ::TSP::Reference& master_slide() const;
  inline ::TSP::Reference* mutable_master_slide();
  inline ::TSP::Reference* release_master_slide();
  inline void set_allocated_master_slide(::TSP::Reference* master_slide);

  // required string master_name = 3;
  inline bool has_master_name() const;
  inline void clear_master_name();
  static const int kMasterNameFieldNumber = 3;
  inline const ::std::string& master_name() const;
  inline void set_master_name(const ::std::string& value);
  inline void set_master_name(const char* value);
  inline void set_master_name(const char* value, size_t size);
  inline ::std::string* mutable_master_name();
  inline ::std::string* release_master_name();
  inline void set_allocated_master_name(::std::string* master_name);

  // required string old_master_name = 4;
  inline bool has_old_master_name() const;
  inline void clear_old_master_name();
  static const int kOldMasterNameFieldNumber = 4;
  inline const ::std::string& old_master_name() const;
  inline void set_old_master_name(const ::std::string& value);
  inline void set_old_master_name(const char* value);
  inline void set_old_master_name(const char* value, size_t size);
  inline ::std::string* mutable_old_master_name();
  inline ::std::string* release_old_master_name();
  inline void set_allocated_old_master_name(::std::string* old_master_name);

  // @@protoc_insertion_point(class_scope:KN.CommandRenameMasterArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_master_slide();
  inline void clear_has_master_slide();
  inline void set_has_master_name();
  inline void clear_has_master_name();
  inline void set_has_old_master_name();
  inline void clear_has_old_master_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* master_slide_;
  ::std::string* master_name_;
  ::std::string* old_master_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRenameMasterArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideInsertBuildArchive : public ::google::protobuf::Message {
 public:
  CommandSlideInsertBuildArchive();
  virtual ~CommandSlideInsertBuildArchive();

  CommandSlideInsertBuildArchive(const CommandSlideInsertBuildArchive& from);

  inline CommandSlideInsertBuildArchive& operator=(const CommandSlideInsertBuildArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideInsertBuildArchive& default_instance();

  void Swap(CommandSlideInsertBuildArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideInsertBuildArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideInsertBuildArchive& from);
  void MergeFrom(const CommandSlideInsertBuildArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required .TSP.Reference build = 3;
  inline bool has_build() const;
  inline void clear_build();
  static const int kBuildFieldNumber = 3;
  inline const ::TSP::Reference& build() const;
  inline ::TSP::Reference* mutable_build();
  inline ::TSP::Reference* release_build();
  inline void set_allocated_build(::TSP::Reference* build);

  // required uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional bool shouldCreateChunks = 5;
  inline bool has_shouldcreatechunks() const;
  inline void clear_shouldcreatechunks();
  static const int kShouldCreateChunksFieldNumber = 5;
  inline bool shouldcreatechunks() const;
  inline void set_shouldcreatechunks(bool value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideInsertBuildArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_build();
  inline void clear_has_build();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_shouldcreatechunks();
  inline void clear_has_shouldcreatechunks();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::TSP::Reference* build_;
  ::google::protobuf::uint32 index_;
  bool shouldcreatechunks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideInsertBuildArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideRemoveBuildArchive : public ::google::protobuf::Message {
 public:
  CommandSlideRemoveBuildArchive();
  virtual ~CommandSlideRemoveBuildArchive();

  CommandSlideRemoveBuildArchive(const CommandSlideRemoveBuildArchive& from);

  inline CommandSlideRemoveBuildArchive& operator=(const CommandSlideRemoveBuildArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideRemoveBuildArchive& default_instance();

  void Swap(CommandSlideRemoveBuildArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideRemoveBuildArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideRemoveBuildArchive& from);
  void MergeFrom(const CommandSlideRemoveBuildArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required .TSP.Reference build = 3;
  inline bool has_build() const;
  inline void clear_build();
  static const int kBuildFieldNumber = 3;
  inline const ::TSP::Reference& build() const;
  inline ::TSP::Reference* mutable_build();
  inline ::TSP::Reference* release_build();
  inline void set_allocated_build(::TSP::Reference* build);

  // required uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideRemoveBuildArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_build();
  inline void clear_has_build();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::TSP::Reference* build_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideRemoveBuildArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideMoveBuildWithoutMovingChunksArchive : public ::google::protobuf::Message {
 public:
  CommandSlideMoveBuildWithoutMovingChunksArchive();
  virtual ~CommandSlideMoveBuildWithoutMovingChunksArchive();

  CommandSlideMoveBuildWithoutMovingChunksArchive(const CommandSlideMoveBuildWithoutMovingChunksArchive& from);

  inline CommandSlideMoveBuildWithoutMovingChunksArchive& operator=(const CommandSlideMoveBuildWithoutMovingChunksArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideMoveBuildWithoutMovingChunksArchive& default_instance();

  void Swap(CommandSlideMoveBuildWithoutMovingChunksArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideMoveBuildWithoutMovingChunksArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideMoveBuildWithoutMovingChunksArchive& from);
  void MergeFrom(const CommandSlideMoveBuildWithoutMovingChunksArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 oldIndex = 4;
  inline bool has_oldindex() const;
  inline void clear_oldindex();
  static const int kOldIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 oldindex() const;
  inline void set_oldindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideMoveBuildWithoutMovingChunksArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_oldindex();
  inline void clear_has_oldindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 oldindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideMoveBuildWithoutMovingChunksArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideMoveBuildsArchive : public ::google::protobuf::Message {
 public:
  CommandSlideMoveBuildsArchive();
  virtual ~CommandSlideMoveBuildsArchive();

  CommandSlideMoveBuildsArchive(const CommandSlideMoveBuildsArchive& from);

  inline CommandSlideMoveBuildsArchive& operator=(const CommandSlideMoveBuildsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideMoveBuildsArchive& default_instance();

  void Swap(CommandSlideMoveBuildsArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideMoveBuildsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideMoveBuildsArchive& from);
  void MergeFrom(const CommandSlideMoveBuildsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference builds = 2;
  inline int builds_size() const;
  inline void clear_builds();
  static const int kBuildsFieldNumber = 2;
  inline const ::TSP::Reference& builds(int index) const;
  inline ::TSP::Reference* mutable_builds(int index);
  inline ::TSP::Reference* add_builds();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      builds() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_builds();

  // optional uint32 toIndex = 3;
  inline bool has_toindex() const;
  inline void clear_toindex();
  static const int kToIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 toindex() const;
  inline void set_toindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideMoveBuildsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_toindex();
  inline void clear_has_toindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > builds_;
  ::google::protobuf::uint32 toindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideMoveBuildsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideInsertBuildChunkArchive : public ::google::protobuf::Message {
 public:
  CommandSlideInsertBuildChunkArchive();
  virtual ~CommandSlideInsertBuildChunkArchive();

  CommandSlideInsertBuildChunkArchive(const CommandSlideInsertBuildChunkArchive& from);

  inline CommandSlideInsertBuildChunkArchive& operator=(const CommandSlideInsertBuildChunkArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideInsertBuildChunkArchive& default_instance();

  void Swap(CommandSlideInsertBuildChunkArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideInsertBuildChunkArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideInsertBuildChunkArchive& from);
  void MergeFrom(const CommandSlideInsertBuildChunkArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required .KN.BuildChunkArchive buildChunk = 3;
  inline bool has_buildchunk() const;
  inline void clear_buildchunk();
  static const int kBuildChunkFieldNumber = 3;
  inline const ::KN::BuildChunkArchive& buildchunk() const;
  inline ::KN::BuildChunkArchive* mutable_buildchunk();
  inline ::KN::BuildChunkArchive* release_buildchunk();
  inline void set_allocated_buildchunk(::KN::BuildChunkArchive* buildchunk);

  // required uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideInsertBuildChunkArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_buildchunk();
  inline void clear_has_buildchunk();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::KN::BuildChunkArchive* buildchunk_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideInsertBuildChunkArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideRemoveBuildChunkArchive : public ::google::protobuf::Message {
 public:
  CommandSlideRemoveBuildChunkArchive();
  virtual ~CommandSlideRemoveBuildChunkArchive();

  CommandSlideRemoveBuildChunkArchive(const CommandSlideRemoveBuildChunkArchive& from);

  inline CommandSlideRemoveBuildChunkArchive& operator=(const CommandSlideRemoveBuildChunkArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideRemoveBuildChunkArchive& default_instance();

  void Swap(CommandSlideRemoveBuildChunkArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideRemoveBuildChunkArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideRemoveBuildChunkArchive& from);
  void MergeFrom(const CommandSlideRemoveBuildChunkArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required .KN.BuildChunkArchive buildChunk = 3;
  inline bool has_buildchunk() const;
  inline void clear_buildchunk();
  static const int kBuildChunkFieldNumber = 3;
  inline const ::KN::BuildChunkArchive& buildchunk() const;
  inline ::KN::BuildChunkArchive* mutable_buildchunk();
  inline ::KN::BuildChunkArchive* release_buildchunk();
  inline void set_allocated_buildchunk(::KN::BuildChunkArchive* buildchunk);

  // required uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideRemoveBuildChunkArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_buildchunk();
  inline void clear_has_buildchunk();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::KN::BuildChunkArchive* buildchunk_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideRemoveBuildChunkArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideMoveBuildChunkArchive : public ::google::protobuf::Message {
 public:
  CommandSlideMoveBuildChunkArchive();
  virtual ~CommandSlideMoveBuildChunkArchive();

  CommandSlideMoveBuildChunkArchive(const CommandSlideMoveBuildChunkArchive& from);

  inline CommandSlideMoveBuildChunkArchive& operator=(const CommandSlideMoveBuildChunkArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideMoveBuildChunkArchive& default_instance();

  void Swap(CommandSlideMoveBuildChunkArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideMoveBuildChunkArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideMoveBuildChunkArchive& from);
  void MergeFrom(const CommandSlideMoveBuildChunkArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 oldIndex = 4;
  inline bool has_oldindex() const;
  inline void clear_oldindex();
  static const int kOldIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 oldindex() const;
  inline void set_oldindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideMoveBuildChunkArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_oldindex();
  inline void clear_has_oldindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 oldindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideMoveBuildChunkArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideMoveBuildChunksArchive : public ::google::protobuf::Message {
 public:
  CommandSlideMoveBuildChunksArchive();
  virtual ~CommandSlideMoveBuildChunksArchive();

  CommandSlideMoveBuildChunksArchive(const CommandSlideMoveBuildChunksArchive& from);

  inline CommandSlideMoveBuildChunksArchive& operator=(const CommandSlideMoveBuildChunksArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideMoveBuildChunksArchive& default_instance();

  void Swap(CommandSlideMoveBuildChunksArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideMoveBuildChunksArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideMoveBuildChunksArchive& from);
  void MergeFrom(const CommandSlideMoveBuildChunksArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .KN.BuildChunkArchive buildChunks = 2;
  inline int buildchunks_size() const;
  inline void clear_buildchunks();
  static const int kBuildChunksFieldNumber = 2;
  inline const ::KN::BuildChunkArchive& buildchunks(int index) const;
  inline ::KN::BuildChunkArchive* mutable_buildchunks(int index);
  inline ::KN::BuildChunkArchive* add_buildchunks();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >&
      buildchunks() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >*
      mutable_buildchunks();

  // optional uint32 toIndex = 3;
  inline bool has_toindex() const;
  inline void clear_toindex();
  static const int kToIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 toindex() const;
  inline void set_toindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideMoveBuildChunksArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_toindex();
  inline void clear_has_toindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive > buildchunks_;
  ::google::protobuf::uint32 toindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideMoveBuildChunksArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandBuildSetValueArchive : public ::google::protobuf::Message {
 public:
  CommandBuildSetValueArchive();
  virtual ~CommandBuildSetValueArchive();

  CommandBuildSetValueArchive(const CommandBuildSetValueArchive& from);

  inline CommandBuildSetValueArchive& operator=(const CommandBuildSetValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandBuildSetValueArchive& default_instance();

  void Swap(CommandBuildSetValueArchive* other);

  // implements Message ----------------------------------------------

  CommandBuildSetValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandBuildSetValueArchive& from);
  void MergeFrom(const CommandBuildSetValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference build = 2;
  inline bool has_build() const;
  inline void clear_build();
  static const int kBuildFieldNumber = 2;
  inline const ::TSP::Reference& build() const;
  inline ::TSP::Reference* mutable_build();
  inline ::TSP::Reference* release_build();
  inline void set_allocated_build(::TSP::Reference* build);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // repeated string effects = 4;
  inline int effects_size() const;
  inline void clear_effects();
  static const int kEffectsFieldNumber = 4;
  inline const ::std::string& effects(int index) const;
  inline ::std::string* mutable_effects(int index);
  inline void set_effects(int index, const ::std::string& value);
  inline void set_effects(int index, const char* value);
  inline void set_effects(int index, const char* value, size_t size);
  inline ::std::string* add_effects();
  inline void add_effects(const ::std::string& value);
  inline void add_effects(const char* value);
  inline void add_effects(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& effects() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_effects();

  // repeated string types = 5;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 5;
  inline const ::std::string& types(int index) const;
  inline ::std::string* mutable_types(int index);
  inline void set_types(int index, const ::std::string& value);
  inline void set_types(int index, const char* value);
  inline void set_types(int index, const char* value, size_t size);
  inline ::std::string* add_types();
  inline void add_types(const ::std::string& value);
  inline void add_types(const char* value);
  inline void add_types(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& types() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_types();

  // repeated string deliveries = 6;
  inline int deliveries_size() const;
  inline void clear_deliveries();
  static const int kDeliveriesFieldNumber = 6;
  inline const ::std::string& deliveries(int index) const;
  inline ::std::string* mutable_deliveries(int index);
  inline void set_deliveries(int index, const ::std::string& value);
  inline void set_deliveries(int index, const char* value);
  inline void set_deliveries(int index, const char* value, size_t size);
  inline ::std::string* add_deliveries();
  inline void add_deliveries(const ::std::string& value);
  inline void add_deliveries(const char* value);
  inline void add_deliveries(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& deliveries() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_deliveries();

  // repeated uint32 directions = 7;
  inline int directions_size() const;
  inline void clear_directions();
  static const int kDirectionsFieldNumber = 7;
  inline ::google::protobuf::uint32 directions(int index) const;
  inline void set_directions(int index, ::google::protobuf::uint32 value);
  inline void add_directions(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      directions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_directions();

  // repeated double durations = 8;
  inline int durations_size() const;
  inline void clear_durations();
  static const int kDurationsFieldNumber = 8;
  inline double durations(int index) const;
  inline void set_durations(int index, double value);
  inline void add_durations(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      durations() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_durations();

  // repeated double delays = 9;
  inline int delays_size() const;
  inline void clear_delays();
  static const int kDelaysFieldNumber = 9;
  inline double delays(int index) const;
  inline void set_delays(int index, double value);
  inline void add_delays(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      delays() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_delays();

  // repeated double delayAutomaticAfters = 10;
  inline int delayautomaticafters_size() const;
  inline void clear_delayautomaticafters();
  static const int kDelayAutomaticAftersFieldNumber = 10;
  inline double delayautomaticafters(int index) const;
  inline void set_delayautomaticafters(int index, double value);
  inline void add_delayautomaticafters(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      delayautomaticafters() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_delayautomaticafters();

  // repeated double delayAutomaticWiths = 11;
  inline int delayautomaticwiths_size() const;
  inline void clear_delayautomaticwiths();
  static const int kDelayAutomaticWithsFieldNumber = 11;
  inline double delayautomaticwiths(int index) const;
  inline void set_delayautomaticwiths(int index, double value);
  inline void add_delayautomaticwiths(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      delayautomaticwiths() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_delayautomaticwiths();

  // repeated bool eventTriggers = 12;
  inline int eventtriggers_size() const;
  inline void clear_eventtriggers();
  static const int kEventTriggersFieldNumber = 12;
  inline bool eventtriggers(int index) const;
  inline void set_eventtriggers(int index, bool value);
  inline void add_eventtriggers(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      eventtriggers() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_eventtriggers();

  // @@protoc_insertion_point(class_scope:KN.CommandBuildSetValueArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_build();
  inline void clear_has_build();
  inline void set_has_property();
  inline void clear_has_property();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* build_;
  ::std::string* property_;
  ::google::protobuf::RepeatedPtrField< ::std::string> effects_;
  ::google::protobuf::RepeatedPtrField< ::std::string> types_;
  ::google::protobuf::RepeatedPtrField< ::std::string> deliveries_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > directions_;
  ::google::protobuf::RepeatedField< double > durations_;
  ::google::protobuf::RepeatedField< double > delays_;
  ::google::protobuf::RepeatedField< double > delayautomaticafters_;
  ::google::protobuf::RepeatedField< double > delayautomaticwiths_;
  ::google::protobuf::RepeatedField< bool > eventtriggers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandBuildSetValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandBuildChunkSetValueArchive : public ::google::protobuf::Message {
 public:
  CommandBuildChunkSetValueArchive();
  virtual ~CommandBuildChunkSetValueArchive();

  CommandBuildChunkSetValueArchive(const CommandBuildChunkSetValueArchive& from);

  inline CommandBuildChunkSetValueArchive& operator=(const CommandBuildChunkSetValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandBuildChunkSetValueArchive& default_instance();

  void Swap(CommandBuildChunkSetValueArchive* other);

  // implements Message ----------------------------------------------

  CommandBuildChunkSetValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandBuildChunkSetValueArchive& from);
  void MergeFrom(const CommandBuildChunkSetValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .KN.BuildChunkArchive buildChunk = 2;
  inline bool has_buildchunk() const;
  inline void clear_buildchunk();
  static const int kBuildChunkFieldNumber = 2;
  inline const ::KN::BuildChunkArchive& buildchunk() const;
  inline ::KN::BuildChunkArchive* mutable_buildchunk();
  inline ::KN::BuildChunkArchive* release_buildchunk();
  inline void set_allocated_buildchunk(::KN::BuildChunkArchive* buildchunk);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // repeated uint32 referents = 4;
  inline int referents_size() const;
  inline void clear_referents();
  static const int kReferentsFieldNumber = 4;
  inline ::google::protobuf::uint32 referents(int index) const;
  inline void set_referents(int index, ::google::protobuf::uint32 value);
  inline void add_referents(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      referents() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_referents();

  // repeated bool automatics = 5;
  inline int automatics_size() const;
  inline void clear_automatics();
  static const int kAutomaticsFieldNumber = 5;
  inline bool automatics(int index) const;
  inline void set_automatics(int index, bool value);
  inline void add_automatics(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      automatics() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_automatics();

  // repeated double durations = 6;
  inline int durations_size() const;
  inline void clear_durations();
  static const int kDurationsFieldNumber = 6;
  inline double durations(int index) const;
  inline void set_durations(int index, double value);
  inline void add_durations(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      durations() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_durations();

  // repeated double delays = 7;
  inline int delays_size() const;
  inline void clear_delays();
  static const int kDelaysFieldNumber = 7;
  inline double delays(int index) const;
  inline void set_delays(int index, double value);
  inline void add_delays(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      delays() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_delays();

  // optional bool oldOwnsValue = 8;
  inline bool has_oldownsvalue() const;
  inline void clear_oldownsvalue();
  static const int kOldOwnsValueFieldNumber = 8;
  inline bool oldownsvalue() const;
  inline void set_oldownsvalue(bool value);

  // @@protoc_insertion_point(class_scope:KN.CommandBuildChunkSetValueArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_buildchunk();
  inline void clear_has_buildchunk();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_oldownsvalue();
  inline void clear_has_oldownsvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::KN::BuildChunkArchive* buildchunk_;
  ::std::string* property_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > referents_;
  ::google::protobuf::RepeatedField< bool > automatics_;
  ::google::protobuf::RepeatedField< double > durations_;
  ::google::protobuf::RepeatedField< double > delays_;
  bool oldownsvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandBuildChunkSetValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandTransitionSetValueArchive : public ::google::protobuf::Message {
 public:
  CommandTransitionSetValueArchive();
  virtual ~CommandTransitionSetValueArchive();

  CommandTransitionSetValueArchive(const CommandTransitionSetValueArchive& from);

  inline CommandTransitionSetValueArchive& operator=(const CommandTransitionSetValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandTransitionSetValueArchive& default_instance();

  void Swap(CommandTransitionSetValueArchive* other);

  // implements Message ----------------------------------------------

  CommandTransitionSetValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandTransitionSetValueArchive& from);
  void MergeFrom(const CommandTransitionSetValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slideNode = 2;
  inline bool has_slidenode() const;
  inline void clear_slidenode();
  static const int kSlideNodeFieldNumber = 2;
  inline const ::TSP::Reference& slidenode() const;
  inline ::TSP::Reference* mutable_slidenode();
  inline ::TSP::Reference* release_slidenode();
  inline void set_allocated_slidenode(::TSP::Reference* slidenode);

  // required string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // repeated string effects = 4;
  inline int effects_size() const;
  inline void clear_effects();
  static const int kEffectsFieldNumber = 4;
  inline const ::std::string& effects(int index) const;
  inline ::std::string* mutable_effects(int index);
  inline void set_effects(int index, const ::std::string& value);
  inline void set_effects(int index, const char* value);
  inline void set_effects(int index, const char* value, size_t size);
  inline ::std::string* add_effects();
  inline void add_effects(const ::std::string& value);
  inline void add_effects(const char* value);
  inline void add_effects(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& effects() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_effects();

  // repeated string unused = 5;
  inline int unused_size() const;
  inline void clear_unused();
  static const int kUnusedFieldNumber = 5;
  inline const ::std::string& unused(int index) const;
  inline ::std::string* mutable_unused(int index);
  inline void set_unused(int index, const ::std::string& value);
  inline void set_unused(int index, const char* value);
  inline void set_unused(int index, const char* value, size_t size);
  inline ::std::string* add_unused();
  inline void add_unused(const ::std::string& value);
  inline void add_unused(const char* value);
  inline void add_unused(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unused() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unused();

  // repeated string unused2 = 6;
  inline int unused2_size() const;
  inline void clear_unused2();
  static const int kUnused2FieldNumber = 6;
  inline const ::std::string& unused2(int index) const;
  inline ::std::string* mutable_unused2(int index);
  inline void set_unused2(int index, const ::std::string& value);
  inline void set_unused2(int index, const char* value);
  inline void set_unused2(int index, const char* value, size_t size);
  inline ::std::string* add_unused2();
  inline void add_unused2(const ::std::string& value);
  inline void add_unused2(const char* value);
  inline void add_unused2(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unused2() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unused2();

  // repeated string unused3 = 7;
  inline int unused3_size() const;
  inline void clear_unused3();
  static const int kUnused3FieldNumber = 7;
  inline const ::std::string& unused3(int index) const;
  inline ::std::string* mutable_unused3(int index);
  inline void set_unused3(int index, const ::std::string& value);
  inline void set_unused3(int index, const char* value);
  inline void set_unused3(int index, const char* value, size_t size);
  inline ::std::string* add_unused3();
  inline void add_unused3(const ::std::string& value);
  inline void add_unused3(const char* value);
  inline void add_unused3(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unused3() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unused3();

  // repeated double durations = 8;
  inline int durations_size() const;
  inline void clear_durations();
  static const int kDurationsFieldNumber = 8;
  inline double durations(int index) const;
  inline void set_durations(int index, double value);
  inline void add_durations(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      durations() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_durations();

  // repeated uint32 directions = 9;
  inline int directions_size() const;
  inline void clear_directions();
  static const int kDirectionsFieldNumber = 9;
  inline ::google::protobuf::uint32 directions(int index) const;
  inline void set_directions(int index, ::google::protobuf::uint32 value);
  inline void add_directions(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      directions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_directions();

  // repeated bool isAutomatics = 10;
  inline int isautomatics_size() const;
  inline void clear_isautomatics();
  static const int kIsAutomaticsFieldNumber = 10;
  inline bool isautomatics(int index) const;
  inline void set_isautomatics(int index, bool value);
  inline void add_isautomatics(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      isautomatics() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_isautomatics();

  // repeated double delays = 11;
  inline int delays_size() const;
  inline void clear_delays();
  static const int kDelaysFieldNumber = 11;
  inline double delays(int index) const;
  inline void set_delays(int index, double value);
  inline void add_delays(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      delays() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_delays();

  // @@protoc_insertion_point(class_scope:KN.CommandTransitionSetValueArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slidenode();
  inline void clear_has_slidenode();
  inline void set_has_property();
  inline void clear_has_property();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slidenode_;
  ::std::string* property_;
  ::google::protobuf::RepeatedPtrField< ::std::string> effects_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unused_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unused2_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unused3_;
  ::google::protobuf::RepeatedField< double > durations_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > directions_;
  ::google::protobuf::RepeatedField< bool > isautomatics_;
  ::google::protobuf::RepeatedField< double > delays_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandTransitionSetValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowSetSlideNumberVisibilityArchive : public ::google::protobuf::Message {
 public:
  CommandShowSetSlideNumberVisibilityArchive();
  virtual ~CommandShowSetSlideNumberVisibilityArchive();

  CommandShowSetSlideNumberVisibilityArchive(const CommandShowSetSlideNumberVisibilityArchive& from);

  inline CommandShowSetSlideNumberVisibilityArchive& operator=(const CommandShowSetSlideNumberVisibilityArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowSetSlideNumberVisibilityArchive& default_instance();

  void Swap(CommandShowSetSlideNumberVisibilityArchive* other);

  // implements Message ----------------------------------------------

  CommandShowSetSlideNumberVisibilityArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowSetSlideNumberVisibilityArchive& from);
  void MergeFrom(const CommandShowSetSlideNumberVisibilityArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // required bool slideNumbersVisible = 3;
  inline bool has_slidenumbersvisible() const;
  inline void clear_slidenumbersvisible();
  static const int kSlideNumbersVisibleFieldNumber = 3;
  inline bool slidenumbersvisible() const;
  inline void set_slidenumbersvisible(bool value);

  // optional .TSP.Reference providerUndo = 4;
  inline bool has_providerundo() const;
  inline void clear_providerundo();
  static const int kProviderUndoFieldNumber = 4;
  inline const ::TSP::Reference& providerundo() const;
  inline ::TSP::Reference* mutable_providerundo();
  inline ::TSP::Reference* release_providerundo();
  inline void set_allocated_providerundo(::TSP::Reference* providerundo);

  // @@protoc_insertion_point(class_scope:KN.CommandShowSetSlideNumberVisibilityArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_slidenumbersvisible();
  inline void clear_has_slidenumbersvisible();
  inline void set_has_providerundo();
  inline void clear_has_providerundo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* providerundo_;
  bool slidenumbersvisible_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowSetSlideNumberVisibilityArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMasterRescaleArchive : public ::google::protobuf::Message {
 public:
  CommandMasterRescaleArchive();
  virtual ~CommandMasterRescaleArchive();

  CommandMasterRescaleArchive(const CommandMasterRescaleArchive& from);

  inline CommandMasterRescaleArchive& operator=(const CommandMasterRescaleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMasterRescaleArchive& default_instance();

  void Swap(CommandMasterRescaleArchive* other);

  // implements Message ----------------------------------------------

  CommandMasterRescaleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMasterRescaleArchive& from);
  void MergeFrom(const CommandMasterRescaleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference master = 2;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 2;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // @@protoc_insertion_point(class_scope:KN.CommandMasterRescaleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_master();
  inline void clear_has_master();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* master_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMasterRescaleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMasterSetThumbnailTextArchive : public ::google::protobuf::Message {
 public:
  CommandMasterSetThumbnailTextArchive();
  virtual ~CommandMasterSetThumbnailTextArchive();

  CommandMasterSetThumbnailTextArchive(const CommandMasterSetThumbnailTextArchive& from);

  inline CommandMasterSetThumbnailTextArchive& operator=(const CommandMasterSetThumbnailTextArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMasterSetThumbnailTextArchive& default_instance();

  void Swap(CommandMasterSetThumbnailTextArchive* other);

  // implements Message ----------------------------------------------

  CommandMasterSetThumbnailTextArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMasterSetThumbnailTextArchive& from);
  void MergeFrom(const CommandMasterSetThumbnailTextArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference master = 2;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 2;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // required bool is_body = 3;
  inline bool has_is_body() const;
  inline void clear_is_body();
  static const int kIsBodyFieldNumber = 3;
  inline bool is_body() const;
  inline void set_is_body(bool value);

  // optional string new_text = 4;
  inline bool has_new_text() const;
  inline void clear_new_text();
  static const int kNewTextFieldNumber = 4;
  inline const ::std::string& new_text() const;
  inline void set_new_text(const ::std::string& value);
  inline void set_new_text(const char* value);
  inline void set_new_text(const char* value, size_t size);
  inline ::std::string* mutable_new_text();
  inline ::std::string* release_new_text();
  inline void set_allocated_new_text(::std::string* new_text);

  // optional string old_text = 5;
  inline bool has_old_text() const;
  inline void clear_old_text();
  static const int kOldTextFieldNumber = 5;
  inline const ::std::string& old_text() const;
  inline void set_old_text(const ::std::string& value);
  inline void set_old_text(const char* value);
  inline void set_old_text(const char* value, size_t size);
  inline ::std::string* mutable_old_text();
  inline ::std::string* release_old_text();
  inline void set_allocated_old_text(::std::string* old_text);

  // @@protoc_insertion_point(class_scope:KN.CommandMasterSetThumbnailTextArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_is_body();
  inline void clear_has_is_body();
  inline void set_has_new_text();
  inline void clear_has_new_text();
  inline void set_has_old_text();
  inline void clear_has_old_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* master_;
  ::std::string* new_text_;
  ::std::string* old_text_;
  bool is_body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMasterSetThumbnailTextArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMasterSetBodyStylesArchive : public ::google::protobuf::Message {
 public:
  CommandMasterSetBodyStylesArchive();
  virtual ~CommandMasterSetBodyStylesArchive();

  CommandMasterSetBodyStylesArchive(const CommandMasterSetBodyStylesArchive& from);

  inline CommandMasterSetBodyStylesArchive& operator=(const CommandMasterSetBodyStylesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMasterSetBodyStylesArchive& default_instance();

  void Swap(CommandMasterSetBodyStylesArchive* other);

  // implements Message ----------------------------------------------

  CommandMasterSetBodyStylesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMasterSetBodyStylesArchive& from);
  void MergeFrom(const CommandMasterSetBodyStylesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference master = 2;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 2;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // repeated .TSP.Reference new_paragraph_styles = 3;
  inline int new_paragraph_styles_size() const;
  inline void clear_new_paragraph_styles();
  static const int kNewParagraphStylesFieldNumber = 3;
  inline const ::TSP::Reference& new_paragraph_styles(int index) const;
  inline ::TSP::Reference* mutable_new_paragraph_styles(int index);
  inline ::TSP::Reference* add_new_paragraph_styles();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      new_paragraph_styles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_new_paragraph_styles();

  // repeated .TSP.Reference new_list_styles = 4;
  inline int new_list_styles_size() const;
  inline void clear_new_list_styles();
  static const int kNewListStylesFieldNumber = 4;
  inline const ::TSP::Reference& new_list_styles(int index) const;
  inline ::TSP::Reference* mutable_new_list_styles(int index);
  inline ::TSP::Reference* add_new_list_styles();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      new_list_styles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_new_list_styles();

  // repeated .TSP.Reference old_paragraph_styles = 5;
  inline int old_paragraph_styles_size() const;
  inline void clear_old_paragraph_styles();
  static const int kOldParagraphStylesFieldNumber = 5;
  inline const ::TSP::Reference& old_paragraph_styles(int index) const;
  inline ::TSP::Reference* mutable_old_paragraph_styles(int index);
  inline ::TSP::Reference* add_old_paragraph_styles();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_paragraph_styles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_paragraph_styles();

  // repeated .TSP.Reference old_list_styles = 6;
  inline int old_list_styles_size() const;
  inline void clear_old_list_styles();
  static const int kOldListStylesFieldNumber = 6;
  inline const ::TSP::Reference& old_list_styles(int index) const;
  inline ::TSP::Reference* mutable_old_list_styles(int index);
  inline ::TSP::Reference* add_old_list_styles();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_list_styles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_list_styles();

  // @@protoc_insertion_point(class_scope:KN.CommandMasterSetBodyStylesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_master();
  inline void clear_has_master();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* master_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > new_paragraph_styles_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > new_list_styles_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_paragraph_styles_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_list_styles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMasterSetBodyStylesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideApplyThemeArchive : public ::google::protobuf::Message {
 public:
  CommandSlideApplyThemeArchive();
  virtual ~CommandSlideApplyThemeArchive();

  CommandSlideApplyThemeArchive(const CommandSlideApplyThemeArchive& from);

  inline CommandSlideApplyThemeArchive& operator=(const CommandSlideApplyThemeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideApplyThemeArchive& default_instance();

  void Swap(CommandSlideApplyThemeArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideApplyThemeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideApplyThemeArchive& from);
  void MergeFrom(const CommandSlideApplyThemeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.ApplyThemeChildCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::ApplyThemeChildCommandArchive& super() const;
  inline ::TSS::ApplyThemeChildCommandArchive* mutable_super();
  inline ::TSS::ApplyThemeChildCommandArchive* release_super();
  inline void set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super);

  // required .KN.MasterChangeBlobArchive blob = 2;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 2;
  inline const ::KN::MasterChangeBlobArchive& blob() const;
  inline ::KN::MasterChangeBlobArchive* mutable_blob();
  inline ::KN::MasterChangeBlobArchive* release_blob();
  inline void set_allocated_blob(::KN::MasterChangeBlobArchive* blob);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideApplyThemeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_blob();
  inline void clear_has_blob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::ApplyThemeChildCommandArchive* super_;
  ::KN::MasterChangeBlobArchive* blob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideApplyThemeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandChangeMasterSlideArchive : public ::google::protobuf::Message {
 public:
  CommandChangeMasterSlideArchive();
  virtual ~CommandChangeMasterSlideArchive();

  CommandChangeMasterSlideArchive(const CommandChangeMasterSlideArchive& from);

  inline CommandChangeMasterSlideArchive& operator=(const CommandChangeMasterSlideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandChangeMasterSlideArchive& default_instance();

  void Swap(CommandChangeMasterSlideArchive* other);

  // implements Message ----------------------------------------------

  CommandChangeMasterSlideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandChangeMasterSlideArchive& from);
  void MergeFrom(const CommandChangeMasterSlideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required .TSP.Reference master = 3;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 3;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // required .TSP.Reference placeholder_commands = 4;
  inline bool has_placeholder_commands() const;
  inline void clear_placeholder_commands();
  static const int kPlaceholderCommandsFieldNumber = 4;
  inline const ::TSP::Reference& placeholder_commands() const;
  inline ::TSP::Reference* mutable_placeholder_commands();
  inline ::TSP::Reference* release_placeholder_commands();
  inline void set_allocated_placeholder_commands(::TSP::Reference* placeholder_commands);

  // @@protoc_insertion_point(class_scope:KN.CommandChangeMasterSlideArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_placeholder_commands();
  inline void clear_has_placeholder_commands();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::TSP::Reference* master_;
  ::TSP::Reference* placeholder_commands_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandChangeMasterSlideArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlidePrimitiveSetMasterArchive : public ::google::protobuf::Message {
 public:
  CommandSlidePrimitiveSetMasterArchive();
  virtual ~CommandSlidePrimitiveSetMasterArchive();

  CommandSlidePrimitiveSetMasterArchive(const CommandSlidePrimitiveSetMasterArchive& from);

  inline CommandSlidePrimitiveSetMasterArchive& operator=(const CommandSlidePrimitiveSetMasterArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlidePrimitiveSetMasterArchive& default_instance();

  void Swap(CommandSlidePrimitiveSetMasterArchive* other);

  // implements Message ----------------------------------------------

  CommandSlidePrimitiveSetMasterArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlidePrimitiveSetMasterArchive& from);
  void MergeFrom(const CommandSlidePrimitiveSetMasterArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // required .TSP.Reference master = 3;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 3;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // required .TSP.Reference old_master = 4;
  inline bool has_old_master() const;
  inline void clear_old_master();
  static const int kOldMasterFieldNumber = 4;
  inline const ::TSP::Reference& old_master() const;
  inline ::TSP::Reference* mutable_old_master();
  inline ::TSP::Reference* release_old_master();
  inline void set_allocated_old_master(::TSP::Reference* old_master);

  // @@protoc_insertion_point(class_scope:KN.CommandSlidePrimitiveSetMasterArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_old_master();
  inline void clear_has_old_master();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* slide_;
  ::TSP::Reference* master_;
  ::TSP::Reference* old_master_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlidePrimitiveSetMasterArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSlideReapplyMasterArchive : public ::google::protobuf::Message {
 public:
  CommandSlideReapplyMasterArchive();
  virtual ~CommandSlideReapplyMasterArchive();

  CommandSlideReapplyMasterArchive(const CommandSlideReapplyMasterArchive& from);

  inline CommandSlideReapplyMasterArchive& operator=(const CommandSlideReapplyMasterArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSlideReapplyMasterArchive& default_instance();

  void Swap(CommandSlideReapplyMasterArchive* other);

  // implements Message ----------------------------------------------

  CommandSlideReapplyMasterArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSlideReapplyMasterArchive& from);
  void MergeFrom(const CommandSlideReapplyMasterArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference reapply_accumulated_command = 2;
  inline bool has_reapply_accumulated_command() const;
  inline void clear_reapply_accumulated_command();
  static const int kReapplyAccumulatedCommandFieldNumber = 2;
  inline const ::TSP::Reference& reapply_accumulated_command() const;
  inline ::TSP::Reference* mutable_reapply_accumulated_command();
  inline ::TSP::Reference* release_reapply_accumulated_command();
  inline void set_allocated_reapply_accumulated_command(::TSP::Reference* reapply_accumulated_command);

  // @@protoc_insertion_point(class_scope:KN.CommandSlideReapplyMasterArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_reapply_accumulated_command();
  inline void clear_has_reapply_accumulated_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* reapply_accumulated_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSlideReapplyMasterArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandShowSetSoundtrack : public ::google::protobuf::Message {
 public:
  CommandShowSetSoundtrack();
  virtual ~CommandShowSetSoundtrack();

  CommandShowSetSoundtrack(const CommandShowSetSoundtrack& from);

  inline CommandShowSetSoundtrack& operator=(const CommandShowSetSoundtrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandShowSetSoundtrack& default_instance();

  void Swap(CommandShowSetSoundtrack* other);

  // implements Message ----------------------------------------------

  CommandShowSetSoundtrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandShowSetSoundtrack& from);
  void MergeFrom(const CommandShowSetSoundtrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // optional .TSP.Reference soundtrack = 3;
  inline bool has_soundtrack() const;
  inline void clear_soundtrack();
  static const int kSoundtrackFieldNumber = 3;
  inline const ::TSP::Reference& soundtrack() const;
  inline ::TSP::Reference* mutable_soundtrack();
  inline ::TSP::Reference* release_soundtrack();
  inline void set_allocated_soundtrack(::TSP::Reference* soundtrack);

  // optional .TSP.Reference old_soundtrack = 4;
  inline bool has_old_soundtrack() const;
  inline void clear_old_soundtrack();
  static const int kOldSoundtrackFieldNumber = 4;
  inline const ::TSP::Reference& old_soundtrack() const;
  inline ::TSP::Reference* mutable_old_soundtrack();
  inline ::TSP::Reference* release_old_soundtrack();
  inline void set_allocated_old_soundtrack(::TSP::Reference* old_soundtrack);

  // @@protoc_insertion_point(class_scope:KN.CommandShowSetSoundtrack)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_soundtrack();
  inline void clear_has_soundtrack();
  inline void set_has_old_soundtrack();
  inline void clear_has_old_soundtrack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* soundtrack_;
  ::TSP::Reference* old_soundtrack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandShowSetSoundtrack* default_instance_;
};
// -------------------------------------------------------------------

class CommandSoundtrackSetValue_PropertyValue : public ::google::protobuf::Message {
 public:
  CommandSoundtrackSetValue_PropertyValue();
  virtual ~CommandSoundtrackSetValue_PropertyValue();

  CommandSoundtrackSetValue_PropertyValue(const CommandSoundtrackSetValue_PropertyValue& from);

  inline CommandSoundtrackSetValue_PropertyValue& operator=(const CommandSoundtrackSetValue_PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSoundtrackSetValue_PropertyValue& default_instance();

  void Swap(CommandSoundtrackSetValue_PropertyValue* other);

  // implements Message ----------------------------------------------

  CommandSoundtrackSetValue_PropertyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSoundtrackSetValue_PropertyValue& from);
  void MergeFrom(const CommandSoundtrackSetValue_PropertyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double double_value = 1;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 1;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional .KN.Soundtrack.SoundtrackMode mode_value = 2;
  inline bool has_mode_value() const;
  inline void clear_mode_value();
  static const int kModeValueFieldNumber = 2;
  inline ::KN::Soundtrack_SoundtrackMode mode_value() const;
  inline void set_mode_value(::KN::Soundtrack_SoundtrackMode value);

  // repeated .TSP.DataReference media_reference_values = 3;
  inline int media_reference_values_size() const;
  inline void clear_media_reference_values();
  static const int kMediaReferenceValuesFieldNumber = 3;
  inline const ::TSP::DataReference& media_reference_values(int index) const;
  inline ::TSP::DataReference* mutable_media_reference_values(int index);
  inline ::TSP::DataReference* add_media_reference_values();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >&
      media_reference_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >*
      mutable_media_reference_values();

  // @@protoc_insertion_point(class_scope:KN.CommandSoundtrackSetValue.PropertyValue)
 private:
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_mode_value();
  inline void clear_has_mode_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double double_value_;
  ::google::protobuf::RepeatedPtrField< ::TSP::DataReference > media_reference_values_;
  int mode_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSoundtrackSetValue_PropertyValue* default_instance_;
};
// -------------------------------------------------------------------

class CommandSoundtrackSetValue : public ::google::protobuf::Message {
 public:
  CommandSoundtrackSetValue();
  virtual ~CommandSoundtrackSetValue();

  CommandSoundtrackSetValue(const CommandSoundtrackSetValue& from);

  inline CommandSoundtrackSetValue& operator=(const CommandSoundtrackSetValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSoundtrackSetValue& default_instance();

  void Swap(CommandSoundtrackSetValue* other);

  // implements Message ----------------------------------------------

  CommandSoundtrackSetValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSoundtrackSetValue& from);
  void MergeFrom(const CommandSoundtrackSetValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandSoundtrackSetValue_PropertyValue PropertyValue;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference soundtrack = 2;
  inline bool has_soundtrack() const;
  inline void clear_soundtrack();
  static const int kSoundtrackFieldNumber = 2;
  inline const ::TSP::Reference& soundtrack() const;
  inline ::TSP::Reference* mutable_soundtrack();
  inline ::TSP::Reference* release_soundtrack();
  inline void set_allocated_soundtrack(::TSP::Reference* soundtrack);

  // optional string property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // optional .KN.CommandSoundtrackSetValue.PropertyValue old_value = 4;
  inline bool has_old_value() const;
  inline void clear_old_value();
  static const int kOldValueFieldNumber = 4;
  inline const ::KN::CommandSoundtrackSetValue_PropertyValue& old_value() const;
  inline ::KN::CommandSoundtrackSetValue_PropertyValue* mutable_old_value();
  inline ::KN::CommandSoundtrackSetValue_PropertyValue* release_old_value();
  inline void set_allocated_old_value(::KN::CommandSoundtrackSetValue_PropertyValue* old_value);

  // optional .KN.CommandSoundtrackSetValue.PropertyValue new_value = 5;
  inline bool has_new_value() const;
  inline void clear_new_value();
  static const int kNewValueFieldNumber = 5;
  inline const ::KN::CommandSoundtrackSetValue_PropertyValue& new_value() const;
  inline ::KN::CommandSoundtrackSetValue_PropertyValue* mutable_new_value();
  inline ::KN::CommandSoundtrackSetValue_PropertyValue* release_new_value();
  inline void set_allocated_new_value(::KN::CommandSoundtrackSetValue_PropertyValue* new_value);

  // @@protoc_insertion_point(class_scope:KN.CommandSoundtrackSetValue)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_soundtrack();
  inline void clear_has_soundtrack();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_old_value();
  inline void clear_has_old_value();
  inline void set_has_new_value();
  inline void clear_has_new_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* soundtrack_;
  ::std::string* property_;
  ::KN::CommandSoundtrackSetValue_PropertyValue* old_value_;
  ::KN::CommandSoundtrackSetValue_PropertyValue* new_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSoundtrackSetValue* default_instance_;
};
// -------------------------------------------------------------------

class SlideCollectionCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  SlideCollectionCommandSelectionBehaviorArchive();
  virtual ~SlideCollectionCommandSelectionBehaviorArchive();

  SlideCollectionCommandSelectionBehaviorArchive(const SlideCollectionCommandSelectionBehaviorArchive& from);

  inline SlideCollectionCommandSelectionBehaviorArchive& operator=(const SlideCollectionCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideCollectionCommandSelectionBehaviorArchive& default_instance();

  void Swap(SlideCollectionCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  SlideCollectionCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideCollectionCommandSelectionBehaviorArchive& from);
  void MergeFrom(const SlideCollectionCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlideCollectionCommandSelectionBehaviorArchive_Type Type;
  static const Type kKindSlideSelectionBehaviorTypeGeneral = SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeGeneral;
  static const Type kKindSlideSelectionBehaviorTypeInsertion = SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeInsertion;
  static const Type kKindSlideSelectionBehaviorTypeDeletion = SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeDeletion;
  static const Type kKindSlideSelectionBehaviorTypeMove = SlideCollectionCommandSelectionBehaviorArchive_Type_kKindSlideSelectionBehaviorTypeMove;
  static inline bool Type_IsValid(int value) {
    return SlideCollectionCommandSelectionBehaviorArchive_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SlideCollectionCommandSelectionBehaviorArchive_Type_Type_MIN;
  static const Type Type_MAX =
    SlideCollectionCommandSelectionBehaviorArchive_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SlideCollectionCommandSelectionBehaviorArchive_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SlideCollectionCommandSelectionBehaviorArchive_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SlideCollectionCommandSelectionBehaviorArchive_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SlideCollectionCommandSelectionBehaviorArchive_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Reference archived_new_selection = 1;
  inline bool has_archived_new_selection() const;
  inline void clear_archived_new_selection();
  static const int kArchivedNewSelectionFieldNumber = 1;
  inline const ::TSP::Reference& archived_new_selection() const;
  inline ::TSP::Reference* mutable_archived_new_selection();
  inline ::TSP::Reference* release_archived_new_selection();
  inline void set_allocated_archived_new_selection(::TSP::Reference* archived_new_selection);

  // optional .TSP.Reference archived_old_selection = 2;
  inline bool has_archived_old_selection() const;
  inline void clear_archived_old_selection();
  static const int kArchivedOldSelectionFieldNumber = 2;
  inline const ::TSP::Reference& archived_old_selection() const;
  inline ::TSP::Reference* mutable_archived_old_selection();
  inline ::TSP::Reference* release_archived_old_selection();
  inline void set_allocated_archived_old_selection(::TSP::Reference* archived_old_selection);

  // optional .KN.SlideCollectionCommandSelectionBehaviorArchive.Type type = 3 [default = kKindSlideSelectionBehaviorTypeGeneral];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::KN::SlideCollectionCommandSelectionBehaviorArchive_Type type() const;
  inline void set_type(::KN::SlideCollectionCommandSelectionBehaviorArchive_Type value);

  // @@protoc_insertion_point(class_scope:KN.SlideCollectionCommandSelectionBehaviorArchive)
 private:
  inline void set_has_archived_new_selection();
  inline void clear_has_archived_new_selection();
  inline void set_has_archived_old_selection();
  inline void clear_has_archived_old_selection();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* archived_new_selection_;
  ::TSP::Reference* archived_old_selection_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideCollectionCommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartInfoGeometryCommandArchive : public ::google::protobuf::Message {
 public:
  ChartInfoGeometryCommandArchive();
  virtual ~ChartInfoGeometryCommandArchive();

  ChartInfoGeometryCommandArchive(const ChartInfoGeometryCommandArchive& from);

  inline ChartInfoGeometryCommandArchive& operator=(const ChartInfoGeometryCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartInfoGeometryCommandArchive& default_instance();

  void Swap(ChartInfoGeometryCommandArchive* other);

  // implements Message ----------------------------------------------

  ChartInfoGeometryCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartInfoGeometryCommandArchive& from);
  void MergeFrom(const ChartInfoGeometryCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:KN.ChartInfoGeometryCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_KNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_KNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChartInfoGeometryCommandArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// UIStateCommandGroupArchive

// required .TSK.CommandGroupArchive super = 1;
inline bool UIStateCommandGroupArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIStateCommandGroupArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIStateCommandGroupArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIStateCommandGroupArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandGroupArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandGroupArchive& UIStateCommandGroupArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandGroupArchive* UIStateCommandGroupArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandGroupArchive;
  return super_;
}
inline ::TSK::CommandGroupArchive* UIStateCommandGroupArchive::release_super() {
  clear_has_super();
  ::TSK::CommandGroupArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void UIStateCommandGroupArchive::set_allocated_super(::TSK::CommandGroupArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference uiState = 2;
inline bool UIStateCommandGroupArchive::has_uistate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIStateCommandGroupArchive::set_has_uistate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIStateCommandGroupArchive::clear_has_uistate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIStateCommandGroupArchive::clear_uistate() {
  if (uistate_ != NULL) uistate_->::TSP::Reference::Clear();
  clear_has_uistate();
}
inline const ::TSP::Reference& UIStateCommandGroupArchive::uistate() const {
  return uistate_ != NULL ? *uistate_ : *default_instance_->uistate_;
}
inline ::TSP::Reference* UIStateCommandGroupArchive::mutable_uistate() {
  set_has_uistate();
  if (uistate_ == NULL) uistate_ = new ::TSP::Reference;
  return uistate_;
}
inline ::TSP::Reference* UIStateCommandGroupArchive::release_uistate() {
  clear_has_uistate();
  ::TSP::Reference* temp = uistate_;
  uistate_ = NULL;
  return temp;
}
inline void UIStateCommandGroupArchive::set_allocated_uistate(::TSP::Reference* uistate) {
  delete uistate_;
  uistate_ = uistate;
  if (uistate) {
    set_has_uistate();
  } else {
    clear_has_uistate();
  }
}

// required string property = 3;
inline bool UIStateCommandGroupArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIStateCommandGroupArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIStateCommandGroupArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIStateCommandGroupArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& UIStateCommandGroupArchive::property() const {
  return *property_;
}
inline void UIStateCommandGroupArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void UIStateCommandGroupArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void UIStateCommandGroupArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIStateCommandGroupArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* UIStateCommandGroupArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIStateCommandGroupArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TSP.Reference slideNodesToEdit = 4;
inline int UIStateCommandGroupArchive::slidenodestoedit_size() const {
  return slidenodestoedit_.size();
}
inline void UIStateCommandGroupArchive::clear_slidenodestoedit() {
  slidenodestoedit_.Clear();
}
inline const ::TSP::Reference& UIStateCommandGroupArchive::slidenodestoedit(int index) const {
  return slidenodestoedit_.Get(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::mutable_slidenodestoedit(int index) {
  return slidenodestoedit_.Mutable(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::add_slidenodestoedit() {
  return slidenodestoedit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UIStateCommandGroupArchive::slidenodestoedit() const {
  return slidenodestoedit_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UIStateCommandGroupArchive::mutable_slidenodestoedit() {
  return &slidenodestoedit_;
}

// repeated .TSP.Reference masterSlideNodesToApply = 5;
inline int UIStateCommandGroupArchive::masterslidenodestoapply_size() const {
  return masterslidenodestoapply_.size();
}
inline void UIStateCommandGroupArchive::clear_masterslidenodestoapply() {
  masterslidenodestoapply_.Clear();
}
inline const ::TSP::Reference& UIStateCommandGroupArchive::masterslidenodestoapply(int index) const {
  return masterslidenodestoapply_.Get(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::mutable_masterslidenodestoapply(int index) {
  return masterslidenodestoapply_.Mutable(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::add_masterslidenodestoapply() {
  return masterslidenodestoapply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UIStateCommandGroupArchive::masterslidenodestoapply() const {
  return masterslidenodestoapply_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UIStateCommandGroupArchive::mutable_masterslidenodestoapply() {
  return &masterslidenodestoapply_;
}

// repeated .TSP.Size thumbnailSizes = 6;
inline int UIStateCommandGroupArchive::thumbnailsizes_size() const {
  return thumbnailsizes_.size();
}
inline void UIStateCommandGroupArchive::clear_thumbnailsizes() {
  thumbnailsizes_.Clear();
}
inline const ::TSP::Size& UIStateCommandGroupArchive::thumbnailsizes(int index) const {
  return thumbnailsizes_.Get(index);
}
inline ::TSP::Size* UIStateCommandGroupArchive::mutable_thumbnailsizes(int index) {
  return thumbnailsizes_.Mutable(index);
}
inline ::TSP::Size* UIStateCommandGroupArchive::add_thumbnailsizes() {
  return thumbnailsizes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Size >&
UIStateCommandGroupArchive::thumbnailsizes() const {
  return thumbnailsizes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Size >*
UIStateCommandGroupArchive::mutable_thumbnailsizes() {
  return &thumbnailsizes_;
}

// repeated .TSP.Reference selectedSlideNodes = 7;
inline int UIStateCommandGroupArchive::selectedslidenodes_size() const {
  return selectedslidenodes_.size();
}
inline void UIStateCommandGroupArchive::clear_selectedslidenodes() {
  selectedslidenodes_.Clear();
}
inline const ::TSP::Reference& UIStateCommandGroupArchive::selectedslidenodes(int index) const {
  return selectedslidenodes_.Get(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::mutable_selectedslidenodes(int index) {
  return selectedslidenodes_.Mutable(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::add_selectedslidenodes() {
  return selectedslidenodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UIStateCommandGroupArchive::selectedslidenodes() const {
  return selectedslidenodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UIStateCommandGroupArchive::mutable_selectedslidenodes() {
  return &selectedslidenodes_;
}

// repeated .TSP.Reference restoreSelectedSlideNodes = 8;
inline int UIStateCommandGroupArchive::restoreselectedslidenodes_size() const {
  return restoreselectedslidenodes_.size();
}
inline void UIStateCommandGroupArchive::clear_restoreselectedslidenodes() {
  restoreselectedslidenodes_.Clear();
}
inline const ::TSP::Reference& UIStateCommandGroupArchive::restoreselectedslidenodes(int index) const {
  return restoreselectedslidenodes_.Get(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::mutable_restoreselectedslidenodes(int index) {
  return restoreselectedslidenodes_.Mutable(index);
}
inline ::TSP::Reference* UIStateCommandGroupArchive::add_restoreselectedslidenodes() {
  return restoreselectedslidenodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UIStateCommandGroupArchive::restoreselectedslidenodes() const {
  return restoreselectedslidenodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UIStateCommandGroupArchive::mutable_restoreselectedslidenodes() {
  return &restoreselectedslidenodes_;
}

// -------------------------------------------------------------------

// CommandSlideInsertDrawablesArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideInsertDrawablesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideInsertDrawablesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideInsertDrawablesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideInsertDrawablesArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideInsertDrawablesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideInsertDrawablesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideInsertDrawablesArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideInsertDrawablesArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideInsertDrawablesArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideInsertDrawablesArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideInsertDrawablesArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideInsertDrawablesArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideInsertDrawablesArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideInsertDrawablesArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideInsertDrawablesArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideInsertDrawablesArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// repeated .TSP.Reference drawables = 3;
inline int CommandSlideInsertDrawablesArchive::drawables_size() const {
  return drawables_.size();
}
inline void CommandSlideInsertDrawablesArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& CommandSlideInsertDrawablesArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* CommandSlideInsertDrawablesArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideInsertDrawablesArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideInsertDrawablesArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideInsertDrawablesArchive::mutable_drawables() {
  return &drawables_;
}

// optional bool forDrag = 4;
inline bool CommandSlideInsertDrawablesArchive::has_fordrag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideInsertDrawablesArchive::set_has_fordrag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideInsertDrawablesArchive::clear_has_fordrag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideInsertDrawablesArchive::clear_fordrag() {
  fordrag_ = false;
  clear_has_fordrag();
}
inline bool CommandSlideInsertDrawablesArchive::fordrag() const {
  return fordrag_;
}
inline void CommandSlideInsertDrawablesArchive::set_fordrag(bool value) {
  set_has_fordrag();
  fordrag_ = value;
}

// optional int32 atIndex = 5;
inline bool CommandSlideInsertDrawablesArchive::has_atindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSlideInsertDrawablesArchive::set_has_atindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSlideInsertDrawablesArchive::clear_has_atindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSlideInsertDrawablesArchive::clear_atindex() {
  atindex_ = 0;
  clear_has_atindex();
}
inline ::google::protobuf::int32 CommandSlideInsertDrawablesArchive::atindex() const {
  return atindex_;
}
inline void CommandSlideInsertDrawablesArchive::set_atindex(::google::protobuf::int32 value) {
  set_has_atindex();
  atindex_ = value;
}

// required bool use_object_placeholder_geometry = 6;
inline bool CommandSlideInsertDrawablesArchive::has_use_object_placeholder_geometry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSlideInsertDrawablesArchive::set_has_use_object_placeholder_geometry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSlideInsertDrawablesArchive::clear_has_use_object_placeholder_geometry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSlideInsertDrawablesArchive::clear_use_object_placeholder_geometry() {
  use_object_placeholder_geometry_ = false;
  clear_has_use_object_placeholder_geometry();
}
inline bool CommandSlideInsertDrawablesArchive::use_object_placeholder_geometry() const {
  return use_object_placeholder_geometry_;
}
inline void CommandSlideInsertDrawablesArchive::set_use_object_placeholder_geometry(bool value) {
  set_has_use_object_placeholder_geometry();
  use_object_placeholder_geometry_ = value;
}

// -------------------------------------------------------------------

// CommandSlideSetPlaceholdersForTagsArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideSetPlaceholdersForTagsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideSetPlaceholdersForTagsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideSetPlaceholdersForTagsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideSetPlaceholdersForTagsArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlideSetPlaceholdersForTagsArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlideSetPlaceholdersForTagsArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlideSetPlaceholdersForTagsArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlideSetPlaceholdersForTagsArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// repeated .TSP.Reference infos = 3;
inline int CommandSlideSetPlaceholdersForTagsArchive::infos_size() const {
  return infos_.size();
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_infos() {
  infos_.Clear();
}
inline const ::TSP::Reference& CommandSlideSetPlaceholdersForTagsArchive::infos(int index) const {
  return infos_.Get(index);
}
inline ::TSP::Reference* CommandSlideSetPlaceholdersForTagsArchive::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideSetPlaceholdersForTagsArchive::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideSetPlaceholdersForTagsArchive::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideSetPlaceholdersForTagsArchive::mutable_infos() {
  return &infos_;
}

// repeated string tags = 4;
inline int CommandSlideSetPlaceholdersForTagsArchive::tags_size() const {
  return tags_.size();
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CommandSlideSetPlaceholdersForTagsArchive::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CommandSlideSetPlaceholdersForTagsArchive::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSlideSetPlaceholdersForTagsArchive::add_tags() {
  return tags_.Add();
}
inline void CommandSlideSetPlaceholdersForTagsArchive::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandSlideSetPlaceholdersForTagsArchive::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandSlideSetPlaceholdersForTagsArchive::mutable_tags() {
  return &tags_;
}

// repeated .TSP.Reference old_infos = 6;
inline int CommandSlideSetPlaceholdersForTagsArchive::old_infos_size() const {
  return old_infos_.size();
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_old_infos() {
  old_infos_.Clear();
}
inline const ::TSP::Reference& CommandSlideSetPlaceholdersForTagsArchive::old_infos(int index) const {
  return old_infos_.Get(index);
}
inline ::TSP::Reference* CommandSlideSetPlaceholdersForTagsArchive::mutable_old_infos(int index) {
  return old_infos_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideSetPlaceholdersForTagsArchive::add_old_infos() {
  return old_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideSetPlaceholdersForTagsArchive::old_infos() const {
  return old_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideSetPlaceholdersForTagsArchive::mutable_old_infos() {
  return &old_infos_;
}

// repeated string old_tags = 5;
inline int CommandSlideSetPlaceholdersForTagsArchive::old_tags_size() const {
  return old_tags_.size();
}
inline void CommandSlideSetPlaceholdersForTagsArchive::clear_old_tags() {
  old_tags_.Clear();
}
inline const ::std::string& CommandSlideSetPlaceholdersForTagsArchive::old_tags(int index) const {
  return old_tags_.Get(index);
}
inline ::std::string* CommandSlideSetPlaceholdersForTagsArchive::mutable_old_tags(int index) {
  return old_tags_.Mutable(index);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_old_tags(int index, const ::std::string& value) {
  old_tags_.Mutable(index)->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_old_tags(int index, const char* value) {
  old_tags_.Mutable(index)->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::set_old_tags(int index, const char* value, size_t size) {
  old_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSlideSetPlaceholdersForTagsArchive::add_old_tags() {
  return old_tags_.Add();
}
inline void CommandSlideSetPlaceholdersForTagsArchive::add_old_tags(const ::std::string& value) {
  old_tags_.Add()->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::add_old_tags(const char* value) {
  old_tags_.Add()->assign(value);
}
inline void CommandSlideSetPlaceholdersForTagsArchive::add_old_tags(const char* value, size_t size) {
  old_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandSlideSetPlaceholdersForTagsArchive::old_tags() const {
  return old_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandSlideSetPlaceholdersForTagsArchive::mutable_old_tags() {
  return &old_tags_;
}

// -------------------------------------------------------------------

// CommandSlideRemoveDrawableArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideRemoveDrawableArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideRemoveDrawableArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideRemoveDrawableArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideRemoveDrawableArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideRemoveDrawableArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideRemoveDrawableArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideRemoveDrawableArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideRemoveDrawableArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideRemoveDrawableArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideRemoveDrawableArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideRemoveDrawableArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideRemoveDrawableArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideRemoveDrawableArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideRemoveDrawableArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideRemoveDrawableArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideRemoveDrawableArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// repeated .TSP.Reference sortedDrawables = 3;
inline int CommandSlideRemoveDrawableArchive::sorteddrawables_size() const {
  return sorteddrawables_.size();
}
inline void CommandSlideRemoveDrawableArchive::clear_sorteddrawables() {
  sorteddrawables_.Clear();
}
inline const ::TSP::Reference& CommandSlideRemoveDrawableArchive::sorteddrawables(int index) const {
  return sorteddrawables_.Get(index);
}
inline ::TSP::Reference* CommandSlideRemoveDrawableArchive::mutable_sorteddrawables(int index) {
  return sorteddrawables_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideRemoveDrawableArchive::add_sorteddrawables() {
  return sorteddrawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideRemoveDrawableArchive::sorteddrawables() const {
  return sorteddrawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideRemoveDrawableArchive::mutable_sorteddrawables() {
  return &sorteddrawables_;
}

// required .TSP.IndexSet drawableIndices = 4;
inline bool CommandSlideRemoveDrawableArchive::has_drawableindices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideRemoveDrawableArchive::set_has_drawableindices() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideRemoveDrawableArchive::clear_has_drawableindices() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideRemoveDrawableArchive::clear_drawableindices() {
  if (drawableindices_ != NULL) drawableindices_->::TSP::IndexSet::Clear();
  clear_has_drawableindices();
}
inline const ::TSP::IndexSet& CommandSlideRemoveDrawableArchive::drawableindices() const {
  return drawableindices_ != NULL ? *drawableindices_ : *default_instance_->drawableindices_;
}
inline ::TSP::IndexSet* CommandSlideRemoveDrawableArchive::mutable_drawableindices() {
  set_has_drawableindices();
  if (drawableindices_ == NULL) drawableindices_ = new ::TSP::IndexSet;
  return drawableindices_;
}
inline ::TSP::IndexSet* CommandSlideRemoveDrawableArchive::release_drawableindices() {
  clear_has_drawableindices();
  ::TSP::IndexSet* temp = drawableindices_;
  drawableindices_ = NULL;
  return temp;
}
inline void CommandSlideRemoveDrawableArchive::set_allocated_drawableindices(::TSP::IndexSet* drawableindices) {
  delete drawableindices_;
  drawableindices_ = drawableindices;
  if (drawableindices) {
    set_has_drawableindices();
  } else {
    clear_has_drawableindices();
  }
}

// repeated string placeholderTags = 5;
inline int CommandSlideRemoveDrawableArchive::placeholdertags_size() const {
  return placeholdertags_.size();
}
inline void CommandSlideRemoveDrawableArchive::clear_placeholdertags() {
  placeholdertags_.Clear();
}
inline const ::std::string& CommandSlideRemoveDrawableArchive::placeholdertags(int index) const {
  return placeholdertags_.Get(index);
}
inline ::std::string* CommandSlideRemoveDrawableArchive::mutable_placeholdertags(int index) {
  return placeholdertags_.Mutable(index);
}
inline void CommandSlideRemoveDrawableArchive::set_placeholdertags(int index, const ::std::string& value) {
  placeholdertags_.Mutable(index)->assign(value);
}
inline void CommandSlideRemoveDrawableArchive::set_placeholdertags(int index, const char* value) {
  placeholdertags_.Mutable(index)->assign(value);
}
inline void CommandSlideRemoveDrawableArchive::set_placeholdertags(int index, const char* value, size_t size) {
  placeholdertags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSlideRemoveDrawableArchive::add_placeholdertags() {
  return placeholdertags_.Add();
}
inline void CommandSlideRemoveDrawableArchive::add_placeholdertags(const ::std::string& value) {
  placeholdertags_.Add()->assign(value);
}
inline void CommandSlideRemoveDrawableArchive::add_placeholdertags(const char* value) {
  placeholdertags_.Add()->assign(value);
}
inline void CommandSlideRemoveDrawableArchive::add_placeholdertags(const char* value, size_t size) {
  placeholdertags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandSlideRemoveDrawableArchive::placeholdertags() const {
  return placeholdertags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandSlideRemoveDrawableArchive::mutable_placeholdertags() {
  return &placeholdertags_;
}

// optional .TSP.Reference info_using_object_placeholder_geometry = 6;
inline bool CommandSlideRemoveDrawableArchive::has_info_using_object_placeholder_geometry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSlideRemoveDrawableArchive::set_has_info_using_object_placeholder_geometry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSlideRemoveDrawableArchive::clear_has_info_using_object_placeholder_geometry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSlideRemoveDrawableArchive::clear_info_using_object_placeholder_geometry() {
  if (info_using_object_placeholder_geometry_ != NULL) info_using_object_placeholder_geometry_->::TSP::Reference::Clear();
  clear_has_info_using_object_placeholder_geometry();
}
inline const ::TSP::Reference& CommandSlideRemoveDrawableArchive::info_using_object_placeholder_geometry() const {
  return info_using_object_placeholder_geometry_ != NULL ? *info_using_object_placeholder_geometry_ : *default_instance_->info_using_object_placeholder_geometry_;
}
inline ::TSP::Reference* CommandSlideRemoveDrawableArchive::mutable_info_using_object_placeholder_geometry() {
  set_has_info_using_object_placeholder_geometry();
  if (info_using_object_placeholder_geometry_ == NULL) info_using_object_placeholder_geometry_ = new ::TSP::Reference;
  return info_using_object_placeholder_geometry_;
}
inline ::TSP::Reference* CommandSlideRemoveDrawableArchive::release_info_using_object_placeholder_geometry() {
  clear_has_info_using_object_placeholder_geometry();
  ::TSP::Reference* temp = info_using_object_placeholder_geometry_;
  info_using_object_placeholder_geometry_ = NULL;
  return temp;
}
inline void CommandSlideRemoveDrawableArchive::set_allocated_info_using_object_placeholder_geometry(::TSP::Reference* info_using_object_placeholder_geometry) {
  delete info_using_object_placeholder_geometry_;
  info_using_object_placeholder_geometry_ = info_using_object_placeholder_geometry;
  if (info_using_object_placeholder_geometry) {
    set_has_info_using_object_placeholder_geometry();
  } else {
    clear_has_info_using_object_placeholder_geometry();
  }
}

// optional bool did_match_object_placeholder_geometry = 7;
inline bool CommandSlideRemoveDrawableArchive::has_did_match_object_placeholder_geometry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandSlideRemoveDrawableArchive::set_has_did_match_object_placeholder_geometry() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandSlideRemoveDrawableArchive::clear_has_did_match_object_placeholder_geometry() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandSlideRemoveDrawableArchive::clear_did_match_object_placeholder_geometry() {
  did_match_object_placeholder_geometry_ = false;
  clear_has_did_match_object_placeholder_geometry();
}
inline bool CommandSlideRemoveDrawableArchive::did_match_object_placeholder_geometry() const {
  return did_match_object_placeholder_geometry_;
}
inline void CommandSlideRemoveDrawableArchive::set_did_match_object_placeholder_geometry(bool value) {
  set_has_did_match_object_placeholder_geometry();
  did_match_object_placeholder_geometry_ = value;
}

// -------------------------------------------------------------------

// CommandSlideMoveDrawableZOrderArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideMoveDrawableZOrderArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideMoveDrawableZOrderArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideMoveDrawableZOrderArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveDrawableZOrderArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveDrawableZOrderArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideMoveDrawableZOrderArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideMoveDrawableZOrderArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideMoveDrawableZOrderArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideMoveDrawableZOrderArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideMoveDrawableZOrderArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideMoveDrawableZOrderArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideMoveDrawableZOrderArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// repeated .TSP.Reference infos = 3;
inline int CommandSlideMoveDrawableZOrderArchive::infos_size() const {
  return infos_.size();
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_infos() {
  infos_.Clear();
}
inline const ::TSP::Reference& CommandSlideMoveDrawableZOrderArchive::infos(int index) const {
  return infos_.Get(index);
}
inline ::TSP::Reference* CommandSlideMoveDrawableZOrderArchive::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideMoveDrawableZOrderArchive::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideMoveDrawableZOrderArchive::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideMoveDrawableZOrderArchive::mutable_infos() {
  return &infos_;
}

// repeated .TSP.Reference old_ordered_infos = 4;
inline int CommandSlideMoveDrawableZOrderArchive::old_ordered_infos_size() const {
  return old_ordered_infos_.size();
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_old_ordered_infos() {
  old_ordered_infos_.Clear();
}
inline const ::TSP::Reference& CommandSlideMoveDrawableZOrderArchive::old_ordered_infos(int index) const {
  return old_ordered_infos_.Get(index);
}
inline ::TSP::Reference* CommandSlideMoveDrawableZOrderArchive::mutable_old_ordered_infos(int index) {
  return old_ordered_infos_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideMoveDrawableZOrderArchive::add_old_ordered_infos() {
  return old_ordered_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideMoveDrawableZOrderArchive::old_ordered_infos() const {
  return old_ordered_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideMoveDrawableZOrderArchive::mutable_old_ordered_infos() {
  return &old_ordered_infos_;
}

// required .TSP.IndexSet indexes = 5;
inline bool CommandSlideMoveDrawableZOrderArchive::has_indexes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSlideMoveDrawableZOrderArchive::set_has_indexes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_has_indexes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSlideMoveDrawableZOrderArchive::clear_indexes() {
  if (indexes_ != NULL) indexes_->::TSP::IndexSet::Clear();
  clear_has_indexes();
}
inline const ::TSP::IndexSet& CommandSlideMoveDrawableZOrderArchive::indexes() const {
  return indexes_ != NULL ? *indexes_ : *default_instance_->indexes_;
}
inline ::TSP::IndexSet* CommandSlideMoveDrawableZOrderArchive::mutable_indexes() {
  set_has_indexes();
  if (indexes_ == NULL) indexes_ = new ::TSP::IndexSet;
  return indexes_;
}
inline ::TSP::IndexSet* CommandSlideMoveDrawableZOrderArchive::release_indexes() {
  clear_has_indexes();
  ::TSP::IndexSet* temp = indexes_;
  indexes_ = NULL;
  return temp;
}
inline void CommandSlideMoveDrawableZOrderArchive::set_allocated_indexes(::TSP::IndexSet* indexes) {
  delete indexes_;
  indexes_ = indexes;
  if (indexes) {
    set_has_indexes();
  } else {
    clear_has_indexes();
  }
}

// -------------------------------------------------------------------

// CommandSlidePasteDrawablesArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlidePasteDrawablesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlidePasteDrawablesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlidePasteDrawablesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlidePasteDrawablesArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlidePasteDrawablesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlidePasteDrawablesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlidePasteDrawablesArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlidePasteDrawablesArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference commands = 2;
inline int CommandSlidePasteDrawablesArchive::commands_size() const {
  return commands_.size();
}
inline void CommandSlidePasteDrawablesArchive::clear_commands() {
  commands_.Clear();
}
inline const ::TSP::Reference& CommandSlidePasteDrawablesArchive::commands(int index) const {
  return commands_.Get(index);
}
inline ::TSP::Reference* CommandSlidePasteDrawablesArchive::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::TSP::Reference* CommandSlidePasteDrawablesArchive::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlidePasteDrawablesArchive::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlidePasteDrawablesArchive::mutable_commands() {
  return &commands_;
}

// required .TSP.Reference slide = 3;
inline bool CommandSlidePasteDrawablesArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlidePasteDrawablesArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlidePasteDrawablesArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlidePasteDrawablesArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlidePasteDrawablesArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlidePasteDrawablesArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlidePasteDrawablesArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlidePasteDrawablesArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// repeated .TSP.Reference drawables = 4;
inline int CommandSlidePasteDrawablesArchive::drawables_size() const {
  return drawables_.size();
}
inline void CommandSlidePasteDrawablesArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& CommandSlidePasteDrawablesArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* CommandSlidePasteDrawablesArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* CommandSlidePasteDrawablesArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlidePasteDrawablesArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlidePasteDrawablesArchive::mutable_drawables() {
  return &drawables_;
}

// optional bool has_builds = 5 [default = false];
inline bool CommandSlidePasteDrawablesArchive::has_has_builds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSlidePasteDrawablesArchive::set_has_has_builds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSlidePasteDrawablesArchive::clear_has_has_builds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSlidePasteDrawablesArchive::clear_has_builds() {
  has_builds_ = false;
  clear_has_has_builds();
}
inline bool CommandSlidePasteDrawablesArchive::has_builds() const {
  return has_builds_;
}
inline void CommandSlidePasteDrawablesArchive::set_has_builds(bool value) {
  set_has_has_builds();
  has_builds_ = value;
}

// -------------------------------------------------------------------

// CommandSlideNodeSetPropertyArchive_PropertyValue

// optional bool boolValue = 1;
inline bool CommandSlideNodeSetPropertyArchive_PropertyValue::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool CommandSlideNodeSetPropertyArchive_PropertyValue::boolvalue() const {
  return boolvalue_;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// optional .TSP.DataReference image = 3;
inline bool CommandSlideNodeSetPropertyArchive_PropertyValue::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::clear_image() {
  if (image_ != NULL) image_->::TSP::DataReference::Clear();
  clear_has_image();
}
inline const ::TSP::DataReference& CommandSlideNodeSetPropertyArchive_PropertyValue::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::TSP::DataReference* CommandSlideNodeSetPropertyArchive_PropertyValue::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::TSP::DataReference;
  return image_;
}
inline ::TSP::DataReference* CommandSlideNodeSetPropertyArchive_PropertyValue::release_image() {
  clear_has_image();
  ::TSP::DataReference* temp = image_;
  image_ = NULL;
  return temp;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::set_allocated_image(::TSP::DataReference* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// optional .TSP.Reference database_image = 2;
inline bool CommandSlideNodeSetPropertyArchive_PropertyValue::has_database_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::set_has_database_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::clear_has_database_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::clear_database_image() {
  if (database_image_ != NULL) database_image_->::TSP::Reference::Clear();
  clear_has_database_image();
}
inline const ::TSP::Reference& CommandSlideNodeSetPropertyArchive_PropertyValue::database_image() const {
  return database_image_ != NULL ? *database_image_ : *default_instance_->database_image_;
}
inline ::TSP::Reference* CommandSlideNodeSetPropertyArchive_PropertyValue::mutable_database_image() {
  set_has_database_image();
  if (database_image_ == NULL) database_image_ = new ::TSP::Reference;
  return database_image_;
}
inline ::TSP::Reference* CommandSlideNodeSetPropertyArchive_PropertyValue::release_database_image() {
  clear_has_database_image();
  ::TSP::Reference* temp = database_image_;
  database_image_ = NULL;
  return temp;
}
inline void CommandSlideNodeSetPropertyArchive_PropertyValue::set_allocated_database_image(::TSP::Reference* database_image) {
  delete database_image_;
  database_image_ = database_image;
  if (database_image) {
    set_has_database_image();
  } else {
    clear_has_database_image();
  }
}

// -------------------------------------------------------------------

// CommandSlideNodeSetPropertyArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideNodeSetPropertyArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideNodeSetPropertyArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideNodeSetPropertyArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideNodeSetPropertyArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideNodeSetPropertyArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideNodeSetPropertyArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideNodeSetPropertyArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideNodeSetPropertyArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideNodeSetPropertyArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideNodeSetPropertyArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required string property = 3;
inline bool CommandSlideNodeSetPropertyArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandSlideNodeSetPropertyArchive::property() const {
  return *property_;
}
inline void CommandSlideNodeSetPropertyArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandSlideNodeSetPropertyArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandSlideNodeSetPropertyArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSlideNodeSetPropertyArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandSlideNodeSetPropertyArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSlideNodeSetPropertyArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .KN.CommandSlideNodeSetPropertyArchive.PropertyValue oldValue = 4;
inline bool CommandSlideNodeSetPropertyArchive::has_oldvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive::set_has_oldvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_has_oldvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_oldvalue() {
  if (oldvalue_ != NULL) oldvalue_->::KN::CommandSlideNodeSetPropertyArchive_PropertyValue::Clear();
  clear_has_oldvalue();
}
inline const ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue& CommandSlideNodeSetPropertyArchive::oldvalue() const {
  return oldvalue_ != NULL ? *oldvalue_ : *default_instance_->oldvalue_;
}
inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* CommandSlideNodeSetPropertyArchive::mutable_oldvalue() {
  set_has_oldvalue();
  if (oldvalue_ == NULL) oldvalue_ = new ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue;
  return oldvalue_;
}
inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* CommandSlideNodeSetPropertyArchive::release_oldvalue() {
  clear_has_oldvalue();
  ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* temp = oldvalue_;
  oldvalue_ = NULL;
  return temp;
}
inline void CommandSlideNodeSetPropertyArchive::set_allocated_oldvalue(::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* oldvalue) {
  delete oldvalue_;
  oldvalue_ = oldvalue;
  if (oldvalue) {
    set_has_oldvalue();
  } else {
    clear_has_oldvalue();
  }
}

// required .KN.CommandSlideNodeSetPropertyArchive.PropertyValue newValue = 5;
inline bool CommandSlideNodeSetPropertyArchive::has_newvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSlideNodeSetPropertyArchive::set_has_newvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_has_newvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSlideNodeSetPropertyArchive::clear_newvalue() {
  if (newvalue_ != NULL) newvalue_->::KN::CommandSlideNodeSetPropertyArchive_PropertyValue::Clear();
  clear_has_newvalue();
}
inline const ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue& CommandSlideNodeSetPropertyArchive::newvalue() const {
  return newvalue_ != NULL ? *newvalue_ : *default_instance_->newvalue_;
}
inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* CommandSlideNodeSetPropertyArchive::mutable_newvalue() {
  set_has_newvalue();
  if (newvalue_ == NULL) newvalue_ = new ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue;
  return newvalue_;
}
inline ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* CommandSlideNodeSetPropertyArchive::release_newvalue() {
  clear_has_newvalue();
  ::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* temp = newvalue_;
  newvalue_ = NULL;
  return temp;
}
inline void CommandSlideNodeSetPropertyArchive::set_allocated_newvalue(::KN::CommandSlideNodeSetPropertyArchive_PropertyValue* newvalue) {
  delete newvalue_;
  newvalue_ = newvalue;
  if (newvalue) {
    set_has_newvalue();
  } else {
    clear_has_newvalue();
  }
}

// -------------------------------------------------------------------

// CommandSlideSetValueArchive_PropertyValue

// optional bool boolValue = 1;
inline bool CommandSlideSetValueArchive_PropertyValue::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideSetValueArchive_PropertyValue::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideSetValueArchive_PropertyValue::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideSetValueArchive_PropertyValue::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool CommandSlideSetValueArchive_PropertyValue::boolvalue() const {
  return boolvalue_;
}
inline void CommandSlideSetValueArchive_PropertyValue::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// optional .TSP.Reference objectValue = 2;
inline bool CommandSlideSetValueArchive_PropertyValue::has_objectvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideSetValueArchive_PropertyValue::set_has_objectvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideSetValueArchive_PropertyValue::clear_has_objectvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideSetValueArchive_PropertyValue::clear_objectvalue() {
  if (objectvalue_ != NULL) objectvalue_->::TSP::Reference::Clear();
  clear_has_objectvalue();
}
inline const ::TSP::Reference& CommandSlideSetValueArchive_PropertyValue::objectvalue() const {
  return objectvalue_ != NULL ? *objectvalue_ : *default_instance_->objectvalue_;
}
inline ::TSP::Reference* CommandSlideSetValueArchive_PropertyValue::mutable_objectvalue() {
  set_has_objectvalue();
  if (objectvalue_ == NULL) objectvalue_ = new ::TSP::Reference;
  return objectvalue_;
}
inline ::TSP::Reference* CommandSlideSetValueArchive_PropertyValue::release_objectvalue() {
  clear_has_objectvalue();
  ::TSP::Reference* temp = objectvalue_;
  objectvalue_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive_PropertyValue::set_allocated_objectvalue(::TSP::Reference* objectvalue) {
  delete objectvalue_;
  objectvalue_ = objectvalue;
  if (objectvalue) {
    set_has_objectvalue();
  } else {
    clear_has_objectvalue();
  }
}

// optional .TSD.FillArchive fill = 3;
inline bool CommandSlideSetValueArchive_PropertyValue::has_fill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideSetValueArchive_PropertyValue::set_has_fill() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideSetValueArchive_PropertyValue::clear_has_fill() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideSetValueArchive_PropertyValue::clear_fill() {
  if (fill_ != NULL) fill_->::TSD::FillArchive::Clear();
  clear_has_fill();
}
inline const ::TSD::FillArchive& CommandSlideSetValueArchive_PropertyValue::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSD::FillArchive* CommandSlideSetValueArchive_PropertyValue::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSD::FillArchive;
  return fill_;
}
inline ::TSD::FillArchive* CommandSlideSetValueArchive_PropertyValue::release_fill() {
  clear_has_fill();
  ::TSD::FillArchive* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive_PropertyValue::set_allocated_fill(::TSD::FillArchive* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// -------------------------------------------------------------------

// CommandSlideSetValueArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideSetValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideSetValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideSetValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideSetValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideSetValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideSetValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideSetValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlideSetValueArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideSetValueArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideSetValueArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideSetValueArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlideSetValueArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlideSetValueArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlideSetValueArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required string property = 3;
inline bool CommandSlideSetValueArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideSetValueArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideSetValueArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideSetValueArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandSlideSetValueArchive::property() const {
  return *property_;
}
inline void CommandSlideSetValueArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandSlideSetValueArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandSlideSetValueArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSlideSetValueArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandSlideSetValueArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSlideSetValueArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .KN.CommandSlideSetValueArchive.PropertyValue oldValue = 4;
inline bool CommandSlideSetValueArchive::has_oldvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideSetValueArchive::set_has_oldvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideSetValueArchive::clear_has_oldvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideSetValueArchive::clear_oldvalue() {
  if (oldvalue_ != NULL) oldvalue_->::KN::CommandSlideSetValueArchive_PropertyValue::Clear();
  clear_has_oldvalue();
}
inline const ::KN::CommandSlideSetValueArchive_PropertyValue& CommandSlideSetValueArchive::oldvalue() const {
  return oldvalue_ != NULL ? *oldvalue_ : *default_instance_->oldvalue_;
}
inline ::KN::CommandSlideSetValueArchive_PropertyValue* CommandSlideSetValueArchive::mutable_oldvalue() {
  set_has_oldvalue();
  if (oldvalue_ == NULL) oldvalue_ = new ::KN::CommandSlideSetValueArchive_PropertyValue;
  return oldvalue_;
}
inline ::KN::CommandSlideSetValueArchive_PropertyValue* CommandSlideSetValueArchive::release_oldvalue() {
  clear_has_oldvalue();
  ::KN::CommandSlideSetValueArchive_PropertyValue* temp = oldvalue_;
  oldvalue_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive::set_allocated_oldvalue(::KN::CommandSlideSetValueArchive_PropertyValue* oldvalue) {
  delete oldvalue_;
  oldvalue_ = oldvalue;
  if (oldvalue) {
    set_has_oldvalue();
  } else {
    clear_has_oldvalue();
  }
}

// required .KN.CommandSlideSetValueArchive.PropertyValue newValue = 5;
inline bool CommandSlideSetValueArchive::has_newvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSlideSetValueArchive::set_has_newvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSlideSetValueArchive::clear_has_newvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSlideSetValueArchive::clear_newvalue() {
  if (newvalue_ != NULL) newvalue_->::KN::CommandSlideSetValueArchive_PropertyValue::Clear();
  clear_has_newvalue();
}
inline const ::KN::CommandSlideSetValueArchive_PropertyValue& CommandSlideSetValueArchive::newvalue() const {
  return newvalue_ != NULL ? *newvalue_ : *default_instance_->newvalue_;
}
inline ::KN::CommandSlideSetValueArchive_PropertyValue* CommandSlideSetValueArchive::mutable_newvalue() {
  set_has_newvalue();
  if (newvalue_ == NULL) newvalue_ = new ::KN::CommandSlideSetValueArchive_PropertyValue;
  return newvalue_;
}
inline ::KN::CommandSlideSetValueArchive_PropertyValue* CommandSlideSetValueArchive::release_newvalue() {
  clear_has_newvalue();
  ::KN::CommandSlideSetValueArchive_PropertyValue* temp = newvalue_;
  newvalue_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive::set_allocated_newvalue(::KN::CommandSlideSetValueArchive_PropertyValue* newvalue) {
  delete newvalue_;
  newvalue_ = newvalue;
  if (newvalue) {
    set_has_newvalue();
  } else {
    clear_has_newvalue();
  }
}

// required .TSP.Reference oldSlideStyle = 6;
inline bool CommandSlideSetValueArchive::has_oldslidestyle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSlideSetValueArchive::set_has_oldslidestyle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSlideSetValueArchive::clear_has_oldslidestyle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSlideSetValueArchive::clear_oldslidestyle() {
  if (oldslidestyle_ != NULL) oldslidestyle_->::TSP::Reference::Clear();
  clear_has_oldslidestyle();
}
inline const ::TSP::Reference& CommandSlideSetValueArchive::oldslidestyle() const {
  return oldslidestyle_ != NULL ? *oldslidestyle_ : *default_instance_->oldslidestyle_;
}
inline ::TSP::Reference* CommandSlideSetValueArchive::mutable_oldslidestyle() {
  set_has_oldslidestyle();
  if (oldslidestyle_ == NULL) oldslidestyle_ = new ::TSP::Reference;
  return oldslidestyle_;
}
inline ::TSP::Reference* CommandSlideSetValueArchive::release_oldslidestyle() {
  clear_has_oldslidestyle();
  ::TSP::Reference* temp = oldslidestyle_;
  oldslidestyle_ = NULL;
  return temp;
}
inline void CommandSlideSetValueArchive::set_allocated_oldslidestyle(::TSP::Reference* oldslidestyle) {
  delete oldslidestyle_;
  oldslidestyle_ = oldslidestyle;
  if (oldslidestyle) {
    set_has_oldslidestyle();
  } else {
    clear_has_oldslidestyle();
  }
}

// -------------------------------------------------------------------

// CommandSlideSetStyleArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideSetStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideSetStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideSetStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideSetStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideSetStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideSetStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideSetStyleArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideSetStyleArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlideSetStyleArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideSetStyleArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideSetStyleArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideSetStyleArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlideSetStyleArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlideSetStyleArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlideSetStyleArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlideSetStyleArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required .TSP.Reference slide_style = 3;
inline bool CommandSlideSetStyleArchive::has_slide_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideSetStyleArchive::set_has_slide_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideSetStyleArchive::clear_has_slide_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideSetStyleArchive::clear_slide_style() {
  if (slide_style_ != NULL) slide_style_->::TSP::Reference::Clear();
  clear_has_slide_style();
}
inline const ::TSP::Reference& CommandSlideSetStyleArchive::slide_style() const {
  return slide_style_ != NULL ? *slide_style_ : *default_instance_->slide_style_;
}
inline ::TSP::Reference* CommandSlideSetStyleArchive::mutable_slide_style() {
  set_has_slide_style();
  if (slide_style_ == NULL) slide_style_ = new ::TSP::Reference;
  return slide_style_;
}
inline ::TSP::Reference* CommandSlideSetStyleArchive::release_slide_style() {
  clear_has_slide_style();
  ::TSP::Reference* temp = slide_style_;
  slide_style_ = NULL;
  return temp;
}
inline void CommandSlideSetStyleArchive::set_allocated_slide_style(::TSP::Reference* slide_style) {
  delete slide_style_;
  slide_style_ = slide_style;
  if (slide_style) {
    set_has_slide_style();
  } else {
    clear_has_slide_style();
  }
}

// required .TSP.Reference old_slide_style = 4;
inline bool CommandSlideSetStyleArchive::has_old_slide_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideSetStyleArchive::set_has_old_slide_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideSetStyleArchive::clear_has_old_slide_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideSetStyleArchive::clear_old_slide_style() {
  if (old_slide_style_ != NULL) old_slide_style_->::TSP::Reference::Clear();
  clear_has_old_slide_style();
}
inline const ::TSP::Reference& CommandSlideSetStyleArchive::old_slide_style() const {
  return old_slide_style_ != NULL ? *old_slide_style_ : *default_instance_->old_slide_style_;
}
inline ::TSP::Reference* CommandSlideSetStyleArchive::mutable_old_slide_style() {
  set_has_old_slide_style();
  if (old_slide_style_ == NULL) old_slide_style_ = new ::TSP::Reference;
  return old_slide_style_;
}
inline ::TSP::Reference* CommandSlideSetStyleArchive::release_old_slide_style() {
  clear_has_old_slide_style();
  ::TSP::Reference* temp = old_slide_style_;
  old_slide_style_ = NULL;
  return temp;
}
inline void CommandSlideSetStyleArchive::set_allocated_old_slide_style(::TSP::Reference* old_slide_style) {
  delete old_slide_style_;
  old_slide_style_ = old_slide_style;
  if (old_slide_style) {
    set_has_old_slide_style();
  } else {
    clear_has_old_slide_style();
  }
}

// -------------------------------------------------------------------

// CommandShowMarkOutOfSyncRecordingArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowMarkOutOfSyncRecordingArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowMarkOutOfSyncRecordingArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowMarkOutOfSyncRecordingArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowMarkOutOfSyncRecordingArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowMarkOutOfSyncRecordingArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowMarkOutOfSyncRecordingArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowMarkOutOfSyncRecordingArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowMarkOutOfSyncRecordingArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// optional .TSP.Reference old_recording = 3;
inline bool CommandShowMarkOutOfSyncRecordingArchive::has_old_recording() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::set_has_old_recording() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::clear_has_old_recording() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::clear_old_recording() {
  if (old_recording_ != NULL) old_recording_->::TSP::Reference::Clear();
  clear_has_old_recording();
}
inline const ::TSP::Reference& CommandShowMarkOutOfSyncRecordingArchive::old_recording() const {
  return old_recording_ != NULL ? *old_recording_ : *default_instance_->old_recording_;
}
inline ::TSP::Reference* CommandShowMarkOutOfSyncRecordingArchive::mutable_old_recording() {
  set_has_old_recording();
  if (old_recording_ == NULL) old_recording_ = new ::TSP::Reference;
  return old_recording_;
}
inline ::TSP::Reference* CommandShowMarkOutOfSyncRecordingArchive::release_old_recording() {
  clear_has_old_recording();
  ::TSP::Reference* temp = old_recording_;
  old_recording_ = NULL;
  return temp;
}
inline void CommandShowMarkOutOfSyncRecordingArchive::set_allocated_old_recording(::TSP::Reference* old_recording) {
  delete old_recording_;
  old_recording_ = old_recording;
  if (old_recording) {
    set_has_old_recording();
  } else {
    clear_has_old_recording();
  }
}

// -------------------------------------------------------------------

// CommandShowRemoveRecordingArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowRemoveRecordingArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowRemoveRecordingArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowRemoveRecordingArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowRemoveRecordingArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowRemoveRecordingArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowRemoveRecordingArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowRemoveRecordingArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowRemoveRecordingArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowRemoveRecordingArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowRemoveRecordingArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowRemoveRecordingArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowRemoveRecordingArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowRemoveRecordingArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowRemoveRecordingArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowRemoveRecordingArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowRemoveRecordingArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// optional .TSP.Reference old_recording = 3;
inline bool CommandShowRemoveRecordingArchive::has_old_recording() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowRemoveRecordingArchive::set_has_old_recording() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowRemoveRecordingArchive::clear_has_old_recording() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowRemoveRecordingArchive::clear_old_recording() {
  if (old_recording_ != NULL) old_recording_->::TSP::Reference::Clear();
  clear_has_old_recording();
}
inline const ::TSP::Reference& CommandShowRemoveRecordingArchive::old_recording() const {
  return old_recording_ != NULL ? *old_recording_ : *default_instance_->old_recording_;
}
inline ::TSP::Reference* CommandShowRemoveRecordingArchive::mutable_old_recording() {
  set_has_old_recording();
  if (old_recording_ == NULL) old_recording_ = new ::TSP::Reference;
  return old_recording_;
}
inline ::TSP::Reference* CommandShowRemoveRecordingArchive::release_old_recording() {
  clear_has_old_recording();
  ::TSP::Reference* temp = old_recording_;
  old_recording_ = NULL;
  return temp;
}
inline void CommandShowRemoveRecordingArchive::set_allocated_old_recording(::TSP::Reference* old_recording) {
  delete old_recording_;
  old_recording_ = old_recording;
  if (old_recording) {
    set_has_old_recording();
  } else {
    clear_has_old_recording();
  }
}

// -------------------------------------------------------------------

// CommandShowReplaceRecordingArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowReplaceRecordingArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowReplaceRecordingArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowReplaceRecordingArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowReplaceRecordingArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowReplaceRecordingArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowReplaceRecordingArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowReplaceRecordingArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowReplaceRecordingArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowReplaceRecordingArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowReplaceRecordingArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowReplaceRecordingArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowReplaceRecordingArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowReplaceRecordingArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowReplaceRecordingArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowReplaceRecordingArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowReplaceRecordingArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required .TSP.Reference replacement_recording = 3;
inline bool CommandShowReplaceRecordingArchive::has_replacement_recording() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowReplaceRecordingArchive::set_has_replacement_recording() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowReplaceRecordingArchive::clear_has_replacement_recording() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowReplaceRecordingArchive::clear_replacement_recording() {
  if (replacement_recording_ != NULL) replacement_recording_->::TSP::Reference::Clear();
  clear_has_replacement_recording();
}
inline const ::TSP::Reference& CommandShowReplaceRecordingArchive::replacement_recording() const {
  return replacement_recording_ != NULL ? *replacement_recording_ : *default_instance_->replacement_recording_;
}
inline ::TSP::Reference* CommandShowReplaceRecordingArchive::mutable_replacement_recording() {
  set_has_replacement_recording();
  if (replacement_recording_ == NULL) replacement_recording_ = new ::TSP::Reference;
  return replacement_recording_;
}
inline ::TSP::Reference* CommandShowReplaceRecordingArchive::release_replacement_recording() {
  clear_has_replacement_recording();
  ::TSP::Reference* temp = replacement_recording_;
  replacement_recording_ = NULL;
  return temp;
}
inline void CommandShowReplaceRecordingArchive::set_allocated_replacement_recording(::TSP::Reference* replacement_recording) {
  delete replacement_recording_;
  replacement_recording_ = replacement_recording;
  if (replacement_recording) {
    set_has_replacement_recording();
  } else {
    clear_has_replacement_recording();
  }
}

// required double replacement_start_time = 4;
inline bool CommandShowReplaceRecordingArchive::has_replacement_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowReplaceRecordingArchive::set_has_replacement_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowReplaceRecordingArchive::clear_has_replacement_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowReplaceRecordingArchive::clear_replacement_start_time() {
  replacement_start_time_ = 0;
  clear_has_replacement_start_time();
}
inline double CommandShowReplaceRecordingArchive::replacement_start_time() const {
  return replacement_start_time_;
}
inline void CommandShowReplaceRecordingArchive::set_replacement_start_time(double value) {
  set_has_replacement_start_time();
  replacement_start_time_ = value;
}

// optional .TSP.Reference old_recording = 5;
inline bool CommandShowReplaceRecordingArchive::has_old_recording() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandShowReplaceRecordingArchive::set_has_old_recording() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandShowReplaceRecordingArchive::clear_has_old_recording() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandShowReplaceRecordingArchive::clear_old_recording() {
  if (old_recording_ != NULL) old_recording_->::TSP::Reference::Clear();
  clear_has_old_recording();
}
inline const ::TSP::Reference& CommandShowReplaceRecordingArchive::old_recording() const {
  return old_recording_ != NULL ? *old_recording_ : *default_instance_->old_recording_;
}
inline ::TSP::Reference* CommandShowReplaceRecordingArchive::mutable_old_recording() {
  set_has_old_recording();
  if (old_recording_ == NULL) old_recording_ = new ::TSP::Reference;
  return old_recording_;
}
inline ::TSP::Reference* CommandShowReplaceRecordingArchive::release_old_recording() {
  clear_has_old_recording();
  ::TSP::Reference* temp = old_recording_;
  old_recording_ = NULL;
  return temp;
}
inline void CommandShowReplaceRecordingArchive::set_allocated_old_recording(::TSP::Reference* old_recording) {
  delete old_recording_;
  old_recording_ = old_recording;
  if (old_recording) {
    set_has_old_recording();
  } else {
    clear_has_old_recording();
  }
}

// -------------------------------------------------------------------

// CommandShowSetValueArchive_PropertyValue

// optional bool bool_value = 1;
inline bool CommandShowSetValueArchive_PropertyValue::has_bool_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowSetValueArchive_PropertyValue::set_has_bool_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_has_bool_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_bool_value() {
  bool_value_ = false;
  clear_has_bool_value();
}
inline bool CommandShowSetValueArchive_PropertyValue::bool_value() const {
  return bool_value_;
}
inline void CommandShowSetValueArchive_PropertyValue::set_bool_value(bool value) {
  set_has_bool_value();
  bool_value_ = value;
}

// optional double double_value = 2;
inline bool CommandShowSetValueArchive_PropertyValue::has_double_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowSetValueArchive_PropertyValue::set_has_double_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double CommandShowSetValueArchive_PropertyValue::double_value() const {
  return double_value_;
}
inline void CommandShowSetValueArchive_PropertyValue::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}

// optional .KN.ShowArchive.KNShowMode show_mode_value = 3;
inline bool CommandShowSetValueArchive_PropertyValue::has_show_mode_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowSetValueArchive_PropertyValue::set_has_show_mode_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_has_show_mode_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_show_mode_value() {
  show_mode_value_ = 0;
  clear_has_show_mode_value();
}
inline ::KN::ShowArchive_KNShowMode CommandShowSetValueArchive_PropertyValue::show_mode_value() const {
  return static_cast< ::KN::ShowArchive_KNShowMode >(show_mode_value_);
}
inline void CommandShowSetValueArchive_PropertyValue::set_show_mode_value(::KN::ShowArchive_KNShowMode value) {
  assert(::KN::ShowArchive_KNShowMode_IsValid(value));
  set_has_show_mode_value();
  show_mode_value_ = value;
}

// optional .TSP.Size size_value = 4;
inline bool CommandShowSetValueArchive_PropertyValue::has_size_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowSetValueArchive_PropertyValue::set_has_size_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_has_size_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowSetValueArchive_PropertyValue::clear_size_value() {
  if (size_value_ != NULL) size_value_->::TSP::Size::Clear();
  clear_has_size_value();
}
inline const ::TSP::Size& CommandShowSetValueArchive_PropertyValue::size_value() const {
  return size_value_ != NULL ? *size_value_ : *default_instance_->size_value_;
}
inline ::TSP::Size* CommandShowSetValueArchive_PropertyValue::mutable_size_value() {
  set_has_size_value();
  if (size_value_ == NULL) size_value_ = new ::TSP::Size;
  return size_value_;
}
inline ::TSP::Size* CommandShowSetValueArchive_PropertyValue::release_size_value() {
  clear_has_size_value();
  ::TSP::Size* temp = size_value_;
  size_value_ = NULL;
  return temp;
}
inline void CommandShowSetValueArchive_PropertyValue::set_allocated_size_value(::TSP::Size* size_value) {
  delete size_value_;
  size_value_ = size_value;
  if (size_value) {
    set_has_size_value();
  } else {
    clear_has_size_value();
  }
}

// -------------------------------------------------------------------

// CommandShowSetValueArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowSetValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowSetValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowSetValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowSetValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowSetValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowSetValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowSetValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowSetValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowSetValueArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowSetValueArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowSetValueArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowSetValueArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowSetValueArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowSetValueArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowSetValueArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowSetValueArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required string property = 3;
inline bool CommandShowSetValueArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowSetValueArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowSetValueArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowSetValueArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandShowSetValueArchive::property() const {
  return *property_;
}
inline void CommandShowSetValueArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandShowSetValueArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandShowSetValueArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandShowSetValueArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandShowSetValueArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandShowSetValueArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .KN.CommandShowSetValueArchive.PropertyValue old_value = 4;
inline bool CommandShowSetValueArchive::has_old_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowSetValueArchive::set_has_old_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowSetValueArchive::clear_has_old_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowSetValueArchive::clear_old_value() {
  if (old_value_ != NULL) old_value_->::KN::CommandShowSetValueArchive_PropertyValue::Clear();
  clear_has_old_value();
}
inline const ::KN::CommandShowSetValueArchive_PropertyValue& CommandShowSetValueArchive::old_value() const {
  return old_value_ != NULL ? *old_value_ : *default_instance_->old_value_;
}
inline ::KN::CommandShowSetValueArchive_PropertyValue* CommandShowSetValueArchive::mutable_old_value() {
  set_has_old_value();
  if (old_value_ == NULL) old_value_ = new ::KN::CommandShowSetValueArchive_PropertyValue;
  return old_value_;
}
inline ::KN::CommandShowSetValueArchive_PropertyValue* CommandShowSetValueArchive::release_old_value() {
  clear_has_old_value();
  ::KN::CommandShowSetValueArchive_PropertyValue* temp = old_value_;
  old_value_ = NULL;
  return temp;
}
inline void CommandShowSetValueArchive::set_allocated_old_value(::KN::CommandShowSetValueArchive_PropertyValue* old_value) {
  delete old_value_;
  old_value_ = old_value;
  if (old_value) {
    set_has_old_value();
  } else {
    clear_has_old_value();
  }
}

// required .KN.CommandShowSetValueArchive.PropertyValue new_value = 5;
inline bool CommandShowSetValueArchive::has_new_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandShowSetValueArchive::set_has_new_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandShowSetValueArchive::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandShowSetValueArchive::clear_new_value() {
  if (new_value_ != NULL) new_value_->::KN::CommandShowSetValueArchive_PropertyValue::Clear();
  clear_has_new_value();
}
inline const ::KN::CommandShowSetValueArchive_PropertyValue& CommandShowSetValueArchive::new_value() const {
  return new_value_ != NULL ? *new_value_ : *default_instance_->new_value_;
}
inline ::KN::CommandShowSetValueArchive_PropertyValue* CommandShowSetValueArchive::mutable_new_value() {
  set_has_new_value();
  if (new_value_ == NULL) new_value_ = new ::KN::CommandShowSetValueArchive_PropertyValue;
  return new_value_;
}
inline ::KN::CommandShowSetValueArchive_PropertyValue* CommandShowSetValueArchive::release_new_value() {
  clear_has_new_value();
  ::KN::CommandShowSetValueArchive_PropertyValue* temp = new_value_;
  new_value_ = NULL;
  return temp;
}
inline void CommandShowSetValueArchive::set_allocated_new_value(::KN::CommandShowSetValueArchive_PropertyValue* new_value) {
  delete new_value_;
  new_value_ = new_value;
  if (new_value) {
    set_has_new_value();
  } else {
    clear_has_new_value();
  }
}

// -------------------------------------------------------------------

// CommandShowInsertSlideArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowInsertSlideArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowInsertSlideArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowInsertSlideArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowInsertSlideArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowInsertSlideArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowInsertSlideArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowInsertSlideArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowInsertSlideArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowInsertSlideArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowInsertSlideArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowInsertSlideArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowInsertSlideArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowInsertSlideArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowInsertSlideArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowInsertSlideArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowInsertSlideArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required .TSP.Reference slideNode = 3;
inline bool CommandShowInsertSlideArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowInsertSlideArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowInsertSlideArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowInsertSlideArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandShowInsertSlideArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandShowInsertSlideArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandShowInsertSlideArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandShowInsertSlideArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required uint32 childIndex = 4;
inline bool CommandShowInsertSlideArchive::has_childindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowInsertSlideArchive::set_has_childindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowInsertSlideArchive::clear_has_childindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowInsertSlideArchive::clear_childindex() {
  childindex_ = 0u;
  clear_has_childindex();
}
inline ::google::protobuf::uint32 CommandShowInsertSlideArchive::childindex() const {
  return childindex_;
}
inline void CommandShowInsertSlideArchive::set_childindex(::google::protobuf::uint32 value) {
  set_has_childindex();
  childindex_ = value;
}

// required .TSP.Reference parentSlideNode = 5;
inline bool CommandShowInsertSlideArchive::has_parentslidenode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandShowInsertSlideArchive::set_has_parentslidenode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandShowInsertSlideArchive::clear_has_parentslidenode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandShowInsertSlideArchive::clear_parentslidenode() {
  if (parentslidenode_ != NULL) parentslidenode_->::TSP::Reference::Clear();
  clear_has_parentslidenode();
}
inline const ::TSP::Reference& CommandShowInsertSlideArchive::parentslidenode() const {
  return parentslidenode_ != NULL ? *parentslidenode_ : *default_instance_->parentslidenode_;
}
inline ::TSP::Reference* CommandShowInsertSlideArchive::mutable_parentslidenode() {
  set_has_parentslidenode();
  if (parentslidenode_ == NULL) parentslidenode_ = new ::TSP::Reference;
  return parentslidenode_;
}
inline ::TSP::Reference* CommandShowInsertSlideArchive::release_parentslidenode() {
  clear_has_parentslidenode();
  ::TSP::Reference* temp = parentslidenode_;
  parentslidenode_ = NULL;
  return temp;
}
inline void CommandShowInsertSlideArchive::set_allocated_parentslidenode(::TSP::Reference* parentslidenode) {
  delete parentslidenode_;
  parentslidenode_ = parentslidenode;
  if (parentslidenode) {
    set_has_parentslidenode();
  } else {
    clear_has_parentslidenode();
  }
}

// optional .KN.CommandShowInsertSlideArchive.Kind kind = 6 [default = kKindInsertSlide];
inline bool CommandShowInsertSlideArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandShowInsertSlideArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandShowInsertSlideArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandShowInsertSlideArchive::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::KN::CommandShowInsertSlideArchive_Kind CommandShowInsertSlideArchive::kind() const {
  return static_cast< ::KN::CommandShowInsertSlideArchive_Kind >(kind_);
}
inline void CommandShowInsertSlideArchive::set_kind(::KN::CommandShowInsertSlideArchive_Kind value) {
  assert(::KN::CommandShowInsertSlideArchive_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// CommandShowMoveSlideArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowMoveSlideArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowMoveSlideArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowMoveSlideArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowMoveSlideArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowMoveSlideArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowMoveSlideArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowMoveSlideArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowMoveSlideArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowMoveSlideArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowMoveSlideArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowMoveSlideArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowMoveSlideArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowMoveSlideArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowMoveSlideArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowMoveSlideArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowMoveSlideArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required .TSP.Reference slideNode = 3;
inline bool CommandShowMoveSlideArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowMoveSlideArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowMoveSlideArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowMoveSlideArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandShowMoveSlideArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandShowMoveSlideArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandShowMoveSlideArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandShowMoveSlideArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// repeated .TSP.Reference parentSlideNodes = 4;
inline int CommandShowMoveSlideArchive::parentslidenodes_size() const {
  return parentslidenodes_.size();
}
inline void CommandShowMoveSlideArchive::clear_parentslidenodes() {
  parentslidenodes_.Clear();
}
inline const ::TSP::Reference& CommandShowMoveSlideArchive::parentslidenodes(int index) const {
  return parentslidenodes_.Get(index);
}
inline ::TSP::Reference* CommandShowMoveSlideArchive::mutable_parentslidenodes(int index) {
  return parentslidenodes_.Mutable(index);
}
inline ::TSP::Reference* CommandShowMoveSlideArchive::add_parentslidenodes() {
  return parentslidenodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandShowMoveSlideArchive::parentslidenodes() const {
  return parentslidenodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandShowMoveSlideArchive::mutable_parentslidenodes() {
  return &parentslidenodes_;
}

// repeated uint32 childIndices = 5;
inline int CommandShowMoveSlideArchive::childindices_size() const {
  return childindices_.size();
}
inline void CommandShowMoveSlideArchive::clear_childindices() {
  childindices_.Clear();
}
inline ::google::protobuf::uint32 CommandShowMoveSlideArchive::childindices(int index) const {
  return childindices_.Get(index);
}
inline void CommandShowMoveSlideArchive::set_childindices(int index, ::google::protobuf::uint32 value) {
  childindices_.Set(index, value);
}
inline void CommandShowMoveSlideArchive::add_childindices(::google::protobuf::uint32 value) {
  childindices_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandShowMoveSlideArchive::childindices() const {
  return childindices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandShowMoveSlideArchive::mutable_childindices() {
  return &childindices_;
}

// -------------------------------------------------------------------

// CommandShowRemoveSlideArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowRemoveSlideArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowRemoveSlideArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowRemoveSlideArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowRemoveSlideArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowRemoveSlideArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowRemoveSlideArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowRemoveSlideArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowRemoveSlideArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowRemoveSlideArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowRemoveSlideArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowRemoveSlideArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowRemoveSlideArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowRemoveSlideArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowRemoveSlideArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowRemoveSlideArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowRemoveSlideArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required .TSP.Reference slideNode = 3;
inline bool CommandShowRemoveSlideArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowRemoveSlideArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowRemoveSlideArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowRemoveSlideArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandShowRemoveSlideArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandShowRemoveSlideArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandShowRemoveSlideArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandShowRemoveSlideArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required .TSP.Reference parentSlideNode = 4;
inline bool CommandShowRemoveSlideArchive::has_parentslidenode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowRemoveSlideArchive::set_has_parentslidenode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowRemoveSlideArchive::clear_has_parentslidenode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowRemoveSlideArchive::clear_parentslidenode() {
  if (parentslidenode_ != NULL) parentslidenode_->::TSP::Reference::Clear();
  clear_has_parentslidenode();
}
inline const ::TSP::Reference& CommandShowRemoveSlideArchive::parentslidenode() const {
  return parentslidenode_ != NULL ? *parentslidenode_ : *default_instance_->parentslidenode_;
}
inline ::TSP::Reference* CommandShowRemoveSlideArchive::mutable_parentslidenode() {
  set_has_parentslidenode();
  if (parentslidenode_ == NULL) parentslidenode_ = new ::TSP::Reference;
  return parentslidenode_;
}
inline ::TSP::Reference* CommandShowRemoveSlideArchive::release_parentslidenode() {
  clear_has_parentslidenode();
  ::TSP::Reference* temp = parentslidenode_;
  parentslidenode_ = NULL;
  return temp;
}
inline void CommandShowRemoveSlideArchive::set_allocated_parentslidenode(::TSP::Reference* parentslidenode) {
  delete parentslidenode_;
  parentslidenode_ = parentslidenode;
  if (parentslidenode) {
    set_has_parentslidenode();
  } else {
    clear_has_parentslidenode();
  }
}

// required uint32 childIndex = 5;
inline bool CommandShowRemoveSlideArchive::has_childindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandShowRemoveSlideArchive::set_has_childindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandShowRemoveSlideArchive::clear_has_childindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandShowRemoveSlideArchive::clear_childindex() {
  childindex_ = 0u;
  clear_has_childindex();
}
inline ::google::protobuf::uint32 CommandShowRemoveSlideArchive::childindex() const {
  return childindex_;
}
inline void CommandShowRemoveSlideArchive::set_childindex(::google::protobuf::uint32 value) {
  set_has_childindex();
  childindex_ = value;
}

// -------------------------------------------------------------------

// CommandShowChangeThemeArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowChangeThemeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowChangeThemeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowChangeThemeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowChangeThemeArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowChangeThemeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowChangeThemeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowChangeThemeArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowChangeThemeArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowChangeThemeArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowChangeThemeArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowChangeThemeArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowChangeThemeArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowChangeThemeArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowChangeThemeArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowChangeThemeArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowChangeThemeArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required .TSP.Reference theme = 3;
inline bool CommandShowChangeThemeArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowChangeThemeArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowChangeThemeArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowChangeThemeArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& CommandShowChangeThemeArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* CommandShowChangeThemeArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* CommandShowChangeThemeArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void CommandShowChangeThemeArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .TSP.Reference old_theme = 4;
inline bool CommandShowChangeThemeArchive::has_old_theme() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowChangeThemeArchive::set_has_old_theme() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowChangeThemeArchive::clear_has_old_theme() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowChangeThemeArchive::clear_old_theme() {
  if (old_theme_ != NULL) old_theme_->::TSP::Reference::Clear();
  clear_has_old_theme();
}
inline const ::TSP::Reference& CommandShowChangeThemeArchive::old_theme() const {
  return old_theme_ != NULL ? *old_theme_ : *default_instance_->old_theme_;
}
inline ::TSP::Reference* CommandShowChangeThemeArchive::mutable_old_theme() {
  set_has_old_theme();
  if (old_theme_ == NULL) old_theme_ = new ::TSP::Reference;
  return old_theme_;
}
inline ::TSP::Reference* CommandShowChangeThemeArchive::release_old_theme() {
  clear_has_old_theme();
  ::TSP::Reference* temp = old_theme_;
  old_theme_ = NULL;
  return temp;
}
inline void CommandShowChangeThemeArchive::set_allocated_old_theme(::TSP::Reference* old_theme) {
  delete old_theme_;
  old_theme_ = old_theme;
  if (old_theme) {
    set_has_old_theme();
  } else {
    clear_has_old_theme();
  }
}

// optional string template_identifier = 5;
inline bool CommandShowChangeThemeArchive::has_template_identifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandShowChangeThemeArchive::set_has_template_identifier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandShowChangeThemeArchive::clear_has_template_identifier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandShowChangeThemeArchive::clear_template_identifier() {
  if (template_identifier_ != &::google::protobuf::internal::kEmptyString) {
    template_identifier_->clear();
  }
  clear_has_template_identifier();
}
inline const ::std::string& CommandShowChangeThemeArchive::template_identifier() const {
  return *template_identifier_;
}
inline void CommandShowChangeThemeArchive::set_template_identifier(const ::std::string& value) {
  set_has_template_identifier();
  if (template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    template_identifier_ = new ::std::string;
  }
  template_identifier_->assign(value);
}
inline void CommandShowChangeThemeArchive::set_template_identifier(const char* value) {
  set_has_template_identifier();
  if (template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    template_identifier_ = new ::std::string;
  }
  template_identifier_->assign(value);
}
inline void CommandShowChangeThemeArchive::set_template_identifier(const char* value, size_t size) {
  set_has_template_identifier();
  if (template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    template_identifier_ = new ::std::string;
  }
  template_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandShowChangeThemeArchive::mutable_template_identifier() {
  set_has_template_identifier();
  if (template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    template_identifier_ = new ::std::string;
  }
  return template_identifier_;
}
inline ::std::string* CommandShowChangeThemeArchive::release_template_identifier() {
  clear_has_template_identifier();
  if (template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = template_identifier_;
    template_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandShowChangeThemeArchive::set_allocated_template_identifier(::std::string* template_identifier) {
  if (template_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete template_identifier_;
  }
  if (template_identifier) {
    set_has_template_identifier();
    template_identifier_ = template_identifier;
  } else {
    clear_has_template_identifier();
    template_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_template_identifier = 6;
inline bool CommandShowChangeThemeArchive::has_old_template_identifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandShowChangeThemeArchive::set_has_old_template_identifier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandShowChangeThemeArchive::clear_has_old_template_identifier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandShowChangeThemeArchive::clear_old_template_identifier() {
  if (old_template_identifier_ != &::google::protobuf::internal::kEmptyString) {
    old_template_identifier_->clear();
  }
  clear_has_old_template_identifier();
}
inline const ::std::string& CommandShowChangeThemeArchive::old_template_identifier() const {
  return *old_template_identifier_;
}
inline void CommandShowChangeThemeArchive::set_old_template_identifier(const ::std::string& value) {
  set_has_old_template_identifier();
  if (old_template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    old_template_identifier_ = new ::std::string;
  }
  old_template_identifier_->assign(value);
}
inline void CommandShowChangeThemeArchive::set_old_template_identifier(const char* value) {
  set_has_old_template_identifier();
  if (old_template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    old_template_identifier_ = new ::std::string;
  }
  old_template_identifier_->assign(value);
}
inline void CommandShowChangeThemeArchive::set_old_template_identifier(const char* value, size_t size) {
  set_has_old_template_identifier();
  if (old_template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    old_template_identifier_ = new ::std::string;
  }
  old_template_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandShowChangeThemeArchive::mutable_old_template_identifier() {
  set_has_old_template_identifier();
  if (old_template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    old_template_identifier_ = new ::std::string;
  }
  return old_template_identifier_;
}
inline ::std::string* CommandShowChangeThemeArchive::release_old_template_identifier() {
  clear_has_old_template_identifier();
  if (old_template_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_template_identifier_;
    old_template_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandShowChangeThemeArchive::set_allocated_old_template_identifier(::std::string* old_template_identifier) {
  if (old_template_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete old_template_identifier_;
  }
  if (old_template_identifier) {
    set_has_old_template_identifier();
    old_template_identifier_ = old_template_identifier;
  } else {
    clear_has_old_template_identifier();
    old_template_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandMoveMastersArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandMoveMastersArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMoveMastersArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMoveMastersArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMoveMastersArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandMoveMastersArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandMoveMastersArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandMoveMastersArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMoveMastersArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference theme = 2;
inline bool CommandMoveMastersArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMoveMastersArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMoveMastersArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMoveMastersArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& CommandMoveMastersArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* CommandMoveMastersArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* CommandMoveMastersArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void CommandMoveMastersArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// repeated .TSP.Reference master_slides = 3;
inline int CommandMoveMastersArchive::master_slides_size() const {
  return master_slides_.size();
}
inline void CommandMoveMastersArchive::clear_master_slides() {
  master_slides_.Clear();
}
inline const ::TSP::Reference& CommandMoveMastersArchive::master_slides(int index) const {
  return master_slides_.Get(index);
}
inline ::TSP::Reference* CommandMoveMastersArchive::mutable_master_slides(int index) {
  return master_slides_.Mutable(index);
}
inline ::TSP::Reference* CommandMoveMastersArchive::add_master_slides() {
  return master_slides_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMoveMastersArchive::master_slides() const {
  return master_slides_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMoveMastersArchive::mutable_master_slides() {
  return &master_slides_;
}

// repeated .TSP.Reference previous_indexes_keys = 4;
inline int CommandMoveMastersArchive::previous_indexes_keys_size() const {
  return previous_indexes_keys_.size();
}
inline void CommandMoveMastersArchive::clear_previous_indexes_keys() {
  previous_indexes_keys_.Clear();
}
inline const ::TSP::Reference& CommandMoveMastersArchive::previous_indexes_keys(int index) const {
  return previous_indexes_keys_.Get(index);
}
inline ::TSP::Reference* CommandMoveMastersArchive::mutable_previous_indexes_keys(int index) {
  return previous_indexes_keys_.Mutable(index);
}
inline ::TSP::Reference* CommandMoveMastersArchive::add_previous_indexes_keys() {
  return previous_indexes_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMoveMastersArchive::previous_indexes_keys() const {
  return previous_indexes_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMoveMastersArchive::mutable_previous_indexes_keys() {
  return &previous_indexes_keys_;
}

// repeated uint32 previous_indexes_values = 5;
inline int CommandMoveMastersArchive::previous_indexes_values_size() const {
  return previous_indexes_values_.size();
}
inline void CommandMoveMastersArchive::clear_previous_indexes_values() {
  previous_indexes_values_.Clear();
}
inline ::google::protobuf::uint32 CommandMoveMastersArchive::previous_indexes_values(int index) const {
  return previous_indexes_values_.Get(index);
}
inline void CommandMoveMastersArchive::set_previous_indexes_values(int index, ::google::protobuf::uint32 value) {
  previous_indexes_values_.Set(index, value);
}
inline void CommandMoveMastersArchive::add_previous_indexes_values(::google::protobuf::uint32 value) {
  previous_indexes_values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandMoveMastersArchive::previous_indexes_values() const {
  return previous_indexes_values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandMoveMastersArchive::mutable_previous_indexes_values() {
  return &previous_indexes_values_;
}

// repeated .TSP.Reference final_master_arrangement = 6;
inline int CommandMoveMastersArchive::final_master_arrangement_size() const {
  return final_master_arrangement_.size();
}
inline void CommandMoveMastersArchive::clear_final_master_arrangement() {
  final_master_arrangement_.Clear();
}
inline const ::TSP::Reference& CommandMoveMastersArchive::final_master_arrangement(int index) const {
  return final_master_arrangement_.Get(index);
}
inline ::TSP::Reference* CommandMoveMastersArchive::mutable_final_master_arrangement(int index) {
  return final_master_arrangement_.Mutable(index);
}
inline ::TSP::Reference* CommandMoveMastersArchive::add_final_master_arrangement() {
  return final_master_arrangement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMoveMastersArchive::final_master_arrangement() const {
  return final_master_arrangement_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMoveMastersArchive::mutable_final_master_arrangement() {
  return &final_master_arrangement_;
}

// -------------------------------------------------------------------

// CommandInsertMasterArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandInsertMasterArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInsertMasterArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInsertMasterArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInsertMasterArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandInsertMasterArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandInsertMasterArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandInsertMasterArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandInsertMasterArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference theme = 2;
inline bool CommandInsertMasterArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInsertMasterArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInsertMasterArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInsertMasterArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& CommandInsertMasterArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* CommandInsertMasterArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* CommandInsertMasterArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void CommandInsertMasterArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .TSP.Reference master_slide_node = 3;
inline bool CommandInsertMasterArchive::has_master_slide_node() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInsertMasterArchive::set_has_master_slide_node() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInsertMasterArchive::clear_has_master_slide_node() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInsertMasterArchive::clear_master_slide_node() {
  if (master_slide_node_ != NULL) master_slide_node_->::TSP::Reference::Clear();
  clear_has_master_slide_node();
}
inline const ::TSP::Reference& CommandInsertMasterArchive::master_slide_node() const {
  return master_slide_node_ != NULL ? *master_slide_node_ : *default_instance_->master_slide_node_;
}
inline ::TSP::Reference* CommandInsertMasterArchive::mutable_master_slide_node() {
  set_has_master_slide_node();
  if (master_slide_node_ == NULL) master_slide_node_ = new ::TSP::Reference;
  return master_slide_node_;
}
inline ::TSP::Reference* CommandInsertMasterArchive::release_master_slide_node() {
  clear_has_master_slide_node();
  ::TSP::Reference* temp = master_slide_node_;
  master_slide_node_ = NULL;
  return temp;
}
inline void CommandInsertMasterArchive::set_allocated_master_slide_node(::TSP::Reference* master_slide_node) {
  delete master_slide_node_;
  master_slide_node_ = master_slide_node;
  if (master_slide_node) {
    set_has_master_slide_node();
  } else {
    clear_has_master_slide_node();
  }
}

// required uint32 insertion_index = 4;
inline bool CommandInsertMasterArchive::has_insertion_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInsertMasterArchive::set_has_insertion_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInsertMasterArchive::clear_has_insertion_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInsertMasterArchive::clear_insertion_index() {
  insertion_index_ = 0u;
  clear_has_insertion_index();
}
inline ::google::protobuf::uint32 CommandInsertMasterArchive::insertion_index() const {
  return insertion_index_;
}
inline void CommandInsertMasterArchive::set_insertion_index(::google::protobuf::uint32 value) {
  set_has_insertion_index();
  insertion_index_ = value;
}

// required bool was_inserted_with_drop = 5;
inline bool CommandInsertMasterArchive::has_was_inserted_with_drop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandInsertMasterArchive::set_has_was_inserted_with_drop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandInsertMasterArchive::clear_has_was_inserted_with_drop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandInsertMasterArchive::clear_was_inserted_with_drop() {
  was_inserted_with_drop_ = false;
  clear_has_was_inserted_with_drop();
}
inline bool CommandInsertMasterArchive::was_inserted_with_drop() const {
  return was_inserted_with_drop_;
}
inline void CommandInsertMasterArchive::set_was_inserted_with_drop(bool value) {
  set_has_was_inserted_with_drop();
  was_inserted_with_drop_ = value;
}

// -------------------------------------------------------------------

// CommandRemoveMasterArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandRemoveMasterArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRemoveMasterArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRemoveMasterArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRemoveMasterArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandRemoveMasterArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandRemoveMasterArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandRemoveMasterArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRemoveMasterArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference theme = 2;
inline bool CommandRemoveMasterArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRemoveMasterArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRemoveMasterArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRemoveMasterArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& CommandRemoveMasterArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* CommandRemoveMasterArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* CommandRemoveMasterArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void CommandRemoveMasterArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .TSP.Reference master_slide_node = 3;
inline bool CommandRemoveMasterArchive::has_master_slide_node() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRemoveMasterArchive::set_has_master_slide_node() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRemoveMasterArchive::clear_has_master_slide_node() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRemoveMasterArchive::clear_master_slide_node() {
  if (master_slide_node_ != NULL) master_slide_node_->::TSP::Reference::Clear();
  clear_has_master_slide_node();
}
inline const ::TSP::Reference& CommandRemoveMasterArchive::master_slide_node() const {
  return master_slide_node_ != NULL ? *master_slide_node_ : *default_instance_->master_slide_node_;
}
inline ::TSP::Reference* CommandRemoveMasterArchive::mutable_master_slide_node() {
  set_has_master_slide_node();
  if (master_slide_node_ == NULL) master_slide_node_ = new ::TSP::Reference;
  return master_slide_node_;
}
inline ::TSP::Reference* CommandRemoveMasterArchive::release_master_slide_node() {
  clear_has_master_slide_node();
  ::TSP::Reference* temp = master_slide_node_;
  master_slide_node_ = NULL;
  return temp;
}
inline void CommandRemoveMasterArchive::set_allocated_master_slide_node(::TSP::Reference* master_slide_node) {
  delete master_slide_node_;
  master_slide_node_ = master_slide_node;
  if (master_slide_node) {
    set_has_master_slide_node();
  } else {
    clear_has_master_slide_node();
  }
}

// required uint32 previous_index = 4;
inline bool CommandRemoveMasterArchive::has_previous_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRemoveMasterArchive::set_has_previous_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRemoveMasterArchive::clear_has_previous_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRemoveMasterArchive::clear_previous_index() {
  previous_index_ = 0u;
  clear_has_previous_index();
}
inline ::google::protobuf::uint32 CommandRemoveMasterArchive::previous_index() const {
  return previous_index_;
}
inline void CommandRemoveMasterArchive::set_previous_index(::google::protobuf::uint32 value) {
  set_has_previous_index();
  previous_index_ = value;
}

// optional .TSP.Reference master_change_commands = 5;
inline bool CommandRemoveMasterArchive::has_master_change_commands() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRemoveMasterArchive::set_has_master_change_commands() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRemoveMasterArchive::clear_has_master_change_commands() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRemoveMasterArchive::clear_master_change_commands() {
  if (master_change_commands_ != NULL) master_change_commands_->::TSP::Reference::Clear();
  clear_has_master_change_commands();
}
inline const ::TSP::Reference& CommandRemoveMasterArchive::master_change_commands() const {
  return master_change_commands_ != NULL ? *master_change_commands_ : *default_instance_->master_change_commands_;
}
inline ::TSP::Reference* CommandRemoveMasterArchive::mutable_master_change_commands() {
  set_has_master_change_commands();
  if (master_change_commands_ == NULL) master_change_commands_ = new ::TSP::Reference;
  return master_change_commands_;
}
inline ::TSP::Reference* CommandRemoveMasterArchive::release_master_change_commands() {
  clear_has_master_change_commands();
  ::TSP::Reference* temp = master_change_commands_;
  master_change_commands_ = NULL;
  return temp;
}
inline void CommandRemoveMasterArchive::set_allocated_master_change_commands(::TSP::Reference* master_change_commands) {
  delete master_change_commands_;
  master_change_commands_ = master_change_commands;
  if (master_change_commands) {
    set_has_master_change_commands();
  } else {
    clear_has_master_change_commands();
  }
}

// -------------------------------------------------------------------

// CommandRenameMasterArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandRenameMasterArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRenameMasterArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRenameMasterArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRenameMasterArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandRenameMasterArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandRenameMasterArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandRenameMasterArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRenameMasterArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference master_slide = 2;
inline bool CommandRenameMasterArchive::has_master_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRenameMasterArchive::set_has_master_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRenameMasterArchive::clear_has_master_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRenameMasterArchive::clear_master_slide() {
  if (master_slide_ != NULL) master_slide_->::TSP::Reference::Clear();
  clear_has_master_slide();
}
inline const ::TSP::Reference& CommandRenameMasterArchive::master_slide() const {
  return master_slide_ != NULL ? *master_slide_ : *default_instance_->master_slide_;
}
inline ::TSP::Reference* CommandRenameMasterArchive::mutable_master_slide() {
  set_has_master_slide();
  if (master_slide_ == NULL) master_slide_ = new ::TSP::Reference;
  return master_slide_;
}
inline ::TSP::Reference* CommandRenameMasterArchive::release_master_slide() {
  clear_has_master_slide();
  ::TSP::Reference* temp = master_slide_;
  master_slide_ = NULL;
  return temp;
}
inline void CommandRenameMasterArchive::set_allocated_master_slide(::TSP::Reference* master_slide) {
  delete master_slide_;
  master_slide_ = master_slide;
  if (master_slide) {
    set_has_master_slide();
  } else {
    clear_has_master_slide();
  }
}

// required string master_name = 3;
inline bool CommandRenameMasterArchive::has_master_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRenameMasterArchive::set_has_master_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRenameMasterArchive::clear_has_master_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRenameMasterArchive::clear_master_name() {
  if (master_name_ != &::google::protobuf::internal::kEmptyString) {
    master_name_->clear();
  }
  clear_has_master_name();
}
inline const ::std::string& CommandRenameMasterArchive::master_name() const {
  return *master_name_;
}
inline void CommandRenameMasterArchive::set_master_name(const ::std::string& value) {
  set_has_master_name();
  if (master_name_ == &::google::protobuf::internal::kEmptyString) {
    master_name_ = new ::std::string;
  }
  master_name_->assign(value);
}
inline void CommandRenameMasterArchive::set_master_name(const char* value) {
  set_has_master_name();
  if (master_name_ == &::google::protobuf::internal::kEmptyString) {
    master_name_ = new ::std::string;
  }
  master_name_->assign(value);
}
inline void CommandRenameMasterArchive::set_master_name(const char* value, size_t size) {
  set_has_master_name();
  if (master_name_ == &::google::protobuf::internal::kEmptyString) {
    master_name_ = new ::std::string;
  }
  master_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandRenameMasterArchive::mutable_master_name() {
  set_has_master_name();
  if (master_name_ == &::google::protobuf::internal::kEmptyString) {
    master_name_ = new ::std::string;
  }
  return master_name_;
}
inline ::std::string* CommandRenameMasterArchive::release_master_name() {
  clear_has_master_name();
  if (master_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = master_name_;
    master_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandRenameMasterArchive::set_allocated_master_name(::std::string* master_name) {
  if (master_name_ != &::google::protobuf::internal::kEmptyString) {
    delete master_name_;
  }
  if (master_name) {
    set_has_master_name();
    master_name_ = master_name;
  } else {
    clear_has_master_name();
    master_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string old_master_name = 4;
inline bool CommandRenameMasterArchive::has_old_master_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRenameMasterArchive::set_has_old_master_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRenameMasterArchive::clear_has_old_master_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRenameMasterArchive::clear_old_master_name() {
  if (old_master_name_ != &::google::protobuf::internal::kEmptyString) {
    old_master_name_->clear();
  }
  clear_has_old_master_name();
}
inline const ::std::string& CommandRenameMasterArchive::old_master_name() const {
  return *old_master_name_;
}
inline void CommandRenameMasterArchive::set_old_master_name(const ::std::string& value) {
  set_has_old_master_name();
  if (old_master_name_ == &::google::protobuf::internal::kEmptyString) {
    old_master_name_ = new ::std::string;
  }
  old_master_name_->assign(value);
}
inline void CommandRenameMasterArchive::set_old_master_name(const char* value) {
  set_has_old_master_name();
  if (old_master_name_ == &::google::protobuf::internal::kEmptyString) {
    old_master_name_ = new ::std::string;
  }
  old_master_name_->assign(value);
}
inline void CommandRenameMasterArchive::set_old_master_name(const char* value, size_t size) {
  set_has_old_master_name();
  if (old_master_name_ == &::google::protobuf::internal::kEmptyString) {
    old_master_name_ = new ::std::string;
  }
  old_master_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandRenameMasterArchive::mutable_old_master_name() {
  set_has_old_master_name();
  if (old_master_name_ == &::google::protobuf::internal::kEmptyString) {
    old_master_name_ = new ::std::string;
  }
  return old_master_name_;
}
inline ::std::string* CommandRenameMasterArchive::release_old_master_name() {
  clear_has_old_master_name();
  if (old_master_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_master_name_;
    old_master_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandRenameMasterArchive::set_allocated_old_master_name(::std::string* old_master_name) {
  if (old_master_name_ != &::google::protobuf::internal::kEmptyString) {
    delete old_master_name_;
  }
  if (old_master_name) {
    set_has_old_master_name();
    old_master_name_ = old_master_name;
  } else {
    clear_has_old_master_name();
    old_master_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandSlideInsertBuildArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideInsertBuildArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideInsertBuildArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideInsertBuildArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideInsertBuildArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideInsertBuildArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideInsertBuildArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideInsertBuildArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideInsertBuildArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideInsertBuildArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideInsertBuildArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideInsertBuildArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideInsertBuildArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideInsertBuildArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideInsertBuildArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideInsertBuildArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideInsertBuildArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required .TSP.Reference build = 3;
inline bool CommandSlideInsertBuildArchive::has_build() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideInsertBuildArchive::set_has_build() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideInsertBuildArchive::clear_has_build() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideInsertBuildArchive::clear_build() {
  if (build_ != NULL) build_->::TSP::Reference::Clear();
  clear_has_build();
}
inline const ::TSP::Reference& CommandSlideInsertBuildArchive::build() const {
  return build_ != NULL ? *build_ : *default_instance_->build_;
}
inline ::TSP::Reference* CommandSlideInsertBuildArchive::mutable_build() {
  set_has_build();
  if (build_ == NULL) build_ = new ::TSP::Reference;
  return build_;
}
inline ::TSP::Reference* CommandSlideInsertBuildArchive::release_build() {
  clear_has_build();
  ::TSP::Reference* temp = build_;
  build_ = NULL;
  return temp;
}
inline void CommandSlideInsertBuildArchive::set_allocated_build(::TSP::Reference* build) {
  delete build_;
  build_ = build;
  if (build) {
    set_has_build();
  } else {
    clear_has_build();
  }
}

// required uint32 index = 4;
inline bool CommandSlideInsertBuildArchive::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideInsertBuildArchive::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideInsertBuildArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideInsertBuildArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandSlideInsertBuildArchive::index() const {
  return index_;
}
inline void CommandSlideInsertBuildArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional bool shouldCreateChunks = 5;
inline bool CommandSlideInsertBuildArchive::has_shouldcreatechunks() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSlideInsertBuildArchive::set_has_shouldcreatechunks() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSlideInsertBuildArchive::clear_has_shouldcreatechunks() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSlideInsertBuildArchive::clear_shouldcreatechunks() {
  shouldcreatechunks_ = false;
  clear_has_shouldcreatechunks();
}
inline bool CommandSlideInsertBuildArchive::shouldcreatechunks() const {
  return shouldcreatechunks_;
}
inline void CommandSlideInsertBuildArchive::set_shouldcreatechunks(bool value) {
  set_has_shouldcreatechunks();
  shouldcreatechunks_ = value;
}

// -------------------------------------------------------------------

// CommandSlideRemoveBuildArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideRemoveBuildArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideRemoveBuildArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideRemoveBuildArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideRemoveBuildArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideRemoveBuildArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideRemoveBuildArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideRemoveBuildArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideRemoveBuildArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideRemoveBuildArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideRemoveBuildArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideRemoveBuildArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideRemoveBuildArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideRemoveBuildArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideRemoveBuildArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideRemoveBuildArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideRemoveBuildArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required .TSP.Reference build = 3;
inline bool CommandSlideRemoveBuildArchive::has_build() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideRemoveBuildArchive::set_has_build() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideRemoveBuildArchive::clear_has_build() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideRemoveBuildArchive::clear_build() {
  if (build_ != NULL) build_->::TSP::Reference::Clear();
  clear_has_build();
}
inline const ::TSP::Reference& CommandSlideRemoveBuildArchive::build() const {
  return build_ != NULL ? *build_ : *default_instance_->build_;
}
inline ::TSP::Reference* CommandSlideRemoveBuildArchive::mutable_build() {
  set_has_build();
  if (build_ == NULL) build_ = new ::TSP::Reference;
  return build_;
}
inline ::TSP::Reference* CommandSlideRemoveBuildArchive::release_build() {
  clear_has_build();
  ::TSP::Reference* temp = build_;
  build_ = NULL;
  return temp;
}
inline void CommandSlideRemoveBuildArchive::set_allocated_build(::TSP::Reference* build) {
  delete build_;
  build_ = build;
  if (build) {
    set_has_build();
  } else {
    clear_has_build();
  }
}

// required uint32 index = 4;
inline bool CommandSlideRemoveBuildArchive::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideRemoveBuildArchive::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideRemoveBuildArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideRemoveBuildArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandSlideRemoveBuildArchive::index() const {
  return index_;
}
inline void CommandSlideRemoveBuildArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// CommandSlideMoveBuildWithoutMovingChunksArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideMoveBuildWithoutMovingChunksArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideMoveBuildWithoutMovingChunksArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildWithoutMovingChunksArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildWithoutMovingChunksArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandSlideMoveBuildWithoutMovingChunksArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandSlideMoveBuildWithoutMovingChunksArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandSlideMoveBuildWithoutMovingChunksArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandSlideMoveBuildWithoutMovingChunksArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required uint32 index = 3;
inline bool CommandSlideMoveBuildWithoutMovingChunksArchive::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandSlideMoveBuildWithoutMovingChunksArchive::index() const {
  return index_;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 oldIndex = 4;
inline bool CommandSlideMoveBuildWithoutMovingChunksArchive::has_oldindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_has_oldindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_has_oldindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::clear_oldindex() {
  oldindex_ = 0u;
  clear_has_oldindex();
}
inline ::google::protobuf::uint32 CommandSlideMoveBuildWithoutMovingChunksArchive::oldindex() const {
  return oldindex_;
}
inline void CommandSlideMoveBuildWithoutMovingChunksArchive::set_oldindex(::google::protobuf::uint32 value) {
  set_has_oldindex();
  oldindex_ = value;
}

// -------------------------------------------------------------------

// CommandSlideMoveBuildsArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideMoveBuildsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideMoveBuildsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideMoveBuildsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideMoveBuildsArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideMoveBuildsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildsArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideMoveBuildsArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference builds = 2;
inline int CommandSlideMoveBuildsArchive::builds_size() const {
  return builds_.size();
}
inline void CommandSlideMoveBuildsArchive::clear_builds() {
  builds_.Clear();
}
inline const ::TSP::Reference& CommandSlideMoveBuildsArchive::builds(int index) const {
  return builds_.Get(index);
}
inline ::TSP::Reference* CommandSlideMoveBuildsArchive::mutable_builds(int index) {
  return builds_.Mutable(index);
}
inline ::TSP::Reference* CommandSlideMoveBuildsArchive::add_builds() {
  return builds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSlideMoveBuildsArchive::builds() const {
  return builds_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSlideMoveBuildsArchive::mutable_builds() {
  return &builds_;
}

// optional uint32 toIndex = 3;
inline bool CommandSlideMoveBuildsArchive::has_toindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideMoveBuildsArchive::set_has_toindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideMoveBuildsArchive::clear_has_toindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideMoveBuildsArchive::clear_toindex() {
  toindex_ = 0u;
  clear_has_toindex();
}
inline ::google::protobuf::uint32 CommandSlideMoveBuildsArchive::toindex() const {
  return toindex_;
}
inline void CommandSlideMoveBuildsArchive::set_toindex(::google::protobuf::uint32 value) {
  set_has_toindex();
  toindex_ = value;
}

// -------------------------------------------------------------------

// CommandSlideInsertBuildChunkArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideInsertBuildChunkArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideInsertBuildChunkArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideInsertBuildChunkArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideInsertBuildChunkArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideInsertBuildChunkArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideInsertBuildChunkArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlideInsertBuildChunkArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideInsertBuildChunkArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlideInsertBuildChunkArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlideInsertBuildChunkArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlideInsertBuildChunkArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlideInsertBuildChunkArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required .KN.BuildChunkArchive buildChunk = 3;
inline bool CommandSlideInsertBuildChunkArchive::has_buildchunk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideInsertBuildChunkArchive::set_has_buildchunk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_has_buildchunk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_buildchunk() {
  if (buildchunk_ != NULL) buildchunk_->::KN::BuildChunkArchive::Clear();
  clear_has_buildchunk();
}
inline const ::KN::BuildChunkArchive& CommandSlideInsertBuildChunkArchive::buildchunk() const {
  return buildchunk_ != NULL ? *buildchunk_ : *default_instance_->buildchunk_;
}
inline ::KN::BuildChunkArchive* CommandSlideInsertBuildChunkArchive::mutable_buildchunk() {
  set_has_buildchunk();
  if (buildchunk_ == NULL) buildchunk_ = new ::KN::BuildChunkArchive;
  return buildchunk_;
}
inline ::KN::BuildChunkArchive* CommandSlideInsertBuildChunkArchive::release_buildchunk() {
  clear_has_buildchunk();
  ::KN::BuildChunkArchive* temp = buildchunk_;
  buildchunk_ = NULL;
  return temp;
}
inline void CommandSlideInsertBuildChunkArchive::set_allocated_buildchunk(::KN::BuildChunkArchive* buildchunk) {
  delete buildchunk_;
  buildchunk_ = buildchunk;
  if (buildchunk) {
    set_has_buildchunk();
  } else {
    clear_has_buildchunk();
  }
}

// required uint32 index = 4;
inline bool CommandSlideInsertBuildChunkArchive::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideInsertBuildChunkArchive::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideInsertBuildChunkArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandSlideInsertBuildChunkArchive::index() const {
  return index_;
}
inline void CommandSlideInsertBuildChunkArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// CommandSlideRemoveBuildChunkArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideRemoveBuildChunkArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideRemoveBuildChunkArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideRemoveBuildChunkArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideRemoveBuildChunkArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideRemoveBuildChunkArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideRemoveBuildChunkArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlideRemoveBuildChunkArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideRemoveBuildChunkArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlideRemoveBuildChunkArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlideRemoveBuildChunkArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlideRemoveBuildChunkArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlideRemoveBuildChunkArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required .KN.BuildChunkArchive buildChunk = 3;
inline bool CommandSlideRemoveBuildChunkArchive::has_buildchunk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideRemoveBuildChunkArchive::set_has_buildchunk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_has_buildchunk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_buildchunk() {
  if (buildchunk_ != NULL) buildchunk_->::KN::BuildChunkArchive::Clear();
  clear_has_buildchunk();
}
inline const ::KN::BuildChunkArchive& CommandSlideRemoveBuildChunkArchive::buildchunk() const {
  return buildchunk_ != NULL ? *buildchunk_ : *default_instance_->buildchunk_;
}
inline ::KN::BuildChunkArchive* CommandSlideRemoveBuildChunkArchive::mutable_buildchunk() {
  set_has_buildchunk();
  if (buildchunk_ == NULL) buildchunk_ = new ::KN::BuildChunkArchive;
  return buildchunk_;
}
inline ::KN::BuildChunkArchive* CommandSlideRemoveBuildChunkArchive::release_buildchunk() {
  clear_has_buildchunk();
  ::KN::BuildChunkArchive* temp = buildchunk_;
  buildchunk_ = NULL;
  return temp;
}
inline void CommandSlideRemoveBuildChunkArchive::set_allocated_buildchunk(::KN::BuildChunkArchive* buildchunk) {
  delete buildchunk_;
  buildchunk_ = buildchunk;
  if (buildchunk) {
    set_has_buildchunk();
  } else {
    clear_has_buildchunk();
  }
}

// required uint32 index = 4;
inline bool CommandSlideRemoveBuildChunkArchive::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideRemoveBuildChunkArchive::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideRemoveBuildChunkArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandSlideRemoveBuildChunkArchive::index() const {
  return index_;
}
inline void CommandSlideRemoveBuildChunkArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// CommandSlideMoveBuildChunkArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideMoveBuildChunkArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideMoveBuildChunkArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideMoveBuildChunkArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildChunkArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildChunkArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideMoveBuildChunkArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlideMoveBuildChunkArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideMoveBuildChunkArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlideMoveBuildChunkArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlideMoveBuildChunkArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlideMoveBuildChunkArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlideMoveBuildChunkArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required uint32 index = 3;
inline bool CommandSlideMoveBuildChunkArchive::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideMoveBuildChunkArchive::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandSlideMoveBuildChunkArchive::index() const {
  return index_;
}
inline void CommandSlideMoveBuildChunkArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 oldIndex = 4;
inline bool CommandSlideMoveBuildChunkArchive::has_oldindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlideMoveBuildChunkArchive::set_has_oldindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_has_oldindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlideMoveBuildChunkArchive::clear_oldindex() {
  oldindex_ = 0u;
  clear_has_oldindex();
}
inline ::google::protobuf::uint32 CommandSlideMoveBuildChunkArchive::oldindex() const {
  return oldindex_;
}
inline void CommandSlideMoveBuildChunkArchive::set_oldindex(::google::protobuf::uint32 value) {
  set_has_oldindex();
  oldindex_ = value;
}

// -------------------------------------------------------------------

// CommandSlideMoveBuildChunksArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideMoveBuildChunksArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideMoveBuildChunksArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideMoveBuildChunksArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideMoveBuildChunksArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideMoveBuildChunksArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildChunksArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideMoveBuildChunksArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideMoveBuildChunksArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .KN.BuildChunkArchive buildChunks = 2;
inline int CommandSlideMoveBuildChunksArchive::buildchunks_size() const {
  return buildchunks_.size();
}
inline void CommandSlideMoveBuildChunksArchive::clear_buildchunks() {
  buildchunks_.Clear();
}
inline const ::KN::BuildChunkArchive& CommandSlideMoveBuildChunksArchive::buildchunks(int index) const {
  return buildchunks_.Get(index);
}
inline ::KN::BuildChunkArchive* CommandSlideMoveBuildChunksArchive::mutable_buildchunks(int index) {
  return buildchunks_.Mutable(index);
}
inline ::KN::BuildChunkArchive* CommandSlideMoveBuildChunksArchive::add_buildchunks() {
  return buildchunks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >&
CommandSlideMoveBuildChunksArchive::buildchunks() const {
  return buildchunks_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >*
CommandSlideMoveBuildChunksArchive::mutable_buildchunks() {
  return &buildchunks_;
}

// optional uint32 toIndex = 3;
inline bool CommandSlideMoveBuildChunksArchive::has_toindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlideMoveBuildChunksArchive::set_has_toindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlideMoveBuildChunksArchive::clear_has_toindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlideMoveBuildChunksArchive::clear_toindex() {
  toindex_ = 0u;
  clear_has_toindex();
}
inline ::google::protobuf::uint32 CommandSlideMoveBuildChunksArchive::toindex() const {
  return toindex_;
}
inline void CommandSlideMoveBuildChunksArchive::set_toindex(::google::protobuf::uint32 value) {
  set_has_toindex();
  toindex_ = value;
}

// -------------------------------------------------------------------

// CommandBuildSetValueArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandBuildSetValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandBuildSetValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandBuildSetValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandBuildSetValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandBuildSetValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandBuildSetValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandBuildSetValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandBuildSetValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference build = 2;
inline bool CommandBuildSetValueArchive::has_build() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandBuildSetValueArchive::set_has_build() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandBuildSetValueArchive::clear_has_build() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandBuildSetValueArchive::clear_build() {
  if (build_ != NULL) build_->::TSP::Reference::Clear();
  clear_has_build();
}
inline const ::TSP::Reference& CommandBuildSetValueArchive::build() const {
  return build_ != NULL ? *build_ : *default_instance_->build_;
}
inline ::TSP::Reference* CommandBuildSetValueArchive::mutable_build() {
  set_has_build();
  if (build_ == NULL) build_ = new ::TSP::Reference;
  return build_;
}
inline ::TSP::Reference* CommandBuildSetValueArchive::release_build() {
  clear_has_build();
  ::TSP::Reference* temp = build_;
  build_ = NULL;
  return temp;
}
inline void CommandBuildSetValueArchive::set_allocated_build(::TSP::Reference* build) {
  delete build_;
  build_ = build;
  if (build) {
    set_has_build();
  } else {
    clear_has_build();
  }
}

// required string property = 3;
inline bool CommandBuildSetValueArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandBuildSetValueArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandBuildSetValueArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandBuildSetValueArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandBuildSetValueArchive::property() const {
  return *property_;
}
inline void CommandBuildSetValueArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandBuildSetValueArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandBuildSetValueArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandBuildSetValueArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandBuildSetValueArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandBuildSetValueArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string effects = 4;
inline int CommandBuildSetValueArchive::effects_size() const {
  return effects_.size();
}
inline void CommandBuildSetValueArchive::clear_effects() {
  effects_.Clear();
}
inline const ::std::string& CommandBuildSetValueArchive::effects(int index) const {
  return effects_.Get(index);
}
inline ::std::string* CommandBuildSetValueArchive::mutable_effects(int index) {
  return effects_.Mutable(index);
}
inline void CommandBuildSetValueArchive::set_effects(int index, const ::std::string& value) {
  effects_.Mutable(index)->assign(value);
}
inline void CommandBuildSetValueArchive::set_effects(int index, const char* value) {
  effects_.Mutable(index)->assign(value);
}
inline void CommandBuildSetValueArchive::set_effects(int index, const char* value, size_t size) {
  effects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandBuildSetValueArchive::add_effects() {
  return effects_.Add();
}
inline void CommandBuildSetValueArchive::add_effects(const ::std::string& value) {
  effects_.Add()->assign(value);
}
inline void CommandBuildSetValueArchive::add_effects(const char* value) {
  effects_.Add()->assign(value);
}
inline void CommandBuildSetValueArchive::add_effects(const char* value, size_t size) {
  effects_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandBuildSetValueArchive::effects() const {
  return effects_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandBuildSetValueArchive::mutable_effects() {
  return &effects_;
}

// repeated string types = 5;
inline int CommandBuildSetValueArchive::types_size() const {
  return types_.size();
}
inline void CommandBuildSetValueArchive::clear_types() {
  types_.Clear();
}
inline const ::std::string& CommandBuildSetValueArchive::types(int index) const {
  return types_.Get(index);
}
inline ::std::string* CommandBuildSetValueArchive::mutable_types(int index) {
  return types_.Mutable(index);
}
inline void CommandBuildSetValueArchive::set_types(int index, const ::std::string& value) {
  types_.Mutable(index)->assign(value);
}
inline void CommandBuildSetValueArchive::set_types(int index, const char* value) {
  types_.Mutable(index)->assign(value);
}
inline void CommandBuildSetValueArchive::set_types(int index, const char* value, size_t size) {
  types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandBuildSetValueArchive::add_types() {
  return types_.Add();
}
inline void CommandBuildSetValueArchive::add_types(const ::std::string& value) {
  types_.Add()->assign(value);
}
inline void CommandBuildSetValueArchive::add_types(const char* value) {
  types_.Add()->assign(value);
}
inline void CommandBuildSetValueArchive::add_types(const char* value, size_t size) {
  types_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandBuildSetValueArchive::types() const {
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandBuildSetValueArchive::mutable_types() {
  return &types_;
}

// repeated string deliveries = 6;
inline int CommandBuildSetValueArchive::deliveries_size() const {
  return deliveries_.size();
}
inline void CommandBuildSetValueArchive::clear_deliveries() {
  deliveries_.Clear();
}
inline const ::std::string& CommandBuildSetValueArchive::deliveries(int index) const {
  return deliveries_.Get(index);
}
inline ::std::string* CommandBuildSetValueArchive::mutable_deliveries(int index) {
  return deliveries_.Mutable(index);
}
inline void CommandBuildSetValueArchive::set_deliveries(int index, const ::std::string& value) {
  deliveries_.Mutable(index)->assign(value);
}
inline void CommandBuildSetValueArchive::set_deliveries(int index, const char* value) {
  deliveries_.Mutable(index)->assign(value);
}
inline void CommandBuildSetValueArchive::set_deliveries(int index, const char* value, size_t size) {
  deliveries_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandBuildSetValueArchive::add_deliveries() {
  return deliveries_.Add();
}
inline void CommandBuildSetValueArchive::add_deliveries(const ::std::string& value) {
  deliveries_.Add()->assign(value);
}
inline void CommandBuildSetValueArchive::add_deliveries(const char* value) {
  deliveries_.Add()->assign(value);
}
inline void CommandBuildSetValueArchive::add_deliveries(const char* value, size_t size) {
  deliveries_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandBuildSetValueArchive::deliveries() const {
  return deliveries_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandBuildSetValueArchive::mutable_deliveries() {
  return &deliveries_;
}

// repeated uint32 directions = 7;
inline int CommandBuildSetValueArchive::directions_size() const {
  return directions_.size();
}
inline void CommandBuildSetValueArchive::clear_directions() {
  directions_.Clear();
}
inline ::google::protobuf::uint32 CommandBuildSetValueArchive::directions(int index) const {
  return directions_.Get(index);
}
inline void CommandBuildSetValueArchive::set_directions(int index, ::google::protobuf::uint32 value) {
  directions_.Set(index, value);
}
inline void CommandBuildSetValueArchive::add_directions(::google::protobuf::uint32 value) {
  directions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandBuildSetValueArchive::directions() const {
  return directions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandBuildSetValueArchive::mutable_directions() {
  return &directions_;
}

// repeated double durations = 8;
inline int CommandBuildSetValueArchive::durations_size() const {
  return durations_.size();
}
inline void CommandBuildSetValueArchive::clear_durations() {
  durations_.Clear();
}
inline double CommandBuildSetValueArchive::durations(int index) const {
  return durations_.Get(index);
}
inline void CommandBuildSetValueArchive::set_durations(int index, double value) {
  durations_.Set(index, value);
}
inline void CommandBuildSetValueArchive::add_durations(double value) {
  durations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandBuildSetValueArchive::durations() const {
  return durations_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandBuildSetValueArchive::mutable_durations() {
  return &durations_;
}

// repeated double delays = 9;
inline int CommandBuildSetValueArchive::delays_size() const {
  return delays_.size();
}
inline void CommandBuildSetValueArchive::clear_delays() {
  delays_.Clear();
}
inline double CommandBuildSetValueArchive::delays(int index) const {
  return delays_.Get(index);
}
inline void CommandBuildSetValueArchive::set_delays(int index, double value) {
  delays_.Set(index, value);
}
inline void CommandBuildSetValueArchive::add_delays(double value) {
  delays_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandBuildSetValueArchive::delays() const {
  return delays_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandBuildSetValueArchive::mutable_delays() {
  return &delays_;
}

// repeated double delayAutomaticAfters = 10;
inline int CommandBuildSetValueArchive::delayautomaticafters_size() const {
  return delayautomaticafters_.size();
}
inline void CommandBuildSetValueArchive::clear_delayautomaticafters() {
  delayautomaticafters_.Clear();
}
inline double CommandBuildSetValueArchive::delayautomaticafters(int index) const {
  return delayautomaticafters_.Get(index);
}
inline void CommandBuildSetValueArchive::set_delayautomaticafters(int index, double value) {
  delayautomaticafters_.Set(index, value);
}
inline void CommandBuildSetValueArchive::add_delayautomaticafters(double value) {
  delayautomaticafters_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandBuildSetValueArchive::delayautomaticafters() const {
  return delayautomaticafters_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandBuildSetValueArchive::mutable_delayautomaticafters() {
  return &delayautomaticafters_;
}

// repeated double delayAutomaticWiths = 11;
inline int CommandBuildSetValueArchive::delayautomaticwiths_size() const {
  return delayautomaticwiths_.size();
}
inline void CommandBuildSetValueArchive::clear_delayautomaticwiths() {
  delayautomaticwiths_.Clear();
}
inline double CommandBuildSetValueArchive::delayautomaticwiths(int index) const {
  return delayautomaticwiths_.Get(index);
}
inline void CommandBuildSetValueArchive::set_delayautomaticwiths(int index, double value) {
  delayautomaticwiths_.Set(index, value);
}
inline void CommandBuildSetValueArchive::add_delayautomaticwiths(double value) {
  delayautomaticwiths_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandBuildSetValueArchive::delayautomaticwiths() const {
  return delayautomaticwiths_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandBuildSetValueArchive::mutable_delayautomaticwiths() {
  return &delayautomaticwiths_;
}

// repeated bool eventTriggers = 12;
inline int CommandBuildSetValueArchive::eventtriggers_size() const {
  return eventtriggers_.size();
}
inline void CommandBuildSetValueArchive::clear_eventtriggers() {
  eventtriggers_.Clear();
}
inline bool CommandBuildSetValueArchive::eventtriggers(int index) const {
  return eventtriggers_.Get(index);
}
inline void CommandBuildSetValueArchive::set_eventtriggers(int index, bool value) {
  eventtriggers_.Set(index, value);
}
inline void CommandBuildSetValueArchive::add_eventtriggers(bool value) {
  eventtriggers_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
CommandBuildSetValueArchive::eventtriggers() const {
  return eventtriggers_;
}
inline ::google::protobuf::RepeatedField< bool >*
CommandBuildSetValueArchive::mutable_eventtriggers() {
  return &eventtriggers_;
}

// -------------------------------------------------------------------

// CommandBuildChunkSetValueArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandBuildChunkSetValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandBuildChunkSetValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandBuildChunkSetValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandBuildChunkSetValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandBuildChunkSetValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandBuildChunkSetValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandBuildChunkSetValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandBuildChunkSetValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .KN.BuildChunkArchive buildChunk = 2;
inline bool CommandBuildChunkSetValueArchive::has_buildchunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandBuildChunkSetValueArchive::set_has_buildchunk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandBuildChunkSetValueArchive::clear_has_buildchunk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandBuildChunkSetValueArchive::clear_buildchunk() {
  if (buildchunk_ != NULL) buildchunk_->::KN::BuildChunkArchive::Clear();
  clear_has_buildchunk();
}
inline const ::KN::BuildChunkArchive& CommandBuildChunkSetValueArchive::buildchunk() const {
  return buildchunk_ != NULL ? *buildchunk_ : *default_instance_->buildchunk_;
}
inline ::KN::BuildChunkArchive* CommandBuildChunkSetValueArchive::mutable_buildchunk() {
  set_has_buildchunk();
  if (buildchunk_ == NULL) buildchunk_ = new ::KN::BuildChunkArchive;
  return buildchunk_;
}
inline ::KN::BuildChunkArchive* CommandBuildChunkSetValueArchive::release_buildchunk() {
  clear_has_buildchunk();
  ::KN::BuildChunkArchive* temp = buildchunk_;
  buildchunk_ = NULL;
  return temp;
}
inline void CommandBuildChunkSetValueArchive::set_allocated_buildchunk(::KN::BuildChunkArchive* buildchunk) {
  delete buildchunk_;
  buildchunk_ = buildchunk;
  if (buildchunk) {
    set_has_buildchunk();
  } else {
    clear_has_buildchunk();
  }
}

// required string property = 3;
inline bool CommandBuildChunkSetValueArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandBuildChunkSetValueArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandBuildChunkSetValueArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandBuildChunkSetValueArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandBuildChunkSetValueArchive::property() const {
  return *property_;
}
inline void CommandBuildChunkSetValueArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandBuildChunkSetValueArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandBuildChunkSetValueArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandBuildChunkSetValueArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandBuildChunkSetValueArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandBuildChunkSetValueArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 referents = 4;
inline int CommandBuildChunkSetValueArchive::referents_size() const {
  return referents_.size();
}
inline void CommandBuildChunkSetValueArchive::clear_referents() {
  referents_.Clear();
}
inline ::google::protobuf::uint32 CommandBuildChunkSetValueArchive::referents(int index) const {
  return referents_.Get(index);
}
inline void CommandBuildChunkSetValueArchive::set_referents(int index, ::google::protobuf::uint32 value) {
  referents_.Set(index, value);
}
inline void CommandBuildChunkSetValueArchive::add_referents(::google::protobuf::uint32 value) {
  referents_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandBuildChunkSetValueArchive::referents() const {
  return referents_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandBuildChunkSetValueArchive::mutable_referents() {
  return &referents_;
}

// repeated bool automatics = 5;
inline int CommandBuildChunkSetValueArchive::automatics_size() const {
  return automatics_.size();
}
inline void CommandBuildChunkSetValueArchive::clear_automatics() {
  automatics_.Clear();
}
inline bool CommandBuildChunkSetValueArchive::automatics(int index) const {
  return automatics_.Get(index);
}
inline void CommandBuildChunkSetValueArchive::set_automatics(int index, bool value) {
  automatics_.Set(index, value);
}
inline void CommandBuildChunkSetValueArchive::add_automatics(bool value) {
  automatics_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
CommandBuildChunkSetValueArchive::automatics() const {
  return automatics_;
}
inline ::google::protobuf::RepeatedField< bool >*
CommandBuildChunkSetValueArchive::mutable_automatics() {
  return &automatics_;
}

// repeated double durations = 6;
inline int CommandBuildChunkSetValueArchive::durations_size() const {
  return durations_.size();
}
inline void CommandBuildChunkSetValueArchive::clear_durations() {
  durations_.Clear();
}
inline double CommandBuildChunkSetValueArchive::durations(int index) const {
  return durations_.Get(index);
}
inline void CommandBuildChunkSetValueArchive::set_durations(int index, double value) {
  durations_.Set(index, value);
}
inline void CommandBuildChunkSetValueArchive::add_durations(double value) {
  durations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandBuildChunkSetValueArchive::durations() const {
  return durations_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandBuildChunkSetValueArchive::mutable_durations() {
  return &durations_;
}

// repeated double delays = 7;
inline int CommandBuildChunkSetValueArchive::delays_size() const {
  return delays_.size();
}
inline void CommandBuildChunkSetValueArchive::clear_delays() {
  delays_.Clear();
}
inline double CommandBuildChunkSetValueArchive::delays(int index) const {
  return delays_.Get(index);
}
inline void CommandBuildChunkSetValueArchive::set_delays(int index, double value) {
  delays_.Set(index, value);
}
inline void CommandBuildChunkSetValueArchive::add_delays(double value) {
  delays_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandBuildChunkSetValueArchive::delays() const {
  return delays_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandBuildChunkSetValueArchive::mutable_delays() {
  return &delays_;
}

// optional bool oldOwnsValue = 8;
inline bool CommandBuildChunkSetValueArchive::has_oldownsvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandBuildChunkSetValueArchive::set_has_oldownsvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandBuildChunkSetValueArchive::clear_has_oldownsvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandBuildChunkSetValueArchive::clear_oldownsvalue() {
  oldownsvalue_ = false;
  clear_has_oldownsvalue();
}
inline bool CommandBuildChunkSetValueArchive::oldownsvalue() const {
  return oldownsvalue_;
}
inline void CommandBuildChunkSetValueArchive::set_oldownsvalue(bool value) {
  set_has_oldownsvalue();
  oldownsvalue_ = value;
}

// -------------------------------------------------------------------

// CommandTransitionSetValueArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandTransitionSetValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandTransitionSetValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandTransitionSetValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandTransitionSetValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandTransitionSetValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandTransitionSetValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandTransitionSetValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandTransitionSetValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slideNode = 2;
inline bool CommandTransitionSetValueArchive::has_slidenode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandTransitionSetValueArchive::set_has_slidenode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandTransitionSetValueArchive::clear_has_slidenode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandTransitionSetValueArchive::clear_slidenode() {
  if (slidenode_ != NULL) slidenode_->::TSP::Reference::Clear();
  clear_has_slidenode();
}
inline const ::TSP::Reference& CommandTransitionSetValueArchive::slidenode() const {
  return slidenode_ != NULL ? *slidenode_ : *default_instance_->slidenode_;
}
inline ::TSP::Reference* CommandTransitionSetValueArchive::mutable_slidenode() {
  set_has_slidenode();
  if (slidenode_ == NULL) slidenode_ = new ::TSP::Reference;
  return slidenode_;
}
inline ::TSP::Reference* CommandTransitionSetValueArchive::release_slidenode() {
  clear_has_slidenode();
  ::TSP::Reference* temp = slidenode_;
  slidenode_ = NULL;
  return temp;
}
inline void CommandTransitionSetValueArchive::set_allocated_slidenode(::TSP::Reference* slidenode) {
  delete slidenode_;
  slidenode_ = slidenode;
  if (slidenode) {
    set_has_slidenode();
  } else {
    clear_has_slidenode();
  }
}

// required string property = 3;
inline bool CommandTransitionSetValueArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandTransitionSetValueArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandTransitionSetValueArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandTransitionSetValueArchive::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandTransitionSetValueArchive::property() const {
  return *property_;
}
inline void CommandTransitionSetValueArchive::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandTransitionSetValueArchive::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandTransitionSetValueArchive::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandTransitionSetValueArchive::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandTransitionSetValueArchive::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandTransitionSetValueArchive::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string effects = 4;
inline int CommandTransitionSetValueArchive::effects_size() const {
  return effects_.size();
}
inline void CommandTransitionSetValueArchive::clear_effects() {
  effects_.Clear();
}
inline const ::std::string& CommandTransitionSetValueArchive::effects(int index) const {
  return effects_.Get(index);
}
inline ::std::string* CommandTransitionSetValueArchive::mutable_effects(int index) {
  return effects_.Mutable(index);
}
inline void CommandTransitionSetValueArchive::set_effects(int index, const ::std::string& value) {
  effects_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_effects(int index, const char* value) {
  effects_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_effects(int index, const char* value, size_t size) {
  effects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandTransitionSetValueArchive::add_effects() {
  return effects_.Add();
}
inline void CommandTransitionSetValueArchive::add_effects(const ::std::string& value) {
  effects_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_effects(const char* value) {
  effects_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_effects(const char* value, size_t size) {
  effects_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandTransitionSetValueArchive::effects() const {
  return effects_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandTransitionSetValueArchive::mutable_effects() {
  return &effects_;
}

// repeated string unused = 5;
inline int CommandTransitionSetValueArchive::unused_size() const {
  return unused_.size();
}
inline void CommandTransitionSetValueArchive::clear_unused() {
  unused_.Clear();
}
inline const ::std::string& CommandTransitionSetValueArchive::unused(int index) const {
  return unused_.Get(index);
}
inline ::std::string* CommandTransitionSetValueArchive::mutable_unused(int index) {
  return unused_.Mutable(index);
}
inline void CommandTransitionSetValueArchive::set_unused(int index, const ::std::string& value) {
  unused_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_unused(int index, const char* value) {
  unused_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_unused(int index, const char* value, size_t size) {
  unused_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandTransitionSetValueArchive::add_unused() {
  return unused_.Add();
}
inline void CommandTransitionSetValueArchive::add_unused(const ::std::string& value) {
  unused_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_unused(const char* value) {
  unused_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_unused(const char* value, size_t size) {
  unused_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandTransitionSetValueArchive::unused() const {
  return unused_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandTransitionSetValueArchive::mutable_unused() {
  return &unused_;
}

// repeated string unused2 = 6;
inline int CommandTransitionSetValueArchive::unused2_size() const {
  return unused2_.size();
}
inline void CommandTransitionSetValueArchive::clear_unused2() {
  unused2_.Clear();
}
inline const ::std::string& CommandTransitionSetValueArchive::unused2(int index) const {
  return unused2_.Get(index);
}
inline ::std::string* CommandTransitionSetValueArchive::mutable_unused2(int index) {
  return unused2_.Mutable(index);
}
inline void CommandTransitionSetValueArchive::set_unused2(int index, const ::std::string& value) {
  unused2_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_unused2(int index, const char* value) {
  unused2_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_unused2(int index, const char* value, size_t size) {
  unused2_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandTransitionSetValueArchive::add_unused2() {
  return unused2_.Add();
}
inline void CommandTransitionSetValueArchive::add_unused2(const ::std::string& value) {
  unused2_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_unused2(const char* value) {
  unused2_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_unused2(const char* value, size_t size) {
  unused2_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandTransitionSetValueArchive::unused2() const {
  return unused2_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandTransitionSetValueArchive::mutable_unused2() {
  return &unused2_;
}

// repeated string unused3 = 7;
inline int CommandTransitionSetValueArchive::unused3_size() const {
  return unused3_.size();
}
inline void CommandTransitionSetValueArchive::clear_unused3() {
  unused3_.Clear();
}
inline const ::std::string& CommandTransitionSetValueArchive::unused3(int index) const {
  return unused3_.Get(index);
}
inline ::std::string* CommandTransitionSetValueArchive::mutable_unused3(int index) {
  return unused3_.Mutable(index);
}
inline void CommandTransitionSetValueArchive::set_unused3(int index, const ::std::string& value) {
  unused3_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_unused3(int index, const char* value) {
  unused3_.Mutable(index)->assign(value);
}
inline void CommandTransitionSetValueArchive::set_unused3(int index, const char* value, size_t size) {
  unused3_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandTransitionSetValueArchive::add_unused3() {
  return unused3_.Add();
}
inline void CommandTransitionSetValueArchive::add_unused3(const ::std::string& value) {
  unused3_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_unused3(const char* value) {
  unused3_.Add()->assign(value);
}
inline void CommandTransitionSetValueArchive::add_unused3(const char* value, size_t size) {
  unused3_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandTransitionSetValueArchive::unused3() const {
  return unused3_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandTransitionSetValueArchive::mutable_unused3() {
  return &unused3_;
}

// repeated double durations = 8;
inline int CommandTransitionSetValueArchive::durations_size() const {
  return durations_.size();
}
inline void CommandTransitionSetValueArchive::clear_durations() {
  durations_.Clear();
}
inline double CommandTransitionSetValueArchive::durations(int index) const {
  return durations_.Get(index);
}
inline void CommandTransitionSetValueArchive::set_durations(int index, double value) {
  durations_.Set(index, value);
}
inline void CommandTransitionSetValueArchive::add_durations(double value) {
  durations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandTransitionSetValueArchive::durations() const {
  return durations_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandTransitionSetValueArchive::mutable_durations() {
  return &durations_;
}

// repeated uint32 directions = 9;
inline int CommandTransitionSetValueArchive::directions_size() const {
  return directions_.size();
}
inline void CommandTransitionSetValueArchive::clear_directions() {
  directions_.Clear();
}
inline ::google::protobuf::uint32 CommandTransitionSetValueArchive::directions(int index) const {
  return directions_.Get(index);
}
inline void CommandTransitionSetValueArchive::set_directions(int index, ::google::protobuf::uint32 value) {
  directions_.Set(index, value);
}
inline void CommandTransitionSetValueArchive::add_directions(::google::protobuf::uint32 value) {
  directions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandTransitionSetValueArchive::directions() const {
  return directions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandTransitionSetValueArchive::mutable_directions() {
  return &directions_;
}

// repeated bool isAutomatics = 10;
inline int CommandTransitionSetValueArchive::isautomatics_size() const {
  return isautomatics_.size();
}
inline void CommandTransitionSetValueArchive::clear_isautomatics() {
  isautomatics_.Clear();
}
inline bool CommandTransitionSetValueArchive::isautomatics(int index) const {
  return isautomatics_.Get(index);
}
inline void CommandTransitionSetValueArchive::set_isautomatics(int index, bool value) {
  isautomatics_.Set(index, value);
}
inline void CommandTransitionSetValueArchive::add_isautomatics(bool value) {
  isautomatics_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
CommandTransitionSetValueArchive::isautomatics() const {
  return isautomatics_;
}
inline ::google::protobuf::RepeatedField< bool >*
CommandTransitionSetValueArchive::mutable_isautomatics() {
  return &isautomatics_;
}

// repeated double delays = 11;
inline int CommandTransitionSetValueArchive::delays_size() const {
  return delays_.size();
}
inline void CommandTransitionSetValueArchive::clear_delays() {
  delays_.Clear();
}
inline double CommandTransitionSetValueArchive::delays(int index) const {
  return delays_.Get(index);
}
inline void CommandTransitionSetValueArchive::set_delays(int index, double value) {
  delays_.Set(index, value);
}
inline void CommandTransitionSetValueArchive::add_delays(double value) {
  delays_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandTransitionSetValueArchive::delays() const {
  return delays_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandTransitionSetValueArchive::mutable_delays() {
  return &delays_;
}

// -------------------------------------------------------------------

// CommandShowSetSlideNumberVisibilityArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandShowSetSlideNumberVisibilityArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowSetSlideNumberVisibilityArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowSetSlideNumberVisibilityArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowSetSlideNumberVisibilityArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool CommandShowSetSlideNumberVisibilityArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowSetSlideNumberVisibilityArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowSetSlideNumberVisibilityArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowSetSlideNumberVisibilityArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// required bool slideNumbersVisible = 3;
inline bool CommandShowSetSlideNumberVisibilityArchive::has_slidenumbersvisible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_has_slidenumbersvisible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_has_slidenumbersvisible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_slidenumbersvisible() {
  slidenumbersvisible_ = false;
  clear_has_slidenumbersvisible();
}
inline bool CommandShowSetSlideNumberVisibilityArchive::slidenumbersvisible() const {
  return slidenumbersvisible_;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_slidenumbersvisible(bool value) {
  set_has_slidenumbersvisible();
  slidenumbersvisible_ = value;
}

// optional .TSP.Reference providerUndo = 4;
inline bool CommandShowSetSlideNumberVisibilityArchive::has_providerundo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_has_providerundo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_has_providerundo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowSetSlideNumberVisibilityArchive::clear_providerundo() {
  if (providerundo_ != NULL) providerundo_->::TSP::Reference::Clear();
  clear_has_providerundo();
}
inline const ::TSP::Reference& CommandShowSetSlideNumberVisibilityArchive::providerundo() const {
  return providerundo_ != NULL ? *providerundo_ : *default_instance_->providerundo_;
}
inline ::TSP::Reference* CommandShowSetSlideNumberVisibilityArchive::mutable_providerundo() {
  set_has_providerundo();
  if (providerundo_ == NULL) providerundo_ = new ::TSP::Reference;
  return providerundo_;
}
inline ::TSP::Reference* CommandShowSetSlideNumberVisibilityArchive::release_providerundo() {
  clear_has_providerundo();
  ::TSP::Reference* temp = providerundo_;
  providerundo_ = NULL;
  return temp;
}
inline void CommandShowSetSlideNumberVisibilityArchive::set_allocated_providerundo(::TSP::Reference* providerundo) {
  delete providerundo_;
  providerundo_ = providerundo;
  if (providerundo) {
    set_has_providerundo();
  } else {
    clear_has_providerundo();
  }
}

// -------------------------------------------------------------------

// CommandMasterRescaleArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandMasterRescaleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMasterRescaleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMasterRescaleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMasterRescaleArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandMasterRescaleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandMasterRescaleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandMasterRescaleArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMasterRescaleArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference master = 2;
inline bool CommandMasterRescaleArchive::has_master() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMasterRescaleArchive::set_has_master() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMasterRescaleArchive::clear_has_master() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMasterRescaleArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& CommandMasterRescaleArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* CommandMasterRescaleArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* CommandMasterRescaleArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void CommandMasterRescaleArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// -------------------------------------------------------------------

// CommandMasterSetThumbnailTextArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandMasterSetThumbnailTextArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMasterSetThumbnailTextArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandMasterSetThumbnailTextArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandMasterSetThumbnailTextArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandMasterSetThumbnailTextArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMasterSetThumbnailTextArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference master = 2;
inline bool CommandMasterSetThumbnailTextArchive::has_master() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMasterSetThumbnailTextArchive::set_has_master() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_has_master() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& CommandMasterSetThumbnailTextArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* CommandMasterSetThumbnailTextArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* CommandMasterSetThumbnailTextArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void CommandMasterSetThumbnailTextArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// required bool is_body = 3;
inline bool CommandMasterSetThumbnailTextArchive::has_is_body() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandMasterSetThumbnailTextArchive::set_has_is_body() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_has_is_body() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_is_body() {
  is_body_ = false;
  clear_has_is_body();
}
inline bool CommandMasterSetThumbnailTextArchive::is_body() const {
  return is_body_;
}
inline void CommandMasterSetThumbnailTextArchive::set_is_body(bool value) {
  set_has_is_body();
  is_body_ = value;
}

// optional string new_text = 4;
inline bool CommandMasterSetThumbnailTextArchive::has_new_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandMasterSetThumbnailTextArchive::set_has_new_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_has_new_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_new_text() {
  if (new_text_ != &::google::protobuf::internal::kEmptyString) {
    new_text_->clear();
  }
  clear_has_new_text();
}
inline const ::std::string& CommandMasterSetThumbnailTextArchive::new_text() const {
  return *new_text_;
}
inline void CommandMasterSetThumbnailTextArchive::set_new_text(const ::std::string& value) {
  set_has_new_text();
  if (new_text_ == &::google::protobuf::internal::kEmptyString) {
    new_text_ = new ::std::string;
  }
  new_text_->assign(value);
}
inline void CommandMasterSetThumbnailTextArchive::set_new_text(const char* value) {
  set_has_new_text();
  if (new_text_ == &::google::protobuf::internal::kEmptyString) {
    new_text_ = new ::std::string;
  }
  new_text_->assign(value);
}
inline void CommandMasterSetThumbnailTextArchive::set_new_text(const char* value, size_t size) {
  set_has_new_text();
  if (new_text_ == &::google::protobuf::internal::kEmptyString) {
    new_text_ = new ::std::string;
  }
  new_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandMasterSetThumbnailTextArchive::mutable_new_text() {
  set_has_new_text();
  if (new_text_ == &::google::protobuf::internal::kEmptyString) {
    new_text_ = new ::std::string;
  }
  return new_text_;
}
inline ::std::string* CommandMasterSetThumbnailTextArchive::release_new_text() {
  clear_has_new_text();
  if (new_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_text_;
    new_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandMasterSetThumbnailTextArchive::set_allocated_new_text(::std::string* new_text) {
  if (new_text_ != &::google::protobuf::internal::kEmptyString) {
    delete new_text_;
  }
  if (new_text) {
    set_has_new_text();
    new_text_ = new_text;
  } else {
    clear_has_new_text();
    new_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_text = 5;
inline bool CommandMasterSetThumbnailTextArchive::has_old_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandMasterSetThumbnailTextArchive::set_has_old_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_has_old_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandMasterSetThumbnailTextArchive::clear_old_text() {
  if (old_text_ != &::google::protobuf::internal::kEmptyString) {
    old_text_->clear();
  }
  clear_has_old_text();
}
inline const ::std::string& CommandMasterSetThumbnailTextArchive::old_text() const {
  return *old_text_;
}
inline void CommandMasterSetThumbnailTextArchive::set_old_text(const ::std::string& value) {
  set_has_old_text();
  if (old_text_ == &::google::protobuf::internal::kEmptyString) {
    old_text_ = new ::std::string;
  }
  old_text_->assign(value);
}
inline void CommandMasterSetThumbnailTextArchive::set_old_text(const char* value) {
  set_has_old_text();
  if (old_text_ == &::google::protobuf::internal::kEmptyString) {
    old_text_ = new ::std::string;
  }
  old_text_->assign(value);
}
inline void CommandMasterSetThumbnailTextArchive::set_old_text(const char* value, size_t size) {
  set_has_old_text();
  if (old_text_ == &::google::protobuf::internal::kEmptyString) {
    old_text_ = new ::std::string;
  }
  old_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandMasterSetThumbnailTextArchive::mutable_old_text() {
  set_has_old_text();
  if (old_text_ == &::google::protobuf::internal::kEmptyString) {
    old_text_ = new ::std::string;
  }
  return old_text_;
}
inline ::std::string* CommandMasterSetThumbnailTextArchive::release_old_text() {
  clear_has_old_text();
  if (old_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_text_;
    old_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandMasterSetThumbnailTextArchive::set_allocated_old_text(::std::string* old_text) {
  if (old_text_ != &::google::protobuf::internal::kEmptyString) {
    delete old_text_;
  }
  if (old_text) {
    set_has_old_text();
    old_text_ = old_text;
  } else {
    clear_has_old_text();
    old_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandMasterSetBodyStylesArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandMasterSetBodyStylesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMasterSetBodyStylesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMasterSetBodyStylesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMasterSetBodyStylesArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandMasterSetBodyStylesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandMasterSetBodyStylesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandMasterSetBodyStylesArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMasterSetBodyStylesArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference master = 2;
inline bool CommandMasterSetBodyStylesArchive::has_master() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMasterSetBodyStylesArchive::set_has_master() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMasterSetBodyStylesArchive::clear_has_master() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMasterSetBodyStylesArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& CommandMasterSetBodyStylesArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void CommandMasterSetBodyStylesArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// repeated .TSP.Reference new_paragraph_styles = 3;
inline int CommandMasterSetBodyStylesArchive::new_paragraph_styles_size() const {
  return new_paragraph_styles_.size();
}
inline void CommandMasterSetBodyStylesArchive::clear_new_paragraph_styles() {
  new_paragraph_styles_.Clear();
}
inline const ::TSP::Reference& CommandMasterSetBodyStylesArchive::new_paragraph_styles(int index) const {
  return new_paragraph_styles_.Get(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::mutable_new_paragraph_styles(int index) {
  return new_paragraph_styles_.Mutable(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::add_new_paragraph_styles() {
  return new_paragraph_styles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMasterSetBodyStylesArchive::new_paragraph_styles() const {
  return new_paragraph_styles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMasterSetBodyStylesArchive::mutable_new_paragraph_styles() {
  return &new_paragraph_styles_;
}

// repeated .TSP.Reference new_list_styles = 4;
inline int CommandMasterSetBodyStylesArchive::new_list_styles_size() const {
  return new_list_styles_.size();
}
inline void CommandMasterSetBodyStylesArchive::clear_new_list_styles() {
  new_list_styles_.Clear();
}
inline const ::TSP::Reference& CommandMasterSetBodyStylesArchive::new_list_styles(int index) const {
  return new_list_styles_.Get(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::mutable_new_list_styles(int index) {
  return new_list_styles_.Mutable(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::add_new_list_styles() {
  return new_list_styles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMasterSetBodyStylesArchive::new_list_styles() const {
  return new_list_styles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMasterSetBodyStylesArchive::mutable_new_list_styles() {
  return &new_list_styles_;
}

// repeated .TSP.Reference old_paragraph_styles = 5;
inline int CommandMasterSetBodyStylesArchive::old_paragraph_styles_size() const {
  return old_paragraph_styles_.size();
}
inline void CommandMasterSetBodyStylesArchive::clear_old_paragraph_styles() {
  old_paragraph_styles_.Clear();
}
inline const ::TSP::Reference& CommandMasterSetBodyStylesArchive::old_paragraph_styles(int index) const {
  return old_paragraph_styles_.Get(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::mutable_old_paragraph_styles(int index) {
  return old_paragraph_styles_.Mutable(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::add_old_paragraph_styles() {
  return old_paragraph_styles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMasterSetBodyStylesArchive::old_paragraph_styles() const {
  return old_paragraph_styles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMasterSetBodyStylesArchive::mutable_old_paragraph_styles() {
  return &old_paragraph_styles_;
}

// repeated .TSP.Reference old_list_styles = 6;
inline int CommandMasterSetBodyStylesArchive::old_list_styles_size() const {
  return old_list_styles_.size();
}
inline void CommandMasterSetBodyStylesArchive::clear_old_list_styles() {
  old_list_styles_.Clear();
}
inline const ::TSP::Reference& CommandMasterSetBodyStylesArchive::old_list_styles(int index) const {
  return old_list_styles_.Get(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::mutable_old_list_styles(int index) {
  return old_list_styles_.Mutable(index);
}
inline ::TSP::Reference* CommandMasterSetBodyStylesArchive::add_old_list_styles() {
  return old_list_styles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandMasterSetBodyStylesArchive::old_list_styles() const {
  return old_list_styles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandMasterSetBodyStylesArchive::mutable_old_list_styles() {
  return &old_list_styles_;
}

// -------------------------------------------------------------------

// CommandSlideApplyThemeArchive

// required .TSS.ApplyThemeChildCommandArchive super = 1;
inline bool CommandSlideApplyThemeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideApplyThemeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideApplyThemeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideApplyThemeArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::ApplyThemeChildCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSS::ApplyThemeChildCommandArchive& CommandSlideApplyThemeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* CommandSlideApplyThemeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::ApplyThemeChildCommandArchive;
  return super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* CommandSlideApplyThemeArchive::release_super() {
  clear_has_super();
  ::TSS::ApplyThemeChildCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideApplyThemeArchive::set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .KN.MasterChangeBlobArchive blob = 2;
inline bool CommandSlideApplyThemeArchive::has_blob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideApplyThemeArchive::set_has_blob() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideApplyThemeArchive::clear_has_blob() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideApplyThemeArchive::clear_blob() {
  if (blob_ != NULL) blob_->::KN::MasterChangeBlobArchive::Clear();
  clear_has_blob();
}
inline const ::KN::MasterChangeBlobArchive& CommandSlideApplyThemeArchive::blob() const {
  return blob_ != NULL ? *blob_ : *default_instance_->blob_;
}
inline ::KN::MasterChangeBlobArchive* CommandSlideApplyThemeArchive::mutable_blob() {
  set_has_blob();
  if (blob_ == NULL) blob_ = new ::KN::MasterChangeBlobArchive;
  return blob_;
}
inline ::KN::MasterChangeBlobArchive* CommandSlideApplyThemeArchive::release_blob() {
  clear_has_blob();
  ::KN::MasterChangeBlobArchive* temp = blob_;
  blob_ = NULL;
  return temp;
}
inline void CommandSlideApplyThemeArchive::set_allocated_blob(::KN::MasterChangeBlobArchive* blob) {
  delete blob_;
  blob_ = blob;
  if (blob) {
    set_has_blob();
  } else {
    clear_has_blob();
  }
}

// -------------------------------------------------------------------

// CommandChangeMasterSlideArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandChangeMasterSlideArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandChangeMasterSlideArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandChangeMasterSlideArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandChangeMasterSlideArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandChangeMasterSlideArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandChangeMasterSlideArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandChangeMasterSlideArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandChangeMasterSlideArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandChangeMasterSlideArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandChangeMasterSlideArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandChangeMasterSlideArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandChangeMasterSlideArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandChangeMasterSlideArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandChangeMasterSlideArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandChangeMasterSlideArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandChangeMasterSlideArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required .TSP.Reference master = 3;
inline bool CommandChangeMasterSlideArchive::has_master() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandChangeMasterSlideArchive::set_has_master() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandChangeMasterSlideArchive::clear_has_master() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandChangeMasterSlideArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& CommandChangeMasterSlideArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* CommandChangeMasterSlideArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* CommandChangeMasterSlideArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void CommandChangeMasterSlideArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// required .TSP.Reference placeholder_commands = 4;
inline bool CommandChangeMasterSlideArchive::has_placeholder_commands() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandChangeMasterSlideArchive::set_has_placeholder_commands() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandChangeMasterSlideArchive::clear_has_placeholder_commands() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandChangeMasterSlideArchive::clear_placeholder_commands() {
  if (placeholder_commands_ != NULL) placeholder_commands_->::TSP::Reference::Clear();
  clear_has_placeholder_commands();
}
inline const ::TSP::Reference& CommandChangeMasterSlideArchive::placeholder_commands() const {
  return placeholder_commands_ != NULL ? *placeholder_commands_ : *default_instance_->placeholder_commands_;
}
inline ::TSP::Reference* CommandChangeMasterSlideArchive::mutable_placeholder_commands() {
  set_has_placeholder_commands();
  if (placeholder_commands_ == NULL) placeholder_commands_ = new ::TSP::Reference;
  return placeholder_commands_;
}
inline ::TSP::Reference* CommandChangeMasterSlideArchive::release_placeholder_commands() {
  clear_has_placeholder_commands();
  ::TSP::Reference* temp = placeholder_commands_;
  placeholder_commands_ = NULL;
  return temp;
}
inline void CommandChangeMasterSlideArchive::set_allocated_placeholder_commands(::TSP::Reference* placeholder_commands) {
  delete placeholder_commands_;
  placeholder_commands_ = placeholder_commands;
  if (placeholder_commands) {
    set_has_placeholder_commands();
  } else {
    clear_has_placeholder_commands();
  }
}

// -------------------------------------------------------------------

// CommandSlidePrimitiveSetMasterArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlidePrimitiveSetMasterArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlidePrimitiveSetMasterArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlidePrimitiveSetMasterArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlidePrimitiveSetMasterArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference slide = 2;
inline bool CommandSlidePrimitiveSetMasterArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& CommandSlidePrimitiveSetMasterArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* CommandSlidePrimitiveSetMasterArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* CommandSlidePrimitiveSetMasterArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// required .TSP.Reference master = 3;
inline bool CommandSlidePrimitiveSetMasterArchive::has_master() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_has_master() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_has_master() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& CommandSlidePrimitiveSetMasterArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* CommandSlidePrimitiveSetMasterArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* CommandSlidePrimitiveSetMasterArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// required .TSP.Reference old_master = 4;
inline bool CommandSlidePrimitiveSetMasterArchive::has_old_master() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_has_old_master() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_has_old_master() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSlidePrimitiveSetMasterArchive::clear_old_master() {
  if (old_master_ != NULL) old_master_->::TSP::Reference::Clear();
  clear_has_old_master();
}
inline const ::TSP::Reference& CommandSlidePrimitiveSetMasterArchive::old_master() const {
  return old_master_ != NULL ? *old_master_ : *default_instance_->old_master_;
}
inline ::TSP::Reference* CommandSlidePrimitiveSetMasterArchive::mutable_old_master() {
  set_has_old_master();
  if (old_master_ == NULL) old_master_ = new ::TSP::Reference;
  return old_master_;
}
inline ::TSP::Reference* CommandSlidePrimitiveSetMasterArchive::release_old_master() {
  clear_has_old_master();
  ::TSP::Reference* temp = old_master_;
  old_master_ = NULL;
  return temp;
}
inline void CommandSlidePrimitiveSetMasterArchive::set_allocated_old_master(::TSP::Reference* old_master) {
  delete old_master_;
  old_master_ = old_master;
  if (old_master) {
    set_has_old_master();
  } else {
    clear_has_old_master();
  }
}

// -------------------------------------------------------------------

// CommandSlideReapplyMasterArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSlideReapplyMasterArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSlideReapplyMasterArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSlideReapplyMasterArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSlideReapplyMasterArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSlideReapplyMasterArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSlideReapplyMasterArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSlideReapplyMasterArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSlideReapplyMasterArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference reapply_accumulated_command = 2;
inline bool CommandSlideReapplyMasterArchive::has_reapply_accumulated_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSlideReapplyMasterArchive::set_has_reapply_accumulated_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSlideReapplyMasterArchive::clear_has_reapply_accumulated_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSlideReapplyMasterArchive::clear_reapply_accumulated_command() {
  if (reapply_accumulated_command_ != NULL) reapply_accumulated_command_->::TSP::Reference::Clear();
  clear_has_reapply_accumulated_command();
}
inline const ::TSP::Reference& CommandSlideReapplyMasterArchive::reapply_accumulated_command() const {
  return reapply_accumulated_command_ != NULL ? *reapply_accumulated_command_ : *default_instance_->reapply_accumulated_command_;
}
inline ::TSP::Reference* CommandSlideReapplyMasterArchive::mutable_reapply_accumulated_command() {
  set_has_reapply_accumulated_command();
  if (reapply_accumulated_command_ == NULL) reapply_accumulated_command_ = new ::TSP::Reference;
  return reapply_accumulated_command_;
}
inline ::TSP::Reference* CommandSlideReapplyMasterArchive::release_reapply_accumulated_command() {
  clear_has_reapply_accumulated_command();
  ::TSP::Reference* temp = reapply_accumulated_command_;
  reapply_accumulated_command_ = NULL;
  return temp;
}
inline void CommandSlideReapplyMasterArchive::set_allocated_reapply_accumulated_command(::TSP::Reference* reapply_accumulated_command) {
  delete reapply_accumulated_command_;
  reapply_accumulated_command_ = reapply_accumulated_command;
  if (reapply_accumulated_command) {
    set_has_reapply_accumulated_command();
  } else {
    clear_has_reapply_accumulated_command();
  }
}

// -------------------------------------------------------------------

// CommandShowSetSoundtrack

// required .TSK.CommandArchive super = 1;
inline bool CommandShowSetSoundtrack::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandShowSetSoundtrack::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandShowSetSoundtrack::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandShowSetSoundtrack::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandShowSetSoundtrack::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandShowSetSoundtrack::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandShowSetSoundtrack::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandShowSetSoundtrack::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference show = 2;
inline bool CommandShowSetSoundtrack::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandShowSetSoundtrack::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandShowSetSoundtrack::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandShowSetSoundtrack::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& CommandShowSetSoundtrack::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* CommandShowSetSoundtrack::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* CommandShowSetSoundtrack::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void CommandShowSetSoundtrack::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// optional .TSP.Reference soundtrack = 3;
inline bool CommandShowSetSoundtrack::has_soundtrack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandShowSetSoundtrack::set_has_soundtrack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandShowSetSoundtrack::clear_has_soundtrack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandShowSetSoundtrack::clear_soundtrack() {
  if (soundtrack_ != NULL) soundtrack_->::TSP::Reference::Clear();
  clear_has_soundtrack();
}
inline const ::TSP::Reference& CommandShowSetSoundtrack::soundtrack() const {
  return soundtrack_ != NULL ? *soundtrack_ : *default_instance_->soundtrack_;
}
inline ::TSP::Reference* CommandShowSetSoundtrack::mutable_soundtrack() {
  set_has_soundtrack();
  if (soundtrack_ == NULL) soundtrack_ = new ::TSP::Reference;
  return soundtrack_;
}
inline ::TSP::Reference* CommandShowSetSoundtrack::release_soundtrack() {
  clear_has_soundtrack();
  ::TSP::Reference* temp = soundtrack_;
  soundtrack_ = NULL;
  return temp;
}
inline void CommandShowSetSoundtrack::set_allocated_soundtrack(::TSP::Reference* soundtrack) {
  delete soundtrack_;
  soundtrack_ = soundtrack;
  if (soundtrack) {
    set_has_soundtrack();
  } else {
    clear_has_soundtrack();
  }
}

// optional .TSP.Reference old_soundtrack = 4;
inline bool CommandShowSetSoundtrack::has_old_soundtrack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandShowSetSoundtrack::set_has_old_soundtrack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandShowSetSoundtrack::clear_has_old_soundtrack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandShowSetSoundtrack::clear_old_soundtrack() {
  if (old_soundtrack_ != NULL) old_soundtrack_->::TSP::Reference::Clear();
  clear_has_old_soundtrack();
}
inline const ::TSP::Reference& CommandShowSetSoundtrack::old_soundtrack() const {
  return old_soundtrack_ != NULL ? *old_soundtrack_ : *default_instance_->old_soundtrack_;
}
inline ::TSP::Reference* CommandShowSetSoundtrack::mutable_old_soundtrack() {
  set_has_old_soundtrack();
  if (old_soundtrack_ == NULL) old_soundtrack_ = new ::TSP::Reference;
  return old_soundtrack_;
}
inline ::TSP::Reference* CommandShowSetSoundtrack::release_old_soundtrack() {
  clear_has_old_soundtrack();
  ::TSP::Reference* temp = old_soundtrack_;
  old_soundtrack_ = NULL;
  return temp;
}
inline void CommandShowSetSoundtrack::set_allocated_old_soundtrack(::TSP::Reference* old_soundtrack) {
  delete old_soundtrack_;
  old_soundtrack_ = old_soundtrack;
  if (old_soundtrack) {
    set_has_old_soundtrack();
  } else {
    clear_has_old_soundtrack();
  }
}

// -------------------------------------------------------------------

// CommandSoundtrackSetValue_PropertyValue

// optional double double_value = 1;
inline bool CommandSoundtrackSetValue_PropertyValue::has_double_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSoundtrackSetValue_PropertyValue::set_has_double_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSoundtrackSetValue_PropertyValue::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSoundtrackSetValue_PropertyValue::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double CommandSoundtrackSetValue_PropertyValue::double_value() const {
  return double_value_;
}
inline void CommandSoundtrackSetValue_PropertyValue::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}

// optional .KN.Soundtrack.SoundtrackMode mode_value = 2;
inline bool CommandSoundtrackSetValue_PropertyValue::has_mode_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSoundtrackSetValue_PropertyValue::set_has_mode_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSoundtrackSetValue_PropertyValue::clear_has_mode_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSoundtrackSetValue_PropertyValue::clear_mode_value() {
  mode_value_ = 0;
  clear_has_mode_value();
}
inline ::KN::Soundtrack_SoundtrackMode CommandSoundtrackSetValue_PropertyValue::mode_value() const {
  return static_cast< ::KN::Soundtrack_SoundtrackMode >(mode_value_);
}
inline void CommandSoundtrackSetValue_PropertyValue::set_mode_value(::KN::Soundtrack_SoundtrackMode value) {
  assert(::KN::Soundtrack_SoundtrackMode_IsValid(value));
  set_has_mode_value();
  mode_value_ = value;
}

// repeated .TSP.DataReference media_reference_values = 3;
inline int CommandSoundtrackSetValue_PropertyValue::media_reference_values_size() const {
  return media_reference_values_.size();
}
inline void CommandSoundtrackSetValue_PropertyValue::clear_media_reference_values() {
  media_reference_values_.Clear();
}
inline const ::TSP::DataReference& CommandSoundtrackSetValue_PropertyValue::media_reference_values(int index) const {
  return media_reference_values_.Get(index);
}
inline ::TSP::DataReference* CommandSoundtrackSetValue_PropertyValue::mutable_media_reference_values(int index) {
  return media_reference_values_.Mutable(index);
}
inline ::TSP::DataReference* CommandSoundtrackSetValue_PropertyValue::add_media_reference_values() {
  return media_reference_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >&
CommandSoundtrackSetValue_PropertyValue::media_reference_values() const {
  return media_reference_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >*
CommandSoundtrackSetValue_PropertyValue::mutable_media_reference_values() {
  return &media_reference_values_;
}

// -------------------------------------------------------------------

// CommandSoundtrackSetValue

// required .TSK.CommandArchive super = 1;
inline bool CommandSoundtrackSetValue::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSoundtrackSetValue::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSoundtrackSetValue::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSoundtrackSetValue::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSoundtrackSetValue::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSoundtrackSetValue::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSoundtrackSetValue::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSoundtrackSetValue::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference soundtrack = 2;
inline bool CommandSoundtrackSetValue::has_soundtrack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSoundtrackSetValue::set_has_soundtrack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSoundtrackSetValue::clear_has_soundtrack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSoundtrackSetValue::clear_soundtrack() {
  if (soundtrack_ != NULL) soundtrack_->::TSP::Reference::Clear();
  clear_has_soundtrack();
}
inline const ::TSP::Reference& CommandSoundtrackSetValue::soundtrack() const {
  return soundtrack_ != NULL ? *soundtrack_ : *default_instance_->soundtrack_;
}
inline ::TSP::Reference* CommandSoundtrackSetValue::mutable_soundtrack() {
  set_has_soundtrack();
  if (soundtrack_ == NULL) soundtrack_ = new ::TSP::Reference;
  return soundtrack_;
}
inline ::TSP::Reference* CommandSoundtrackSetValue::release_soundtrack() {
  clear_has_soundtrack();
  ::TSP::Reference* temp = soundtrack_;
  soundtrack_ = NULL;
  return temp;
}
inline void CommandSoundtrackSetValue::set_allocated_soundtrack(::TSP::Reference* soundtrack) {
  delete soundtrack_;
  soundtrack_ = soundtrack;
  if (soundtrack) {
    set_has_soundtrack();
  } else {
    clear_has_soundtrack();
  }
}

// optional string property = 3;
inline bool CommandSoundtrackSetValue::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSoundtrackSetValue::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSoundtrackSetValue::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSoundtrackSetValue::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& CommandSoundtrackSetValue::property() const {
  return *property_;
}
inline void CommandSoundtrackSetValue::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandSoundtrackSetValue::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void CommandSoundtrackSetValue::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSoundtrackSetValue::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* CommandSoundtrackSetValue::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSoundtrackSetValue::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .KN.CommandSoundtrackSetValue.PropertyValue old_value = 4;
inline bool CommandSoundtrackSetValue::has_old_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSoundtrackSetValue::set_has_old_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSoundtrackSetValue::clear_has_old_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSoundtrackSetValue::clear_old_value() {
  if (old_value_ != NULL) old_value_->::KN::CommandSoundtrackSetValue_PropertyValue::Clear();
  clear_has_old_value();
}
inline const ::KN::CommandSoundtrackSetValue_PropertyValue& CommandSoundtrackSetValue::old_value() const {
  return old_value_ != NULL ? *old_value_ : *default_instance_->old_value_;
}
inline ::KN::CommandSoundtrackSetValue_PropertyValue* CommandSoundtrackSetValue::mutable_old_value() {
  set_has_old_value();
  if (old_value_ == NULL) old_value_ = new ::KN::CommandSoundtrackSetValue_PropertyValue;
  return old_value_;
}
inline ::KN::CommandSoundtrackSetValue_PropertyValue* CommandSoundtrackSetValue::release_old_value() {
  clear_has_old_value();
  ::KN::CommandSoundtrackSetValue_PropertyValue* temp = old_value_;
  old_value_ = NULL;
  return temp;
}
inline void CommandSoundtrackSetValue::set_allocated_old_value(::KN::CommandSoundtrackSetValue_PropertyValue* old_value) {
  delete old_value_;
  old_value_ = old_value;
  if (old_value) {
    set_has_old_value();
  } else {
    clear_has_old_value();
  }
}

// optional .KN.CommandSoundtrackSetValue.PropertyValue new_value = 5;
inline bool CommandSoundtrackSetValue::has_new_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSoundtrackSetValue::set_has_new_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSoundtrackSetValue::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSoundtrackSetValue::clear_new_value() {
  if (new_value_ != NULL) new_value_->::KN::CommandSoundtrackSetValue_PropertyValue::Clear();
  clear_has_new_value();
}
inline const ::KN::CommandSoundtrackSetValue_PropertyValue& CommandSoundtrackSetValue::new_value() const {
  return new_value_ != NULL ? *new_value_ : *default_instance_->new_value_;
}
inline ::KN::CommandSoundtrackSetValue_PropertyValue* CommandSoundtrackSetValue::mutable_new_value() {
  set_has_new_value();
  if (new_value_ == NULL) new_value_ = new ::KN::CommandSoundtrackSetValue_PropertyValue;
  return new_value_;
}
inline ::KN::CommandSoundtrackSetValue_PropertyValue* CommandSoundtrackSetValue::release_new_value() {
  clear_has_new_value();
  ::KN::CommandSoundtrackSetValue_PropertyValue* temp = new_value_;
  new_value_ = NULL;
  return temp;
}
inline void CommandSoundtrackSetValue::set_allocated_new_value(::KN::CommandSoundtrackSetValue_PropertyValue* new_value) {
  delete new_value_;
  new_value_ = new_value;
  if (new_value) {
    set_has_new_value();
  } else {
    clear_has_new_value();
  }
}

// -------------------------------------------------------------------

// SlideCollectionCommandSelectionBehaviorArchive

// optional .TSP.Reference archived_new_selection = 1;
inline bool SlideCollectionCommandSelectionBehaviorArchive::has_archived_new_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::set_has_archived_new_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::clear_has_archived_new_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::clear_archived_new_selection() {
  if (archived_new_selection_ != NULL) archived_new_selection_->::TSP::Reference::Clear();
  clear_has_archived_new_selection();
}
inline const ::TSP::Reference& SlideCollectionCommandSelectionBehaviorArchive::archived_new_selection() const {
  return archived_new_selection_ != NULL ? *archived_new_selection_ : *default_instance_->archived_new_selection_;
}
inline ::TSP::Reference* SlideCollectionCommandSelectionBehaviorArchive::mutable_archived_new_selection() {
  set_has_archived_new_selection();
  if (archived_new_selection_ == NULL) archived_new_selection_ = new ::TSP::Reference;
  return archived_new_selection_;
}
inline ::TSP::Reference* SlideCollectionCommandSelectionBehaviorArchive::release_archived_new_selection() {
  clear_has_archived_new_selection();
  ::TSP::Reference* temp = archived_new_selection_;
  archived_new_selection_ = NULL;
  return temp;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::set_allocated_archived_new_selection(::TSP::Reference* archived_new_selection) {
  delete archived_new_selection_;
  archived_new_selection_ = archived_new_selection;
  if (archived_new_selection) {
    set_has_archived_new_selection();
  } else {
    clear_has_archived_new_selection();
  }
}

// optional .TSP.Reference archived_old_selection = 2;
inline bool SlideCollectionCommandSelectionBehaviorArchive::has_archived_old_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::set_has_archived_old_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::clear_has_archived_old_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::clear_archived_old_selection() {
  if (archived_old_selection_ != NULL) archived_old_selection_->::TSP::Reference::Clear();
  clear_has_archived_old_selection();
}
inline const ::TSP::Reference& SlideCollectionCommandSelectionBehaviorArchive::archived_old_selection() const {
  return archived_old_selection_ != NULL ? *archived_old_selection_ : *default_instance_->archived_old_selection_;
}
inline ::TSP::Reference* SlideCollectionCommandSelectionBehaviorArchive::mutable_archived_old_selection() {
  set_has_archived_old_selection();
  if (archived_old_selection_ == NULL) archived_old_selection_ = new ::TSP::Reference;
  return archived_old_selection_;
}
inline ::TSP::Reference* SlideCollectionCommandSelectionBehaviorArchive::release_archived_old_selection() {
  clear_has_archived_old_selection();
  ::TSP::Reference* temp = archived_old_selection_;
  archived_old_selection_ = NULL;
  return temp;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::set_allocated_archived_old_selection(::TSP::Reference* archived_old_selection) {
  delete archived_old_selection_;
  archived_old_selection_ = archived_old_selection;
  if (archived_old_selection) {
    set_has_archived_old_selection();
  } else {
    clear_has_archived_old_selection();
  }
}

// optional .KN.SlideCollectionCommandSelectionBehaviorArchive.Type type = 3 [default = kKindSlideSelectionBehaviorTypeGeneral];
inline bool SlideCollectionCommandSelectionBehaviorArchive::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlideCollectionCommandSelectionBehaviorArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::KN::SlideCollectionCommandSelectionBehaviorArchive_Type SlideCollectionCommandSelectionBehaviorArchive::type() const {
  return static_cast< ::KN::SlideCollectionCommandSelectionBehaviorArchive_Type >(type_);
}
inline void SlideCollectionCommandSelectionBehaviorArchive::set_type(::KN::SlideCollectionCommandSelectionBehaviorArchive_Type value) {
  assert(::KN::SlideCollectionCommandSelectionBehaviorArchive_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ChartInfoGeometryCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChartInfoGeometryCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartInfoGeometryCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartInfoGeometryCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartInfoGeometryCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChartInfoGeometryCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChartInfoGeometryCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChartInfoGeometryCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartInfoGeometryCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KN

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::CommandShowInsertSlideArchive_Kind>() {
  return ::KN::CommandShowInsertSlideArchive_Kind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::SlideCollectionCommandSelectionBehaviorArchive_Type>() {
  return ::KN::SlideCollectionCommandSelectionBehaviorArchive_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KNCommandArchives_2eproto__INCLUDED
