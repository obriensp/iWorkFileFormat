// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSTArchives.proto

#ifndef PROTOBUF_TSTArchives_2eproto__INCLUDED
#define PROTOBUF_TSTArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSDArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSCEArchives.pb.h"
#include "TSWPArchives.pb.h"
#include "TSTStylePropertyArchiving.pb.h"
// @@protoc_insertion_point(includes)

namespace TST {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSTArchives_2eproto();
void protobuf_AssignDesc_TSTArchives_2eproto();
void protobuf_ShutdownFile_TSTArchives_2eproto();

class CellID;
class TableSize;
class CellRange;
class TableSelection;
class TileRowInfo;
class Tile;
class TileStorage;
class TileStorage_Tile;
class PopUpMenuModel;
class PopUpMenuModel_CellValue;
class TableDataList;
class TableDataList_ListEntry;
class TableRBTree;
class TableRBTree_Node;
class HeaderStorageBucket;
class HeaderStorageBucket_Header;
class HeaderStorage;
class DataStore;
class TableInfoArchive;
class EditingStateArchive;
class WPTableInfoArchive;
class TableStyleNetworkArchive;
class TableModelArchive;
class DurationWrapperArchive;
class Cell;
class MergeRegionMapArchive;
class CellMapArchive;
class CellMapArchive_CellMapEntry;
class DoubleStyleMapArchive;
class DoubleStyleMapArchive_DoubleStyleMapEntryArchive;
class StyleTableMapArchive;
class StyleTableMapArchive_StyleTableMapEntryArchive;
class SelectionArchive;
class FilterRuleArchive;
class TableStyleArchive;
class CellStyleArchive;
class FormulaPredicateArchive;
class ConditionalStyleSetArchive;
class ConditionalStyleSetArchive_ConditionalStyleRule;
class FilterSetArchive;
class TokenAttachmentArchive;
class FormulaArchive;
class ExpressionNodeArchive;
class BooleanNodeArchive;
class NumberNodeArchive;
class StringNodeArchive;
class IdentifierNodeArchive;
class ArrayNodeArchive;
class ListNodeArchive;
class OperatorNodeArchive;
class PostfixOperatorNodeArchive;
class PrefixOperatorNodeArchive;
class FunctionNodeArchive;
class FunctionEndNodeArchive;
class DateNodeArchive;
class ReferenceNodeArchive;
class DurationNodeArchive;
class ArgumentPlaceholderNodeArchive;
class EmptyExpressionNodeArchive;
class LayoutHintArchive;
class CompletionTokenAttachmentArchive;
class HiddenStateFormulaOwnerArchive;
class RichTextPayloadArchive;
class FormulaEqualsTokenAttachmentArchive;
class CellRegion;

enum PopUpMenuModel_CellValueType {
  PopUpMenuModel_CellValueType_NIL_TYPE = 1,
  PopUpMenuModel_CellValueType_BOOLEAN_TYPE = 2,
  PopUpMenuModel_CellValueType_DATE_TYPE = 3,
  PopUpMenuModel_CellValueType_NUMBER_TYPE = 4,
  PopUpMenuModel_CellValueType_STRING_TYPE = 5
};
bool PopUpMenuModel_CellValueType_IsValid(int value);
const PopUpMenuModel_CellValueType PopUpMenuModel_CellValueType_CellValueType_MIN = PopUpMenuModel_CellValueType_NIL_TYPE;
const PopUpMenuModel_CellValueType PopUpMenuModel_CellValueType_CellValueType_MAX = PopUpMenuModel_CellValueType_STRING_TYPE;
const int PopUpMenuModel_CellValueType_CellValueType_ARRAYSIZE = PopUpMenuModel_CellValueType_CellValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PopUpMenuModel_CellValueType_descriptor();
inline const ::std::string& PopUpMenuModel_CellValueType_Name(PopUpMenuModel_CellValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PopUpMenuModel_CellValueType_descriptor(), value);
}
inline bool PopUpMenuModel_CellValueType_Parse(
    const ::std::string& name, PopUpMenuModel_CellValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PopUpMenuModel_CellValueType>(
    PopUpMenuModel_CellValueType_descriptor(), name, value);
}
enum TableDataList_ListType {
  TableDataList_ListType_STRING = 1,
  TableDataList_ListType_FORMAT = 2,
  TableDataList_ListType_FORMULA = 3,
  TableDataList_ListType_STYLE = 4,
  TableDataList_ListType_FORMULA_ERROR = 5,
  TableDataList_ListType_CUSTOM_FORMAT = 6,
  TableDataList_ListType_MULTIPLE_CHOICE_LIST_FORMAT = 7,
  TableDataList_ListType_RICH_TEXT_PAYLOAD = 8,
  TableDataList_ListType_CONDITIONAL_STYLE = 9,
  TableDataList_ListType_COMMENT_STORAGE = 10
};
bool TableDataList_ListType_IsValid(int value);
const TableDataList_ListType TableDataList_ListType_ListType_MIN = TableDataList_ListType_STRING;
const TableDataList_ListType TableDataList_ListType_ListType_MAX = TableDataList_ListType_COMMENT_STORAGE;
const int TableDataList_ListType_ListType_ARRAYSIZE = TableDataList_ListType_ListType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableDataList_ListType_descriptor();
inline const ::std::string& TableDataList_ListType_Name(TableDataList_ListType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableDataList_ListType_descriptor(), value);
}
inline bool TableDataList_ListType_Parse(
    const ::std::string& name, TableDataList_ListType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableDataList_ListType>(
    TableDataList_ListType_descriptor(), name, value);
}
enum FormulaPredicateArchive_FormulaPredicateType {
  FormulaPredicateArchive_FormulaPredicateType_PredNone = 0,
  FormulaPredicateArchive_FormulaPredicateType_TextStartsWith = 1,
  FormulaPredicateArchive_FormulaPredicateType_TextEndsWith = 2,
  FormulaPredicateArchive_FormulaPredicateType_TextContains = 3,
  FormulaPredicateArchive_FormulaPredicateType_TextDoesNotContain = 4,
  FormulaPredicateArchive_FormulaPredicateType_ValueEqual = 5,
  FormulaPredicateArchive_FormulaPredicateType_ValueNotEqual = 6,
  FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThan = 7,
  FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThanOrEqual = 8,
  FormulaPredicateArchive_FormulaPredicateType_ValueLessThan = 9,
  FormulaPredicateArchive_FormulaPredicateType_ValueLessThanOrEqual = 10,
  FormulaPredicateArchive_FormulaPredicateType_ValueAboveAverage = 11,
  FormulaPredicateArchive_FormulaPredicateType_ValueBelowAverage = 12,
  FormulaPredicateArchive_FormulaPredicateType_ValueBetween = 13,
  FormulaPredicateArchive_FormulaPredicateType_Formula = 14,
  FormulaPredicateArchive_FormulaPredicateType_Duplicates = 15,
  FormulaPredicateArchive_FormulaPredicateType_Uniques = 16,
  FormulaPredicateArchive_FormulaPredicateType_DateIsToday = 17,
  FormulaPredicateArchive_FormulaPredicateType_DateIsYesterday = 18,
  FormulaPredicateArchive_FormulaPredicateType_DateIsTomorrow = 19,
  FormulaPredicateArchive_FormulaPredicateType_DateIsTheDate = 20,
  FormulaPredicateArchive_FormulaPredicateType_DateBeforeTheDate = 21,
  FormulaPredicateArchive_FormulaPredicateType_DateAfterTheDate = 22,
  FormulaPredicateArchive_FormulaPredicateType_DateIsInTheRange = 23,
  FormulaPredicateArchive_FormulaPredicateType_DateInTheNext = 24,
  FormulaPredicateArchive_FormulaPredicateType_DateInTheLast = 25,
  FormulaPredicateArchive_FormulaPredicateType_DateIsExactly = 26,
  FormulaPredicateArchive_FormulaPredicateType_DateBeforeRelative = 27,
  FormulaPredicateArchive_FormulaPredicateType_DateAfterRelative = 28,
  FormulaPredicateArchive_FormulaPredicateType_DateBetweenRelative = 29,
  FormulaPredicateArchive_FormulaPredicateType_ValueTop = 30,
  FormulaPredicateArchive_FormulaPredicateType_ValueBottom = 31,
  FormulaPredicateArchive_FormulaPredicateType_ValueNotBetween = 32,
  FormulaPredicateArchive_FormulaPredicateType_DateInThis = 33,
  FormulaPredicateArchive_FormulaPredicateType_IsBlank = 34,
  FormulaPredicateArchive_FormulaPredicateType_IsNotBlank = 35,
  FormulaPredicateArchive_FormulaPredicateType_TextIs = 36,
  FormulaPredicateArchive_FormulaPredicateType_TextIsNot = 37,
  FormulaPredicateArchive_FormulaPredicateType_DurationEqual = 38,
  FormulaPredicateArchive_FormulaPredicateType_DurationNotEqual = 39,
  FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThan = 40,
  FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThanOrEqual = 41,
  FormulaPredicateArchive_FormulaPredicateType_DurationLessThan = 42,
  FormulaPredicateArchive_FormulaPredicateType_DurationLessThanOrEqual = 43,
  FormulaPredicateArchive_FormulaPredicateType_DurationBetween = 44,
  FormulaPredicateArchive_FormulaPredicateType_DurationNotBetween = 45,
  FormulaPredicateArchive_FormulaPredicateType_DurationAboveAverage = 46,
  FormulaPredicateArchive_FormulaPredicateType_DurationBelowAverage = 47,
  FormulaPredicateArchive_FormulaPredicateType_DurationTop = 48,
  FormulaPredicateArchive_FormulaPredicateType_DurationBottom = 49
};
bool FormulaPredicateArchive_FormulaPredicateType_IsValid(int value);
const FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MIN = FormulaPredicateArchive_FormulaPredicateType_PredNone;
const FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MAX = FormulaPredicateArchive_FormulaPredicateType_DurationBottom;
const int FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_ARRAYSIZE = FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FormulaPredicateArchive_FormulaPredicateType_descriptor();
inline const ::std::string& FormulaPredicateArchive_FormulaPredicateType_Name(FormulaPredicateArchive_FormulaPredicateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FormulaPredicateArchive_FormulaPredicateType_descriptor(), value);
}
inline bool FormulaPredicateArchive_FormulaPredicateType_Parse(
    const ::std::string& name, FormulaPredicateArchive_FormulaPredicateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FormulaPredicateArchive_FormulaPredicateType>(
    FormulaPredicateArchive_FormulaPredicateType_descriptor(), name, value);
}
enum FormulaPredicateArchive_QualifierType {
  FormulaPredicateArchive_QualifierType_QualNone = 0,
  FormulaPredicateArchive_QualifierType_Days = 2,
  FormulaPredicateArchive_QualifierType_Weeks = 3,
  FormulaPredicateArchive_QualifierType_Months = 4,
  FormulaPredicateArchive_QualifierType_Years = 5,
  FormulaPredicateArchive_QualifierType_Ago = 6,
  FormulaPredicateArchive_QualifierType_FromNow = 7,
  FormulaPredicateArchive_QualifierType_Quarters = 8,
  FormulaPredicateArchive_QualifierType_Percent = 9,
  FormulaPredicateArchive_QualifierType_Values = 10
};
bool FormulaPredicateArchive_QualifierType_IsValid(int value);
const FormulaPredicateArchive_QualifierType FormulaPredicateArchive_QualifierType_QualifierType_MIN = FormulaPredicateArchive_QualifierType_QualNone;
const FormulaPredicateArchive_QualifierType FormulaPredicateArchive_QualifierType_QualifierType_MAX = FormulaPredicateArchive_QualifierType_Values;
const int FormulaPredicateArchive_QualifierType_QualifierType_ARRAYSIZE = FormulaPredicateArchive_QualifierType_QualifierType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FormulaPredicateArchive_QualifierType_descriptor();
inline const ::std::string& FormulaPredicateArchive_QualifierType_Name(FormulaPredicateArchive_QualifierType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FormulaPredicateArchive_QualifierType_descriptor(), value);
}
inline bool FormulaPredicateArchive_QualifierType_Parse(
    const ::std::string& name, FormulaPredicateArchive_QualifierType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FormulaPredicateArchive_QualifierType>(
    FormulaPredicateArchive_QualifierType_descriptor(), name, value);
}
enum FilterSetArchive_FilterSetType {
  FilterSetArchive_FilterSetType_FilterSetArchiveTypeAll = 0,
  FilterSetArchive_FilterSetType_FilterSetArchiveTypeAny = 1
};
bool FilterSetArchive_FilterSetType_IsValid(int value);
const FilterSetArchive_FilterSetType FilterSetArchive_FilterSetType_FilterSetType_MIN = FilterSetArchive_FilterSetType_FilterSetArchiveTypeAll;
const FilterSetArchive_FilterSetType FilterSetArchive_FilterSetType_FilterSetType_MAX = FilterSetArchive_FilterSetType_FilterSetArchiveTypeAny;
const int FilterSetArchive_FilterSetType_FilterSetType_ARRAYSIZE = FilterSetArchive_FilterSetType_FilterSetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FilterSetArchive_FilterSetType_descriptor();
inline const ::std::string& FilterSetArchive_FilterSetType_Name(FilterSetArchive_FilterSetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FilterSetArchive_FilterSetType_descriptor(), value);
}
inline bool FilterSetArchive_FilterSetType_Parse(
    const ::std::string& name, FilterSetArchive_FilterSetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterSetArchive_FilterSetType>(
    FilterSetArchive_FilterSetType_descriptor(), name, value);
}
enum CellType {
  genericCellType = 0,
  spanCellType = 1,
  numberCellType = 2,
  textCellType = 3,
  formulaCellType = 4,
  dateCellType = 5,
  boolCellType = 6,
  durationCellType = 7,
  formulaErrorCellType = 8,
  automaticCellType = 9
};
bool CellType_IsValid(int value);
const CellType CellType_MIN = genericCellType;
const CellType CellType_MAX = automaticCellType;
const int CellType_ARRAYSIZE = CellType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CellType_descriptor();
inline const ::std::string& CellType_Name(CellType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CellType_descriptor(), value);
}
inline bool CellType_Parse(
    const ::std::string& name, CellType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CellType>(
    CellType_descriptor(), name, value);
}
enum CellValueType {
  emptyCellValueType = 0,
  numberCellValueType = 1,
  stringCellValueType = 2,
  providedCellValueType = 3,
  dateCellValueType = 4,
  boolCellValueType = 5,
  durationCellValueType = 6,
  errorCellValueType = 7,
  richTextCellType = 8
};
bool CellValueType_IsValid(int value);
const CellValueType CellValueType_MIN = emptyCellValueType;
const CellValueType CellValueType_MAX = richTextCellType;
const int CellValueType_ARRAYSIZE = CellValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CellValueType_descriptor();
inline const ::std::string& CellValueType_Name(CellValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CellValueType_descriptor(), value);
}
inline bool CellValueType_Parse(
    const ::std::string& name, CellValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CellValueType>(
    CellValueType_descriptor(), name, value);
}
enum SelectionTypeArchive {
  cellSelectionType = 0,
  rowSelectionType = 1,
  columnSelectionType = 2,
  cellEditingSelectionType = 3,
  tableNameSelectionType = 4,
  tableSelectionType = 5
};
bool SelectionTypeArchive_IsValid(int value);
const SelectionTypeArchive SelectionTypeArchive_MIN = cellSelectionType;
const SelectionTypeArchive SelectionTypeArchive_MAX = tableSelectionType;
const int SelectionTypeArchive_ARRAYSIZE = SelectionTypeArchive_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectionTypeArchive_descriptor();
inline const ::std::string& SelectionTypeArchive_Name(SelectionTypeArchive value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectionTypeArchive_descriptor(), value);
}
inline bool SelectionTypeArchive_Parse(
    const ::std::string& name, SelectionTypeArchive* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectionTypeArchive>(
    SelectionTypeArchive_descriptor(), name, value);
}
enum FillDirectionArchive {
  kTSTFillDownArchive = 1,
  kTSTFillUpArchive = 2,
  kTSTFillRightArchive = 3,
  kTSTFillLeftArchive = 4
};
bool FillDirectionArchive_IsValid(int value);
const FillDirectionArchive FillDirectionArchive_MIN = kTSTFillDownArchive;
const FillDirectionArchive FillDirectionArchive_MAX = kTSTFillLeftArchive;
const int FillDirectionArchive_ARRAYSIZE = FillDirectionArchive_MAX + 1;

const ::google::protobuf::EnumDescriptor* FillDirectionArchive_descriptor();
inline const ::std::string& FillDirectionArchive_Name(FillDirectionArchive value) {
  return ::google::protobuf::internal::NameOfEnum(
    FillDirectionArchive_descriptor(), value);
}
inline bool FillDirectionArchive_Parse(
    const ::std::string& name, FillDirectionArchive* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FillDirectionArchive>(
    FillDirectionArchive_descriptor(), name, value);
}
enum MergeActionArchive {
  mergeActionMerge = 0,
  mergeActionUnmerge = 1
};
bool MergeActionArchive_IsValid(int value);
const MergeActionArchive MergeActionArchive_MIN = mergeActionMerge;
const MergeActionArchive MergeActionArchive_MAX = mergeActionUnmerge;
const int MergeActionArchive_ARRAYSIZE = MergeActionArchive_MAX + 1;

const ::google::protobuf::EnumDescriptor* MergeActionArchive_descriptor();
inline const ::std::string& MergeActionArchive_Name(MergeActionArchive value) {
  return ::google::protobuf::internal::NameOfEnum(
    MergeActionArchive_descriptor(), value);
}
inline bool MergeActionArchive_Parse(
    const ::std::string& name, MergeActionArchive* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MergeActionArchive>(
    MergeActionArchive_descriptor(), name, value);
}
enum HideShowActionArchive {
  hideShowActionHide = 0,
  hideShowActionShow = 1
};
bool HideShowActionArchive_IsValid(int value);
const HideShowActionArchive HideShowActionArchive_MIN = hideShowActionHide;
const HideShowActionArchive HideShowActionArchive_MAX = hideShowActionShow;
const int HideShowActionArchive_ARRAYSIZE = HideShowActionArchive_MAX + 1;

const ::google::protobuf::EnumDescriptor* HideShowActionArchive_descriptor();
inline const ::std::string& HideShowActionArchive_Name(HideShowActionArchive value) {
  return ::google::protobuf::internal::NameOfEnum(
    HideShowActionArchive_descriptor(), value);
}
inline bool HideShowActionArchive_Parse(
    const ::std::string& name, HideShowActionArchive* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HideShowActionArchive>(
    HideShowActionArchive_descriptor(), name, value);
}
// ===================================================================

class CellID : public ::google::protobuf::Message {
 public:
  CellID();
  virtual ~CellID();

  CellID(const CellID& from);

  inline CellID& operator=(const CellID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellID& default_instance();

  void Swap(CellID* other);

  // implements Message ----------------------------------------------

  CellID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellID& from);
  void MergeFrom(const CellID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 packedData = 1;
  inline bool has_packeddata() const;
  inline void clear_packeddata();
  static const int kPackedDataFieldNumber = 1;
  inline ::google::protobuf::uint32 packeddata() const;
  inline void set_packeddata(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CellID)
 private:
  inline void set_has_packeddata();
  inline void clear_has_packeddata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 packeddata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CellID* default_instance_;
};
// -------------------------------------------------------------------

class TableSize : public ::google::protobuf::Message {
 public:
  TableSize();
  virtual ~TableSize();

  TableSize(const TableSize& from);

  inline TableSize& operator=(const TableSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSize& default_instance();

  void Swap(TableSize* other);

  // implements Message ----------------------------------------------

  TableSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSize& from);
  void MergeFrom(const TableSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 packedData = 1;
  inline bool has_packeddata() const;
  inline void clear_packeddata();
  static const int kPackedDataFieldNumber = 1;
  inline ::google::protobuf::uint32 packeddata() const;
  inline void set_packeddata(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.TableSize)
 private:
  inline void set_has_packeddata();
  inline void clear_has_packeddata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 packeddata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableSize* default_instance_;
};
// -------------------------------------------------------------------

class CellRange : public ::google::protobuf::Message {
 public:
  CellRange();
  virtual ~CellRange();

  CellRange(const CellRange& from);

  inline CellRange& operator=(const CellRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellRange& default_instance();

  void Swap(CellRange* other);

  // implements Message ----------------------------------------------

  CellRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellRange& from);
  void MergeFrom(const CellRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline const ::TST::CellID& origin() const;
  inline ::TST::CellID* mutable_origin();
  inline ::TST::CellID* release_origin();
  inline void set_allocated_origin(::TST::CellID* origin);

  // required .TST.TableSize size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::TST::TableSize& size() const;
  inline ::TST::TableSize* mutable_size();
  inline ::TST::TableSize* release_size();
  inline void set_allocated_size(::TST::TableSize* size);

  // @@protoc_insertion_point(class_scope:TST.CellRange)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* origin_;
  ::TST::TableSize* size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CellRange* default_instance_;
};
// -------------------------------------------------------------------

class TableSelection : public ::google::protobuf::Message {
 public:
  TableSelection();
  virtual ~TableSelection();

  TableSelection(const TableSelection& from);

  inline TableSelection& operator=(const TableSelection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSelection& default_instance();

  void Swap(TableSelection* other);

  // implements Message ----------------------------------------------

  TableSelection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSelection& from);
  void MergeFrom(const TableSelection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellRange cellRange = 1;
  inline bool has_cellrange() const;
  inline void clear_cellrange();
  static const int kCellRangeFieldNumber = 1;
  inline const ::TST::CellRange& cellrange() const;
  inline ::TST::CellRange* mutable_cellrange();
  inline ::TST::CellRange* release_cellrange();
  inline void set_allocated_cellrange(::TST::CellRange* cellrange);

  // required .TST.CellRange extendedCellRange = 2;
  inline bool has_extendedcellrange() const;
  inline void clear_extendedcellrange();
  static const int kExtendedCellRangeFieldNumber = 2;
  inline const ::TST::CellRange& extendedcellrange() const;
  inline ::TST::CellRange* mutable_extendedcellrange();
  inline ::TST::CellRange* release_extendedcellrange();
  inline void set_allocated_extendedcellrange(::TST::CellRange* extendedcellrange);

  // required bool extendedCellRangeValid = 3;
  inline bool has_extendedcellrangevalid() const;
  inline void clear_extendedcellrangevalid();
  static const int kExtendedCellRangeValidFieldNumber = 3;
  inline bool extendedcellrangevalid() const;
  inline void set_extendedcellrangevalid(bool value);

  // required .TST.SelectionTypeArchive selection_type = 4;
  inline bool has_selection_type() const;
  inline void clear_selection_type();
  static const int kSelectionTypeFieldNumber = 4;
  inline ::TST::SelectionTypeArchive selection_type() const;
  inline void set_selection_type(::TST::SelectionTypeArchive value);

  // @@protoc_insertion_point(class_scope:TST.TableSelection)
 private:
  inline void set_has_cellrange();
  inline void clear_has_cellrange();
  inline void set_has_extendedcellrange();
  inline void clear_has_extendedcellrange();
  inline void set_has_extendedcellrangevalid();
  inline void clear_has_extendedcellrangevalid();
  inline void set_has_selection_type();
  inline void clear_has_selection_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellRange* cellrange_;
  ::TST::CellRange* extendedcellrange_;
  bool extendedcellrangevalid_;
  int selection_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableSelection* default_instance_;
};
// -------------------------------------------------------------------

class TileRowInfo : public ::google::protobuf::Message {
 public:
  TileRowInfo();
  virtual ~TileRowInfo();

  TileRowInfo(const TileRowInfo& from);

  inline TileRowInfo& operator=(const TileRowInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileRowInfo& default_instance();

  void Swap(TileRowInfo* other);

  // implements Message ----------------------------------------------

  TileRowInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileRowInfo& from);
  void MergeFrom(const TileRowInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 storage_version = 5;
  inline bool has_storage_version() const;
  inline void clear_storage_version();
  static const int kStorageVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 storage_version() const;
  inline void set_storage_version(::google::protobuf::uint32 value);

  // required uint32 tileRowIndex = 1;
  inline bool has_tilerowindex() const;
  inline void clear_tilerowindex();
  static const int kTileRowIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 tilerowindex() const;
  inline void set_tilerowindex(::google::protobuf::uint32 value);

  // required uint32 cellCount = 2;
  inline bool has_cellcount() const;
  inline void clear_cellcount();
  static const int kCellCountFieldNumber = 2;
  inline ::google::protobuf::uint32 cellcount() const;
  inline void set_cellcount(::google::protobuf::uint32 value);

  // required bytes cellStorageBuffer = 3;
  inline bool has_cellstoragebuffer() const;
  inline void clear_cellstoragebuffer();
  static const int kCellStorageBufferFieldNumber = 3;
  inline const ::std::string& cellstoragebuffer() const;
  inline void set_cellstoragebuffer(const ::std::string& value);
  inline void set_cellstoragebuffer(const char* value);
  inline void set_cellstoragebuffer(const void* value, size_t size);
  inline ::std::string* mutable_cellstoragebuffer();
  inline ::std::string* release_cellstoragebuffer();
  inline void set_allocated_cellstoragebuffer(::std::string* cellstoragebuffer);

  // required bytes cellOffsets = 4;
  inline bool has_celloffsets() const;
  inline void clear_celloffsets();
  static const int kCellOffsetsFieldNumber = 4;
  inline const ::std::string& celloffsets() const;
  inline void set_celloffsets(const ::std::string& value);
  inline void set_celloffsets(const char* value);
  inline void set_celloffsets(const void* value, size_t size);
  inline ::std::string* mutable_celloffsets();
  inline ::std::string* release_celloffsets();
  inline void set_allocated_celloffsets(::std::string* celloffsets);

  // @@protoc_insertion_point(class_scope:TST.TileRowInfo)
 private:
  inline void set_has_storage_version();
  inline void clear_has_storage_version();
  inline void set_has_tilerowindex();
  inline void clear_has_tilerowindex();
  inline void set_has_cellcount();
  inline void clear_has_cellcount();
  inline void set_has_cellstoragebuffer();
  inline void clear_has_cellstoragebuffer();
  inline void set_has_celloffsets();
  inline void clear_has_celloffsets();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 storage_version_;
  ::google::protobuf::uint32 tilerowindex_;
  ::std::string* cellstoragebuffer_;
  ::std::string* celloffsets_;
  ::google::protobuf::uint32 cellcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TileRowInfo* default_instance_;
};
// -------------------------------------------------------------------

class Tile : public ::google::protobuf::Message {
 public:
  Tile();
  virtual ~Tile();

  Tile(const Tile& from);

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tile& default_instance();

  void Swap(Tile* other);

  // implements Message ----------------------------------------------

  Tile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 maxColumn = 1;
  inline bool has_maxcolumn() const;
  inline void clear_maxcolumn();
  static const int kMaxColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 maxcolumn() const;
  inline void set_maxcolumn(::google::protobuf::uint32 value);

  // required uint32 maxRow = 2;
  inline bool has_maxrow() const;
  inline void clear_maxrow();
  static const int kMaxRowFieldNumber = 2;
  inline ::google::protobuf::uint32 maxrow() const;
  inline void set_maxrow(::google::protobuf::uint32 value);

  // required uint32 numCells = 3;
  inline bool has_numcells() const;
  inline void clear_numcells();
  static const int kNumCellsFieldNumber = 3;
  inline ::google::protobuf::uint32 numcells() const;
  inline void set_numcells(::google::protobuf::uint32 value);

  // required uint32 numrows = 4;
  inline bool has_numrows() const;
  inline void clear_numrows();
  static const int kNumrowsFieldNumber = 4;
  inline ::google::protobuf::uint32 numrows() const;
  inline void set_numrows(::google::protobuf::uint32 value);

  // optional uint32 storage_version = 6;
  inline bool has_storage_version() const;
  inline void clear_storage_version();
  static const int kStorageVersionFieldNumber = 6;
  inline ::google::protobuf::uint32 storage_version() const;
  inline void set_storage_version(::google::protobuf::uint32 value);

  // repeated .TST.TileRowInfo rowInfos = 5;
  inline int rowinfos_size() const;
  inline void clear_rowinfos();
  static const int kRowInfosFieldNumber = 5;
  inline const ::TST::TileRowInfo& rowinfos(int index) const;
  inline ::TST::TileRowInfo* mutable_rowinfos(int index);
  inline ::TST::TileRowInfo* add_rowinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::TileRowInfo >&
      rowinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::TileRowInfo >*
      mutable_rowinfos();

  // @@protoc_insertion_point(class_scope:TST.Tile)
 private:
  inline void set_has_maxcolumn();
  inline void clear_has_maxcolumn();
  inline void set_has_maxrow();
  inline void clear_has_maxrow();
  inline void set_has_numcells();
  inline void clear_has_numcells();
  inline void set_has_numrows();
  inline void clear_has_numrows();
  inline void set_has_storage_version();
  inline void clear_has_storage_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 maxcolumn_;
  ::google::protobuf::uint32 maxrow_;
  ::google::protobuf::uint32 numcells_;
  ::google::protobuf::uint32 numrows_;
  ::google::protobuf::RepeatedPtrField< ::TST::TileRowInfo > rowinfos_;
  ::google::protobuf::uint32 storage_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static Tile* default_instance_;
};
// -------------------------------------------------------------------

class TileStorage_Tile : public ::google::protobuf::Message {
 public:
  TileStorage_Tile();
  virtual ~TileStorage_Tile();

  TileStorage_Tile(const TileStorage_Tile& from);

  inline TileStorage_Tile& operator=(const TileStorage_Tile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileStorage_Tile& default_instance();

  void Swap(TileStorage_Tile* other);

  // implements Message ----------------------------------------------

  TileStorage_Tile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileStorage_Tile& from);
  void MergeFrom(const TileStorage_Tile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tileid = 1;
  inline bool has_tileid() const;
  inline void clear_tileid();
  static const int kTileidFieldNumber = 1;
  inline ::google::protobuf::uint32 tileid() const;
  inline void set_tileid(::google::protobuf::uint32 value);

  // required .TSP.Reference tile = 2;
  inline bool has_tile() const;
  inline void clear_tile();
  static const int kTileFieldNumber = 2;
  inline const ::TSP::Reference& tile() const;
  inline ::TSP::Reference* mutable_tile();
  inline ::TSP::Reference* release_tile();
  inline void set_allocated_tile(::TSP::Reference* tile);

  // @@protoc_insertion_point(class_scope:TST.TileStorage.Tile)
 private:
  inline void set_has_tileid();
  inline void clear_has_tileid();
  inline void set_has_tile();
  inline void clear_has_tile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* tile_;
  ::google::protobuf::uint32 tileid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TileStorage_Tile* default_instance_;
};
// -------------------------------------------------------------------

class TileStorage : public ::google::protobuf::Message {
 public:
  TileStorage();
  virtual ~TileStorage();

  TileStorage(const TileStorage& from);

  inline TileStorage& operator=(const TileStorage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileStorage& default_instance();

  void Swap(TileStorage* other);

  // implements Message ----------------------------------------------

  TileStorage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileStorage& from);
  void MergeFrom(const TileStorage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TileStorage_Tile Tile;

  // accessors -------------------------------------------------------

  // repeated .TST.TileStorage.Tile tiles = 1;
  inline int tiles_size() const;
  inline void clear_tiles();
  static const int kTilesFieldNumber = 1;
  inline const ::TST::TileStorage_Tile& tiles(int index) const;
  inline ::TST::TileStorage_Tile* mutable_tiles(int index);
  inline ::TST::TileStorage_Tile* add_tiles();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::TileStorage_Tile >&
      tiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::TileStorage_Tile >*
      mutable_tiles();

  // @@protoc_insertion_point(class_scope:TST.TileStorage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::TileStorage_Tile > tiles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TileStorage* default_instance_;
};
// -------------------------------------------------------------------

class PopUpMenuModel_CellValue : public ::google::protobuf::Message {
 public:
  PopUpMenuModel_CellValue();
  virtual ~PopUpMenuModel_CellValue();

  PopUpMenuModel_CellValue(const PopUpMenuModel_CellValue& from);

  inline PopUpMenuModel_CellValue& operator=(const PopUpMenuModel_CellValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PopUpMenuModel_CellValue& default_instance();

  void Swap(PopUpMenuModel_CellValue* other);

  // implements Message ----------------------------------------------

  PopUpMenuModel_CellValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PopUpMenuModel_CellValue& from);
  void MergeFrom(const PopUpMenuModel_CellValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
  inline bool has_cell_value_type() const;
  inline void clear_cell_value_type();
  static const int kCellValueTypeFieldNumber = 1;
  inline ::TST::PopUpMenuModel_CellValueType cell_value_type() const;
  inline void set_cell_value_type(::TST::PopUpMenuModel_CellValueType value);

  // optional .TSCE.BooleanCellValueArchive boolean_value = 2;
  inline bool has_boolean_value() const;
  inline void clear_boolean_value();
  static const int kBooleanValueFieldNumber = 2;
  inline const ::TSCE::BooleanCellValueArchive& boolean_value() const;
  inline ::TSCE::BooleanCellValueArchive* mutable_boolean_value();
  inline ::TSCE::BooleanCellValueArchive* release_boolean_value();
  inline void set_allocated_boolean_value(::TSCE::BooleanCellValueArchive* boolean_value);

  // optional .TSCE.DateCellValueArchive date_value = 3;
  inline bool has_date_value() const;
  inline void clear_date_value();
  static const int kDateValueFieldNumber = 3;
  inline const ::TSCE::DateCellValueArchive& date_value() const;
  inline ::TSCE::DateCellValueArchive* mutable_date_value();
  inline ::TSCE::DateCellValueArchive* release_date_value();
  inline void set_allocated_date_value(::TSCE::DateCellValueArchive* date_value);

  // optional .TSCE.NumberCellValueArchive number_value = 4;
  inline bool has_number_value() const;
  inline void clear_number_value();
  static const int kNumberValueFieldNumber = 4;
  inline const ::TSCE::NumberCellValueArchive& number_value() const;
  inline ::TSCE::NumberCellValueArchive* mutable_number_value();
  inline ::TSCE::NumberCellValueArchive* release_number_value();
  inline void set_allocated_number_value(::TSCE::NumberCellValueArchive* number_value);

  // optional .TSCE.StringCellValueArchive string_value = 5;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 5;
  inline const ::TSCE::StringCellValueArchive& string_value() const;
  inline ::TSCE::StringCellValueArchive* mutable_string_value();
  inline ::TSCE::StringCellValueArchive* release_string_value();
  inline void set_allocated_string_value(::TSCE::StringCellValueArchive* string_value);

  // @@protoc_insertion_point(class_scope:TST.PopUpMenuModel.CellValue)
 private:
  inline void set_has_cell_value_type();
  inline void clear_has_cell_value_type();
  inline void set_has_boolean_value();
  inline void clear_has_boolean_value();
  inline void set_has_date_value();
  inline void clear_has_date_value();
  inline void set_has_number_value();
  inline void clear_has_number_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::BooleanCellValueArchive* boolean_value_;
  ::TSCE::DateCellValueArchive* date_value_;
  ::TSCE::NumberCellValueArchive* number_value_;
  ::TSCE::StringCellValueArchive* string_value_;
  int cell_value_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static PopUpMenuModel_CellValue* default_instance_;
};
// -------------------------------------------------------------------

class PopUpMenuModel : public ::google::protobuf::Message {
 public:
  PopUpMenuModel();
  virtual ~PopUpMenuModel();

  PopUpMenuModel(const PopUpMenuModel& from);

  inline PopUpMenuModel& operator=(const PopUpMenuModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PopUpMenuModel& default_instance();

  void Swap(PopUpMenuModel* other);

  // implements Message ----------------------------------------------

  PopUpMenuModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PopUpMenuModel& from);
  void MergeFrom(const PopUpMenuModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PopUpMenuModel_CellValue CellValue;

  typedef PopUpMenuModel_CellValueType CellValueType;
  static const CellValueType NIL_TYPE = PopUpMenuModel_CellValueType_NIL_TYPE;
  static const CellValueType BOOLEAN_TYPE = PopUpMenuModel_CellValueType_BOOLEAN_TYPE;
  static const CellValueType DATE_TYPE = PopUpMenuModel_CellValueType_DATE_TYPE;
  static const CellValueType NUMBER_TYPE = PopUpMenuModel_CellValueType_NUMBER_TYPE;
  static const CellValueType STRING_TYPE = PopUpMenuModel_CellValueType_STRING_TYPE;
  static inline bool CellValueType_IsValid(int value) {
    return PopUpMenuModel_CellValueType_IsValid(value);
  }
  static const CellValueType CellValueType_MIN =
    PopUpMenuModel_CellValueType_CellValueType_MIN;
  static const CellValueType CellValueType_MAX =
    PopUpMenuModel_CellValueType_CellValueType_MAX;
  static const int CellValueType_ARRAYSIZE =
    PopUpMenuModel_CellValueType_CellValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CellValueType_descriptor() {
    return PopUpMenuModel_CellValueType_descriptor();
  }
  static inline const ::std::string& CellValueType_Name(CellValueType value) {
    return PopUpMenuModel_CellValueType_Name(value);
  }
  static inline bool CellValueType_Parse(const ::std::string& name,
      CellValueType* value) {
    return PopUpMenuModel_CellValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
  inline int item_size() const PROTOBUF_DEPRECATED;
  inline void clear_item() PROTOBUF_DEPRECATED;
  static const int kItemFieldNumber = 1;
  inline const ::TST::PopUpMenuModel_CellValue& item(int index) const PROTOBUF_DEPRECATED;
  inline ::TST::PopUpMenuModel_CellValue* mutable_item(int index) PROTOBUF_DEPRECATED;
  inline ::TST::PopUpMenuModel_CellValue* add_item() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >&
      item() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >*
      mutable_item() PROTOBUF_DEPRECATED;

  // repeated .TSCE.CellValueArchive tsce_item = 2;
  inline int tsce_item_size() const;
  inline void clear_tsce_item();
  static const int kTsceItemFieldNumber = 2;
  inline const ::TSCE::CellValueArchive& tsce_item(int index) const;
  inline ::TSCE::CellValueArchive* mutable_tsce_item(int index);
  inline ::TSCE::CellValueArchive* add_tsce_item();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >&
      tsce_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >*
      mutable_tsce_item();

  // @@protoc_insertion_point(class_scope:TST.PopUpMenuModel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue > item_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive > tsce_item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static PopUpMenuModel* default_instance_;
};
// -------------------------------------------------------------------

class TableDataList_ListEntry : public ::google::protobuf::Message {
 public:
  TableDataList_ListEntry();
  virtual ~TableDataList_ListEntry();

  TableDataList_ListEntry(const TableDataList_ListEntry& from);

  inline TableDataList_ListEntry& operator=(const TableDataList_ListEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDataList_ListEntry& default_instance();

  void Swap(TableDataList_ListEntry* other);

  // implements Message ----------------------------------------------

  TableDataList_ListEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableDataList_ListEntry& from);
  void MergeFrom(const TableDataList_ListEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);

  // required uint32 refcount = 2;
  inline bool has_refcount() const;
  inline void clear_refcount();
  static const int kRefcountFieldNumber = 2;
  inline ::google::protobuf::uint32 refcount() const;
  inline void set_refcount(::google::protobuf::uint32 value);

  // optional string string = 3;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 3;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  inline void set_allocated_string(::std::string* string);

  // optional .TSP.Reference reference = 4;
  inline bool has_reference() const;
  inline void clear_reference();
  static const int kReferenceFieldNumber = 4;
  inline const ::TSP::Reference& reference() const;
  inline ::TSP::Reference* mutable_reference();
  inline ::TSP::Reference* release_reference();
  inline void set_allocated_reference(::TSP::Reference* reference);

  // optional .TSCE.FormulaArchive formula = 5;
  inline bool has_formula() const;
  inline void clear_formula();
  static const int kFormulaFieldNumber = 5;
  inline const ::TSCE::FormulaArchive& formula() const;
  inline ::TSCE::FormulaArchive* mutable_formula();
  inline ::TSCE::FormulaArchive* release_formula();
  inline void set_allocated_formula(::TSCE::FormulaArchive* formula);

  // optional .TSK.FormatStructArchive format = 6;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 6;
  inline const ::TSK::FormatStructArchive& format() const;
  inline ::TSK::FormatStructArchive* mutable_format();
  inline ::TSK::FormatStructArchive* release_format();
  inline void set_allocated_format(::TSK::FormatStructArchive* format);

  // optional .TST.CellRange region = 7;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 7;
  inline const ::TST::CellRange& region() const;
  inline ::TST::CellRange* mutable_region();
  inline ::TST::CellRange* release_region();
  inline void set_allocated_region(::TST::CellRange* region);

  // optional .TSK.CustomFormatArchive custom_format = 8;
  inline bool has_custom_format() const;
  inline void clear_custom_format();
  static const int kCustomFormatFieldNumber = 8;
  inline const ::TSK::CustomFormatArchive& custom_format() const;
  inline ::TSK::CustomFormatArchive* mutable_custom_format();
  inline ::TSK::CustomFormatArchive* release_custom_format();
  inline void set_allocated_custom_format(::TSK::CustomFormatArchive* custom_format);

  // optional .TSP.Reference richTextPayload = 9;
  inline bool has_richtextpayload() const;
  inline void clear_richtextpayload();
  static const int kRichTextPayloadFieldNumber = 9;
  inline const ::TSP::Reference& richtextpayload() const;
  inline ::TSP::Reference* mutable_richtextpayload();
  inline ::TSP::Reference* release_richtextpayload();
  inline void set_allocated_richtextpayload(::TSP::Reference* richtextpayload);

  // optional .TSP.Reference comment_storage = 10;
  inline bool has_comment_storage() const;
  inline void clear_comment_storage();
  static const int kCommentStorageFieldNumber = 10;
  inline const ::TSP::Reference& comment_storage() const;
  inline ::TSP::Reference* mutable_comment_storage();
  inline ::TSP::Reference* release_comment_storage();
  inline void set_allocated_comment_storage(::TSP::Reference* comment_storage);

  // @@protoc_insertion_point(class_scope:TST.TableDataList.ListEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_refcount();
  inline void clear_has_refcount();
  inline void set_has_string();
  inline void clear_has_string();
  inline void set_has_reference();
  inline void clear_has_reference();
  inline void set_has_formula();
  inline void clear_has_formula();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_custom_format();
  inline void clear_has_custom_format();
  inline void set_has_richtextpayload();
  inline void clear_has_richtextpayload();
  inline void set_has_comment_storage();
  inline void clear_has_comment_storage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 key_;
  ::google::protobuf::uint32 refcount_;
  ::std::string* string_;
  ::TSP::Reference* reference_;
  ::TSCE::FormulaArchive* formula_;
  ::TSK::FormatStructArchive* format_;
  ::TST::CellRange* region_;
  ::TSK::CustomFormatArchive* custom_format_;
  ::TSP::Reference* richtextpayload_;
  ::TSP::Reference* comment_storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableDataList_ListEntry* default_instance_;
};
// -------------------------------------------------------------------

class TableDataList : public ::google::protobuf::Message {
 public:
  TableDataList();
  virtual ~TableDataList();

  TableDataList(const TableDataList& from);

  inline TableDataList& operator=(const TableDataList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDataList& default_instance();

  void Swap(TableDataList* other);

  // implements Message ----------------------------------------------

  TableDataList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableDataList& from);
  void MergeFrom(const TableDataList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TableDataList_ListEntry ListEntry;

  typedef TableDataList_ListType ListType;
  static const ListType STRING = TableDataList_ListType_STRING;
  static const ListType FORMAT = TableDataList_ListType_FORMAT;
  static const ListType FORMULA = TableDataList_ListType_FORMULA;
  static const ListType STYLE = TableDataList_ListType_STYLE;
  static const ListType FORMULA_ERROR = TableDataList_ListType_FORMULA_ERROR;
  static const ListType CUSTOM_FORMAT = TableDataList_ListType_CUSTOM_FORMAT;
  static const ListType MULTIPLE_CHOICE_LIST_FORMAT = TableDataList_ListType_MULTIPLE_CHOICE_LIST_FORMAT;
  static const ListType RICH_TEXT_PAYLOAD = TableDataList_ListType_RICH_TEXT_PAYLOAD;
  static const ListType CONDITIONAL_STYLE = TableDataList_ListType_CONDITIONAL_STYLE;
  static const ListType COMMENT_STORAGE = TableDataList_ListType_COMMENT_STORAGE;
  static inline bool ListType_IsValid(int value) {
    return TableDataList_ListType_IsValid(value);
  }
  static const ListType ListType_MIN =
    TableDataList_ListType_ListType_MIN;
  static const ListType ListType_MAX =
    TableDataList_ListType_ListType_MAX;
  static const int ListType_ARRAYSIZE =
    TableDataList_ListType_ListType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ListType_descriptor() {
    return TableDataList_ListType_descriptor();
  }
  static inline const ::std::string& ListType_Name(ListType value) {
    return TableDataList_ListType_Name(value);
  }
  static inline bool ListType_Parse(const ::std::string& name,
      ListType* value) {
    return TableDataList_ListType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TST.TableDataList.ListType listType = 1;
  inline bool has_listtype() const;
  inline void clear_listtype();
  static const int kListTypeFieldNumber = 1;
  inline ::TST::TableDataList_ListType listtype() const;
  inline void set_listtype(::TST::TableDataList_ListType value);

  // required uint32 nextListID = 2;
  inline bool has_nextlistid() const;
  inline void clear_nextlistid();
  static const int kNextListIDFieldNumber = 2;
  inline ::google::protobuf::uint32 nextlistid() const;
  inline void set_nextlistid(::google::protobuf::uint32 value);

  // repeated .TST.TableDataList.ListEntry entries = 3;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline const ::TST::TableDataList_ListEntry& entries(int index) const;
  inline ::TST::TableDataList_ListEntry* mutable_entries(int index);
  inline ::TST::TableDataList_ListEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::TableDataList_ListEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::TableDataList_ListEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TST.TableDataList)
 private:
  inline void set_has_listtype();
  inline void clear_has_listtype();
  inline void set_has_nextlistid();
  inline void clear_has_nextlistid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int listtype_;
  ::google::protobuf::uint32 nextlistid_;
  ::google::protobuf::RepeatedPtrField< ::TST::TableDataList_ListEntry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableDataList* default_instance_;
};
// -------------------------------------------------------------------

class TableRBTree_Node : public ::google::protobuf::Message {
 public:
  TableRBTree_Node();
  virtual ~TableRBTree_Node();

  TableRBTree_Node(const TableRBTree_Node& from);

  inline TableRBTree_Node& operator=(const TableRBTree_Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableRBTree_Node& default_instance();

  void Swap(TableRBTree_Node* other);

  // implements Message ----------------------------------------------

  TableRBTree_Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableRBTree_Node& from);
  void MergeFrom(const TableRBTree_Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);

  // required uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.TableRBTree.Node)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 key_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableRBTree_Node* default_instance_;
};
// -------------------------------------------------------------------

class TableRBTree : public ::google::protobuf::Message {
 public:
  TableRBTree();
  virtual ~TableRBTree();

  TableRBTree(const TableRBTree& from);

  inline TableRBTree& operator=(const TableRBTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableRBTree& default_instance();

  void Swap(TableRBTree* other);

  // implements Message ----------------------------------------------

  TableRBTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableRBTree& from);
  void MergeFrom(const TableRBTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TableRBTree_Node Node;

  // accessors -------------------------------------------------------

  // repeated .TST.TableRBTree.Node nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::TST::TableRBTree_Node& nodes(int index) const;
  inline ::TST::TableRBTree_Node* mutable_nodes(int index);
  inline ::TST::TableRBTree_Node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::TableRBTree_Node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::TableRBTree_Node >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:TST.TableRBTree)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::TableRBTree_Node > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableRBTree* default_instance_;
};
// -------------------------------------------------------------------

class HeaderStorageBucket_Header : public ::google::protobuf::Message {
 public:
  HeaderStorageBucket_Header();
  virtual ~HeaderStorageBucket_Header();

  HeaderStorageBucket_Header(const HeaderStorageBucket_Header& from);

  inline HeaderStorageBucket_Header& operator=(const HeaderStorageBucket_Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeaderStorageBucket_Header& default_instance();

  void Swap(HeaderStorageBucket_Header* other);

  // implements Message ----------------------------------------------

  HeaderStorageBucket_Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeaderStorageBucket_Header& from);
  void MergeFrom(const HeaderStorageBucket_Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required float size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline float size() const;
  inline void set_size(float value);

  // required uint32 hidingState = 3;
  inline bool has_hidingstate() const;
  inline void clear_hidingstate();
  static const int kHidingStateFieldNumber = 3;
  inline ::google::protobuf::uint32 hidingstate() const;
  inline void set_hidingstate(::google::protobuf::uint32 value);

  // required uint32 numberOfCells = 4;
  inline bool has_numberofcells() const;
  inline void clear_numberofcells();
  static const int kNumberOfCellsFieldNumber = 4;
  inline ::google::protobuf::uint32 numberofcells() const;
  inline void set_numberofcells(::google::protobuf::uint32 value);

  // optional .TSP.Reference cell_style = 5;
  inline bool has_cell_style() const;
  inline void clear_cell_style();
  static const int kCellStyleFieldNumber = 5;
  inline const ::TSP::Reference& cell_style() const;
  inline ::TSP::Reference* mutable_cell_style();
  inline ::TSP::Reference* release_cell_style();
  inline void set_allocated_cell_style(::TSP::Reference* cell_style);

  // optional .TSP.Reference text_style = 6;
  inline bool has_text_style() const;
  inline void clear_text_style();
  static const int kTextStyleFieldNumber = 6;
  inline const ::TSP::Reference& text_style() const;
  inline ::TSP::Reference* mutable_text_style();
  inline ::TSP::Reference* release_text_style();
  inline void set_allocated_text_style(::TSP::Reference* text_style);

  // @@protoc_insertion_point(class_scope:TST.HeaderStorageBucket.Header)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_hidingstate();
  inline void clear_has_hidingstate();
  inline void set_has_numberofcells();
  inline void clear_has_numberofcells();
  inline void set_has_cell_style();
  inline void clear_has_cell_style();
  inline void set_has_text_style();
  inline void clear_has_text_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  float size_;
  ::google::protobuf::uint32 hidingstate_;
  ::google::protobuf::uint32 numberofcells_;
  ::TSP::Reference* cell_style_;
  ::TSP::Reference* text_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static HeaderStorageBucket_Header* default_instance_;
};
// -------------------------------------------------------------------

class HeaderStorageBucket : public ::google::protobuf::Message {
 public:
  HeaderStorageBucket();
  virtual ~HeaderStorageBucket();

  HeaderStorageBucket(const HeaderStorageBucket& from);

  inline HeaderStorageBucket& operator=(const HeaderStorageBucket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeaderStorageBucket& default_instance();

  void Swap(HeaderStorageBucket* other);

  // implements Message ----------------------------------------------

  HeaderStorageBucket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeaderStorageBucket& from);
  void MergeFrom(const HeaderStorageBucket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HeaderStorageBucket_Header Header;

  // accessors -------------------------------------------------------

  // required uint32 bucketHashFunction = 1;
  inline bool has_buckethashfunction() const;
  inline void clear_buckethashfunction();
  static const int kBucketHashFunctionFieldNumber = 1;
  inline ::google::protobuf::uint32 buckethashfunction() const;
  inline void set_buckethashfunction(::google::protobuf::uint32 value);

  // repeated .TST.HeaderStorageBucket.Header headers = 2;
  inline int headers_size() const;
  inline void clear_headers();
  static const int kHeadersFieldNumber = 2;
  inline const ::TST::HeaderStorageBucket_Header& headers(int index) const;
  inline ::TST::HeaderStorageBucket_Header* mutable_headers(int index);
  inline ::TST::HeaderStorageBucket_Header* add_headers();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >&
      headers() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >*
      mutable_headers();

  // @@protoc_insertion_point(class_scope:TST.HeaderStorageBucket)
 private:
  inline void set_has_buckethashfunction();
  inline void clear_has_buckethashfunction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::HeaderStorageBucket_Header > headers_;
  ::google::protobuf::uint32 buckethashfunction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static HeaderStorageBucket* default_instance_;
};
// -------------------------------------------------------------------

class HeaderStorage : public ::google::protobuf::Message {
 public:
  HeaderStorage();
  virtual ~HeaderStorage();

  HeaderStorage(const HeaderStorage& from);

  inline HeaderStorage& operator=(const HeaderStorage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeaderStorage& default_instance();

  void Swap(HeaderStorage* other);

  // implements Message ----------------------------------------------

  HeaderStorage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeaderStorage& from);
  void MergeFrom(const HeaderStorage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 bucketHashFunction = 1;
  inline bool has_buckethashfunction() const;
  inline void clear_buckethashfunction();
  static const int kBucketHashFunctionFieldNumber = 1;
  inline ::google::protobuf::uint32 buckethashfunction() const;
  inline void set_buckethashfunction(::google::protobuf::uint32 value);

  // repeated .TSP.Reference buckets = 2;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 2;
  inline const ::TSP::Reference& buckets(int index) const;
  inline ::TSP::Reference* mutable_buckets(int index);
  inline ::TSP::Reference* add_buckets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_buckets();

  // @@protoc_insertion_point(class_scope:TST.HeaderStorage)
 private:
  inline void set_has_buckethashfunction();
  inline void clear_has_buckethashfunction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > buckets_;
  ::google::protobuf::uint32 buckethashfunction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static HeaderStorage* default_instance_;
};
// -------------------------------------------------------------------

class DataStore : public ::google::protobuf::Message {
 public:
  DataStore();
  virtual ~DataStore();

  DataStore(const DataStore& from);

  inline DataStore& operator=(const DataStore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataStore& default_instance();

  void Swap(DataStore* other);

  // implements Message ----------------------------------------------

  DataStore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataStore& from);
  void MergeFrom(const DataStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.HeaderStorage rowHeaders = 1;
  inline bool has_rowheaders() const;
  inline void clear_rowheaders();
  static const int kRowHeadersFieldNumber = 1;
  inline const ::TST::HeaderStorage& rowheaders() const;
  inline ::TST::HeaderStorage* mutable_rowheaders();
  inline ::TST::HeaderStorage* release_rowheaders();
  inline void set_allocated_rowheaders(::TST::HeaderStorage* rowheaders);

  // required .TSP.Reference columnHeaders = 2;
  inline bool has_columnheaders() const;
  inline void clear_columnheaders();
  static const int kColumnHeadersFieldNumber = 2;
  inline const ::TSP::Reference& columnheaders() const;
  inline ::TSP::Reference* mutable_columnheaders();
  inline ::TSP::Reference* release_columnheaders();
  inline void set_allocated_columnheaders(::TSP::Reference* columnheaders);

  // required .TST.TileStorage tiles = 3;
  inline bool has_tiles() const;
  inline void clear_tiles();
  static const int kTilesFieldNumber = 3;
  inline const ::TST::TileStorage& tiles() const;
  inline ::TST::TileStorage* mutable_tiles();
  inline ::TST::TileStorage* release_tiles();
  inline void set_allocated_tiles(::TST::TileStorage* tiles);

  // required .TSP.Reference stringTable = 4;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 4;
  inline const ::TSP::Reference& stringtable() const;
  inline ::TSP::Reference* mutable_stringtable();
  inline ::TSP::Reference* release_stringtable();
  inline void set_allocated_stringtable(::TSP::Reference* stringtable);

  // required .TSP.Reference styleTable = 5;
  inline bool has_styletable() const;
  inline void clear_styletable();
  static const int kStyleTableFieldNumber = 5;
  inline const ::TSP::Reference& styletable() const;
  inline ::TSP::Reference* mutable_styletable();
  inline ::TSP::Reference* release_styletable();
  inline void set_allocated_styletable(::TSP::Reference* styletable);

  // required .TSP.Reference formulaTable = 6;
  inline bool has_formulatable() const;
  inline void clear_formulatable();
  static const int kFormulaTableFieldNumber = 6;
  inline const ::TSP::Reference& formulatable() const;
  inline ::TSP::Reference* mutable_formulatable();
  inline ::TSP::Reference* release_formulatable();
  inline void set_allocated_formulatable(::TSP::Reference* formulatable);

  // optional .TSP.Reference formulaErrorTable = 12;
  inline bool has_formulaerrortable() const;
  inline void clear_formulaerrortable();
  static const int kFormulaErrorTableFieldNumber = 12;
  inline const ::TSP::Reference& formulaerrortable() const;
  inline ::TSP::Reference* mutable_formulaerrortable();
  inline ::TSP::Reference* release_formulaerrortable();
  inline void set_allocated_formulaerrortable(::TSP::Reference* formulaerrortable);

  // required .TSP.Reference formatTable = 11;
  inline bool has_formattable() const;
  inline void clear_formattable();
  static const int kFormatTableFieldNumber = 11;
  inline const ::TSP::Reference& formattable() const;
  inline ::TSP::Reference* mutable_formattable();
  inline ::TSP::Reference* release_formattable();
  inline void set_allocated_formattable(::TSP::Reference* formattable);

  // optional .TSP.Reference multipleChoiceListFormatTable = 16;
  inline bool has_multiplechoicelistformattable() const;
  inline void clear_multiplechoicelistformattable();
  static const int kMultipleChoiceListFormatTableFieldNumber = 16;
  inline const ::TSP::Reference& multiplechoicelistformattable() const;
  inline ::TSP::Reference* mutable_multiplechoicelistformattable();
  inline ::TSP::Reference* release_multiplechoicelistformattable();
  inline void set_allocated_multiplechoicelistformattable(::TSP::Reference* multiplechoicelistformattable);

  // optional .TSP.Reference merge_region_map = 13;
  inline bool has_merge_region_map() const;
  inline void clear_merge_region_map();
  static const int kMergeRegionMapFieldNumber = 13;
  inline const ::TSP::Reference& merge_region_map() const;
  inline ::TSP::Reference* mutable_merge_region_map();
  inline ::TSP::Reference* release_merge_region_map();
  inline void set_allocated_merge_region_map(::TSP::Reference* merge_region_map);

  // optional .TSP.Reference customFormatTable = 15;
  inline bool has_customformattable() const;
  inline void clear_customformattable();
  static const int kCustomFormatTableFieldNumber = 15;
  inline const ::TSP::Reference& customformattable() const;
  inline ::TSP::Reference* mutable_customformattable();
  inline ::TSP::Reference* release_customformattable();
  inline void set_allocated_customformattable(::TSP::Reference* customformattable);

  // required uint32 nextRowStripID = 7;
  inline bool has_nextrowstripid() const;
  inline void clear_nextrowstripid();
  static const int kNextRowStripIDFieldNumber = 7;
  inline ::google::protobuf::uint32 nextrowstripid() const;
  inline void set_nextrowstripid(::google::protobuf::uint32 value);

  // required uint32 nextColumnStripID = 8;
  inline bool has_nextcolumnstripid() const;
  inline void clear_nextcolumnstripid();
  static const int kNextColumnStripIDFieldNumber = 8;
  inline ::google::protobuf::uint32 nextcolumnstripid() const;
  inline void set_nextcolumnstripid(::google::protobuf::uint32 value);

  // required .TST.TableRBTree rowTileTree = 9;
  inline bool has_rowtiletree() const;
  inline void clear_rowtiletree();
  static const int kRowTileTreeFieldNumber = 9;
  inline const ::TST::TableRBTree& rowtiletree() const;
  inline ::TST::TableRBTree* mutable_rowtiletree();
  inline ::TST::TableRBTree* release_rowtiletree();
  inline void set_allocated_rowtiletree(::TST::TableRBTree* rowtiletree);

  // required .TST.TableRBTree columnTileTree = 10;
  inline bool has_columntiletree() const;
  inline void clear_columntiletree();
  static const int kColumnTileTreeFieldNumber = 10;
  inline const ::TST::TableRBTree& columntiletree() const;
  inline ::TST::TableRBTree* mutable_columntiletree();
  inline ::TST::TableRBTree* release_columntiletree();
  inline void set_allocated_columntiletree(::TST::TableRBTree* columntiletree);

  // optional uint32 storage_version = 14;
  inline bool has_storage_version() const;
  inline void clear_storage_version();
  static const int kStorageVersionFieldNumber = 14;
  inline ::google::protobuf::uint32 storage_version() const;
  inline void set_storage_version(::google::protobuf::uint32 value);

  // optional .TSP.Reference richTextPayloadTable = 17;
  inline bool has_richtextpayloadtable() const;
  inline void clear_richtextpayloadtable();
  static const int kRichTextPayloadTableFieldNumber = 17;
  inline const ::TSP::Reference& richtextpayloadtable() const;
  inline ::TSP::Reference* mutable_richtextpayloadtable();
  inline ::TSP::Reference* release_richtextpayloadtable();
  inline void set_allocated_richtextpayloadtable(::TSP::Reference* richtextpayloadtable);

  // optional .TSP.Reference conditionalstyletable = 18;
  inline bool has_conditionalstyletable() const;
  inline void clear_conditionalstyletable();
  static const int kConditionalstyletableFieldNumber = 18;
  inline const ::TSP::Reference& conditionalstyletable() const;
  inline ::TSP::Reference* mutable_conditionalstyletable();
  inline ::TSP::Reference* release_conditionalstyletable();
  inline void set_allocated_conditionalstyletable(::TSP::Reference* conditionalstyletable);

  // optional .TSP.Reference commentStorageTable = 19;
  inline bool has_commentstoragetable() const;
  inline void clear_commentstoragetable();
  static const int kCommentStorageTableFieldNumber = 19;
  inline const ::TSP::Reference& commentstoragetable() const;
  inline ::TSP::Reference* mutable_commentstoragetable();
  inline ::TSP::Reference* release_commentstoragetable();
  inline void set_allocated_commentstoragetable(::TSP::Reference* commentstoragetable);

  // @@protoc_insertion_point(class_scope:TST.DataStore)
 private:
  inline void set_has_rowheaders();
  inline void clear_has_rowheaders();
  inline void set_has_columnheaders();
  inline void clear_has_columnheaders();
  inline void set_has_tiles();
  inline void clear_has_tiles();
  inline void set_has_stringtable();
  inline void clear_has_stringtable();
  inline void set_has_styletable();
  inline void clear_has_styletable();
  inline void set_has_formulatable();
  inline void clear_has_formulatable();
  inline void set_has_formulaerrortable();
  inline void clear_has_formulaerrortable();
  inline void set_has_formattable();
  inline void clear_has_formattable();
  inline void set_has_multiplechoicelistformattable();
  inline void clear_has_multiplechoicelistformattable();
  inline void set_has_merge_region_map();
  inline void clear_has_merge_region_map();
  inline void set_has_customformattable();
  inline void clear_has_customformattable();
  inline void set_has_nextrowstripid();
  inline void clear_has_nextrowstripid();
  inline void set_has_nextcolumnstripid();
  inline void clear_has_nextcolumnstripid();
  inline void set_has_rowtiletree();
  inline void clear_has_rowtiletree();
  inline void set_has_columntiletree();
  inline void clear_has_columntiletree();
  inline void set_has_storage_version();
  inline void clear_has_storage_version();
  inline void set_has_richtextpayloadtable();
  inline void clear_has_richtextpayloadtable();
  inline void set_has_conditionalstyletable();
  inline void clear_has_conditionalstyletable();
  inline void set_has_commentstoragetable();
  inline void clear_has_commentstoragetable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::HeaderStorage* rowheaders_;
  ::TSP::Reference* columnheaders_;
  ::TST::TileStorage* tiles_;
  ::TSP::Reference* stringtable_;
  ::TSP::Reference* styletable_;
  ::TSP::Reference* formulatable_;
  ::TSP::Reference* formulaerrortable_;
  ::TSP::Reference* formattable_;
  ::TSP::Reference* multiplechoicelistformattable_;
  ::TSP::Reference* merge_region_map_;
  ::TSP::Reference* customformattable_;
  ::google::protobuf::uint32 nextrowstripid_;
  ::google::protobuf::uint32 nextcolumnstripid_;
  ::TST::TableRBTree* rowtiletree_;
  ::TST::TableRBTree* columntiletree_;
  ::TSP::Reference* richtextpayloadtable_;
  ::TSP::Reference* conditionalstyletable_;
  ::TSP::Reference* commentstoragetable_;
  ::google::protobuf::uint32 storage_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static DataStore* default_instance_;
};
// -------------------------------------------------------------------

class TableInfoArchive : public ::google::protobuf::Message {
 public:
  TableInfoArchive();
  virtual ~TableInfoArchive();

  TableInfoArchive(const TableInfoArchive& from);

  inline TableInfoArchive& operator=(const TableInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableInfoArchive& default_instance();

  void Swap(TableInfoArchive* other);

  // implements Message ----------------------------------------------

  TableInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableInfoArchive& from);
  void MergeFrom(const TableInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.DrawableArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::DrawableArchive& super() const;
  inline ::TSD::DrawableArchive* mutable_super();
  inline ::TSD::DrawableArchive* release_super();
  inline void set_allocated_super(::TSD::DrawableArchive* super);

  // required .TSP.Reference tableModel = 2;
  inline bool has_tablemodel() const;
  inline void clear_tablemodel();
  static const int kTableModelFieldNumber = 2;
  inline const ::TSP::Reference& tablemodel() const;
  inline ::TSP::Reference* mutable_tablemodel();
  inline ::TSP::Reference* release_tablemodel();
  inline void set_allocated_tablemodel(::TSP::Reference* tablemodel);

  // optional .TSP.Reference editingState = 3;
  inline bool has_editingstate() const;
  inline void clear_editingstate();
  static const int kEditingStateFieldNumber = 3;
  inline const ::TSP::Reference& editingstate() const;
  inline ::TSP::Reference* mutable_editingstate();
  inline ::TSP::Reference* release_editingstate();
  inline void set_allocated_editingstate(::TSP::Reference* editingstate);

  // @@protoc_insertion_point(class_scope:TST.TableInfoArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_tablemodel();
  inline void clear_has_tablemodel();
  inline void set_has_editingstate();
  inline void clear_has_editingstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::DrawableArchive* super_;
  ::TSP::Reference* tablemodel_;
  ::TSP::Reference* editingstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class EditingStateArchive : public ::google::protobuf::Message {
 public:
  EditingStateArchive();
  virtual ~EditingStateArchive();

  EditingStateArchive(const EditingStateArchive& from);

  inline EditingStateArchive& operator=(const EditingStateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditingStateArchive& default_instance();

  void Swap(EditingStateArchive* other);

  // implements Message ----------------------------------------------

  EditingStateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditingStateArchive& from);
  void MergeFrom(const EditingStateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference editingStorage = 1;
  inline bool has_editingstorage() const;
  inline void clear_editingstorage();
  static const int kEditingStorageFieldNumber = 1;
  inline const ::TSP::Reference& editingstorage() const;
  inline ::TSP::Reference* mutable_editingstorage();
  inline ::TSP::Reference* release_editingstorage();
  inline void set_allocated_editingstorage(::TSP::Reference* editingstorage);

  // required .TST.Cell editingCell = 2;
  inline bool has_editingcell() const;
  inline void clear_editingcell();
  static const int kEditingCellFieldNumber = 2;
  inline const ::TST::Cell& editingcell() const;
  inline ::TST::Cell* mutable_editingcell();
  inline ::TST::Cell* release_editingcell();
  inline void set_allocated_editingcell(::TST::Cell* editingcell);

  // optional .TST.SelectionArchive selection = 3;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 3;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // optional .TST.CellID lasteditingcellid = 4;
  inline bool has_lasteditingcellid() const;
  inline void clear_lasteditingcellid();
  static const int kLasteditingcellidFieldNumber = 4;
  inline const ::TST::CellID& lasteditingcellid() const;
  inline ::TST::CellID* mutable_lasteditingcellid();
  inline ::TST::CellID* release_lasteditingcellid();
  inline void set_allocated_lasteditingcellid(::TST::CellID* lasteditingcellid);

  // optional .TST.CellID editingcellid = 5;
  inline bool has_editingcellid() const;
  inline void clear_editingcellid();
  static const int kEditingcellidFieldNumber = 5;
  inline const ::TST::CellID& editingcellid() const;
  inline ::TST::CellID* mutable_editingcellid();
  inline ::TST::CellID* release_editingcellid();
  inline void set_allocated_editingcellid(::TST::CellID* editingcellid);

  // optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
  inline bool has_deprecated_setup_textundoredotransaction() const;
  inline void clear_deprecated_setup_textundoredotransaction();
  static const int kDeprecatedSetupTextUndoRedoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& deprecated_setup_textundoredotransaction() const;
  inline ::TSWP::UndoTransaction* mutable_deprecated_setup_textundoredotransaction();
  inline ::TSWP::UndoTransaction* release_deprecated_setup_textundoredotransaction();
  inline void set_allocated_deprecated_setup_textundoredotransaction(::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction);

  // optional bool cell_was_edited_in_current_session = 7;
  inline bool has_cell_was_edited_in_current_session() const;
  inline void clear_cell_was_edited_in_current_session();
  static const int kCellWasEditedInCurrentSessionFieldNumber = 7;
  inline bool cell_was_edited_in_current_session() const;
  inline void set_cell_was_edited_in_current_session(bool value);

  // @@protoc_insertion_point(class_scope:TST.EditingStateArchive)
 private:
  inline void set_has_editingstorage();
  inline void clear_has_editingstorage();
  inline void set_has_editingcell();
  inline void clear_has_editingcell();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_lasteditingcellid();
  inline void clear_has_lasteditingcellid();
  inline void set_has_editingcellid();
  inline void clear_has_editingcellid();
  inline void set_has_deprecated_setup_textundoredotransaction();
  inline void clear_has_deprecated_setup_textundoredotransaction();
  inline void set_has_cell_was_edited_in_current_session();
  inline void clear_has_cell_was_edited_in_current_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* editingstorage_;
  ::TST::Cell* editingcell_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellID* lasteditingcellid_;
  ::TST::CellID* editingcellid_;
  ::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction_;
  bool cell_was_edited_in_current_session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static EditingStateArchive* default_instance_;
};
// -------------------------------------------------------------------

class WPTableInfoArchive : public ::google::protobuf::Message {
 public:
  WPTableInfoArchive();
  virtual ~WPTableInfoArchive();

  WPTableInfoArchive(const WPTableInfoArchive& from);

  inline WPTableInfoArchive& operator=(const WPTableInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WPTableInfoArchive& default_instance();

  void Swap(WPTableInfoArchive* other);

  // implements Message ----------------------------------------------

  WPTableInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WPTableInfoArchive& from);
  void MergeFrom(const WPTableInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableInfoArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableInfoArchive& super() const;
  inline ::TST::TableInfoArchive* mutable_super();
  inline ::TST::TableInfoArchive* release_super();
  inline void set_allocated_super(::TST::TableInfoArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // @@protoc_insertion_point(class_scope:TST.WPTableInfoArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableInfoArchive* super_;
  ::TSP::Reference* storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static WPTableInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class TableStyleNetworkArchive : public ::google::protobuf::Message {
 public:
  TableStyleNetworkArchive();
  virtual ~TableStyleNetworkArchive();

  TableStyleNetworkArchive(const TableStyleNetworkArchive& from);

  inline TableStyleNetworkArchive& operator=(const TableStyleNetworkArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableStyleNetworkArchive& default_instance();

  void Swap(TableStyleNetworkArchive* other);

  // implements Message ----------------------------------------------

  TableStyleNetworkArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableStyleNetworkArchive& from);
  void MergeFrom(const TableStyleNetworkArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference table_style = 9;
  inline bool has_table_style() const;
  inline void clear_table_style();
  static const int kTableStyleFieldNumber = 9;
  inline const ::TSP::Reference& table_style() const;
  inline ::TSP::Reference* mutable_table_style();
  inline ::TSP::Reference* release_table_style();
  inline void set_allocated_table_style(::TSP::Reference* table_style);

  // required .TSP.Reference body_text_style = 1;
  inline bool has_body_text_style() const;
  inline void clear_body_text_style();
  static const int kBodyTextStyleFieldNumber = 1;
  inline const ::TSP::Reference& body_text_style() const;
  inline ::TSP::Reference* mutable_body_text_style();
  inline ::TSP::Reference* release_body_text_style();
  inline void set_allocated_body_text_style(::TSP::Reference* body_text_style);

  // required .TSP.Reference header_row_text_style = 2;
  inline bool has_header_row_text_style() const;
  inline void clear_header_row_text_style();
  static const int kHeaderRowTextStyleFieldNumber = 2;
  inline const ::TSP::Reference& header_row_text_style() const;
  inline ::TSP::Reference* mutable_header_row_text_style();
  inline ::TSP::Reference* release_header_row_text_style();
  inline void set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style);

  // required .TSP.Reference header_column_text_style = 3;
  inline bool has_header_column_text_style() const;
  inline void clear_header_column_text_style();
  static const int kHeaderColumnTextStyleFieldNumber = 3;
  inline const ::TSP::Reference& header_column_text_style() const;
  inline ::TSP::Reference* mutable_header_column_text_style();
  inline ::TSP::Reference* release_header_column_text_style();
  inline void set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style);

  // required .TSP.Reference footer_row_text_style = 4;
  inline bool has_footer_row_text_style() const;
  inline void clear_footer_row_text_style();
  static const int kFooterRowTextStyleFieldNumber = 4;
  inline const ::TSP::Reference& footer_row_text_style() const;
  inline ::TSP::Reference* mutable_footer_row_text_style();
  inline ::TSP::Reference* release_footer_row_text_style();
  inline void set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style);

  // required .TSP.Reference body_cell_style = 5;
  inline bool has_body_cell_style() const;
  inline void clear_body_cell_style();
  static const int kBodyCellStyleFieldNumber = 5;
  inline const ::TSP::Reference& body_cell_style() const;
  inline ::TSP::Reference* mutable_body_cell_style();
  inline ::TSP::Reference* release_body_cell_style();
  inline void set_allocated_body_cell_style(::TSP::Reference* body_cell_style);

  // required .TSP.Reference header_row_style = 6;
  inline bool has_header_row_style() const;
  inline void clear_header_row_style();
  static const int kHeaderRowStyleFieldNumber = 6;
  inline const ::TSP::Reference& header_row_style() const;
  inline ::TSP::Reference* mutable_header_row_style();
  inline ::TSP::Reference* release_header_row_style();
  inline void set_allocated_header_row_style(::TSP::Reference* header_row_style);

  // required .TSP.Reference header_column_style = 7;
  inline bool has_header_column_style() const;
  inline void clear_header_column_style();
  static const int kHeaderColumnStyleFieldNumber = 7;
  inline const ::TSP::Reference& header_column_style() const;
  inline ::TSP::Reference* mutable_header_column_style();
  inline ::TSP::Reference* release_header_column_style();
  inline void set_allocated_header_column_style(::TSP::Reference* header_column_style);

  // required .TSP.Reference footer_row_style = 8;
  inline bool has_footer_row_style() const;
  inline void clear_footer_row_style();
  static const int kFooterRowStyleFieldNumber = 8;
  inline const ::TSP::Reference& footer_row_style() const;
  inline ::TSP::Reference* mutable_footer_row_style();
  inline ::TSP::Reference* release_footer_row_style();
  inline void set_allocated_footer_row_style(::TSP::Reference* footer_row_style);

  // optional .TSP.Reference table_name_style = 10;
  inline bool has_table_name_style() const;
  inline void clear_table_name_style();
  static const int kTableNameStyleFieldNumber = 10;
  inline const ::TSP::Reference& table_name_style() const;
  inline ::TSP::Reference* mutable_table_name_style();
  inline ::TSP::Reference* release_table_name_style();
  inline void set_allocated_table_name_style(::TSP::Reference* table_name_style);

  // optional .TSP.Reference table_name_shape_style = 11;
  inline bool has_table_name_shape_style() const;
  inline void clear_table_name_shape_style();
  static const int kTableNameShapeStyleFieldNumber = 11;
  inline const ::TSP::Reference& table_name_shape_style() const;
  inline ::TSP::Reference* mutable_table_name_shape_style();
  inline ::TSP::Reference* release_table_name_shape_style();
  inline void set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style);

  // optional uint32 preset_index = 12;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 12;
  inline ::google::protobuf::uint32 preset_index() const;
  inline void set_preset_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.TableStyleNetworkArchive)
 private:
  inline void set_has_table_style();
  inline void clear_has_table_style();
  inline void set_has_body_text_style();
  inline void clear_has_body_text_style();
  inline void set_has_header_row_text_style();
  inline void clear_has_header_row_text_style();
  inline void set_has_header_column_text_style();
  inline void clear_has_header_column_text_style();
  inline void set_has_footer_row_text_style();
  inline void clear_has_footer_row_text_style();
  inline void set_has_body_cell_style();
  inline void clear_has_body_cell_style();
  inline void set_has_header_row_style();
  inline void clear_has_header_row_style();
  inline void set_has_header_column_style();
  inline void clear_has_header_column_style();
  inline void set_has_footer_row_style();
  inline void clear_has_footer_row_style();
  inline void set_has_table_name_style();
  inline void clear_has_table_name_style();
  inline void set_has_table_name_shape_style();
  inline void clear_has_table_name_shape_style();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* table_style_;
  ::TSP::Reference* body_text_style_;
  ::TSP::Reference* header_row_text_style_;
  ::TSP::Reference* header_column_text_style_;
  ::TSP::Reference* footer_row_text_style_;
  ::TSP::Reference* body_cell_style_;
  ::TSP::Reference* header_row_style_;
  ::TSP::Reference* header_column_style_;
  ::TSP::Reference* footer_row_style_;
  ::TSP::Reference* table_name_style_;
  ::TSP::Reference* table_name_shape_style_;
  ::google::protobuf::uint32 preset_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableStyleNetworkArchive* default_instance_;
};
// -------------------------------------------------------------------

class TableModelArchive : public ::google::protobuf::Message {
 public:
  TableModelArchive();
  virtual ~TableModelArchive();

  TableModelArchive(const TableModelArchive& from);

  inline TableModelArchive& operator=(const TableModelArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableModelArchive& default_instance();

  void Swap(TableModelArchive* other);

  // implements Message ----------------------------------------------

  TableModelArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableModelArchive& from);
  void MergeFrom(const TableModelArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::std::string& table_id() const;
  inline void set_table_id(const ::std::string& value);
  inline void set_table_id(const char* value);
  inline void set_table_id(const char* value, size_t size);
  inline ::std::string* mutable_table_id();
  inline ::std::string* release_table_id();
  inline void set_allocated_table_id(::std::string* table_id);

  // optional string from_table_id = 43;
  inline bool has_from_table_id() const;
  inline void clear_from_table_id();
  static const int kFromTableIdFieldNumber = 43;
  inline const ::std::string& from_table_id() const;
  inline void set_from_table_id(const ::std::string& value);
  inline void set_from_table_id(const char* value);
  inline void set_from_table_id(const char* value, size_t size);
  inline ::std::string* mutable_from_table_id();
  inline ::std::string* release_from_table_id();
  inline void set_allocated_from_table_id(::std::string* from_table_id);

  // required .TSP.Reference table_style = 3;
  inline bool has_table_style() const;
  inline void clear_table_style();
  static const int kTableStyleFieldNumber = 3;
  inline const ::TSP::Reference& table_style() const;
  inline ::TSP::Reference* mutable_table_style();
  inline ::TSP::Reference* release_table_style();
  inline void set_allocated_table_style(::TSP::Reference* table_style);

  // required .TSP.Reference body_text_style = 24;
  inline bool has_body_text_style() const;
  inline void clear_body_text_style();
  static const int kBodyTextStyleFieldNumber = 24;
  inline const ::TSP::Reference& body_text_style() const;
  inline ::TSP::Reference* mutable_body_text_style();
  inline ::TSP::Reference* release_body_text_style();
  inline void set_allocated_body_text_style(::TSP::Reference* body_text_style);

  // required .TSP.Reference header_row_text_style = 25;
  inline bool has_header_row_text_style() const;
  inline void clear_header_row_text_style();
  static const int kHeaderRowTextStyleFieldNumber = 25;
  inline const ::TSP::Reference& header_row_text_style() const;
  inline ::TSP::Reference* mutable_header_row_text_style();
  inline ::TSP::Reference* release_header_row_text_style();
  inline void set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style);

  // required .TSP.Reference header_column_text_style = 26;
  inline bool has_header_column_text_style() const;
  inline void clear_header_column_text_style();
  static const int kHeaderColumnTextStyleFieldNumber = 26;
  inline const ::TSP::Reference& header_column_text_style() const;
  inline ::TSP::Reference* mutable_header_column_text_style();
  inline ::TSP::Reference* release_header_column_text_style();
  inline void set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style);

  // required .TSP.Reference footer_row_text_style = 27;
  inline bool has_footer_row_text_style() const;
  inline void clear_footer_row_text_style();
  static const int kFooterRowTextStyleFieldNumber = 27;
  inline const ::TSP::Reference& footer_row_text_style() const;
  inline ::TSP::Reference* mutable_footer_row_text_style();
  inline ::TSP::Reference* release_footer_row_text_style();
  inline void set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style);

  // required .TSP.Reference body_cell_style = 18;
  inline bool has_body_cell_style() const;
  inline void clear_body_cell_style();
  static const int kBodyCellStyleFieldNumber = 18;
  inline const ::TSP::Reference& body_cell_style() const;
  inline ::TSP::Reference* mutable_body_cell_style();
  inline ::TSP::Reference* release_body_cell_style();
  inline void set_allocated_body_cell_style(::TSP::Reference* body_cell_style);

  // required .TSP.Reference header_row_style = 19;
  inline bool has_header_row_style() const;
  inline void clear_header_row_style();
  static const int kHeaderRowStyleFieldNumber = 19;
  inline const ::TSP::Reference& header_row_style() const;
  inline ::TSP::Reference* mutable_header_row_style();
  inline ::TSP::Reference* release_header_row_style();
  inline void set_allocated_header_row_style(::TSP::Reference* header_row_style);

  // required .TSP.Reference header_column_style = 20;
  inline bool has_header_column_style() const;
  inline void clear_header_column_style();
  static const int kHeaderColumnStyleFieldNumber = 20;
  inline const ::TSP::Reference& header_column_style() const;
  inline ::TSP::Reference* mutable_header_column_style();
  inline ::TSP::Reference* release_header_column_style();
  inline void set_allocated_header_column_style(::TSP::Reference* header_column_style);

  // required .TSP.Reference footer_row_style = 21;
  inline bool has_footer_row_style() const;
  inline void clear_footer_row_style();
  static const int kFooterRowStyleFieldNumber = 21;
  inline const ::TSP::Reference& footer_row_style() const;
  inline ::TSP::Reference* mutable_footer_row_style();
  inline ::TSP::Reference* release_footer_row_style();
  inline void set_allocated_footer_row_style(::TSP::Reference* footer_row_style);

  // optional .TSP.Reference table_name_style = 30;
  inline bool has_table_name_style() const;
  inline void clear_table_name_style();
  static const int kTableNameStyleFieldNumber = 30;
  inline const ::TSP::Reference& table_name_style() const;
  inline ::TSP::Reference* mutable_table_name_style();
  inline ::TSP::Reference* release_table_name_style();
  inline void set_allocated_table_name_style(::TSP::Reference* table_name_style);

  // optional .TSP.Reference table_name_shape_style = 36;
  inline bool has_table_name_shape_style() const;
  inline void clear_table_name_shape_style();
  static const int kTableNameShapeStyleFieldNumber = 36;
  inline const ::TSP::Reference& table_name_shape_style() const;
  inline ::TSP::Reference* mutable_table_name_shape_style();
  inline ::TSP::Reference* release_table_name_shape_style();
  inline void set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style);

  // required .TST.DataStore data_store = 4;
  inline bool has_data_store() const;
  inline void clear_data_store();
  static const int kDataStoreFieldNumber = 4;
  inline const ::TST::DataStore& data_store() const;
  inline ::TST::DataStore* mutable_data_store();
  inline ::TST::DataStore* release_data_store();
  inline void set_allocated_data_store(::TST::DataStore* data_store);

  // optional .TSP.Reference provider = 5;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 5;
  inline const ::TSP::Reference& provider() const;
  inline ::TSP::Reference* mutable_provider();
  inline ::TSP::Reference* release_provider();
  inline void set_allocated_provider(::TSP::Reference* provider);

  // required uint32 number_of_rows = 6;
  inline bool has_number_of_rows() const;
  inline void clear_number_of_rows();
  static const int kNumberOfRowsFieldNumber = 6;
  inline ::google::protobuf::uint32 number_of_rows() const;
  inline void set_number_of_rows(::google::protobuf::uint32 value);

  // required uint32 number_of_columns = 7;
  inline bool has_number_of_columns() const;
  inline void clear_number_of_columns();
  static const int kNumberOfColumnsFieldNumber = 7;
  inline ::google::protobuf::uint32 number_of_columns() const;
  inline void set_number_of_columns(::google::protobuf::uint32 value);

  // required string table_name = 8;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 8;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // optional bool table_name_enabled = 22;
  inline bool has_table_name_enabled() const;
  inline void clear_table_name_enabled();
  static const int kTableNameEnabledFieldNumber = 22;
  inline bool table_name_enabled() const;
  inline void set_table_name_enabled(bool value);

  // optional double table_name_height = 33;
  inline bool has_table_name_height() const;
  inline void clear_table_name_height();
  static const int kTableNameHeightFieldNumber = 33;
  inline double table_name_height() const;
  inline void set_table_name_height(double value);

  // optional bool table_name_border_enabled = 37;
  inline bool has_table_name_border_enabled() const;
  inline void clear_table_name_border_enabled();
  static const int kTableNameBorderEnabledFieldNumber = 37;
  inline bool table_name_border_enabled() const;
  inline void set_table_name_border_enabled(bool value);

  // optional uint32 number_of_header_rows = 9;
  inline bool has_number_of_header_rows() const;
  inline void clear_number_of_header_rows();
  static const int kNumberOfHeaderRowsFieldNumber = 9;
  inline ::google::protobuf::uint32 number_of_header_rows() const;
  inline void set_number_of_header_rows(::google::protobuf::uint32 value);

  // optional uint32 number_of_header_columns = 10;
  inline bool has_number_of_header_columns() const;
  inline void clear_number_of_header_columns();
  static const int kNumberOfHeaderColumnsFieldNumber = 10;
  inline ::google::protobuf::uint32 number_of_header_columns() const;
  inline void set_number_of_header_columns(::google::protobuf::uint32 value);

  // optional uint32 number_of_footer_rows = 11;
  inline bool has_number_of_footer_rows() const;
  inline void clear_number_of_footer_rows();
  static const int kNumberOfFooterRowsFieldNumber = 11;
  inline ::google::protobuf::uint32 number_of_footer_rows() const;
  inline void set_number_of_footer_rows(::google::protobuf::uint32 value);

  // optional bool header_rows_frozen = 12;
  inline bool has_header_rows_frozen() const;
  inline void clear_header_rows_frozen();
  static const int kHeaderRowsFrozenFieldNumber = 12;
  inline bool header_rows_frozen() const;
  inline void set_header_rows_frozen(bool value);

  // optional bool header_columns_frozen = 13;
  inline bool has_header_columns_frozen() const;
  inline void clear_header_columns_frozen();
  static const int kHeaderColumnsFrozenFieldNumber = 13;
  inline bool header_columns_frozen() const;
  inline void set_header_columns_frozen(bool value);

  // optional uint32 number_of_hidden_rows = 14;
  inline bool has_number_of_hidden_rows() const;
  inline void clear_number_of_hidden_rows();
  static const int kNumberOfHiddenRowsFieldNumber = 14;
  inline ::google::protobuf::uint32 number_of_hidden_rows() const;
  inline void set_number_of_hidden_rows(::google::protobuf::uint32 value);

  // optional uint32 number_of_hidden_columns = 15;
  inline bool has_number_of_hidden_columns() const;
  inline void clear_number_of_hidden_columns();
  static const int kNumberOfHiddenColumnsFieldNumber = 15;
  inline ::google::protobuf::uint32 number_of_hidden_columns() const;
  inline void set_number_of_hidden_columns(::google::protobuf::uint32 value);

  // optional uint32 number_of_user_hidden_rows = 41;
  inline bool has_number_of_user_hidden_rows() const;
  inline void clear_number_of_user_hidden_rows();
  static const int kNumberOfUserHiddenRowsFieldNumber = 41;
  inline ::google::protobuf::uint32 number_of_user_hidden_rows() const;
  inline void set_number_of_user_hidden_rows(::google::protobuf::uint32 value);

  // optional uint32 number_of_user_hidden_columns = 42;
  inline bool has_number_of_user_hidden_columns() const;
  inline void clear_number_of_user_hidden_columns();
  static const int kNumberOfUserHiddenColumnsFieldNumber = 42;
  inline ::google::protobuf::uint32 number_of_user_hidden_columns() const;
  inline void set_number_of_user_hidden_columns(::google::protobuf::uint32 value);

  // optional uint32 number_of_filtered_rows = 40;
  inline bool has_number_of_filtered_rows() const;
  inline void clear_number_of_filtered_rows();
  static const int kNumberOfFilteredRowsFieldNumber = 40;
  inline ::google::protobuf::uint32 number_of_filtered_rows() const;
  inline void set_number_of_filtered_rows(::google::protobuf::uint32 value);

  // required double default_row_height = 16;
  inline bool has_default_row_height() const;
  inline void clear_default_row_height();
  static const int kDefaultRowHeightFieldNumber = 16;
  inline double default_row_height() const;
  inline void set_default_row_height(double value);

  // required double default_column_width = 17;
  inline bool has_default_column_width() const;
  inline void clear_default_column_width();
  static const int kDefaultColumnWidthFieldNumber = 17;
  inline double default_column_width() const;
  inline void set_default_column_width(double value);

  // optional .TST.CellID origin_offset = 23 [deprecated = true];
  inline bool has_origin_offset() const PROTOBUF_DEPRECATED;
  inline void clear_origin_offset() PROTOBUF_DEPRECATED;
  static const int kOriginOffsetFieldNumber = 23;
  inline const ::TST::CellID& origin_offset() const PROTOBUF_DEPRECATED;
  inline ::TST::CellID* mutable_origin_offset() PROTOBUF_DEPRECATED;
  inline ::TST::CellID* release_origin_offset() PROTOBUF_DEPRECATED;
  inline void set_allocated_origin_offset(::TST::CellID* origin_offset) PROTOBUF_DEPRECATED;

  // required uint32 preset_index = 28;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 28;
  inline ::google::protobuf::uint32 preset_index() const;
  inline void set_preset_index(::google::protobuf::uint32 value);

  // optional bool repeating_header_rows_enabled = 29;
  inline bool has_repeating_header_rows_enabled() const;
  inline void clear_repeating_header_rows_enabled();
  static const int kRepeatingHeaderRowsEnabledFieldNumber = 29;
  inline bool repeating_header_rows_enabled() const;
  inline void set_repeating_header_rows_enabled(bool value);

  // optional bool repeating_header_columns_enabled = 32;
  inline bool has_repeating_header_columns_enabled() const;
  inline void clear_repeating_header_columns_enabled();
  static const int kRepeatingHeaderColumnsEnabledFieldNumber = 32;
  inline bool repeating_header_columns_enabled() const;
  inline void set_repeating_header_columns_enabled(bool value);

  // optional bool style_apply_clears_all = 31;
  inline bool has_style_apply_clears_all() const;
  inline void clear_style_apply_clears_all();
  static const int kStyleApplyClearsAllFieldNumber = 31;
  inline bool style_apply_clears_all() const;
  inline void set_style_apply_clears_all(bool value);

  // optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
  inline bool has_hidden_state_formula_owner_for_columns() const;
  inline void clear_hidden_state_formula_owner_for_columns();
  static const int kHiddenStateFormulaOwnerForColumnsFieldNumber = 34;
  inline const ::TSP::Reference& hidden_state_formula_owner_for_columns() const;
  inline ::TSP::Reference* mutable_hidden_state_formula_owner_for_columns();
  inline ::TSP::Reference* release_hidden_state_formula_owner_for_columns();
  inline void set_allocated_hidden_state_formula_owner_for_columns(::TSP::Reference* hidden_state_formula_owner_for_columns);

  // optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
  inline bool has_hidden_state_formula_owner_for_rows() const;
  inline void clear_hidden_state_formula_owner_for_rows();
  static const int kHiddenStateFormulaOwnerForRowsFieldNumber = 35;
  inline const ::TSP::Reference& hidden_state_formula_owner_for_rows() const;
  inline ::TSP::Reference* mutable_hidden_state_formula_owner_for_rows();
  inline ::TSP::Reference* release_hidden_state_formula_owner_for_rows();
  inline void set_allocated_hidden_state_formula_owner_for_rows(::TSP::Reference* hidden_state_formula_owner_for_rows);

  // optional .TSP.Reference filter_set = 38;
  inline bool has_filter_set() const;
  inline void clear_filter_set();
  static const int kFilterSetFieldNumber = 38;
  inline const ::TSP::Reference& filter_set() const;
  inline ::TSP::Reference* mutable_filter_set();
  inline ::TSP::Reference* release_filter_set();
  inline void set_allocated_filter_set(::TSP::Reference* filter_set);

  // optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
  inline bool has_conditional_style_formula_owner_id() const;
  inline void clear_conditional_style_formula_owner_id();
  static const int kConditionalStyleFormulaOwnerIdFieldNumber = 39;
  inline const ::TSCE::CFUUIDArchive& conditional_style_formula_owner_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_conditional_style_formula_owner_id();
  inline ::TSCE::CFUUIDArchive* release_conditional_style_formula_owner_id();
  inline void set_allocated_conditional_style_formula_owner_id(::TSCE::CFUUIDArchive* conditional_style_formula_owner_id);

  // @@protoc_insertion_point(class_scope:TST.TableModelArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_from_table_id();
  inline void clear_has_from_table_id();
  inline void set_has_table_style();
  inline void clear_has_table_style();
  inline void set_has_body_text_style();
  inline void clear_has_body_text_style();
  inline void set_has_header_row_text_style();
  inline void clear_has_header_row_text_style();
  inline void set_has_header_column_text_style();
  inline void clear_has_header_column_text_style();
  inline void set_has_footer_row_text_style();
  inline void clear_has_footer_row_text_style();
  inline void set_has_body_cell_style();
  inline void clear_has_body_cell_style();
  inline void set_has_header_row_style();
  inline void clear_has_header_row_style();
  inline void set_has_header_column_style();
  inline void clear_has_header_column_style();
  inline void set_has_footer_row_style();
  inline void clear_has_footer_row_style();
  inline void set_has_table_name_style();
  inline void clear_has_table_name_style();
  inline void set_has_table_name_shape_style();
  inline void clear_has_table_name_shape_style();
  inline void set_has_data_store();
  inline void clear_has_data_store();
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_number_of_rows();
  inline void clear_has_number_of_rows();
  inline void set_has_number_of_columns();
  inline void clear_has_number_of_columns();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_table_name_enabled();
  inline void clear_has_table_name_enabled();
  inline void set_has_table_name_height();
  inline void clear_has_table_name_height();
  inline void set_has_table_name_border_enabled();
  inline void clear_has_table_name_border_enabled();
  inline void set_has_number_of_header_rows();
  inline void clear_has_number_of_header_rows();
  inline void set_has_number_of_header_columns();
  inline void clear_has_number_of_header_columns();
  inline void set_has_number_of_footer_rows();
  inline void clear_has_number_of_footer_rows();
  inline void set_has_header_rows_frozen();
  inline void clear_has_header_rows_frozen();
  inline void set_has_header_columns_frozen();
  inline void clear_has_header_columns_frozen();
  inline void set_has_number_of_hidden_rows();
  inline void clear_has_number_of_hidden_rows();
  inline void set_has_number_of_hidden_columns();
  inline void clear_has_number_of_hidden_columns();
  inline void set_has_number_of_user_hidden_rows();
  inline void clear_has_number_of_user_hidden_rows();
  inline void set_has_number_of_user_hidden_columns();
  inline void clear_has_number_of_user_hidden_columns();
  inline void set_has_number_of_filtered_rows();
  inline void clear_has_number_of_filtered_rows();
  inline void set_has_default_row_height();
  inline void clear_has_default_row_height();
  inline void set_has_default_column_width();
  inline void clear_has_default_column_width();
  inline void set_has_origin_offset();
  inline void clear_has_origin_offset();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();
  inline void set_has_repeating_header_rows_enabled();
  inline void clear_has_repeating_header_rows_enabled();
  inline void set_has_repeating_header_columns_enabled();
  inline void clear_has_repeating_header_columns_enabled();
  inline void set_has_style_apply_clears_all();
  inline void clear_has_style_apply_clears_all();
  inline void set_has_hidden_state_formula_owner_for_columns();
  inline void clear_has_hidden_state_formula_owner_for_columns();
  inline void set_has_hidden_state_formula_owner_for_rows();
  inline void clear_has_hidden_state_formula_owner_for_rows();
  inline void set_has_filter_set();
  inline void clear_has_filter_set();
  inline void set_has_conditional_style_formula_owner_id();
  inline void clear_has_conditional_style_formula_owner_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_id_;
  ::std::string* from_table_id_;
  ::TSP::Reference* table_style_;
  ::TSP::Reference* body_text_style_;
  ::TSP::Reference* header_row_text_style_;
  ::TSP::Reference* header_column_text_style_;
  ::TSP::Reference* footer_row_text_style_;
  ::TSP::Reference* body_cell_style_;
  ::TSP::Reference* header_row_style_;
  ::TSP::Reference* header_column_style_;
  ::TSP::Reference* footer_row_style_;
  ::TSP::Reference* table_name_style_;
  ::TSP::Reference* table_name_shape_style_;
  ::TST::DataStore* data_store_;
  ::TSP::Reference* provider_;
  ::google::protobuf::uint32 number_of_rows_;
  ::google::protobuf::uint32 number_of_columns_;
  ::std::string* table_name_;
  double table_name_height_;
  ::google::protobuf::uint32 number_of_header_rows_;
  bool table_name_enabled_;
  bool table_name_border_enabled_;
  bool header_rows_frozen_;
  bool header_columns_frozen_;
  ::google::protobuf::uint32 number_of_header_columns_;
  ::google::protobuf::uint32 number_of_footer_rows_;
  ::google::protobuf::uint32 number_of_hidden_rows_;
  ::google::protobuf::uint32 number_of_hidden_columns_;
  ::google::protobuf::uint32 number_of_user_hidden_rows_;
  ::google::protobuf::uint32 number_of_user_hidden_columns_;
  double default_row_height_;
  ::google::protobuf::uint32 number_of_filtered_rows_;
  ::google::protobuf::uint32 preset_index_;
  double default_column_width_;
  ::TST::CellID* origin_offset_;
  ::TSP::Reference* hidden_state_formula_owner_for_columns_;
  ::TSP::Reference* hidden_state_formula_owner_for_rows_;
  ::TSP::Reference* filter_set_;
  ::TSCE::CFUUIDArchive* conditional_style_formula_owner_id_;
  bool repeating_header_rows_enabled_;
  bool repeating_header_columns_enabled_;
  bool style_apply_clears_all_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableModelArchive* default_instance_;
};
// -------------------------------------------------------------------

class DurationWrapperArchive : public ::google::protobuf::Message {
 public:
  DurationWrapperArchive();
  virtual ~DurationWrapperArchive();

  DurationWrapperArchive(const DurationWrapperArchive& from);

  inline DurationWrapperArchive& operator=(const DurationWrapperArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationWrapperArchive& default_instance();

  void Swap(DurationWrapperArchive* other);

  // implements Message ----------------------------------------------

  DurationWrapperArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DurationWrapperArchive& from);
  void MergeFrom(const DurationWrapperArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TST.DurationWrapperArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static DurationWrapperArchive* default_instance_;
};
// -------------------------------------------------------------------

class Cell : public ::google::protobuf::Message {
 public:
  Cell();
  virtual ~Cell();

  Cell(const Cell& from);

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell& default_instance();

  void Swap(Cell* other);

  // implements Message ----------------------------------------------

  Cell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellValueType valueType = 2;
  inline bool has_valuetype() const;
  inline void clear_valuetype();
  static const int kValueTypeFieldNumber = 2;
  inline ::TST::CellValueType valuetype() const;
  inline void set_valuetype(::TST::CellValueType value);

  // optional double numberValue = 5;
  inline bool has_numbervalue() const;
  inline void clear_numbervalue();
  static const int kNumberValueFieldNumber = 5;
  inline double numbervalue() const;
  inline void set_numbervalue(double value);

  // optional string stringValue = 6;
  inline bool has_stringvalue() const;
  inline void clear_stringvalue();
  static const int kStringValueFieldNumber = 6;
  inline const ::std::string& stringvalue() const;
  inline void set_stringvalue(const ::std::string& value);
  inline void set_stringvalue(const char* value);
  inline void set_stringvalue(const char* value, size_t size);
  inline ::std::string* mutable_stringvalue();
  inline ::std::string* release_stringvalue();
  inline void set_allocated_stringvalue(::std::string* stringvalue);

  // optional bool boolValue = 7;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 7;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  // optional .TSP.Reference cell_style = 3;
  inline bool has_cell_style() const;
  inline void clear_cell_style();
  static const int kCellStyleFieldNumber = 3;
  inline const ::TSP::Reference& cell_style() const;
  inline ::TSP::Reference* mutable_cell_style();
  inline ::TSP::Reference* release_cell_style();
  inline void set_allocated_cell_style(::TSP::Reference* cell_style);

  // optional .TSP.Reference text_style = 4;
  inline bool has_text_style() const;
  inline void clear_text_style();
  static const int kTextStyleFieldNumber = 4;
  inline const ::TSP::Reference& text_style() const;
  inline ::TSP::Reference* mutable_text_style();
  inline ::TSP::Reference* release_text_style();
  inline void set_allocated_text_style(::TSP::Reference* text_style);

  // optional .TSCE.FormulaArchive formula = 8;
  inline bool has_formula() const;
  inline void clear_formula();
  static const int kFormulaFieldNumber = 8;
  inline const ::TSCE::FormulaArchive& formula() const;
  inline ::TSCE::FormulaArchive* mutable_formula();
  inline ::TSCE::FormulaArchive* release_formula();
  inline void set_allocated_formula(::TSCE::FormulaArchive* formula);

  // optional .TSP.Reference formulaError = 10;
  inline bool has_formulaerror() const;
  inline void clear_formulaerror();
  static const int kFormulaErrorFieldNumber = 10;
  inline const ::TSP::Reference& formulaerror() const;
  inline ::TSP::Reference* mutable_formulaerror();
  inline ::TSP::Reference* release_formulaerror();
  inline void set_allocated_formulaerror(::TSP::Reference* formulaerror);

  // optional .TSK.FormatStructArchive current_format = 9;
  inline bool has_current_format() const;
  inline void clear_current_format();
  static const int kCurrentFormatFieldNumber = 9;
  inline const ::TSK::FormatStructArchive& current_format() const;
  inline ::TSK::FormatStructArchive* mutable_current_format();
  inline ::TSK::FormatStructArchive* release_current_format();
  inline void set_allocated_current_format(::TSK::FormatStructArchive* current_format);

  // optional .TSK.FormatStructArchive number_format = 11;
  inline bool has_number_format() const;
  inline void clear_number_format();
  static const int kNumberFormatFieldNumber = 11;
  inline const ::TSK::FormatStructArchive& number_format() const;
  inline ::TSK::FormatStructArchive* mutable_number_format();
  inline ::TSK::FormatStructArchive* release_number_format();
  inline void set_allocated_number_format(::TSK::FormatStructArchive* number_format);

  // optional .TSK.FormatStructArchive currency_format = 12;
  inline bool has_currency_format() const;
  inline void clear_currency_format();
  static const int kCurrencyFormatFieldNumber = 12;
  inline const ::TSK::FormatStructArchive& currency_format() const;
  inline ::TSK::FormatStructArchive* mutable_currency_format();
  inline ::TSK::FormatStructArchive* release_currency_format();
  inline void set_allocated_currency_format(::TSK::FormatStructArchive* currency_format);

  // optional .TSK.FormatStructArchive duration_format = 13;
  inline bool has_duration_format() const;
  inline void clear_duration_format();
  static const int kDurationFormatFieldNumber = 13;
  inline const ::TSK::FormatStructArchive& duration_format() const;
  inline ::TSK::FormatStructArchive* mutable_duration_format();
  inline ::TSK::FormatStructArchive* release_duration_format();
  inline void set_allocated_duration_format(::TSK::FormatStructArchive* duration_format);

  // optional .TSK.FormatStructArchive date_format = 14;
  inline bool has_date_format() const;
  inline void clear_date_format();
  static const int kDateFormatFieldNumber = 14;
  inline const ::TSK::FormatStructArchive& date_format() const;
  inline ::TSK::FormatStructArchive* mutable_date_format();
  inline ::TSK::FormatStructArchive* release_date_format();
  inline void set_allocated_date_format(::TSK::FormatStructArchive* date_format);

  // optional .TSK.FormatStructArchive control_format = 15;
  inline bool has_control_format() const;
  inline void clear_control_format();
  static const int kControlFormatFieldNumber = 15;
  inline const ::TSK::FormatStructArchive& control_format() const;
  inline ::TSK::FormatStructArchive* mutable_control_format();
  inline ::TSK::FormatStructArchive* release_control_format();
  inline void set_allocated_control_format(::TSK::FormatStructArchive* control_format);

  // optional .TSK.FormatStructArchive custom_format = 16;
  inline bool has_custom_format() const;
  inline void clear_custom_format();
  static const int kCustomFormatFieldNumber = 16;
  inline const ::TSK::FormatStructArchive& custom_format() const;
  inline ::TSK::FormatStructArchive* mutable_custom_format();
  inline ::TSK::FormatStructArchive* release_custom_format();
  inline void set_allocated_custom_format(::TSK::FormatStructArchive* custom_format);

  // optional .TSK.FormatStructArchive base_format = 17;
  inline bool has_base_format() const;
  inline void clear_base_format();
  static const int kBaseFormatFieldNumber = 17;
  inline const ::TSK::FormatStructArchive& base_format() const;
  inline ::TSK::FormatStructArchive* mutable_base_format();
  inline ::TSK::FormatStructArchive* release_base_format();
  inline void set_allocated_base_format(::TSK::FormatStructArchive* base_format);

  // optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
  inline bool has_multiple_choice_list_format() const;
  inline void clear_multiple_choice_list_format();
  static const int kMultipleChoiceListFormatFieldNumber = 18;
  inline const ::TSK::FormatStructArchive& multiple_choice_list_format() const;
  inline ::TSK::FormatStructArchive* mutable_multiple_choice_list_format();
  inline ::TSK::FormatStructArchive* release_multiple_choice_list_format();
  inline void set_allocated_multiple_choice_list_format(::TSK::FormatStructArchive* multiple_choice_list_format);

  // optional uint32 explicit_format_flags = 19;
  inline bool has_explicit_format_flags() const;
  inline void clear_explicit_format_flags();
  static const int kExplicitFormatFlagsFieldNumber = 19;
  inline ::google::protobuf::uint32 explicit_format_flags() const;
  inline void set_explicit_format_flags(::google::protobuf::uint32 value);

  // optional .TSP.Reference richTextPayload = 20;
  inline bool has_richtextpayload() const;
  inline void clear_richtextpayload();
  static const int kRichTextPayloadFieldNumber = 20;
  inline const ::TSP::Reference& richtextpayload() const;
  inline ::TSP::Reference* mutable_richtextpayload();
  inline ::TSP::Reference* release_richtextpayload();
  inline void set_allocated_richtextpayload(::TSP::Reference* richtextpayload);

  // optional .TSP.Reference conditional_style = 21;
  inline bool has_conditional_style() const;
  inline void clear_conditional_style();
  static const int kConditionalStyleFieldNumber = 21;
  inline const ::TSP::Reference& conditional_style() const;
  inline ::TSP::Reference* mutable_conditional_style();
  inline ::TSP::Reference* release_conditional_style();
  inline void set_allocated_conditional_style(::TSP::Reference* conditional_style);

  // optional .TSP.Reference multiple_choice_list = 22;
  inline bool has_multiple_choice_list() const;
  inline void clear_multiple_choice_list();
  static const int kMultipleChoiceListFieldNumber = 22;
  inline const ::TSP::Reference& multiple_choice_list() const;
  inline ::TSP::Reference* mutable_multiple_choice_list();
  inline ::TSP::Reference* release_multiple_choice_list();
  inline void set_allocated_multiple_choice_list(::TSP::Reference* multiple_choice_list);

  // optional .TSP.Reference comment_storage = 23;
  inline bool has_comment_storage() const;
  inline void clear_comment_storage();
  static const int kCommentStorageFieldNumber = 23;
  inline const ::TSP::Reference& comment_storage() const;
  inline ::TSP::Reference* mutable_comment_storage();
  inline ::TSP::Reference* release_comment_storage();
  inline void set_allocated_comment_storage(::TSP::Reference* comment_storage);

  // optional uint32 conditional_style_applied_rule = 24;
  inline bool has_conditional_style_applied_rule() const;
  inline void clear_conditional_style_applied_rule();
  static const int kConditionalStyleAppliedRuleFieldNumber = 24;
  inline ::google::protobuf::uint32 conditional_style_applied_rule() const;
  inline void set_conditional_style_applied_rule(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.Cell)
 private:
  inline void set_has_valuetype();
  inline void clear_has_valuetype();
  inline void set_has_numbervalue();
  inline void clear_has_numbervalue();
  inline void set_has_stringvalue();
  inline void clear_has_stringvalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();
  inline void set_has_cell_style();
  inline void clear_has_cell_style();
  inline void set_has_text_style();
  inline void clear_has_text_style();
  inline void set_has_formula();
  inline void clear_has_formula();
  inline void set_has_formulaerror();
  inline void clear_has_formulaerror();
  inline void set_has_current_format();
  inline void clear_has_current_format();
  inline void set_has_number_format();
  inline void clear_has_number_format();
  inline void set_has_currency_format();
  inline void clear_has_currency_format();
  inline void set_has_duration_format();
  inline void clear_has_duration_format();
  inline void set_has_date_format();
  inline void clear_has_date_format();
  inline void set_has_control_format();
  inline void clear_has_control_format();
  inline void set_has_custom_format();
  inline void clear_has_custom_format();
  inline void set_has_base_format();
  inline void clear_has_base_format();
  inline void set_has_multiple_choice_list_format();
  inline void clear_has_multiple_choice_list_format();
  inline void set_has_explicit_format_flags();
  inline void clear_has_explicit_format_flags();
  inline void set_has_richtextpayload();
  inline void clear_has_richtextpayload();
  inline void set_has_conditional_style();
  inline void clear_has_conditional_style();
  inline void set_has_multiple_choice_list();
  inline void clear_has_multiple_choice_list();
  inline void set_has_comment_storage();
  inline void clear_has_comment_storage();
  inline void set_has_conditional_style_applied_rule();
  inline void clear_has_conditional_style_applied_rule();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double numbervalue_;
  int valuetype_;
  bool boolvalue_;
  ::std::string* stringvalue_;
  ::TSP::Reference* cell_style_;
  ::TSP::Reference* text_style_;
  ::TSCE::FormulaArchive* formula_;
  ::TSP::Reference* formulaerror_;
  ::TSK::FormatStructArchive* current_format_;
  ::TSK::FormatStructArchive* number_format_;
  ::TSK::FormatStructArchive* currency_format_;
  ::TSK::FormatStructArchive* duration_format_;
  ::TSK::FormatStructArchive* date_format_;
  ::TSK::FormatStructArchive* control_format_;
  ::TSK::FormatStructArchive* custom_format_;
  ::TSK::FormatStructArchive* base_format_;
  ::TSK::FormatStructArchive* multiple_choice_list_format_;
  ::TSP::Reference* richtextpayload_;
  ::TSP::Reference* conditional_style_;
  ::google::protobuf::uint32 explicit_format_flags_;
  ::google::protobuf::uint32 conditional_style_applied_rule_;
  ::TSP::Reference* multiple_choice_list_;
  ::TSP::Reference* comment_storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static Cell* default_instance_;
};
// -------------------------------------------------------------------

class MergeRegionMapArchive : public ::google::protobuf::Message {
 public:
  MergeRegionMapArchive();
  virtual ~MergeRegionMapArchive();

  MergeRegionMapArchive(const MergeRegionMapArchive& from);

  inline MergeRegionMapArchive& operator=(const MergeRegionMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeRegionMapArchive& default_instance();

  void Swap(MergeRegionMapArchive* other);

  // implements Message ----------------------------------------------

  MergeRegionMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MergeRegionMapArchive& from);
  void MergeFrom(const MergeRegionMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TST.CellRange cell_range = 1;
  inline int cell_range_size() const;
  inline void clear_cell_range();
  static const int kCellRangeFieldNumber = 1;
  inline const ::TST::CellRange& cell_range(int index) const;
  inline ::TST::CellRange* mutable_cell_range(int index);
  inline ::TST::CellRange* add_cell_range();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
      cell_range() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
      mutable_cell_range();

  // @@protoc_insertion_point(class_scope:TST.MergeRegionMapArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::CellRange > cell_range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static MergeRegionMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellMapArchive_CellMapEntry : public ::google::protobuf::Message {
 public:
  CellMapArchive_CellMapEntry();
  virtual ~CellMapArchive_CellMapEntry();

  CellMapArchive_CellMapEntry(const CellMapArchive_CellMapEntry& from);

  inline CellMapArchive_CellMapEntry& operator=(const CellMapArchive_CellMapEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellMapArchive_CellMapEntry& default_instance();

  void Swap(CellMapArchive_CellMapEntry* other);

  // implements Message ----------------------------------------------

  CellMapArchive_CellMapEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellMapArchive_CellMapEntry& from);
  void MergeFrom(const CellMapArchive_CellMapEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID cellID = 1;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellIDFieldNumber = 1;
  inline const ::TST::CellID& cellid() const;
  inline ::TST::CellID* mutable_cellid();
  inline ::TST::CellID* release_cellid();
  inline void set_allocated_cellid(::TST::CellID* cellid);

  // optional .TST.Cell cell = 2;
  inline bool has_cell() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 2;
  inline const ::TST::Cell& cell() const;
  inline ::TST::Cell* mutable_cell();
  inline ::TST::Cell* release_cell();
  inline void set_allocated_cell(::TST::Cell* cell);

  // @@protoc_insertion_point(class_scope:TST.CellMapArchive.CellMapEntry)
 private:
  inline void set_has_cellid();
  inline void clear_has_cellid();
  inline void set_has_cell();
  inline void clear_has_cell();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* cellid_;
  ::TST::Cell* cell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CellMapArchive_CellMapEntry* default_instance_;
};
// -------------------------------------------------------------------

class CellMapArchive : public ::google::protobuf::Message {
 public:
  CellMapArchive();
  virtual ~CellMapArchive();

  CellMapArchive(const CellMapArchive& from);

  inline CellMapArchive& operator=(const CellMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellMapArchive& default_instance();

  void Swap(CellMapArchive* other);

  // implements Message ----------------------------------------------

  CellMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellMapArchive& from);
  void MergeFrom(const CellMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CellMapArchive_CellMapEntry CellMapEntry;

  // accessors -------------------------------------------------------

  // required uint32 capacity = 1;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity() const;
  inline void set_capacity(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
  inline int cellmapentry_size() const;
  inline void clear_cellmapentry();
  static const int kCellMapEntryFieldNumber = 3;
  inline const ::TST::CellMapArchive_CellMapEntry& cellmapentry(int index) const;
  inline ::TST::CellMapArchive_CellMapEntry* mutable_cellmapentry(int index);
  inline ::TST::CellMapArchive_CellMapEntry* add_cellmapentry();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >&
      cellmapentry() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >*
      mutable_cellmapentry();

  // optional bool may_modify_formulas_in_cells = 4 [default = true];
  inline bool has_may_modify_formulas_in_cells() const;
  inline void clear_may_modify_formulas_in_cells();
  static const int kMayModifyFormulasInCellsFieldNumber = 4;
  inline bool may_modify_formulas_in_cells() const;
  inline void set_may_modify_formulas_in_cells(bool value);

  // optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
  inline bool has_may_modify_values_referenced_by_formulas() const;
  inline void clear_may_modify_values_referenced_by_formulas();
  static const int kMayModifyValuesReferencedByFormulasFieldNumber = 5;
  inline bool may_modify_values_referenced_by_formulas() const;
  inline void set_may_modify_values_referenced_by_formulas(bool value);

  // optional bool applies_to_hidden = 6 [default = false];
  inline bool has_applies_to_hidden() const;
  inline void clear_applies_to_hidden();
  static const int kAppliesToHiddenFieldNumber = 6;
  inline bool applies_to_hidden() const;
  inline void set_applies_to_hidden(bool value);

  // @@protoc_insertion_point(class_scope:TST.CellMapArchive)
 private:
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_may_modify_formulas_in_cells();
  inline void clear_has_may_modify_formulas_in_cells();
  inline void set_has_may_modify_values_referenced_by_formulas();
  inline void clear_has_may_modify_values_referenced_by_formulas();
  inline void set_has_applies_to_hidden();
  inline void clear_has_applies_to_hidden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 capacity_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry > cellmapentry_;
  bool may_modify_formulas_in_cells_;
  bool may_modify_values_referenced_by_formulas_;
  bool applies_to_hidden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CellMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class DoubleStyleMapArchive_DoubleStyleMapEntryArchive : public ::google::protobuf::Message {
 public:
  DoubleStyleMapArchive_DoubleStyleMapEntryArchive();
  virtual ~DoubleStyleMapArchive_DoubleStyleMapEntryArchive();

  DoubleStyleMapArchive_DoubleStyleMapEntryArchive(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from);

  inline DoubleStyleMapArchive_DoubleStyleMapEntryArchive& operator=(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& default_instance();

  void Swap(DoubleStyleMapArchive_DoubleStyleMapEntryArchive* other);

  // implements Message ----------------------------------------------

  DoubleStyleMapArchive_DoubleStyleMapEntryArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from);
  void MergeFrom(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID cell_id = 1;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 1;
  inline const ::TST::CellID& cell_id() const;
  inline ::TST::CellID* mutable_cell_id();
  inline ::TST::CellID* release_cell_id();
  inline void set_allocated_cell_id(::TST::CellID* cell_id);

  // required .TSP.Reference old_style = 2;
  inline bool has_old_style() const;
  inline void clear_old_style();
  static const int kOldStyleFieldNumber = 2;
  inline const ::TSP::Reference& old_style() const;
  inline ::TSP::Reference* mutable_old_style();
  inline ::TSP::Reference* release_old_style();
  inline void set_allocated_old_style(::TSP::Reference* old_style);

  // required .TSP.Reference new_style = 3;
  inline bool has_new_style() const;
  inline void clear_new_style();
  static const int kNewStyleFieldNumber = 3;
  inline const ::TSP::Reference& new_style() const;
  inline ::TSP::Reference* mutable_new_style();
  inline ::TSP::Reference* release_new_style();
  inline void set_allocated_new_style(::TSP::Reference* new_style);

  // @@protoc_insertion_point(class_scope:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
 private:
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_old_style();
  inline void clear_has_old_style();
  inline void set_has_new_style();
  inline void clear_has_new_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* cell_id_;
  ::TSP::Reference* old_style_;
  ::TSP::Reference* new_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static DoubleStyleMapArchive_DoubleStyleMapEntryArchive* default_instance_;
};
// -------------------------------------------------------------------

class DoubleStyleMapArchive : public ::google::protobuf::Message {
 public:
  DoubleStyleMapArchive();
  virtual ~DoubleStyleMapArchive();

  DoubleStyleMapArchive(const DoubleStyleMapArchive& from);

  inline DoubleStyleMapArchive& operator=(const DoubleStyleMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleStyleMapArchive& default_instance();

  void Swap(DoubleStyleMapArchive* other);

  // implements Message ----------------------------------------------

  DoubleStyleMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubleStyleMapArchive& from);
  void MergeFrom(const DoubleStyleMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DoubleStyleMapArchive_DoubleStyleMapEntryArchive DoubleStyleMapEntryArchive;

  // accessors -------------------------------------------------------

  // required uint32 capacity = 1;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity() const;
  inline void set_capacity(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
  inline int cell_map_entry_size() const;
  inline void clear_cell_map_entry();
  static const int kCellMapEntryFieldNumber = 3;
  inline const ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive& cell_map_entry(int index) const;
  inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* mutable_cell_map_entry(int index);
  inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* add_cell_map_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >&
      cell_map_entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >*
      mutable_cell_map_entry();

  // @@protoc_insertion_point(class_scope:TST.DoubleStyleMapArchive)
 private:
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 capacity_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive > cell_map_entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static DoubleStyleMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleTableMapArchive_StyleTableMapEntryArchive : public ::google::protobuf::Message {
 public:
  StyleTableMapArchive_StyleTableMapEntryArchive();
  virtual ~StyleTableMapArchive_StyleTableMapEntryArchive();

  StyleTableMapArchive_StyleTableMapEntryArchive(const StyleTableMapArchive_StyleTableMapEntryArchive& from);

  inline StyleTableMapArchive_StyleTableMapEntryArchive& operator=(const StyleTableMapArchive_StyleTableMapEntryArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTableMapArchive_StyleTableMapEntryArchive& default_instance();

  void Swap(StyleTableMapArchive_StyleTableMapEntryArchive* other);

  // implements Message ----------------------------------------------

  StyleTableMapArchive_StyleTableMapEntryArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTableMapArchive_StyleTableMapEntryArchive& from);
  void MergeFrom(const StyleTableMapArchive_StyleTableMapEntryArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);

  // required .TSP.Reference old_style = 2;
  inline bool has_old_style() const;
  inline void clear_old_style();
  static const int kOldStyleFieldNumber = 2;
  inline const ::TSP::Reference& old_style() const;
  inline ::TSP::Reference* mutable_old_style();
  inline ::TSP::Reference* release_old_style();
  inline void set_allocated_old_style(::TSP::Reference* old_style);

  // required .TSP.Reference new_style = 3;
  inline bool has_new_style() const;
  inline void clear_new_style();
  static const int kNewStyleFieldNumber = 3;
  inline const ::TSP::Reference& new_style() const;
  inline ::TSP::Reference* mutable_new_style();
  inline ::TSP::Reference* release_new_style();
  inline void set_allocated_new_style(::TSP::Reference* new_style);

  // @@protoc_insertion_point(class_scope:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_old_style();
  inline void clear_has_old_style();
  inline void set_has_new_style();
  inline void clear_has_new_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* old_style_;
  ::TSP::Reference* new_style_;
  ::google::protobuf::uint32 key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleTableMapArchive_StyleTableMapEntryArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleTableMapArchive : public ::google::protobuf::Message {
 public:
  StyleTableMapArchive();
  virtual ~StyleTableMapArchive();

  StyleTableMapArchive(const StyleTableMapArchive& from);

  inline StyleTableMapArchive& operator=(const StyleTableMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTableMapArchive& default_instance();

  void Swap(StyleTableMapArchive* other);

  // implements Message ----------------------------------------------

  StyleTableMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTableMapArchive& from);
  void MergeFrom(const StyleTableMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StyleTableMapArchive_StyleTableMapEntryArchive StyleTableMapEntryArchive;

  // accessors -------------------------------------------------------

  // required uint32 capacity = 1;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity() const;
  inline void set_capacity(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
  inline int map_entry_size() const;
  inline void clear_map_entry();
  static const int kMapEntryFieldNumber = 3;
  inline const ::TST::StyleTableMapArchive_StyleTableMapEntryArchive& map_entry(int index) const;
  inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* mutable_map_entry(int index);
  inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* add_map_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >&
      map_entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >*
      mutable_map_entry();

  // @@protoc_insertion_point(class_scope:TST.StyleTableMapArchive)
 private:
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 capacity_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive > map_entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleTableMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class SelectionArchive : public ::google::protobuf::Message {
 public:
  SelectionArchive();
  virtual ~SelectionArchive();

  SelectionArchive(const SelectionArchive& from);

  inline SelectionArchive& operator=(const SelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectionArchive& default_instance();

  void Swap(SelectionArchive* other);

  // implements Message ----------------------------------------------

  SelectionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelectionArchive& from);
  void MergeFrom(const SelectionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference tableModel = 1 [deprecated = true];
  inline bool has_tablemodel() const PROTOBUF_DEPRECATED;
  inline void clear_tablemodel() PROTOBUF_DEPRECATED;
  static const int kTableModelFieldNumber = 1;
  inline const ::TSP::Reference& tablemodel() const PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* mutable_tablemodel() PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* release_tablemodel() PROTOBUF_DEPRECATED;
  inline void set_allocated_tablemodel(::TSP::Reference* tablemodel) PROTOBUF_DEPRECATED;

  // required .TST.SelectionTypeArchive selection_type = 4;
  inline bool has_selection_type() const;
  inline void clear_selection_type();
  static const int kSelectionTypeFieldNumber = 4;
  inline ::TST::SelectionTypeArchive selection_type() const;
  inline void set_selection_type(::TST::SelectionTypeArchive value);

  // optional .TST.CellID anchor_cell = 5;
  inline bool has_anchor_cell() const;
  inline void clear_anchor_cell();
  static const int kAnchorCellFieldNumber = 5;
  inline const ::TST::CellID& anchor_cell() const;
  inline ::TST::CellID* mutable_anchor_cell();
  inline ::TST::CellID* release_anchor_cell();
  inline void set_allocated_anchor_cell(::TST::CellID* anchor_cell);

  // repeated .TST.CellRange cell_ranges = 6;
  inline int cell_ranges_size() const;
  inline void clear_cell_ranges();
  static const int kCellRangesFieldNumber = 6;
  inline const ::TST::CellRange& cell_ranges(int index) const;
  inline ::TST::CellRange* mutable_cell_ranges(int index);
  inline ::TST::CellRange* add_cell_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
      cell_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
      mutable_cell_ranges();

  // repeated .TST.CellRange base_ranges = 7;
  inline int base_ranges_size() const;
  inline void clear_base_ranges();
  static const int kBaseRangesFieldNumber = 7;
  inline const ::TST::CellRange& base_ranges(int index) const;
  inline ::TST::CellRange* mutable_base_ranges(int index);
  inline ::TST::CellRange* add_base_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
      base_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
      mutable_base_ranges();

  // optional .TST.CellID cursor_cell = 8;
  inline bool has_cursor_cell() const;
  inline void clear_cursor_cell();
  static const int kCursorCellFieldNumber = 8;
  inline const ::TST::CellID& cursor_cell() const;
  inline ::TST::CellID* mutable_cursor_cell();
  inline ::TST::CellID* release_cursor_cell();
  inline void set_allocated_cursor_cell(::TST::CellID* cursor_cell);

  // @@protoc_insertion_point(class_scope:TST.SelectionArchive)
 private:
  inline void set_has_tablemodel();
  inline void clear_has_tablemodel();
  inline void set_has_selection_type();
  inline void clear_has_selection_type();
  inline void set_has_anchor_cell();
  inline void clear_has_anchor_cell();
  inline void set_has_cursor_cell();
  inline void clear_has_cursor_cell();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* tablemodel_;
  ::TST::CellID* anchor_cell_;
  ::google::protobuf::RepeatedPtrField< ::TST::CellRange > cell_ranges_;
  ::google::protobuf::RepeatedPtrField< ::TST::CellRange > base_ranges_;
  ::TST::CellID* cursor_cell_;
  int selection_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static SelectionArchive* default_instance_;
};
// -------------------------------------------------------------------

class FilterRuleArchive : public ::google::protobuf::Message {
 public:
  FilterRuleArchive();
  virtual ~FilterRuleArchive();

  FilterRuleArchive(const FilterRuleArchive& from);

  inline FilterRuleArchive& operator=(const FilterRuleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterRuleArchive& default_instance();

  void Swap(FilterRuleArchive* other);

  // implements Message ----------------------------------------------

  FilterRuleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterRuleArchive& from);
  void MergeFrom(const FilterRuleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.FormulaPredicateArchive predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::TST::FormulaPredicateArchive& predicate() const;
  inline ::TST::FormulaPredicateArchive* mutable_predicate();
  inline ::TST::FormulaPredicateArchive* release_predicate();
  inline void set_allocated_predicate(::TST::FormulaPredicateArchive* predicate);

  // optional bool disabled = 2;
  inline bool has_disabled() const;
  inline void clear_disabled();
  static const int kDisabledFieldNumber = 2;
  inline bool disabled() const;
  inline void set_disabled(bool value);

  // @@protoc_insertion_point(class_scope:TST.FilterRuleArchive)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_disabled();
  inline void clear_has_disabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::FormulaPredicateArchive* predicate_;
  bool disabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FilterRuleArchive* default_instance_;
};
// -------------------------------------------------------------------

class TableStyleArchive : public ::google::protobuf::Message {
 public:
  TableStyleArchive();
  virtual ~TableStyleArchive();

  TableStyleArchive(const TableStyleArchive& from);

  inline TableStyleArchive& operator=(const TableStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableStyleArchive& default_instance();

  void Swap(TableStyleArchive* other);

  // implements Message ----------------------------------------------

  TableStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableStyleArchive& from);
  void MergeFrom(const TableStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TST.TableStylePropertiesArchive table_properties = 11;
  inline bool has_table_properties() const;
  inline void clear_table_properties();
  static const int kTablePropertiesFieldNumber = 11;
  inline const ::TST::TableStylePropertiesArchive& table_properties() const;
  inline ::TST::TableStylePropertiesArchive* mutable_table_properties();
  inline ::TST::TableStylePropertiesArchive* release_table_properties();
  inline void set_allocated_table_properties(::TST::TableStylePropertiesArchive* table_properties);

  // @@protoc_insertion_point(class_scope:TST.TableStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_table_properties();
  inline void clear_has_table_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TST::TableStylePropertiesArchive* table_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TableStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellStyleArchive : public ::google::protobuf::Message {
 public:
  CellStyleArchive();
  virtual ~CellStyleArchive();

  CellStyleArchive(const CellStyleArchive& from);

  inline CellStyleArchive& operator=(const CellStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellStyleArchive& default_instance();

  void Swap(CellStyleArchive* other);

  // implements Message ----------------------------------------------

  CellStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellStyleArchive& from);
  void MergeFrom(const CellStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TST.CellStylePropertiesArchive cell_properties = 11;
  inline bool has_cell_properties() const;
  inline void clear_cell_properties();
  static const int kCellPropertiesFieldNumber = 11;
  inline const ::TST::CellStylePropertiesArchive& cell_properties() const;
  inline ::TST::CellStylePropertiesArchive* mutable_cell_properties();
  inline ::TST::CellStylePropertiesArchive* release_cell_properties();
  inline void set_allocated_cell_properties(::TST::CellStylePropertiesArchive* cell_properties);

  // @@protoc_insertion_point(class_scope:TST.CellStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_cell_properties();
  inline void clear_has_cell_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TST::CellStylePropertiesArchive* cell_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CellStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaPredicateArchive : public ::google::protobuf::Message {
 public:
  FormulaPredicateArchive();
  virtual ~FormulaPredicateArchive();

  FormulaPredicateArchive(const FormulaPredicateArchive& from);

  inline FormulaPredicateArchive& operator=(const FormulaPredicateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaPredicateArchive& default_instance();

  void Swap(FormulaPredicateArchive* other);

  // implements Message ----------------------------------------------

  FormulaPredicateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaPredicateArchive& from);
  void MergeFrom(const FormulaPredicateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FormulaPredicateArchive_FormulaPredicateType FormulaPredicateType;
  static const FormulaPredicateType PredNone = FormulaPredicateArchive_FormulaPredicateType_PredNone;
  static const FormulaPredicateType TextStartsWith = FormulaPredicateArchive_FormulaPredicateType_TextStartsWith;
  static const FormulaPredicateType TextEndsWith = FormulaPredicateArchive_FormulaPredicateType_TextEndsWith;
  static const FormulaPredicateType TextContains = FormulaPredicateArchive_FormulaPredicateType_TextContains;
  static const FormulaPredicateType TextDoesNotContain = FormulaPredicateArchive_FormulaPredicateType_TextDoesNotContain;
  static const FormulaPredicateType ValueEqual = FormulaPredicateArchive_FormulaPredicateType_ValueEqual;
  static const FormulaPredicateType ValueNotEqual = FormulaPredicateArchive_FormulaPredicateType_ValueNotEqual;
  static const FormulaPredicateType ValueGreaterThan = FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThan;
  static const FormulaPredicateType ValueGreaterThanOrEqual = FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThanOrEqual;
  static const FormulaPredicateType ValueLessThan = FormulaPredicateArchive_FormulaPredicateType_ValueLessThan;
  static const FormulaPredicateType ValueLessThanOrEqual = FormulaPredicateArchive_FormulaPredicateType_ValueLessThanOrEqual;
  static const FormulaPredicateType ValueAboveAverage = FormulaPredicateArchive_FormulaPredicateType_ValueAboveAverage;
  static const FormulaPredicateType ValueBelowAverage = FormulaPredicateArchive_FormulaPredicateType_ValueBelowAverage;
  static const FormulaPredicateType ValueBetween = FormulaPredicateArchive_FormulaPredicateType_ValueBetween;
  static const FormulaPredicateType Formula = FormulaPredicateArchive_FormulaPredicateType_Formula;
  static const FormulaPredicateType Duplicates = FormulaPredicateArchive_FormulaPredicateType_Duplicates;
  static const FormulaPredicateType Uniques = FormulaPredicateArchive_FormulaPredicateType_Uniques;
  static const FormulaPredicateType DateIsToday = FormulaPredicateArchive_FormulaPredicateType_DateIsToday;
  static const FormulaPredicateType DateIsYesterday = FormulaPredicateArchive_FormulaPredicateType_DateIsYesterday;
  static const FormulaPredicateType DateIsTomorrow = FormulaPredicateArchive_FormulaPredicateType_DateIsTomorrow;
  static const FormulaPredicateType DateIsTheDate = FormulaPredicateArchive_FormulaPredicateType_DateIsTheDate;
  static const FormulaPredicateType DateBeforeTheDate = FormulaPredicateArchive_FormulaPredicateType_DateBeforeTheDate;
  static const FormulaPredicateType DateAfterTheDate = FormulaPredicateArchive_FormulaPredicateType_DateAfterTheDate;
  static const FormulaPredicateType DateIsInTheRange = FormulaPredicateArchive_FormulaPredicateType_DateIsInTheRange;
  static const FormulaPredicateType DateInTheNext = FormulaPredicateArchive_FormulaPredicateType_DateInTheNext;
  static const FormulaPredicateType DateInTheLast = FormulaPredicateArchive_FormulaPredicateType_DateInTheLast;
  static const FormulaPredicateType DateIsExactly = FormulaPredicateArchive_FormulaPredicateType_DateIsExactly;
  static const FormulaPredicateType DateBeforeRelative = FormulaPredicateArchive_FormulaPredicateType_DateBeforeRelative;
  static const FormulaPredicateType DateAfterRelative = FormulaPredicateArchive_FormulaPredicateType_DateAfterRelative;
  static const FormulaPredicateType DateBetweenRelative = FormulaPredicateArchive_FormulaPredicateType_DateBetweenRelative;
  static const FormulaPredicateType ValueTop = FormulaPredicateArchive_FormulaPredicateType_ValueTop;
  static const FormulaPredicateType ValueBottom = FormulaPredicateArchive_FormulaPredicateType_ValueBottom;
  static const FormulaPredicateType ValueNotBetween = FormulaPredicateArchive_FormulaPredicateType_ValueNotBetween;
  static const FormulaPredicateType DateInThis = FormulaPredicateArchive_FormulaPredicateType_DateInThis;
  static const FormulaPredicateType IsBlank = FormulaPredicateArchive_FormulaPredicateType_IsBlank;
  static const FormulaPredicateType IsNotBlank = FormulaPredicateArchive_FormulaPredicateType_IsNotBlank;
  static const FormulaPredicateType TextIs = FormulaPredicateArchive_FormulaPredicateType_TextIs;
  static const FormulaPredicateType TextIsNot = FormulaPredicateArchive_FormulaPredicateType_TextIsNot;
  static const FormulaPredicateType DurationEqual = FormulaPredicateArchive_FormulaPredicateType_DurationEqual;
  static const FormulaPredicateType DurationNotEqual = FormulaPredicateArchive_FormulaPredicateType_DurationNotEqual;
  static const FormulaPredicateType DurationGreaterThan = FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThan;
  static const FormulaPredicateType DurationGreaterThanOrEqual = FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThanOrEqual;
  static const FormulaPredicateType DurationLessThan = FormulaPredicateArchive_FormulaPredicateType_DurationLessThan;
  static const FormulaPredicateType DurationLessThanOrEqual = FormulaPredicateArchive_FormulaPredicateType_DurationLessThanOrEqual;
  static const FormulaPredicateType DurationBetween = FormulaPredicateArchive_FormulaPredicateType_DurationBetween;
  static const FormulaPredicateType DurationNotBetween = FormulaPredicateArchive_FormulaPredicateType_DurationNotBetween;
  static const FormulaPredicateType DurationAboveAverage = FormulaPredicateArchive_FormulaPredicateType_DurationAboveAverage;
  static const FormulaPredicateType DurationBelowAverage = FormulaPredicateArchive_FormulaPredicateType_DurationBelowAverage;
  static const FormulaPredicateType DurationTop = FormulaPredicateArchive_FormulaPredicateType_DurationTop;
  static const FormulaPredicateType DurationBottom = FormulaPredicateArchive_FormulaPredicateType_DurationBottom;
  static inline bool FormulaPredicateType_IsValid(int value) {
    return FormulaPredicateArchive_FormulaPredicateType_IsValid(value);
  }
  static const FormulaPredicateType FormulaPredicateType_MIN =
    FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MIN;
  static const FormulaPredicateType FormulaPredicateType_MAX =
    FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MAX;
  static const int FormulaPredicateType_ARRAYSIZE =
    FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FormulaPredicateType_descriptor() {
    return FormulaPredicateArchive_FormulaPredicateType_descriptor();
  }
  static inline const ::std::string& FormulaPredicateType_Name(FormulaPredicateType value) {
    return FormulaPredicateArchive_FormulaPredicateType_Name(value);
  }
  static inline bool FormulaPredicateType_Parse(const ::std::string& name,
      FormulaPredicateType* value) {
    return FormulaPredicateArchive_FormulaPredicateType_Parse(name, value);
  }

  typedef FormulaPredicateArchive_QualifierType QualifierType;
  static const QualifierType QualNone = FormulaPredicateArchive_QualifierType_QualNone;
  static const QualifierType Days = FormulaPredicateArchive_QualifierType_Days;
  static const QualifierType Weeks = FormulaPredicateArchive_QualifierType_Weeks;
  static const QualifierType Months = FormulaPredicateArchive_QualifierType_Months;
  static const QualifierType Years = FormulaPredicateArchive_QualifierType_Years;
  static const QualifierType Ago = FormulaPredicateArchive_QualifierType_Ago;
  static const QualifierType FromNow = FormulaPredicateArchive_QualifierType_FromNow;
  static const QualifierType Quarters = FormulaPredicateArchive_QualifierType_Quarters;
  static const QualifierType Percent = FormulaPredicateArchive_QualifierType_Percent;
  static const QualifierType Values = FormulaPredicateArchive_QualifierType_Values;
  static inline bool QualifierType_IsValid(int value) {
    return FormulaPredicateArchive_QualifierType_IsValid(value);
  }
  static const QualifierType QualifierType_MIN =
    FormulaPredicateArchive_QualifierType_QualifierType_MIN;
  static const QualifierType QualifierType_MAX =
    FormulaPredicateArchive_QualifierType_QualifierType_MAX;
  static const int QualifierType_ARRAYSIZE =
    FormulaPredicateArchive_QualifierType_QualifierType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QualifierType_descriptor() {
    return FormulaPredicateArchive_QualifierType_descriptor();
  }
  static inline const ::std::string& QualifierType_Name(QualifierType value) {
    return FormulaPredicateArchive_QualifierType_Name(value);
  }
  static inline bool QualifierType_Parse(const ::std::string& name,
      QualifierType* value) {
    return FormulaPredicateArchive_QualifierType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSCE.FormulaArchive formula = 1;
  inline bool has_formula() const;
  inline void clear_formula();
  static const int kFormulaFieldNumber = 1;
  inline const ::TSCE::FormulaArchive& formula() const;
  inline ::TSCE::FormulaArchive* mutable_formula();
  inline ::TSCE::FormulaArchive* release_formula();
  inline void set_allocated_formula(::TSCE::FormulaArchive* formula);

  // required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
  inline bool has_predicate_type() const;
  inline void clear_predicate_type();
  static const int kPredicateTypeFieldNumber = 2;
  inline ::TST::FormulaPredicateArchive_FormulaPredicateType predicate_type() const;
  inline void set_predicate_type(::TST::FormulaPredicateArchive_FormulaPredicateType value);

  // required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
  inline bool has_qualifier1() const;
  inline void clear_qualifier1();
  static const int kQualifier1FieldNumber = 3;
  inline ::TST::FormulaPredicateArchive_QualifierType qualifier1() const;
  inline void set_qualifier1(::TST::FormulaPredicateArchive_QualifierType value);

  // required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
  inline bool has_qualifier2() const;
  inline void clear_qualifier2();
  static const int kQualifier2FieldNumber = 4;
  inline ::TST::FormulaPredicateArchive_QualifierType qualifier2() const;
  inline void set_qualifier2(::TST::FormulaPredicateArchive_QualifierType value);

  // required int32 param_index1 = 5;
  inline bool has_param_index1() const;
  inline void clear_param_index1();
  static const int kParamIndex1FieldNumber = 5;
  inline ::google::protobuf::int32 param_index1() const;
  inline void set_param_index1(::google::protobuf::int32 value);

  // required int32 param_index2 = 6;
  inline bool has_param_index2() const;
  inline void clear_param_index2();
  static const int kParamIndex2FieldNumber = 6;
  inline ::google::protobuf::int32 param_index2() const;
  inline void set_param_index2(::google::protobuf::int32 value);

  // required int32 param_index0 = 7;
  inline bool has_param_index0() const;
  inline void clear_param_index0();
  static const int kParamIndex0FieldNumber = 7;
  inline ::google::protobuf::int32 param_index0() const;
  inline void set_param_index0(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TST.FormulaPredicateArchive)
 private:
  inline void set_has_formula();
  inline void clear_has_formula();
  inline void set_has_predicate_type();
  inline void clear_has_predicate_type();
  inline void set_has_qualifier1();
  inline void clear_has_qualifier1();
  inline void set_has_qualifier2();
  inline void clear_has_qualifier2();
  inline void set_has_param_index1();
  inline void clear_has_param_index1();
  inline void set_has_param_index2();
  inline void clear_has_param_index2();
  inline void set_has_param_index0();
  inline void clear_has_param_index0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::FormulaArchive* formula_;
  int predicate_type_;
  int qualifier1_;
  int qualifier2_;
  ::google::protobuf::int32 param_index1_;
  ::google::protobuf::int32 param_index2_;
  ::google::protobuf::int32 param_index0_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaPredicateArchive* default_instance_;
};
// -------------------------------------------------------------------

class ConditionalStyleSetArchive_ConditionalStyleRule : public ::google::protobuf::Message {
 public:
  ConditionalStyleSetArchive_ConditionalStyleRule();
  virtual ~ConditionalStyleSetArchive_ConditionalStyleRule();

  ConditionalStyleSetArchive_ConditionalStyleRule(const ConditionalStyleSetArchive_ConditionalStyleRule& from);

  inline ConditionalStyleSetArchive_ConditionalStyleRule& operator=(const ConditionalStyleSetArchive_ConditionalStyleRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalStyleSetArchive_ConditionalStyleRule& default_instance();

  void Swap(ConditionalStyleSetArchive_ConditionalStyleRule* other);

  // implements Message ----------------------------------------------

  ConditionalStyleSetArchive_ConditionalStyleRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionalStyleSetArchive_ConditionalStyleRule& from);
  void MergeFrom(const ConditionalStyleSetArchive_ConditionalStyleRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.FormulaPredicateArchive predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::TST::FormulaPredicateArchive& predicate() const;
  inline ::TST::FormulaPredicateArchive* mutable_predicate();
  inline ::TST::FormulaPredicateArchive* release_predicate();
  inline void set_allocated_predicate(::TST::FormulaPredicateArchive* predicate);

  // required .TSP.Reference cell_style = 2;
  inline bool has_cell_style() const;
  inline void clear_cell_style();
  static const int kCellStyleFieldNumber = 2;
  inline const ::TSP::Reference& cell_style() const;
  inline ::TSP::Reference* mutable_cell_style();
  inline ::TSP::Reference* release_cell_style();
  inline void set_allocated_cell_style(::TSP::Reference* cell_style);

  // required .TSP.Reference text_style = 3;
  inline bool has_text_style() const;
  inline void clear_text_style();
  static const int kTextStyleFieldNumber = 3;
  inline const ::TSP::Reference& text_style() const;
  inline ::TSP::Reference* mutable_text_style();
  inline ::TSP::Reference* release_text_style();
  inline void set_allocated_text_style(::TSP::Reference* text_style);

  // @@protoc_insertion_point(class_scope:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_cell_style();
  inline void clear_has_cell_style();
  inline void set_has_text_style();
  inline void clear_has_text_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::FormulaPredicateArchive* predicate_;
  ::TSP::Reference* cell_style_;
  ::TSP::Reference* text_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ConditionalStyleSetArchive_ConditionalStyleRule* default_instance_;
};
// -------------------------------------------------------------------

class ConditionalStyleSetArchive : public ::google::protobuf::Message {
 public:
  ConditionalStyleSetArchive();
  virtual ~ConditionalStyleSetArchive();

  ConditionalStyleSetArchive(const ConditionalStyleSetArchive& from);

  inline ConditionalStyleSetArchive& operator=(const ConditionalStyleSetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalStyleSetArchive& default_instance();

  void Swap(ConditionalStyleSetArchive* other);

  // implements Message ----------------------------------------------

  ConditionalStyleSetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionalStyleSetArchive& from);
  void MergeFrom(const ConditionalStyleSetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ConditionalStyleSetArchive_ConditionalStyleRule ConditionalStyleRule;

  // accessors -------------------------------------------------------

  // required uint32 ruleCount = 1;
  inline bool has_rulecount() const;
  inline void clear_rulecount();
  static const int kRuleCountFieldNumber = 1;
  inline ::google::protobuf::uint32 rulecount() const;
  inline void set_rulecount(::google::protobuf::uint32 value);

  // repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 2;
  inline const ::TST::ConditionalStyleSetArchive_ConditionalStyleRule& rules(int index) const;
  inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* mutable_rules(int index);
  inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >*
      mutable_rules();

  // optional .TST.CellID cellID = 3;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellIDFieldNumber = 3;
  inline const ::TST::CellID& cellid() const;
  inline ::TST::CellID* mutable_cellid();
  inline ::TST::CellID* release_cellid();
  inline void set_allocated_cellid(::TST::CellID* cellid);

  // @@protoc_insertion_point(class_scope:TST.ConditionalStyleSetArchive)
 private:
  inline void set_has_rulecount();
  inline void clear_has_rulecount();
  inline void set_has_cellid();
  inline void clear_has_cellid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule > rules_;
  ::TST::CellID* cellid_;
  ::google::protobuf::uint32 rulecount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ConditionalStyleSetArchive* default_instance_;
};
// -------------------------------------------------------------------

class FilterSetArchive : public ::google::protobuf::Message {
 public:
  FilterSetArchive();
  virtual ~FilterSetArchive();

  FilterSetArchive(const FilterSetArchive& from);

  inline FilterSetArchive& operator=(const FilterSetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterSetArchive& default_instance();

  void Swap(FilterSetArchive* other);

  // implements Message ----------------------------------------------

  FilterSetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterSetArchive& from);
  void MergeFrom(const FilterSetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FilterSetArchive_FilterSetType FilterSetType;
  static const FilterSetType FilterSetArchiveTypeAll = FilterSetArchive_FilterSetType_FilterSetArchiveTypeAll;
  static const FilterSetType FilterSetArchiveTypeAny = FilterSetArchive_FilterSetType_FilterSetArchiveTypeAny;
  static inline bool FilterSetType_IsValid(int value) {
    return FilterSetArchive_FilterSetType_IsValid(value);
  }
  static const FilterSetType FilterSetType_MIN =
    FilterSetArchive_FilterSetType_FilterSetType_MIN;
  static const FilterSetType FilterSetType_MAX =
    FilterSetArchive_FilterSetType_FilterSetType_MAX;
  static const int FilterSetType_ARRAYSIZE =
    FilterSetArchive_FilterSetType_FilterSetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FilterSetType_descriptor() {
    return FilterSetArchive_FilterSetType_descriptor();
  }
  static inline const ::std::string& FilterSetType_Name(FilterSetType value) {
    return FilterSetArchive_FilterSetType_Name(value);
  }
  static inline bool FilterSetType_Parse(const ::std::string& name,
      FilterSetType* value) {
    return FilterSetArchive_FilterSetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TST::FilterSetArchive_FilterSetType type() const;
  inline void set_type(::TST::FilterSetArchive_FilterSetType value);

  // optional bool is_enabled = 2 [default = true];
  inline bool has_is_enabled() const;
  inline void clear_is_enabled();
  static const int kIsEnabledFieldNumber = 2;
  inline bool is_enabled() const;
  inline void set_is_enabled(bool value);

  // repeated .TST.FilterRuleArchive filter_rules = 3;
  inline int filter_rules_size() const;
  inline void clear_filter_rules();
  static const int kFilterRulesFieldNumber = 3;
  inline const ::TST::FilterRuleArchive& filter_rules(int index) const;
  inline ::TST::FilterRuleArchive* mutable_filter_rules(int index);
  inline ::TST::FilterRuleArchive* add_filter_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >&
      filter_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >*
      mutable_filter_rules();

  // optional bool needs_formula_rewrite_for_import = 4 [default = false];
  inline bool has_needs_formula_rewrite_for_import() const;
  inline void clear_needs_formula_rewrite_for_import();
  static const int kNeedsFormulaRewriteForImportFieldNumber = 4;
  inline bool needs_formula_rewrite_for_import() const;
  inline void set_needs_formula_rewrite_for_import(bool value);

  // repeated uint32 filter_offsets = 5;
  inline int filter_offsets_size() const;
  inline void clear_filter_offsets();
  static const int kFilterOffsetsFieldNumber = 5;
  inline ::google::protobuf::uint32 filter_offsets(int index) const;
  inline void set_filter_offsets(int index, ::google::protobuf::uint32 value);
  inline void add_filter_offsets(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      filter_offsets() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_filter_offsets();

  // repeated bool filter_enabled = 6;
  inline int filter_enabled_size() const;
  inline void clear_filter_enabled();
  static const int kFilterEnabledFieldNumber = 6;
  inline bool filter_enabled(int index) const;
  inline void set_filter_enabled(int index, bool value);
  inline void add_filter_enabled(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      filter_enabled() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_filter_enabled();

  // @@protoc_insertion_point(class_scope:TST.FilterSetArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_enabled();
  inline void clear_has_is_enabled();
  inline void set_has_needs_formula_rewrite_for_import();
  inline void clear_has_needs_formula_rewrite_for_import();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  bool is_enabled_;
  bool needs_formula_rewrite_for_import_;
  ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive > filter_rules_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > filter_offsets_;
  ::google::protobuf::RepeatedField< bool > filter_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FilterSetArchive* default_instance_;
};
// -------------------------------------------------------------------

class TokenAttachmentArchive : public ::google::protobuf::Message {
 public:
  TokenAttachmentArchive();
  virtual ~TokenAttachmentArchive();

  TokenAttachmentArchive(const TokenAttachmentArchive& from);

  inline TokenAttachmentArchive& operator=(const TokenAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenAttachmentArchive& default_instance();

  void Swap(TokenAttachmentArchive* other);

  // implements Message ----------------------------------------------

  TokenAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenAttachmentArchive& from);
  void MergeFrom(const TokenAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.UIGraphicalAttachment super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::UIGraphicalAttachment& super() const;
  inline ::TSWP::UIGraphicalAttachment* mutable_super();
  inline ::TSWP::UIGraphicalAttachment* release_super();
  inline void set_allocated_super(::TSWP::UIGraphicalAttachment* super);

  // optional .TSP.Reference expressionNode = 2;
  inline bool has_expressionnode() const;
  inline void clear_expressionnode();
  static const int kExpressionNodeFieldNumber = 2;
  inline const ::TSP::Reference& expressionnode() const;
  inline ::TSP::Reference* mutable_expressionnode();
  inline ::TSP::Reference* release_expressionnode();
  inline void set_allocated_expressionnode(::TSP::Reference* expressionnode);

  // @@protoc_insertion_point(class_scope:TST.TokenAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_expressionnode();
  inline void clear_has_expressionnode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::UIGraphicalAttachment* super_;
  ::TSP::Reference* expressionnode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static TokenAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaArchive : public ::google::protobuf::Message {
 public:
  FormulaArchive();
  virtual ~FormulaArchive();

  FormulaArchive(const FormulaArchive& from);

  inline FormulaArchive& operator=(const FormulaArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaArchive& default_instance();

  void Swap(FormulaArchive* other);

  // implements Message ----------------------------------------------

  FormulaArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaArchive& from);
  void MergeFrom(const FormulaArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference expressionTree = 1;
  inline bool has_expressiontree() const;
  inline void clear_expressiontree();
  static const int kExpressionTreeFieldNumber = 1;
  inline const ::TSP::Reference& expressiontree() const;
  inline ::TSP::Reference* mutable_expressiontree();
  inline ::TSP::Reference* release_expressiontree();
  inline void set_allocated_expressiontree(::TSP::Reference* expressiontree);

  // @@protoc_insertion_point(class_scope:TST.FormulaArchive)
 private:
  inline void set_has_expressiontree();
  inline void clear_has_expressiontree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* expressiontree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaArchive* default_instance_;
};
// -------------------------------------------------------------------

class ExpressionNodeArchive : public ::google::protobuf::Message {
 public:
  ExpressionNodeArchive();
  virtual ~ExpressionNodeArchive();

  ExpressionNodeArchive(const ExpressionNodeArchive& from);

  inline ExpressionNodeArchive& operator=(const ExpressionNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExpressionNodeArchive& default_instance();

  void Swap(ExpressionNodeArchive* other);

  // implements Message ----------------------------------------------

  ExpressionNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExpressionNodeArchive& from);
  void MergeFrom(const ExpressionNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference children = 1;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 1;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // optional uint64 first_index = 2 [default = 0];
  inline bool has_first_index() const;
  inline void clear_first_index();
  static const int kFirstIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 first_index() const;
  inline void set_first_index(::google::protobuf::uint64 value);

  // optional uint64 last_index = 3 [default = 0];
  inline bool has_last_index() const;
  inline void clear_last_index();
  static const int kLastIndexFieldNumber = 3;
  inline ::google::protobuf::uint64 last_index() const;
  inline void set_last_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TST.ExpressionNodeArchive)
 private:
  inline void set_has_first_index();
  inline void clear_has_first_index();
  inline void set_has_last_index();
  inline void clear_has_last_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;
  ::google::protobuf::uint64 first_index_;
  ::google::protobuf::uint64 last_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ExpressionNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class BooleanNodeArchive : public ::google::protobuf::Message {
 public:
  BooleanNodeArchive();
  virtual ~BooleanNodeArchive();

  BooleanNodeArchive(const BooleanNodeArchive& from);

  inline BooleanNodeArchive& operator=(const BooleanNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BooleanNodeArchive& default_instance();

  void Swap(BooleanNodeArchive* other);

  // implements Message ----------------------------------------------

  BooleanNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BooleanNodeArchive& from);
  void MergeFrom(const BooleanNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required bool value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:TST.BooleanNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static BooleanNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class NumberNodeArchive : public ::google::protobuf::Message {
 public:
  NumberNodeArchive();
  virtual ~NumberNodeArchive();

  NumberNodeArchive(const NumberNodeArchive& from);

  inline NumberNodeArchive& operator=(const NumberNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberNodeArchive& default_instance();

  void Swap(NumberNodeArchive* other);

  // implements Message ----------------------------------------------

  NumberNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumberNodeArchive& from);
  void MergeFrom(const NumberNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required double number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline double number() const;
  inline void set_number(double value);

  // @@protoc_insertion_point(class_scope:TST.NumberNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  double number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static NumberNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class StringNodeArchive : public ::google::protobuf::Message {
 public:
  StringNodeArchive();
  virtual ~StringNodeArchive();

  StringNodeArchive(const StringNodeArchive& from);

  inline StringNodeArchive& operator=(const StringNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringNodeArchive& default_instance();

  void Swap(StringNodeArchive* other);

  // implements Message ----------------------------------------------

  StringNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringNodeArchive& from);
  void MergeFrom(const StringNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:TST.StringNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static StringNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class IdentifierNodeArchive : public ::google::protobuf::Message {
 public:
  IdentifierNodeArchive();
  virtual ~IdentifierNodeArchive();

  IdentifierNodeArchive(const IdentifierNodeArchive& from);

  inline IdentifierNodeArchive& operator=(const IdentifierNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdentifierNodeArchive& default_instance();

  void Swap(IdentifierNodeArchive* other);

  // implements Message ----------------------------------------------

  IdentifierNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IdentifierNodeArchive& from);
  void MergeFrom(const IdentifierNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // optional string identifier = 2;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  inline void set_allocated_identifier(::std::string* identifier);

  // @@protoc_insertion_point(class_scope:TST.IdentifierNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_identifier();
  inline void clear_has_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::std::string* identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static IdentifierNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ArrayNodeArchive : public ::google::protobuf::Message {
 public:
  ArrayNodeArchive();
  virtual ~ArrayNodeArchive();

  ArrayNodeArchive(const ArrayNodeArchive& from);

  inline ArrayNodeArchive& operator=(const ArrayNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArrayNodeArchive& default_instance();

  void Swap(ArrayNodeArchive* other);

  // implements Message ----------------------------------------------

  ArrayNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArrayNodeArchive& from);
  void MergeFrom(const ArrayNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // optional uint32 columns = 2;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline ::google::protobuf::uint32 columns() const;
  inline void set_columns(::google::protobuf::uint32 value);

  // optional uint32 rows = 3;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.ArrayNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_columns();
  inline void clear_has_columns();
  inline void set_has_rows();
  inline void clear_has_rows();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::google::protobuf::uint32 columns_;
  ::google::protobuf::uint32 rows_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ArrayNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ListNodeArchive : public ::google::protobuf::Message {
 public:
  ListNodeArchive();
  virtual ~ListNodeArchive();

  ListNodeArchive(const ListNodeArchive& from);

  inline ListNodeArchive& operator=(const ListNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListNodeArchive& default_instance();

  void Swap(ListNodeArchive* other);

  // implements Message ----------------------------------------------

  ListNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListNodeArchive& from);
  void MergeFrom(const ListNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // @@protoc_insertion_point(class_scope:TST.ListNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ListNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class OperatorNodeArchive : public ::google::protobuf::Message {
 public:
  OperatorNodeArchive();
  virtual ~OperatorNodeArchive();

  OperatorNodeArchive(const OperatorNodeArchive& from);

  inline OperatorNodeArchive& operator=(const OperatorNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatorNodeArchive& default_instance();

  void Swap(OperatorNodeArchive* other);

  // implements Message ----------------------------------------------

  OperatorNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperatorNodeArchive& from);
  void MergeFrom(const OperatorNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required uint32 operatorChar = 2;
  inline bool has_operatorchar() const;
  inline void clear_operatorchar();
  static const int kOperatorCharFieldNumber = 2;
  inline ::google::protobuf::uint32 operatorchar() const;
  inline void set_operatorchar(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.OperatorNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_operatorchar();
  inline void clear_has_operatorchar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::google::protobuf::uint32 operatorchar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static OperatorNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class PostfixOperatorNodeArchive : public ::google::protobuf::Message {
 public:
  PostfixOperatorNodeArchive();
  virtual ~PostfixOperatorNodeArchive();

  PostfixOperatorNodeArchive(const PostfixOperatorNodeArchive& from);

  inline PostfixOperatorNodeArchive& operator=(const PostfixOperatorNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostfixOperatorNodeArchive& default_instance();

  void Swap(PostfixOperatorNodeArchive* other);

  // implements Message ----------------------------------------------

  PostfixOperatorNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostfixOperatorNodeArchive& from);
  void MergeFrom(const PostfixOperatorNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.OperatorNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::OperatorNodeArchive& super() const;
  inline ::TST::OperatorNodeArchive* mutable_super();
  inline ::TST::OperatorNodeArchive* release_super();
  inline void set_allocated_super(::TST::OperatorNodeArchive* super);

  // @@protoc_insertion_point(class_scope:TST.PostfixOperatorNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::OperatorNodeArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static PostfixOperatorNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class PrefixOperatorNodeArchive : public ::google::protobuf::Message {
 public:
  PrefixOperatorNodeArchive();
  virtual ~PrefixOperatorNodeArchive();

  PrefixOperatorNodeArchive(const PrefixOperatorNodeArchive& from);

  inline PrefixOperatorNodeArchive& operator=(const PrefixOperatorNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrefixOperatorNodeArchive& default_instance();

  void Swap(PrefixOperatorNodeArchive* other);

  // implements Message ----------------------------------------------

  PrefixOperatorNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrefixOperatorNodeArchive& from);
  void MergeFrom(const PrefixOperatorNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.OperatorNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::OperatorNodeArchive& super() const;
  inline ::TST::OperatorNodeArchive* mutable_super();
  inline ::TST::OperatorNodeArchive* release_super();
  inline void set_allocated_super(::TST::OperatorNodeArchive* super);

  // @@protoc_insertion_point(class_scope:TST.PrefixOperatorNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::OperatorNodeArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static PrefixOperatorNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class FunctionNodeArchive : public ::google::protobuf::Message {
 public:
  FunctionNodeArchive();
  virtual ~FunctionNodeArchive();

  FunctionNodeArchive(const FunctionNodeArchive& from);

  inline FunctionNodeArchive& operator=(const FunctionNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionNodeArchive& default_instance();

  void Swap(FunctionNodeArchive* other);

  // implements Message ----------------------------------------------

  FunctionNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionNodeArchive& from);
  void MergeFrom(const FunctionNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required uint32 functionIndex = 2;
  inline bool has_functionindex() const;
  inline void clear_functionindex();
  static const int kFunctionIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 functionindex() const;
  inline void set_functionindex(::google::protobuf::uint32 value);

  // optional string invalidFunctionName = 3;
  inline bool has_invalidfunctionname() const;
  inline void clear_invalidfunctionname();
  static const int kInvalidFunctionNameFieldNumber = 3;
  inline const ::std::string& invalidfunctionname() const;
  inline void set_invalidfunctionname(const ::std::string& value);
  inline void set_invalidfunctionname(const char* value);
  inline void set_invalidfunctionname(const char* value, size_t size);
  inline ::std::string* mutable_invalidfunctionname();
  inline ::std::string* release_invalidfunctionname();
  inline void set_allocated_invalidfunctionname(::std::string* invalidfunctionname);

  // @@protoc_insertion_point(class_scope:TST.FunctionNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_functionindex();
  inline void clear_has_functionindex();
  inline void set_has_invalidfunctionname();
  inline void clear_has_invalidfunctionname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::std::string* invalidfunctionname_;
  ::google::protobuf::uint32 functionindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FunctionNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class FunctionEndNodeArchive : public ::google::protobuf::Message {
 public:
  FunctionEndNodeArchive();
  virtual ~FunctionEndNodeArchive();

  FunctionEndNodeArchive(const FunctionEndNodeArchive& from);

  inline FunctionEndNodeArchive& operator=(const FunctionEndNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionEndNodeArchive& default_instance();

  void Swap(FunctionEndNodeArchive* other);

  // implements Message ----------------------------------------------

  FunctionEndNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionEndNodeArchive& from);
  void MergeFrom(const FunctionEndNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // @@protoc_insertion_point(class_scope:TST.FunctionEndNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FunctionEndNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class DateNodeArchive : public ::google::protobuf::Message {
 public:
  DateNodeArchive();
  virtual ~DateNodeArchive();

  DateNodeArchive(const DateNodeArchive& from);

  inline DateNodeArchive& operator=(const DateNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateNodeArchive& default_instance();

  void Swap(DateNodeArchive* other);

  // implements Message ----------------------------------------------

  DateNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateNodeArchive& from);
  void MergeFrom(const DateNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string format = 3;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 3;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // @@protoc_insertion_point(class_scope:TST.DateNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_format();
  inline void clear_has_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::std::string* value_;
  ::std::string* format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static DateNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceNodeArchive : public ::google::protobuf::Message {
 public:
  ReferenceNodeArchive();
  virtual ~ReferenceNodeArchive();

  ReferenceNodeArchive(const ReferenceNodeArchive& from);

  inline ReferenceNodeArchive& operator=(const ReferenceNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceNodeArchive& default_instance();

  void Swap(ReferenceNodeArchive* other);

  // implements Message ----------------------------------------------

  ReferenceNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceNodeArchive& from);
  void MergeFrom(const ReferenceNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required .TSCE.RangeReferenceArchive rangeReference = 2;
  inline bool has_rangereference() const;
  inline void clear_rangereference();
  static const int kRangeReferenceFieldNumber = 2;
  inline const ::TSCE::RangeReferenceArchive& rangereference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_rangereference();
  inline ::TSCE::RangeReferenceArchive* release_rangereference();
  inline void set_allocated_rangereference(::TSCE::RangeReferenceArchive* rangereference);

  // required uint32 stickyBits = 3;
  inline bool has_stickybits() const;
  inline void clear_stickybits();
  static const int kStickyBitsFieldNumber = 3;
  inline ::google::protobuf::uint32 stickybits() const;
  inline void set_stickybits(::google::protobuf::uint32 value);

  // optional string hostTableID = 4;
  inline bool has_hosttableid() const;
  inline void clear_hosttableid();
  static const int kHostTableIDFieldNumber = 4;
  inline const ::std::string& hosttableid() const;
  inline void set_hosttableid(const ::std::string& value);
  inline void set_hosttableid(const char* value);
  inline void set_hosttableid(const char* value, size_t size);
  inline ::std::string* mutable_hosttableid();
  inline ::std::string* release_hosttableid();
  inline void set_allocated_hosttableid(::std::string* hosttableid);

  // @@protoc_insertion_point(class_scope:TST.ReferenceNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_rangereference();
  inline void clear_has_rangereference();
  inline void set_has_stickybits();
  inline void clear_has_stickybits();
  inline void set_has_hosttableid();
  inline void clear_has_hosttableid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::TSCE::RangeReferenceArchive* rangereference_;
  ::std::string* hosttableid_;
  ::google::protobuf::uint32 stickybits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ReferenceNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class DurationNodeArchive : public ::google::protobuf::Message {
 public:
  DurationNodeArchive();
  virtual ~DurationNodeArchive();

  DurationNodeArchive(const DurationNodeArchive& from);

  inline DurationNodeArchive& operator=(const DurationNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationNodeArchive& default_instance();

  void Swap(DurationNodeArchive* other);

  // implements Message ----------------------------------------------

  DurationNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DurationNodeArchive& from);
  void MergeFrom(const DurationNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required double timeinterval = 2;
  inline bool has_timeinterval() const;
  inline void clear_timeinterval();
  static const int kTimeintervalFieldNumber = 2;
  inline double timeinterval() const;
  inline void set_timeinterval(double value);

  // required uint32 smallest = 3;
  inline bool has_smallest() const;
  inline void clear_smallest();
  static const int kSmallestFieldNumber = 3;
  inline ::google::protobuf::uint32 smallest() const;
  inline void set_smallest(::google::protobuf::uint32 value);

  // required uint32 largest = 4;
  inline bool has_largest() const;
  inline void clear_largest();
  static const int kLargestFieldNumber = 4;
  inline ::google::protobuf::uint32 largest() const;
  inline void set_largest(::google::protobuf::uint32 value);

  // required uint32 style = 5;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 5;
  inline ::google::protobuf::uint32 style() const;
  inline void set_style(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.DurationNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_timeinterval();
  inline void clear_has_timeinterval();
  inline void set_has_smallest();
  inline void clear_has_smallest();
  inline void set_has_largest();
  inline void clear_has_largest();
  inline void set_has_style();
  inline void clear_has_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  double timeinterval_;
  ::google::protobuf::uint32 smallest_;
  ::google::protobuf::uint32 largest_;
  ::google::protobuf::uint32 style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static DurationNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ArgumentPlaceholderNodeArchive : public ::google::protobuf::Message {
 public:
  ArgumentPlaceholderNodeArchive();
  virtual ~ArgumentPlaceholderNodeArchive();

  ArgumentPlaceholderNodeArchive(const ArgumentPlaceholderNodeArchive& from);

  inline ArgumentPlaceholderNodeArchive& operator=(const ArgumentPlaceholderNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArgumentPlaceholderNodeArchive& default_instance();

  void Swap(ArgumentPlaceholderNodeArchive* other);

  // implements Message ----------------------------------------------

  ArgumentPlaceholderNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArgumentPlaceholderNodeArchive& from);
  void MergeFrom(const ArgumentPlaceholderNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // required uint32 functionIndex = 2;
  inline bool has_functionindex() const;
  inline void clear_functionindex();
  static const int kFunctionIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 functionindex() const;
  inline void set_functionindex(::google::protobuf::uint32 value);

  // required uint32 argumentIndex = 3;
  inline bool has_argumentindex() const;
  inline void clear_argumentindex();
  static const int kArgumentIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 argumentindex() const;
  inline void set_argumentindex(::google::protobuf::uint32 value);

  // optional uint32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.ArgumentPlaceholderNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_functionindex();
  inline void clear_has_functionindex();
  inline void set_has_argumentindex();
  inline void clear_has_argumentindex();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;
  ::google::protobuf::uint32 functionindex_;
  ::google::protobuf::uint32 argumentindex_;
  ::google::protobuf::uint32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static ArgumentPlaceholderNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class EmptyExpressionNodeArchive : public ::google::protobuf::Message {
 public:
  EmptyExpressionNodeArchive();
  virtual ~EmptyExpressionNodeArchive();

  EmptyExpressionNodeArchive(const EmptyExpressionNodeArchive& from);

  inline EmptyExpressionNodeArchive& operator=(const EmptyExpressionNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyExpressionNodeArchive& default_instance();

  void Swap(EmptyExpressionNodeArchive* other);

  // implements Message ----------------------------------------------

  EmptyExpressionNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyExpressionNodeArchive& from);
  void MergeFrom(const EmptyExpressionNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.ExpressionNodeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::ExpressionNodeArchive& super() const;
  inline ::TST::ExpressionNodeArchive* mutable_super();
  inline ::TST::ExpressionNodeArchive* release_super();
  inline void set_allocated_super(::TST::ExpressionNodeArchive* super);

  // @@protoc_insertion_point(class_scope:TST.EmptyExpressionNodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::ExpressionNodeArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static EmptyExpressionNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class LayoutHintArchive : public ::google::protobuf::Message {
 public:
  LayoutHintArchive();
  virtual ~LayoutHintArchive();

  LayoutHintArchive(const LayoutHintArchive& from);

  inline LayoutHintArchive& operator=(const LayoutHintArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayoutHintArchive& default_instance();

  void Swap(LayoutHintArchive* other);

  // implements Message ----------------------------------------------

  LayoutHintArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayoutHintArchive& from);
  void MergeFrom(const LayoutHintArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isValid = 1;
  inline bool has_isvalid() const;
  inline void clear_isvalid();
  static const int kIsValidFieldNumber = 1;
  inline bool isvalid() const;
  inline void set_isvalid(bool value);

  // required .TST.CellRange cellRange = 2;
  inline bool has_cellrange() const;
  inline void clear_cellrange();
  static const int kCellRangeFieldNumber = 2;
  inline const ::TST::CellRange& cellrange() const;
  inline ::TST::CellRange* mutable_cellrange();
  inline ::TST::CellRange* release_cellrange();
  inline void set_allocated_cellrange(::TST::CellRange* cellrange);

  // required .TST.CellID hintID = 3;
  inline bool has_hintid() const;
  inline void clear_hintid();
  static const int kHintIDFieldNumber = 3;
  inline const ::TST::CellID& hintid() const;
  inline ::TST::CellID* mutable_hintid();
  inline ::TST::CellID* release_hintid();
  inline void set_allocated_hintid(::TST::CellID* hintid);

  // required .TSP.Size maximumSize = 4;
  inline bool has_maximumsize() const;
  inline void clear_maximumsize();
  static const int kMaximumSizeFieldNumber = 4;
  inline const ::TSP::Size& maximumsize() const;
  inline ::TSP::Size* mutable_maximumsize();
  inline ::TSP::Size* release_maximumsize();
  inline void set_allocated_maximumsize(::TSP::Size* maximumsize);

  // required uint32 partitionPosition = 5;
  inline bool has_partitionposition() const;
  inline void clear_partitionposition();
  static const int kPartitionPositionFieldNumber = 5;
  inline ::google::protobuf::uint32 partitionposition() const;
  inline void set_partitionposition(::google::protobuf::uint32 value);

  // required bool horizontal = 6;
  inline bool has_horizontal() const;
  inline void clear_horizontal();
  static const int kHorizontalFieldNumber = 6;
  inline bool horizontal() const;
  inline void set_horizontal(bool value);

  // optional .TSP.Size effectiveSize = 7;
  inline bool has_effectivesize() const;
  inline void clear_effectivesize();
  static const int kEffectiveSizeFieldNumber = 7;
  inline const ::TSP::Size& effectivesize() const;
  inline ::TSP::Size* mutable_effectivesize();
  inline ::TSP::Size* release_effectivesize();
  inline void set_allocated_effectivesize(::TSP::Size* effectivesize);

  // optional uint32 partitioningPass = 8;
  inline bool has_partitioningpass() const;
  inline void clear_partitioningpass();
  static const int kPartitioningPassFieldNumber = 8;
  inline ::google::protobuf::uint32 partitioningpass() const;
  inline void set_partitioningpass(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.LayoutHintArchive)
 private:
  inline void set_has_isvalid();
  inline void clear_has_isvalid();
  inline void set_has_cellrange();
  inline void clear_has_cellrange();
  inline void set_has_hintid();
  inline void clear_has_hintid();
  inline void set_has_maximumsize();
  inline void clear_has_maximumsize();
  inline void set_has_partitionposition();
  inline void clear_has_partitionposition();
  inline void set_has_horizontal();
  inline void clear_has_horizontal();
  inline void set_has_effectivesize();
  inline void clear_has_effectivesize();
  inline void set_has_partitioningpass();
  inline void clear_has_partitioningpass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellRange* cellrange_;
  ::TST::CellID* hintid_;
  ::TSP::Size* maximumsize_;
  bool isvalid_;
  bool horizontal_;
  ::google::protobuf::uint32 partitionposition_;
  ::TSP::Size* effectivesize_;
  ::google::protobuf::uint32 partitioningpass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static LayoutHintArchive* default_instance_;
};
// -------------------------------------------------------------------

class CompletionTokenAttachmentArchive : public ::google::protobuf::Message {
 public:
  CompletionTokenAttachmentArchive();
  virtual ~CompletionTokenAttachmentArchive();

  CompletionTokenAttachmentArchive(const CompletionTokenAttachmentArchive& from);

  inline CompletionTokenAttachmentArchive& operator=(const CompletionTokenAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompletionTokenAttachmentArchive& default_instance();

  void Swap(CompletionTokenAttachmentArchive* other);

  // implements Message ----------------------------------------------

  CompletionTokenAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompletionTokenAttachmentArchive& from);
  void MergeFrom(const CompletionTokenAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TokenAttachmentArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TokenAttachmentArchive& super() const;
  inline ::TST::TokenAttachmentArchive* mutable_super();
  inline ::TST::TokenAttachmentArchive* release_super();
  inline void set_allocated_super(::TST::TokenAttachmentArchive* super);

  // optional string completionText = 2;
  inline bool has_completiontext() const;
  inline void clear_completiontext();
  static const int kCompletionTextFieldNumber = 2;
  inline const ::std::string& completiontext() const;
  inline void set_completiontext(const ::std::string& value);
  inline void set_completiontext(const char* value);
  inline void set_completiontext(const char* value, size_t size);
  inline ::std::string* mutable_completiontext();
  inline ::std::string* release_completiontext();
  inline void set_allocated_completiontext(::std::string* completiontext);

  // optional uint32 caretPosition = 3;
  inline bool has_caretposition() const;
  inline void clear_caretposition();
  static const int kCaretPositionFieldNumber = 3;
  inline ::google::protobuf::uint32 caretposition() const;
  inline void set_caretposition(::google::protobuf::uint32 value);

  // optional uint32 prefixStart = 4;
  inline bool has_prefixstart() const;
  inline void clear_prefixstart();
  static const int kPrefixStartFieldNumber = 4;
  inline ::google::protobuf::uint32 prefixstart() const;
  inline void set_prefixstart(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CompletionTokenAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_completiontext();
  inline void clear_has_completiontext();
  inline void set_has_caretposition();
  inline void clear_has_caretposition();
  inline void set_has_prefixstart();
  inline void clear_has_prefixstart();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TokenAttachmentArchive* super_;
  ::std::string* completiontext_;
  ::google::protobuf::uint32 caretposition_;
  ::google::protobuf::uint32 prefixstart_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CompletionTokenAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class HiddenStateFormulaOwnerArchive : public ::google::protobuf::Message {
 public:
  HiddenStateFormulaOwnerArchive();
  virtual ~HiddenStateFormulaOwnerArchive();

  HiddenStateFormulaOwnerArchive(const HiddenStateFormulaOwnerArchive& from);

  inline HiddenStateFormulaOwnerArchive& operator=(const HiddenStateFormulaOwnerArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HiddenStateFormulaOwnerArchive& default_instance();

  void Swap(HiddenStateFormulaOwnerArchive* other);

  // implements Message ----------------------------------------------

  HiddenStateFormulaOwnerArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HiddenStateFormulaOwnerArchive& from);
  void MergeFrom(const HiddenStateFormulaOwnerArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSCE.CFUUIDArchive owner_id = 1;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& owner_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_owner_id();
  inline ::TSCE::CFUUIDArchive* release_owner_id();
  inline void set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id);

  // repeated .TSCE.CellValueArchive threshold_value = 2;
  inline int threshold_value_size() const;
  inline void clear_threshold_value();
  static const int kThresholdValueFieldNumber = 2;
  inline const ::TSCE::CellValueArchive& threshold_value(int index) const;
  inline ::TSCE::CellValueArchive* mutable_threshold_value(int index);
  inline ::TSCE::CellValueArchive* add_threshold_value();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >&
      threshold_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >*
      mutable_threshold_value();

  // optional bool needs_to_update_filter_set_for_import = 3 [default = false];
  inline bool has_needs_to_update_filter_set_for_import() const;
  inline void clear_needs_to_update_filter_set_for_import();
  static const int kNeedsToUpdateFilterSetForImportFieldNumber = 3;
  inline bool needs_to_update_filter_set_for_import() const;
  inline void set_needs_to_update_filter_set_for_import(bool value);

  // @@protoc_insertion_point(class_scope:TST.HiddenStateFormulaOwnerArchive)
 private:
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_needs_to_update_filter_set_for_import();
  inline void clear_has_needs_to_update_filter_set_for_import();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* owner_id_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive > threshold_value_;
  bool needs_to_update_filter_set_for_import_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static HiddenStateFormulaOwnerArchive* default_instance_;
};
// -------------------------------------------------------------------

class RichTextPayloadArchive : public ::google::protobuf::Message {
 public:
  RichTextPayloadArchive();
  virtual ~RichTextPayloadArchive();

  RichTextPayloadArchive(const RichTextPayloadArchive& from);

  inline RichTextPayloadArchive& operator=(const RichTextPayloadArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RichTextPayloadArchive& default_instance();

  void Swap(RichTextPayloadArchive* other);

  // implements Message ----------------------------------------------

  RichTextPayloadArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RichTextPayloadArchive& from);
  void MergeFrom(const RichTextPayloadArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference storage = 1;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 1;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSP.Range range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline const ::TSP::Range& range() const;
  inline ::TSP::Range* mutable_range();
  inline ::TSP::Range* release_range();
  inline void set_allocated_range(::TSP::Range* range);

  // required .TST.CellID cellid = 3;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellidFieldNumber = 3;
  inline const ::TST::CellID& cellid() const;
  inline ::TST::CellID* mutable_cellid();
  inline ::TST::CellID* release_cellid();
  inline void set_allocated_cellid(::TST::CellID* cellid);

  // @@protoc_insertion_point(class_scope:TST.RichTextPayloadArchive)
 private:
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_cellid();
  inline void clear_has_cellid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* storage_;
  ::TSP::Range* range_;
  ::TST::CellID* cellid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static RichTextPayloadArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaEqualsTokenAttachmentArchive : public ::google::protobuf::Message {
 public:
  FormulaEqualsTokenAttachmentArchive();
  virtual ~FormulaEqualsTokenAttachmentArchive();

  FormulaEqualsTokenAttachmentArchive(const FormulaEqualsTokenAttachmentArchive& from);

  inline FormulaEqualsTokenAttachmentArchive& operator=(const FormulaEqualsTokenAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaEqualsTokenAttachmentArchive& default_instance();

  void Swap(FormulaEqualsTokenAttachmentArchive* other);

  // implements Message ----------------------------------------------

  FormulaEqualsTokenAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaEqualsTokenAttachmentArchive& from);
  void MergeFrom(const FormulaEqualsTokenAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.UIGraphicalAttachment super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::UIGraphicalAttachment& super() const;
  inline ::TSWP::UIGraphicalAttachment* mutable_super();
  inline ::TSWP::UIGraphicalAttachment* release_super();
  inline void set_allocated_super(::TSWP::UIGraphicalAttachment* super);

  // @@protoc_insertion_point(class_scope:TST.FormulaEqualsTokenAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::UIGraphicalAttachment* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaEqualsTokenAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellRegion : public ::google::protobuf::Message {
 public:
  CellRegion();
  virtual ~CellRegion();

  CellRegion(const CellRegion& from);

  inline CellRegion& operator=(const CellRegion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellRegion& default_instance();

  void Swap(CellRegion* other);

  // implements Message ----------------------------------------------

  CellRegion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellRegion& from);
  void MergeFrom(const CellRegion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TST.CellRange cell_ranges = 1;
  inline int cell_ranges_size() const;
  inline void clear_cell_ranges();
  static const int kCellRangesFieldNumber = 1;
  inline const ::TST::CellRange& cell_ranges(int index) const;
  inline ::TST::CellRange* mutable_cell_ranges(int index);
  inline ::TST::CellRange* add_cell_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
      cell_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
      mutable_cell_ranges();

  // @@protoc_insertion_point(class_scope:TST.CellRegion)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TST::CellRange > cell_ranges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTArchives_2eproto();
  friend void protobuf_AssignDesc_TSTArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTArchives_2eproto();

  void InitAsDefaultInstance();
  static CellRegion* default_instance_;
};
// ===================================================================


// ===================================================================

// CellID

// required fixed32 packedData = 1;
inline bool CellID::has_packeddata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellID::set_has_packeddata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellID::clear_has_packeddata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellID::clear_packeddata() {
  packeddata_ = 0u;
  clear_has_packeddata();
}
inline ::google::protobuf::uint32 CellID::packeddata() const {
  return packeddata_;
}
inline void CellID::set_packeddata(::google::protobuf::uint32 value) {
  set_has_packeddata();
  packeddata_ = value;
}

// -------------------------------------------------------------------

// TableSize

// required fixed32 packedData = 1;
inline bool TableSize::has_packeddata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSize::set_has_packeddata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSize::clear_has_packeddata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSize::clear_packeddata() {
  packeddata_ = 0u;
  clear_has_packeddata();
}
inline ::google::protobuf::uint32 TableSize::packeddata() const {
  return packeddata_;
}
inline void TableSize::set_packeddata(::google::protobuf::uint32 value) {
  set_has_packeddata();
  packeddata_ = value;
}

// -------------------------------------------------------------------

// CellRange

// required .TST.CellID origin = 1;
inline bool CellRange::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellRange::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellRange::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellRange::clear_origin() {
  if (origin_ != NULL) origin_->::TST::CellID::Clear();
  clear_has_origin();
}
inline const ::TST::CellID& CellRange::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::TST::CellID* CellRange::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::TST::CellID;
  return origin_;
}
inline ::TST::CellID* CellRange::release_origin() {
  clear_has_origin();
  ::TST::CellID* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CellRange::set_allocated_origin(::TST::CellID* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// required .TST.TableSize size = 2;
inline bool CellRange::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellRange::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellRange::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellRange::clear_size() {
  if (size_ != NULL) size_->::TST::TableSize::Clear();
  clear_has_size();
}
inline const ::TST::TableSize& CellRange::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::TST::TableSize* CellRange::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::TST::TableSize;
  return size_;
}
inline ::TST::TableSize* CellRange::release_size() {
  clear_has_size();
  ::TST::TableSize* temp = size_;
  size_ = NULL;
  return temp;
}
inline void CellRange::set_allocated_size(::TST::TableSize* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// -------------------------------------------------------------------

// TableSelection

// required .TST.CellRange cellRange = 1;
inline bool TableSelection::has_cellrange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSelection::set_has_cellrange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSelection::clear_has_cellrange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSelection::clear_cellrange() {
  if (cellrange_ != NULL) cellrange_->::TST::CellRange::Clear();
  clear_has_cellrange();
}
inline const ::TST::CellRange& TableSelection::cellrange() const {
  return cellrange_ != NULL ? *cellrange_ : *default_instance_->cellrange_;
}
inline ::TST::CellRange* TableSelection::mutable_cellrange() {
  set_has_cellrange();
  if (cellrange_ == NULL) cellrange_ = new ::TST::CellRange;
  return cellrange_;
}
inline ::TST::CellRange* TableSelection::release_cellrange() {
  clear_has_cellrange();
  ::TST::CellRange* temp = cellrange_;
  cellrange_ = NULL;
  return temp;
}
inline void TableSelection::set_allocated_cellrange(::TST::CellRange* cellrange) {
  delete cellrange_;
  cellrange_ = cellrange;
  if (cellrange) {
    set_has_cellrange();
  } else {
    clear_has_cellrange();
  }
}

// required .TST.CellRange extendedCellRange = 2;
inline bool TableSelection::has_extendedcellrange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableSelection::set_has_extendedcellrange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableSelection::clear_has_extendedcellrange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableSelection::clear_extendedcellrange() {
  if (extendedcellrange_ != NULL) extendedcellrange_->::TST::CellRange::Clear();
  clear_has_extendedcellrange();
}
inline const ::TST::CellRange& TableSelection::extendedcellrange() const {
  return extendedcellrange_ != NULL ? *extendedcellrange_ : *default_instance_->extendedcellrange_;
}
inline ::TST::CellRange* TableSelection::mutable_extendedcellrange() {
  set_has_extendedcellrange();
  if (extendedcellrange_ == NULL) extendedcellrange_ = new ::TST::CellRange;
  return extendedcellrange_;
}
inline ::TST::CellRange* TableSelection::release_extendedcellrange() {
  clear_has_extendedcellrange();
  ::TST::CellRange* temp = extendedcellrange_;
  extendedcellrange_ = NULL;
  return temp;
}
inline void TableSelection::set_allocated_extendedcellrange(::TST::CellRange* extendedcellrange) {
  delete extendedcellrange_;
  extendedcellrange_ = extendedcellrange;
  if (extendedcellrange) {
    set_has_extendedcellrange();
  } else {
    clear_has_extendedcellrange();
  }
}

// required bool extendedCellRangeValid = 3;
inline bool TableSelection::has_extendedcellrangevalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableSelection::set_has_extendedcellrangevalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableSelection::clear_has_extendedcellrangevalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableSelection::clear_extendedcellrangevalid() {
  extendedcellrangevalid_ = false;
  clear_has_extendedcellrangevalid();
}
inline bool TableSelection::extendedcellrangevalid() const {
  return extendedcellrangevalid_;
}
inline void TableSelection::set_extendedcellrangevalid(bool value) {
  set_has_extendedcellrangevalid();
  extendedcellrangevalid_ = value;
}

// required .TST.SelectionTypeArchive selection_type = 4;
inline bool TableSelection::has_selection_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableSelection::set_has_selection_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableSelection::clear_has_selection_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableSelection::clear_selection_type() {
  selection_type_ = 0;
  clear_has_selection_type();
}
inline ::TST::SelectionTypeArchive TableSelection::selection_type() const {
  return static_cast< ::TST::SelectionTypeArchive >(selection_type_);
}
inline void TableSelection::set_selection_type(::TST::SelectionTypeArchive value) {
  assert(::TST::SelectionTypeArchive_IsValid(value));
  set_has_selection_type();
  selection_type_ = value;
}

// -------------------------------------------------------------------

// TileRowInfo

// optional uint32 storage_version = 5;
inline bool TileRowInfo::has_storage_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileRowInfo::set_has_storage_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileRowInfo::clear_has_storage_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileRowInfo::clear_storage_version() {
  storage_version_ = 0u;
  clear_has_storage_version();
}
inline ::google::protobuf::uint32 TileRowInfo::storage_version() const {
  return storage_version_;
}
inline void TileRowInfo::set_storage_version(::google::protobuf::uint32 value) {
  set_has_storage_version();
  storage_version_ = value;
}

// required uint32 tileRowIndex = 1;
inline bool TileRowInfo::has_tilerowindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileRowInfo::set_has_tilerowindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileRowInfo::clear_has_tilerowindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileRowInfo::clear_tilerowindex() {
  tilerowindex_ = 0u;
  clear_has_tilerowindex();
}
inline ::google::protobuf::uint32 TileRowInfo::tilerowindex() const {
  return tilerowindex_;
}
inline void TileRowInfo::set_tilerowindex(::google::protobuf::uint32 value) {
  set_has_tilerowindex();
  tilerowindex_ = value;
}

// required uint32 cellCount = 2;
inline bool TileRowInfo::has_cellcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TileRowInfo::set_has_cellcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TileRowInfo::clear_has_cellcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TileRowInfo::clear_cellcount() {
  cellcount_ = 0u;
  clear_has_cellcount();
}
inline ::google::protobuf::uint32 TileRowInfo::cellcount() const {
  return cellcount_;
}
inline void TileRowInfo::set_cellcount(::google::protobuf::uint32 value) {
  set_has_cellcount();
  cellcount_ = value;
}

// required bytes cellStorageBuffer = 3;
inline bool TileRowInfo::has_cellstoragebuffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TileRowInfo::set_has_cellstoragebuffer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TileRowInfo::clear_has_cellstoragebuffer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TileRowInfo::clear_cellstoragebuffer() {
  if (cellstoragebuffer_ != &::google::protobuf::internal::kEmptyString) {
    cellstoragebuffer_->clear();
  }
  clear_has_cellstoragebuffer();
}
inline const ::std::string& TileRowInfo::cellstoragebuffer() const {
  return *cellstoragebuffer_;
}
inline void TileRowInfo::set_cellstoragebuffer(const ::std::string& value) {
  set_has_cellstoragebuffer();
  if (cellstoragebuffer_ == &::google::protobuf::internal::kEmptyString) {
    cellstoragebuffer_ = new ::std::string;
  }
  cellstoragebuffer_->assign(value);
}
inline void TileRowInfo::set_cellstoragebuffer(const char* value) {
  set_has_cellstoragebuffer();
  if (cellstoragebuffer_ == &::google::protobuf::internal::kEmptyString) {
    cellstoragebuffer_ = new ::std::string;
  }
  cellstoragebuffer_->assign(value);
}
inline void TileRowInfo::set_cellstoragebuffer(const void* value, size_t size) {
  set_has_cellstoragebuffer();
  if (cellstoragebuffer_ == &::google::protobuf::internal::kEmptyString) {
    cellstoragebuffer_ = new ::std::string;
  }
  cellstoragebuffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TileRowInfo::mutable_cellstoragebuffer() {
  set_has_cellstoragebuffer();
  if (cellstoragebuffer_ == &::google::protobuf::internal::kEmptyString) {
    cellstoragebuffer_ = new ::std::string;
  }
  return cellstoragebuffer_;
}
inline ::std::string* TileRowInfo::release_cellstoragebuffer() {
  clear_has_cellstoragebuffer();
  if (cellstoragebuffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cellstoragebuffer_;
    cellstoragebuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TileRowInfo::set_allocated_cellstoragebuffer(::std::string* cellstoragebuffer) {
  if (cellstoragebuffer_ != &::google::protobuf::internal::kEmptyString) {
    delete cellstoragebuffer_;
  }
  if (cellstoragebuffer) {
    set_has_cellstoragebuffer();
    cellstoragebuffer_ = cellstoragebuffer;
  } else {
    clear_has_cellstoragebuffer();
    cellstoragebuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes cellOffsets = 4;
inline bool TileRowInfo::has_celloffsets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TileRowInfo::set_has_celloffsets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TileRowInfo::clear_has_celloffsets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TileRowInfo::clear_celloffsets() {
  if (celloffsets_ != &::google::protobuf::internal::kEmptyString) {
    celloffsets_->clear();
  }
  clear_has_celloffsets();
}
inline const ::std::string& TileRowInfo::celloffsets() const {
  return *celloffsets_;
}
inline void TileRowInfo::set_celloffsets(const ::std::string& value) {
  set_has_celloffsets();
  if (celloffsets_ == &::google::protobuf::internal::kEmptyString) {
    celloffsets_ = new ::std::string;
  }
  celloffsets_->assign(value);
}
inline void TileRowInfo::set_celloffsets(const char* value) {
  set_has_celloffsets();
  if (celloffsets_ == &::google::protobuf::internal::kEmptyString) {
    celloffsets_ = new ::std::string;
  }
  celloffsets_->assign(value);
}
inline void TileRowInfo::set_celloffsets(const void* value, size_t size) {
  set_has_celloffsets();
  if (celloffsets_ == &::google::protobuf::internal::kEmptyString) {
    celloffsets_ = new ::std::string;
  }
  celloffsets_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TileRowInfo::mutable_celloffsets() {
  set_has_celloffsets();
  if (celloffsets_ == &::google::protobuf::internal::kEmptyString) {
    celloffsets_ = new ::std::string;
  }
  return celloffsets_;
}
inline ::std::string* TileRowInfo::release_celloffsets() {
  clear_has_celloffsets();
  if (celloffsets_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = celloffsets_;
    celloffsets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TileRowInfo::set_allocated_celloffsets(::std::string* celloffsets) {
  if (celloffsets_ != &::google::protobuf::internal::kEmptyString) {
    delete celloffsets_;
  }
  if (celloffsets) {
    set_has_celloffsets();
    celloffsets_ = celloffsets;
  } else {
    clear_has_celloffsets();
    celloffsets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Tile

// required uint32 maxColumn = 1;
inline bool Tile::has_maxcolumn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tile::set_has_maxcolumn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tile::clear_has_maxcolumn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tile::clear_maxcolumn() {
  maxcolumn_ = 0u;
  clear_has_maxcolumn();
}
inline ::google::protobuf::uint32 Tile::maxcolumn() const {
  return maxcolumn_;
}
inline void Tile::set_maxcolumn(::google::protobuf::uint32 value) {
  set_has_maxcolumn();
  maxcolumn_ = value;
}

// required uint32 maxRow = 2;
inline bool Tile::has_maxrow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tile::set_has_maxrow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tile::clear_has_maxrow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tile::clear_maxrow() {
  maxrow_ = 0u;
  clear_has_maxrow();
}
inline ::google::protobuf::uint32 Tile::maxrow() const {
  return maxrow_;
}
inline void Tile::set_maxrow(::google::protobuf::uint32 value) {
  set_has_maxrow();
  maxrow_ = value;
}

// required uint32 numCells = 3;
inline bool Tile::has_numcells() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tile::set_has_numcells() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tile::clear_has_numcells() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tile::clear_numcells() {
  numcells_ = 0u;
  clear_has_numcells();
}
inline ::google::protobuf::uint32 Tile::numcells() const {
  return numcells_;
}
inline void Tile::set_numcells(::google::protobuf::uint32 value) {
  set_has_numcells();
  numcells_ = value;
}

// required uint32 numrows = 4;
inline bool Tile::has_numrows() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tile::set_has_numrows() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tile::clear_has_numrows() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Tile::clear_numrows() {
  numrows_ = 0u;
  clear_has_numrows();
}
inline ::google::protobuf::uint32 Tile::numrows() const {
  return numrows_;
}
inline void Tile::set_numrows(::google::protobuf::uint32 value) {
  set_has_numrows();
  numrows_ = value;
}

// optional uint32 storage_version = 6;
inline bool Tile::has_storage_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Tile::set_has_storage_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Tile::clear_has_storage_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Tile::clear_storage_version() {
  storage_version_ = 0u;
  clear_has_storage_version();
}
inline ::google::protobuf::uint32 Tile::storage_version() const {
  return storage_version_;
}
inline void Tile::set_storage_version(::google::protobuf::uint32 value) {
  set_has_storage_version();
  storage_version_ = value;
}

// repeated .TST.TileRowInfo rowInfos = 5;
inline int Tile::rowinfos_size() const {
  return rowinfos_.size();
}
inline void Tile::clear_rowinfos() {
  rowinfos_.Clear();
}
inline const ::TST::TileRowInfo& Tile::rowinfos(int index) const {
  return rowinfos_.Get(index);
}
inline ::TST::TileRowInfo* Tile::mutable_rowinfos(int index) {
  return rowinfos_.Mutable(index);
}
inline ::TST::TileRowInfo* Tile::add_rowinfos() {
  return rowinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::TileRowInfo >&
Tile::rowinfos() const {
  return rowinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::TileRowInfo >*
Tile::mutable_rowinfos() {
  return &rowinfos_;
}

// -------------------------------------------------------------------

// TileStorage_Tile

// required uint32 tileid = 1;
inline bool TileStorage_Tile::has_tileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileStorage_Tile::set_has_tileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileStorage_Tile::clear_has_tileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileStorage_Tile::clear_tileid() {
  tileid_ = 0u;
  clear_has_tileid();
}
inline ::google::protobuf::uint32 TileStorage_Tile::tileid() const {
  return tileid_;
}
inline void TileStorage_Tile::set_tileid(::google::protobuf::uint32 value) {
  set_has_tileid();
  tileid_ = value;
}

// required .TSP.Reference tile = 2;
inline bool TileStorage_Tile::has_tile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileStorage_Tile::set_has_tile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileStorage_Tile::clear_has_tile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileStorage_Tile::clear_tile() {
  if (tile_ != NULL) tile_->::TSP::Reference::Clear();
  clear_has_tile();
}
inline const ::TSP::Reference& TileStorage_Tile::tile() const {
  return tile_ != NULL ? *tile_ : *default_instance_->tile_;
}
inline ::TSP::Reference* TileStorage_Tile::mutable_tile() {
  set_has_tile();
  if (tile_ == NULL) tile_ = new ::TSP::Reference;
  return tile_;
}
inline ::TSP::Reference* TileStorage_Tile::release_tile() {
  clear_has_tile();
  ::TSP::Reference* temp = tile_;
  tile_ = NULL;
  return temp;
}
inline void TileStorage_Tile::set_allocated_tile(::TSP::Reference* tile) {
  delete tile_;
  tile_ = tile;
  if (tile) {
    set_has_tile();
  } else {
    clear_has_tile();
  }
}

// -------------------------------------------------------------------

// TileStorage

// repeated .TST.TileStorage.Tile tiles = 1;
inline int TileStorage::tiles_size() const {
  return tiles_.size();
}
inline void TileStorage::clear_tiles() {
  tiles_.Clear();
}
inline const ::TST::TileStorage_Tile& TileStorage::tiles(int index) const {
  return tiles_.Get(index);
}
inline ::TST::TileStorage_Tile* TileStorage::mutable_tiles(int index) {
  return tiles_.Mutable(index);
}
inline ::TST::TileStorage_Tile* TileStorage::add_tiles() {
  return tiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::TileStorage_Tile >&
TileStorage::tiles() const {
  return tiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::TileStorage_Tile >*
TileStorage::mutable_tiles() {
  return &tiles_;
}

// -------------------------------------------------------------------

// PopUpMenuModel_CellValue

// required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
inline bool PopUpMenuModel_CellValue::has_cell_value_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PopUpMenuModel_CellValue::set_has_cell_value_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PopUpMenuModel_CellValue::clear_has_cell_value_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PopUpMenuModel_CellValue::clear_cell_value_type() {
  cell_value_type_ = 1;
  clear_has_cell_value_type();
}
inline ::TST::PopUpMenuModel_CellValueType PopUpMenuModel_CellValue::cell_value_type() const {
  return static_cast< ::TST::PopUpMenuModel_CellValueType >(cell_value_type_);
}
inline void PopUpMenuModel_CellValue::set_cell_value_type(::TST::PopUpMenuModel_CellValueType value) {
  assert(::TST::PopUpMenuModel_CellValueType_IsValid(value));
  set_has_cell_value_type();
  cell_value_type_ = value;
}

// optional .TSCE.BooleanCellValueArchive boolean_value = 2;
inline bool PopUpMenuModel_CellValue::has_boolean_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PopUpMenuModel_CellValue::set_has_boolean_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PopUpMenuModel_CellValue::clear_has_boolean_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PopUpMenuModel_CellValue::clear_boolean_value() {
  if (boolean_value_ != NULL) boolean_value_->::TSCE::BooleanCellValueArchive::Clear();
  clear_has_boolean_value();
}
inline const ::TSCE::BooleanCellValueArchive& PopUpMenuModel_CellValue::boolean_value() const {
  return boolean_value_ != NULL ? *boolean_value_ : *default_instance_->boolean_value_;
}
inline ::TSCE::BooleanCellValueArchive* PopUpMenuModel_CellValue::mutable_boolean_value() {
  set_has_boolean_value();
  if (boolean_value_ == NULL) boolean_value_ = new ::TSCE::BooleanCellValueArchive;
  return boolean_value_;
}
inline ::TSCE::BooleanCellValueArchive* PopUpMenuModel_CellValue::release_boolean_value() {
  clear_has_boolean_value();
  ::TSCE::BooleanCellValueArchive* temp = boolean_value_;
  boolean_value_ = NULL;
  return temp;
}
inline void PopUpMenuModel_CellValue::set_allocated_boolean_value(::TSCE::BooleanCellValueArchive* boolean_value) {
  delete boolean_value_;
  boolean_value_ = boolean_value;
  if (boolean_value) {
    set_has_boolean_value();
  } else {
    clear_has_boolean_value();
  }
}

// optional .TSCE.DateCellValueArchive date_value = 3;
inline bool PopUpMenuModel_CellValue::has_date_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PopUpMenuModel_CellValue::set_has_date_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PopUpMenuModel_CellValue::clear_has_date_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PopUpMenuModel_CellValue::clear_date_value() {
  if (date_value_ != NULL) date_value_->::TSCE::DateCellValueArchive::Clear();
  clear_has_date_value();
}
inline const ::TSCE::DateCellValueArchive& PopUpMenuModel_CellValue::date_value() const {
  return date_value_ != NULL ? *date_value_ : *default_instance_->date_value_;
}
inline ::TSCE::DateCellValueArchive* PopUpMenuModel_CellValue::mutable_date_value() {
  set_has_date_value();
  if (date_value_ == NULL) date_value_ = new ::TSCE::DateCellValueArchive;
  return date_value_;
}
inline ::TSCE::DateCellValueArchive* PopUpMenuModel_CellValue::release_date_value() {
  clear_has_date_value();
  ::TSCE::DateCellValueArchive* temp = date_value_;
  date_value_ = NULL;
  return temp;
}
inline void PopUpMenuModel_CellValue::set_allocated_date_value(::TSCE::DateCellValueArchive* date_value) {
  delete date_value_;
  date_value_ = date_value;
  if (date_value) {
    set_has_date_value();
  } else {
    clear_has_date_value();
  }
}

// optional .TSCE.NumberCellValueArchive number_value = 4;
inline bool PopUpMenuModel_CellValue::has_number_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PopUpMenuModel_CellValue::set_has_number_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PopUpMenuModel_CellValue::clear_has_number_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PopUpMenuModel_CellValue::clear_number_value() {
  if (number_value_ != NULL) number_value_->::TSCE::NumberCellValueArchive::Clear();
  clear_has_number_value();
}
inline const ::TSCE::NumberCellValueArchive& PopUpMenuModel_CellValue::number_value() const {
  return number_value_ != NULL ? *number_value_ : *default_instance_->number_value_;
}
inline ::TSCE::NumberCellValueArchive* PopUpMenuModel_CellValue::mutable_number_value() {
  set_has_number_value();
  if (number_value_ == NULL) number_value_ = new ::TSCE::NumberCellValueArchive;
  return number_value_;
}
inline ::TSCE::NumberCellValueArchive* PopUpMenuModel_CellValue::release_number_value() {
  clear_has_number_value();
  ::TSCE::NumberCellValueArchive* temp = number_value_;
  number_value_ = NULL;
  return temp;
}
inline void PopUpMenuModel_CellValue::set_allocated_number_value(::TSCE::NumberCellValueArchive* number_value) {
  delete number_value_;
  number_value_ = number_value;
  if (number_value) {
    set_has_number_value();
  } else {
    clear_has_number_value();
  }
}

// optional .TSCE.StringCellValueArchive string_value = 5;
inline bool PopUpMenuModel_CellValue::has_string_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PopUpMenuModel_CellValue::set_has_string_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PopUpMenuModel_CellValue::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PopUpMenuModel_CellValue::clear_string_value() {
  if (string_value_ != NULL) string_value_->::TSCE::StringCellValueArchive::Clear();
  clear_has_string_value();
}
inline const ::TSCE::StringCellValueArchive& PopUpMenuModel_CellValue::string_value() const {
  return string_value_ != NULL ? *string_value_ : *default_instance_->string_value_;
}
inline ::TSCE::StringCellValueArchive* PopUpMenuModel_CellValue::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == NULL) string_value_ = new ::TSCE::StringCellValueArchive;
  return string_value_;
}
inline ::TSCE::StringCellValueArchive* PopUpMenuModel_CellValue::release_string_value() {
  clear_has_string_value();
  ::TSCE::StringCellValueArchive* temp = string_value_;
  string_value_ = NULL;
  return temp;
}
inline void PopUpMenuModel_CellValue::set_allocated_string_value(::TSCE::StringCellValueArchive* string_value) {
  delete string_value_;
  string_value_ = string_value;
  if (string_value) {
    set_has_string_value();
  } else {
    clear_has_string_value();
  }
}

// -------------------------------------------------------------------

// PopUpMenuModel

// repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
inline int PopUpMenuModel::item_size() const {
  return item_.size();
}
inline void PopUpMenuModel::clear_item() {
  item_.Clear();
}
inline const ::TST::PopUpMenuModel_CellValue& PopUpMenuModel::item(int index) const {
  return item_.Get(index);
}
inline ::TST::PopUpMenuModel_CellValue* PopUpMenuModel::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::TST::PopUpMenuModel_CellValue* PopUpMenuModel::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >&
PopUpMenuModel::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >*
PopUpMenuModel::mutable_item() {
  return &item_;
}

// repeated .TSCE.CellValueArchive tsce_item = 2;
inline int PopUpMenuModel::tsce_item_size() const {
  return tsce_item_.size();
}
inline void PopUpMenuModel::clear_tsce_item() {
  tsce_item_.Clear();
}
inline const ::TSCE::CellValueArchive& PopUpMenuModel::tsce_item(int index) const {
  return tsce_item_.Get(index);
}
inline ::TSCE::CellValueArchive* PopUpMenuModel::mutable_tsce_item(int index) {
  return tsce_item_.Mutable(index);
}
inline ::TSCE::CellValueArchive* PopUpMenuModel::add_tsce_item() {
  return tsce_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >&
PopUpMenuModel::tsce_item() const {
  return tsce_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >*
PopUpMenuModel::mutable_tsce_item() {
  return &tsce_item_;
}

// -------------------------------------------------------------------

// TableDataList_ListEntry

// required uint32 key = 1;
inline bool TableDataList_ListEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDataList_ListEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDataList_ListEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDataList_ListEntry::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 TableDataList_ListEntry::key() const {
  return key_;
}
inline void TableDataList_ListEntry::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// required uint32 refcount = 2;
inline bool TableDataList_ListEntry::has_refcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableDataList_ListEntry::set_has_refcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableDataList_ListEntry::clear_has_refcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableDataList_ListEntry::clear_refcount() {
  refcount_ = 0u;
  clear_has_refcount();
}
inline ::google::protobuf::uint32 TableDataList_ListEntry::refcount() const {
  return refcount_;
}
inline void TableDataList_ListEntry::set_refcount(::google::protobuf::uint32 value) {
  set_has_refcount();
  refcount_ = value;
}

// optional string string = 3;
inline bool TableDataList_ListEntry::has_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableDataList_ListEntry::set_has_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableDataList_ListEntry::clear_has_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableDataList_ListEntry::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& TableDataList_ListEntry::string() const {
  return *string_;
}
inline void TableDataList_ListEntry::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void TableDataList_ListEntry::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void TableDataList_ListEntry::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableDataList_ListEntry::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* TableDataList_ListEntry::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableDataList_ListEntry::set_allocated_string(::std::string* string) {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (string) {
    set_has_string();
    string_ = string;
  } else {
    clear_has_string();
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference reference = 4;
inline bool TableDataList_ListEntry::has_reference() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableDataList_ListEntry::set_has_reference() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableDataList_ListEntry::clear_has_reference() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableDataList_ListEntry::clear_reference() {
  if (reference_ != NULL) reference_->::TSP::Reference::Clear();
  clear_has_reference();
}
inline const ::TSP::Reference& TableDataList_ListEntry::reference() const {
  return reference_ != NULL ? *reference_ : *default_instance_->reference_;
}
inline ::TSP::Reference* TableDataList_ListEntry::mutable_reference() {
  set_has_reference();
  if (reference_ == NULL) reference_ = new ::TSP::Reference;
  return reference_;
}
inline ::TSP::Reference* TableDataList_ListEntry::release_reference() {
  clear_has_reference();
  ::TSP::Reference* temp = reference_;
  reference_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_reference(::TSP::Reference* reference) {
  delete reference_;
  reference_ = reference;
  if (reference) {
    set_has_reference();
  } else {
    clear_has_reference();
  }
}

// optional .TSCE.FormulaArchive formula = 5;
inline bool TableDataList_ListEntry::has_formula() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableDataList_ListEntry::set_has_formula() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableDataList_ListEntry::clear_has_formula() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableDataList_ListEntry::clear_formula() {
  if (formula_ != NULL) formula_->::TSCE::FormulaArchive::Clear();
  clear_has_formula();
}
inline const ::TSCE::FormulaArchive& TableDataList_ListEntry::formula() const {
  return formula_ != NULL ? *formula_ : *default_instance_->formula_;
}
inline ::TSCE::FormulaArchive* TableDataList_ListEntry::mutable_formula() {
  set_has_formula();
  if (formula_ == NULL) formula_ = new ::TSCE::FormulaArchive;
  return formula_;
}
inline ::TSCE::FormulaArchive* TableDataList_ListEntry::release_formula() {
  clear_has_formula();
  ::TSCE::FormulaArchive* temp = formula_;
  formula_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  delete formula_;
  formula_ = formula;
  if (formula) {
    set_has_formula();
  } else {
    clear_has_formula();
  }
}

// optional .TSK.FormatStructArchive format = 6;
inline bool TableDataList_ListEntry::has_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableDataList_ListEntry::set_has_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableDataList_ListEntry::clear_has_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableDataList_ListEntry::clear_format() {
  if (format_ != NULL) format_->::TSK::FormatStructArchive::Clear();
  clear_has_format();
}
inline const ::TSK::FormatStructArchive& TableDataList_ListEntry::format() const {
  return format_ != NULL ? *format_ : *default_instance_->format_;
}
inline ::TSK::FormatStructArchive* TableDataList_ListEntry::mutable_format() {
  set_has_format();
  if (format_ == NULL) format_ = new ::TSK::FormatStructArchive;
  return format_;
}
inline ::TSK::FormatStructArchive* TableDataList_ListEntry::release_format() {
  clear_has_format();
  ::TSK::FormatStructArchive* temp = format_;
  format_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_format(::TSK::FormatStructArchive* format) {
  delete format_;
  format_ = format;
  if (format) {
    set_has_format();
  } else {
    clear_has_format();
  }
}

// optional .TST.CellRange region = 7;
inline bool TableDataList_ListEntry::has_region() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TableDataList_ListEntry::set_has_region() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TableDataList_ListEntry::clear_has_region() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TableDataList_ListEntry::clear_region() {
  if (region_ != NULL) region_->::TST::CellRange::Clear();
  clear_has_region();
}
inline const ::TST::CellRange& TableDataList_ListEntry::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::TST::CellRange* TableDataList_ListEntry::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::TST::CellRange;
  return region_;
}
inline ::TST::CellRange* TableDataList_ListEntry::release_region() {
  clear_has_region();
  ::TST::CellRange* temp = region_;
  region_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_region(::TST::CellRange* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// optional .TSK.CustomFormatArchive custom_format = 8;
inline bool TableDataList_ListEntry::has_custom_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TableDataList_ListEntry::set_has_custom_format() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TableDataList_ListEntry::clear_has_custom_format() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TableDataList_ListEntry::clear_custom_format() {
  if (custom_format_ != NULL) custom_format_->::TSK::CustomFormatArchive::Clear();
  clear_has_custom_format();
}
inline const ::TSK::CustomFormatArchive& TableDataList_ListEntry::custom_format() const {
  return custom_format_ != NULL ? *custom_format_ : *default_instance_->custom_format_;
}
inline ::TSK::CustomFormatArchive* TableDataList_ListEntry::mutable_custom_format() {
  set_has_custom_format();
  if (custom_format_ == NULL) custom_format_ = new ::TSK::CustomFormatArchive;
  return custom_format_;
}
inline ::TSK::CustomFormatArchive* TableDataList_ListEntry::release_custom_format() {
  clear_has_custom_format();
  ::TSK::CustomFormatArchive* temp = custom_format_;
  custom_format_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_custom_format(::TSK::CustomFormatArchive* custom_format) {
  delete custom_format_;
  custom_format_ = custom_format;
  if (custom_format) {
    set_has_custom_format();
  } else {
    clear_has_custom_format();
  }
}

// optional .TSP.Reference richTextPayload = 9;
inline bool TableDataList_ListEntry::has_richtextpayload() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TableDataList_ListEntry::set_has_richtextpayload() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TableDataList_ListEntry::clear_has_richtextpayload() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TableDataList_ListEntry::clear_richtextpayload() {
  if (richtextpayload_ != NULL) richtextpayload_->::TSP::Reference::Clear();
  clear_has_richtextpayload();
}
inline const ::TSP::Reference& TableDataList_ListEntry::richtextpayload() const {
  return richtextpayload_ != NULL ? *richtextpayload_ : *default_instance_->richtextpayload_;
}
inline ::TSP::Reference* TableDataList_ListEntry::mutable_richtextpayload() {
  set_has_richtextpayload();
  if (richtextpayload_ == NULL) richtextpayload_ = new ::TSP::Reference;
  return richtextpayload_;
}
inline ::TSP::Reference* TableDataList_ListEntry::release_richtextpayload() {
  clear_has_richtextpayload();
  ::TSP::Reference* temp = richtextpayload_;
  richtextpayload_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_richtextpayload(::TSP::Reference* richtextpayload) {
  delete richtextpayload_;
  richtextpayload_ = richtextpayload;
  if (richtextpayload) {
    set_has_richtextpayload();
  } else {
    clear_has_richtextpayload();
  }
}

// optional .TSP.Reference comment_storage = 10;
inline bool TableDataList_ListEntry::has_comment_storage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TableDataList_ListEntry::set_has_comment_storage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TableDataList_ListEntry::clear_has_comment_storage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TableDataList_ListEntry::clear_comment_storage() {
  if (comment_storage_ != NULL) comment_storage_->::TSP::Reference::Clear();
  clear_has_comment_storage();
}
inline const ::TSP::Reference& TableDataList_ListEntry::comment_storage() const {
  return comment_storage_ != NULL ? *comment_storage_ : *default_instance_->comment_storage_;
}
inline ::TSP::Reference* TableDataList_ListEntry::mutable_comment_storage() {
  set_has_comment_storage();
  if (comment_storage_ == NULL) comment_storage_ = new ::TSP::Reference;
  return comment_storage_;
}
inline ::TSP::Reference* TableDataList_ListEntry::release_comment_storage() {
  clear_has_comment_storage();
  ::TSP::Reference* temp = comment_storage_;
  comment_storage_ = NULL;
  return temp;
}
inline void TableDataList_ListEntry::set_allocated_comment_storage(::TSP::Reference* comment_storage) {
  delete comment_storage_;
  comment_storage_ = comment_storage;
  if (comment_storage) {
    set_has_comment_storage();
  } else {
    clear_has_comment_storage();
  }
}

// -------------------------------------------------------------------

// TableDataList

// required .TST.TableDataList.ListType listType = 1;
inline bool TableDataList::has_listtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDataList::set_has_listtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDataList::clear_has_listtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDataList::clear_listtype() {
  listtype_ = 1;
  clear_has_listtype();
}
inline ::TST::TableDataList_ListType TableDataList::listtype() const {
  return static_cast< ::TST::TableDataList_ListType >(listtype_);
}
inline void TableDataList::set_listtype(::TST::TableDataList_ListType value) {
  assert(::TST::TableDataList_ListType_IsValid(value));
  set_has_listtype();
  listtype_ = value;
}

// required uint32 nextListID = 2;
inline bool TableDataList::has_nextlistid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableDataList::set_has_nextlistid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableDataList::clear_has_nextlistid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableDataList::clear_nextlistid() {
  nextlistid_ = 0u;
  clear_has_nextlistid();
}
inline ::google::protobuf::uint32 TableDataList::nextlistid() const {
  return nextlistid_;
}
inline void TableDataList::set_nextlistid(::google::protobuf::uint32 value) {
  set_has_nextlistid();
  nextlistid_ = value;
}

// repeated .TST.TableDataList.ListEntry entries = 3;
inline int TableDataList::entries_size() const {
  return entries_.size();
}
inline void TableDataList::clear_entries() {
  entries_.Clear();
}
inline const ::TST::TableDataList_ListEntry& TableDataList::entries(int index) const {
  return entries_.Get(index);
}
inline ::TST::TableDataList_ListEntry* TableDataList::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TST::TableDataList_ListEntry* TableDataList::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::TableDataList_ListEntry >&
TableDataList::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::TableDataList_ListEntry >*
TableDataList::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// TableRBTree_Node

// required uint32 key = 1;
inline bool TableRBTree_Node::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableRBTree_Node::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableRBTree_Node::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableRBTree_Node::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 TableRBTree_Node::key() const {
  return key_;
}
inline void TableRBTree_Node::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// required uint32 value = 2;
inline bool TableRBTree_Node::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableRBTree_Node::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableRBTree_Node::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableRBTree_Node::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TableRBTree_Node::value() const {
  return value_;
}
inline void TableRBTree_Node::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TableRBTree

// repeated .TST.TableRBTree.Node nodes = 1;
inline int TableRBTree::nodes_size() const {
  return nodes_.size();
}
inline void TableRBTree::clear_nodes() {
  nodes_.Clear();
}
inline const ::TST::TableRBTree_Node& TableRBTree::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::TST::TableRBTree_Node* TableRBTree::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::TST::TableRBTree_Node* TableRBTree::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::TableRBTree_Node >&
TableRBTree::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::TableRBTree_Node >*
TableRBTree::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// HeaderStorageBucket_Header

// required uint32 index = 1;
inline bool HeaderStorageBucket_Header::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeaderStorageBucket_Header::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeaderStorageBucket_Header::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeaderStorageBucket_Header::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 HeaderStorageBucket_Header::index() const {
  return index_;
}
inline void HeaderStorageBucket_Header::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required float size = 2;
inline bool HeaderStorageBucket_Header::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeaderStorageBucket_Header::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeaderStorageBucket_Header::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeaderStorageBucket_Header::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float HeaderStorageBucket_Header::size() const {
  return size_;
}
inline void HeaderStorageBucket_Header::set_size(float value) {
  set_has_size();
  size_ = value;
}

// required uint32 hidingState = 3;
inline bool HeaderStorageBucket_Header::has_hidingstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeaderStorageBucket_Header::set_has_hidingstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeaderStorageBucket_Header::clear_has_hidingstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeaderStorageBucket_Header::clear_hidingstate() {
  hidingstate_ = 0u;
  clear_has_hidingstate();
}
inline ::google::protobuf::uint32 HeaderStorageBucket_Header::hidingstate() const {
  return hidingstate_;
}
inline void HeaderStorageBucket_Header::set_hidingstate(::google::protobuf::uint32 value) {
  set_has_hidingstate();
  hidingstate_ = value;
}

// required uint32 numberOfCells = 4;
inline bool HeaderStorageBucket_Header::has_numberofcells() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeaderStorageBucket_Header::set_has_numberofcells() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeaderStorageBucket_Header::clear_has_numberofcells() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeaderStorageBucket_Header::clear_numberofcells() {
  numberofcells_ = 0u;
  clear_has_numberofcells();
}
inline ::google::protobuf::uint32 HeaderStorageBucket_Header::numberofcells() const {
  return numberofcells_;
}
inline void HeaderStorageBucket_Header::set_numberofcells(::google::protobuf::uint32 value) {
  set_has_numberofcells();
  numberofcells_ = value;
}

// optional .TSP.Reference cell_style = 5;
inline bool HeaderStorageBucket_Header::has_cell_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeaderStorageBucket_Header::set_has_cell_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeaderStorageBucket_Header::clear_has_cell_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeaderStorageBucket_Header::clear_cell_style() {
  if (cell_style_ != NULL) cell_style_->::TSP::Reference::Clear();
  clear_has_cell_style();
}
inline const ::TSP::Reference& HeaderStorageBucket_Header::cell_style() const {
  return cell_style_ != NULL ? *cell_style_ : *default_instance_->cell_style_;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::mutable_cell_style() {
  set_has_cell_style();
  if (cell_style_ == NULL) cell_style_ = new ::TSP::Reference;
  return cell_style_;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::release_cell_style() {
  clear_has_cell_style();
  ::TSP::Reference* temp = cell_style_;
  cell_style_ = NULL;
  return temp;
}
inline void HeaderStorageBucket_Header::set_allocated_cell_style(::TSP::Reference* cell_style) {
  delete cell_style_;
  cell_style_ = cell_style;
  if (cell_style) {
    set_has_cell_style();
  } else {
    clear_has_cell_style();
  }
}

// optional .TSP.Reference text_style = 6;
inline bool HeaderStorageBucket_Header::has_text_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeaderStorageBucket_Header::set_has_text_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeaderStorageBucket_Header::clear_has_text_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeaderStorageBucket_Header::clear_text_style() {
  if (text_style_ != NULL) text_style_->::TSP::Reference::Clear();
  clear_has_text_style();
}
inline const ::TSP::Reference& HeaderStorageBucket_Header::text_style() const {
  return text_style_ != NULL ? *text_style_ : *default_instance_->text_style_;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::mutable_text_style() {
  set_has_text_style();
  if (text_style_ == NULL) text_style_ = new ::TSP::Reference;
  return text_style_;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::release_text_style() {
  clear_has_text_style();
  ::TSP::Reference* temp = text_style_;
  text_style_ = NULL;
  return temp;
}
inline void HeaderStorageBucket_Header::set_allocated_text_style(::TSP::Reference* text_style) {
  delete text_style_;
  text_style_ = text_style;
  if (text_style) {
    set_has_text_style();
  } else {
    clear_has_text_style();
  }
}

// -------------------------------------------------------------------

// HeaderStorageBucket

// required uint32 bucketHashFunction = 1;
inline bool HeaderStorageBucket::has_buckethashfunction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeaderStorageBucket::set_has_buckethashfunction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeaderStorageBucket::clear_has_buckethashfunction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeaderStorageBucket::clear_buckethashfunction() {
  buckethashfunction_ = 0u;
  clear_has_buckethashfunction();
}
inline ::google::protobuf::uint32 HeaderStorageBucket::buckethashfunction() const {
  return buckethashfunction_;
}
inline void HeaderStorageBucket::set_buckethashfunction(::google::protobuf::uint32 value) {
  set_has_buckethashfunction();
  buckethashfunction_ = value;
}

// repeated .TST.HeaderStorageBucket.Header headers = 2;
inline int HeaderStorageBucket::headers_size() const {
  return headers_.size();
}
inline void HeaderStorageBucket::clear_headers() {
  headers_.Clear();
}
inline const ::TST::HeaderStorageBucket_Header& HeaderStorageBucket::headers(int index) const {
  return headers_.Get(index);
}
inline ::TST::HeaderStorageBucket_Header* HeaderStorageBucket::mutable_headers(int index) {
  return headers_.Mutable(index);
}
inline ::TST::HeaderStorageBucket_Header* HeaderStorageBucket::add_headers() {
  return headers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >&
HeaderStorageBucket::headers() const {
  return headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >*
HeaderStorageBucket::mutable_headers() {
  return &headers_;
}

// -------------------------------------------------------------------

// HeaderStorage

// required uint32 bucketHashFunction = 1;
inline bool HeaderStorage::has_buckethashfunction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeaderStorage::set_has_buckethashfunction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeaderStorage::clear_has_buckethashfunction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeaderStorage::clear_buckethashfunction() {
  buckethashfunction_ = 0u;
  clear_has_buckethashfunction();
}
inline ::google::protobuf::uint32 HeaderStorage::buckethashfunction() const {
  return buckethashfunction_;
}
inline void HeaderStorage::set_buckethashfunction(::google::protobuf::uint32 value) {
  set_has_buckethashfunction();
  buckethashfunction_ = value;
}

// repeated .TSP.Reference buckets = 2;
inline int HeaderStorage::buckets_size() const {
  return buckets_.size();
}
inline void HeaderStorage::clear_buckets() {
  buckets_.Clear();
}
inline const ::TSP::Reference& HeaderStorage::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::TSP::Reference* HeaderStorage::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline ::TSP::Reference* HeaderStorage::add_buckets() {
  return buckets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
HeaderStorage::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
HeaderStorage::mutable_buckets() {
  return &buckets_;
}

// -------------------------------------------------------------------

// DataStore

// required .TST.HeaderStorage rowHeaders = 1;
inline bool DataStore::has_rowheaders() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataStore::set_has_rowheaders() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataStore::clear_has_rowheaders() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataStore::clear_rowheaders() {
  if (rowheaders_ != NULL) rowheaders_->::TST::HeaderStorage::Clear();
  clear_has_rowheaders();
}
inline const ::TST::HeaderStorage& DataStore::rowheaders() const {
  return rowheaders_ != NULL ? *rowheaders_ : *default_instance_->rowheaders_;
}
inline ::TST::HeaderStorage* DataStore::mutable_rowheaders() {
  set_has_rowheaders();
  if (rowheaders_ == NULL) rowheaders_ = new ::TST::HeaderStorage;
  return rowheaders_;
}
inline ::TST::HeaderStorage* DataStore::release_rowheaders() {
  clear_has_rowheaders();
  ::TST::HeaderStorage* temp = rowheaders_;
  rowheaders_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_rowheaders(::TST::HeaderStorage* rowheaders) {
  delete rowheaders_;
  rowheaders_ = rowheaders;
  if (rowheaders) {
    set_has_rowheaders();
  } else {
    clear_has_rowheaders();
  }
}

// required .TSP.Reference columnHeaders = 2;
inline bool DataStore::has_columnheaders() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataStore::set_has_columnheaders() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataStore::clear_has_columnheaders() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataStore::clear_columnheaders() {
  if (columnheaders_ != NULL) columnheaders_->::TSP::Reference::Clear();
  clear_has_columnheaders();
}
inline const ::TSP::Reference& DataStore::columnheaders() const {
  return columnheaders_ != NULL ? *columnheaders_ : *default_instance_->columnheaders_;
}
inline ::TSP::Reference* DataStore::mutable_columnheaders() {
  set_has_columnheaders();
  if (columnheaders_ == NULL) columnheaders_ = new ::TSP::Reference;
  return columnheaders_;
}
inline ::TSP::Reference* DataStore::release_columnheaders() {
  clear_has_columnheaders();
  ::TSP::Reference* temp = columnheaders_;
  columnheaders_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_columnheaders(::TSP::Reference* columnheaders) {
  delete columnheaders_;
  columnheaders_ = columnheaders;
  if (columnheaders) {
    set_has_columnheaders();
  } else {
    clear_has_columnheaders();
  }
}

// required .TST.TileStorage tiles = 3;
inline bool DataStore::has_tiles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataStore::set_has_tiles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataStore::clear_has_tiles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataStore::clear_tiles() {
  if (tiles_ != NULL) tiles_->::TST::TileStorage::Clear();
  clear_has_tiles();
}
inline const ::TST::TileStorage& DataStore::tiles() const {
  return tiles_ != NULL ? *tiles_ : *default_instance_->tiles_;
}
inline ::TST::TileStorage* DataStore::mutable_tiles() {
  set_has_tiles();
  if (tiles_ == NULL) tiles_ = new ::TST::TileStorage;
  return tiles_;
}
inline ::TST::TileStorage* DataStore::release_tiles() {
  clear_has_tiles();
  ::TST::TileStorage* temp = tiles_;
  tiles_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_tiles(::TST::TileStorage* tiles) {
  delete tiles_;
  tiles_ = tiles;
  if (tiles) {
    set_has_tiles();
  } else {
    clear_has_tiles();
  }
}

// required .TSP.Reference stringTable = 4;
inline bool DataStore::has_stringtable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataStore::set_has_stringtable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataStore::clear_has_stringtable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataStore::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::TSP::Reference::Clear();
  clear_has_stringtable();
}
inline const ::TSP::Reference& DataStore::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::TSP::Reference* DataStore::mutable_stringtable() {
  set_has_stringtable();
  if (stringtable_ == NULL) stringtable_ = new ::TSP::Reference;
  return stringtable_;
}
inline ::TSP::Reference* DataStore::release_stringtable() {
  clear_has_stringtable();
  ::TSP::Reference* temp = stringtable_;
  stringtable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_stringtable(::TSP::Reference* stringtable) {
  delete stringtable_;
  stringtable_ = stringtable;
  if (stringtable) {
    set_has_stringtable();
  } else {
    clear_has_stringtable();
  }
}

// required .TSP.Reference styleTable = 5;
inline bool DataStore::has_styletable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataStore::set_has_styletable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataStore::clear_has_styletable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataStore::clear_styletable() {
  if (styletable_ != NULL) styletable_->::TSP::Reference::Clear();
  clear_has_styletable();
}
inline const ::TSP::Reference& DataStore::styletable() const {
  return styletable_ != NULL ? *styletable_ : *default_instance_->styletable_;
}
inline ::TSP::Reference* DataStore::mutable_styletable() {
  set_has_styletable();
  if (styletable_ == NULL) styletable_ = new ::TSP::Reference;
  return styletable_;
}
inline ::TSP::Reference* DataStore::release_styletable() {
  clear_has_styletable();
  ::TSP::Reference* temp = styletable_;
  styletable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_styletable(::TSP::Reference* styletable) {
  delete styletable_;
  styletable_ = styletable;
  if (styletable) {
    set_has_styletable();
  } else {
    clear_has_styletable();
  }
}

// required .TSP.Reference formulaTable = 6;
inline bool DataStore::has_formulatable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataStore::set_has_formulatable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataStore::clear_has_formulatable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataStore::clear_formulatable() {
  if (formulatable_ != NULL) formulatable_->::TSP::Reference::Clear();
  clear_has_formulatable();
}
inline const ::TSP::Reference& DataStore::formulatable() const {
  return formulatable_ != NULL ? *formulatable_ : *default_instance_->formulatable_;
}
inline ::TSP::Reference* DataStore::mutable_formulatable() {
  set_has_formulatable();
  if (formulatable_ == NULL) formulatable_ = new ::TSP::Reference;
  return formulatable_;
}
inline ::TSP::Reference* DataStore::release_formulatable() {
  clear_has_formulatable();
  ::TSP::Reference* temp = formulatable_;
  formulatable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_formulatable(::TSP::Reference* formulatable) {
  delete formulatable_;
  formulatable_ = formulatable;
  if (formulatable) {
    set_has_formulatable();
  } else {
    clear_has_formulatable();
  }
}

// optional .TSP.Reference formulaErrorTable = 12;
inline bool DataStore::has_formulaerrortable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataStore::set_has_formulaerrortable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataStore::clear_has_formulaerrortable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataStore::clear_formulaerrortable() {
  if (formulaerrortable_ != NULL) formulaerrortable_->::TSP::Reference::Clear();
  clear_has_formulaerrortable();
}
inline const ::TSP::Reference& DataStore::formulaerrortable() const {
  return formulaerrortable_ != NULL ? *formulaerrortable_ : *default_instance_->formulaerrortable_;
}
inline ::TSP::Reference* DataStore::mutable_formulaerrortable() {
  set_has_formulaerrortable();
  if (formulaerrortable_ == NULL) formulaerrortable_ = new ::TSP::Reference;
  return formulaerrortable_;
}
inline ::TSP::Reference* DataStore::release_formulaerrortable() {
  clear_has_formulaerrortable();
  ::TSP::Reference* temp = formulaerrortable_;
  formulaerrortable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_formulaerrortable(::TSP::Reference* formulaerrortable) {
  delete formulaerrortable_;
  formulaerrortable_ = formulaerrortable;
  if (formulaerrortable) {
    set_has_formulaerrortable();
  } else {
    clear_has_formulaerrortable();
  }
}

// required .TSP.Reference formatTable = 11;
inline bool DataStore::has_formattable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataStore::set_has_formattable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataStore::clear_has_formattable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataStore::clear_formattable() {
  if (formattable_ != NULL) formattable_->::TSP::Reference::Clear();
  clear_has_formattable();
}
inline const ::TSP::Reference& DataStore::formattable() const {
  return formattable_ != NULL ? *formattable_ : *default_instance_->formattable_;
}
inline ::TSP::Reference* DataStore::mutable_formattable() {
  set_has_formattable();
  if (formattable_ == NULL) formattable_ = new ::TSP::Reference;
  return formattable_;
}
inline ::TSP::Reference* DataStore::release_formattable() {
  clear_has_formattable();
  ::TSP::Reference* temp = formattable_;
  formattable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_formattable(::TSP::Reference* formattable) {
  delete formattable_;
  formattable_ = formattable;
  if (formattable) {
    set_has_formattable();
  } else {
    clear_has_formattable();
  }
}

// optional .TSP.Reference multipleChoiceListFormatTable = 16;
inline bool DataStore::has_multiplechoicelistformattable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataStore::set_has_multiplechoicelistformattable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataStore::clear_has_multiplechoicelistformattable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataStore::clear_multiplechoicelistformattable() {
  if (multiplechoicelistformattable_ != NULL) multiplechoicelistformattable_->::TSP::Reference::Clear();
  clear_has_multiplechoicelistformattable();
}
inline const ::TSP::Reference& DataStore::multiplechoicelistformattable() const {
  return multiplechoicelistformattable_ != NULL ? *multiplechoicelistformattable_ : *default_instance_->multiplechoicelistformattable_;
}
inline ::TSP::Reference* DataStore::mutable_multiplechoicelistformattable() {
  set_has_multiplechoicelistformattable();
  if (multiplechoicelistformattable_ == NULL) multiplechoicelistformattable_ = new ::TSP::Reference;
  return multiplechoicelistformattable_;
}
inline ::TSP::Reference* DataStore::release_multiplechoicelistformattable() {
  clear_has_multiplechoicelistformattable();
  ::TSP::Reference* temp = multiplechoicelistformattable_;
  multiplechoicelistformattable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_multiplechoicelistformattable(::TSP::Reference* multiplechoicelistformattable) {
  delete multiplechoicelistformattable_;
  multiplechoicelistformattable_ = multiplechoicelistformattable;
  if (multiplechoicelistformattable) {
    set_has_multiplechoicelistformattable();
  } else {
    clear_has_multiplechoicelistformattable();
  }
}

// optional .TSP.Reference merge_region_map = 13;
inline bool DataStore::has_merge_region_map() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataStore::set_has_merge_region_map() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataStore::clear_has_merge_region_map() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataStore::clear_merge_region_map() {
  if (merge_region_map_ != NULL) merge_region_map_->::TSP::Reference::Clear();
  clear_has_merge_region_map();
}
inline const ::TSP::Reference& DataStore::merge_region_map() const {
  return merge_region_map_ != NULL ? *merge_region_map_ : *default_instance_->merge_region_map_;
}
inline ::TSP::Reference* DataStore::mutable_merge_region_map() {
  set_has_merge_region_map();
  if (merge_region_map_ == NULL) merge_region_map_ = new ::TSP::Reference;
  return merge_region_map_;
}
inline ::TSP::Reference* DataStore::release_merge_region_map() {
  clear_has_merge_region_map();
  ::TSP::Reference* temp = merge_region_map_;
  merge_region_map_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_merge_region_map(::TSP::Reference* merge_region_map) {
  delete merge_region_map_;
  merge_region_map_ = merge_region_map;
  if (merge_region_map) {
    set_has_merge_region_map();
  } else {
    clear_has_merge_region_map();
  }
}

// optional .TSP.Reference customFormatTable = 15;
inline bool DataStore::has_customformattable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataStore::set_has_customformattable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataStore::clear_has_customformattable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataStore::clear_customformattable() {
  if (customformattable_ != NULL) customformattable_->::TSP::Reference::Clear();
  clear_has_customformattable();
}
inline const ::TSP::Reference& DataStore::customformattable() const {
  return customformattable_ != NULL ? *customformattable_ : *default_instance_->customformattable_;
}
inline ::TSP::Reference* DataStore::mutable_customformattable() {
  set_has_customformattable();
  if (customformattable_ == NULL) customformattable_ = new ::TSP::Reference;
  return customformattable_;
}
inline ::TSP::Reference* DataStore::release_customformattable() {
  clear_has_customformattable();
  ::TSP::Reference* temp = customformattable_;
  customformattable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_customformattable(::TSP::Reference* customformattable) {
  delete customformattable_;
  customformattable_ = customformattable;
  if (customformattable) {
    set_has_customformattable();
  } else {
    clear_has_customformattable();
  }
}

// required uint32 nextRowStripID = 7;
inline bool DataStore::has_nextrowstripid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataStore::set_has_nextrowstripid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataStore::clear_has_nextrowstripid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataStore::clear_nextrowstripid() {
  nextrowstripid_ = 0u;
  clear_has_nextrowstripid();
}
inline ::google::protobuf::uint32 DataStore::nextrowstripid() const {
  return nextrowstripid_;
}
inline void DataStore::set_nextrowstripid(::google::protobuf::uint32 value) {
  set_has_nextrowstripid();
  nextrowstripid_ = value;
}

// required uint32 nextColumnStripID = 8;
inline bool DataStore::has_nextcolumnstripid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataStore::set_has_nextcolumnstripid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataStore::clear_has_nextcolumnstripid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataStore::clear_nextcolumnstripid() {
  nextcolumnstripid_ = 0u;
  clear_has_nextcolumnstripid();
}
inline ::google::protobuf::uint32 DataStore::nextcolumnstripid() const {
  return nextcolumnstripid_;
}
inline void DataStore::set_nextcolumnstripid(::google::protobuf::uint32 value) {
  set_has_nextcolumnstripid();
  nextcolumnstripid_ = value;
}

// required .TST.TableRBTree rowTileTree = 9;
inline bool DataStore::has_rowtiletree() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataStore::set_has_rowtiletree() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataStore::clear_has_rowtiletree() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataStore::clear_rowtiletree() {
  if (rowtiletree_ != NULL) rowtiletree_->::TST::TableRBTree::Clear();
  clear_has_rowtiletree();
}
inline const ::TST::TableRBTree& DataStore::rowtiletree() const {
  return rowtiletree_ != NULL ? *rowtiletree_ : *default_instance_->rowtiletree_;
}
inline ::TST::TableRBTree* DataStore::mutable_rowtiletree() {
  set_has_rowtiletree();
  if (rowtiletree_ == NULL) rowtiletree_ = new ::TST::TableRBTree;
  return rowtiletree_;
}
inline ::TST::TableRBTree* DataStore::release_rowtiletree() {
  clear_has_rowtiletree();
  ::TST::TableRBTree* temp = rowtiletree_;
  rowtiletree_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_rowtiletree(::TST::TableRBTree* rowtiletree) {
  delete rowtiletree_;
  rowtiletree_ = rowtiletree;
  if (rowtiletree) {
    set_has_rowtiletree();
  } else {
    clear_has_rowtiletree();
  }
}

// required .TST.TableRBTree columnTileTree = 10;
inline bool DataStore::has_columntiletree() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataStore::set_has_columntiletree() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataStore::clear_has_columntiletree() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataStore::clear_columntiletree() {
  if (columntiletree_ != NULL) columntiletree_->::TST::TableRBTree::Clear();
  clear_has_columntiletree();
}
inline const ::TST::TableRBTree& DataStore::columntiletree() const {
  return columntiletree_ != NULL ? *columntiletree_ : *default_instance_->columntiletree_;
}
inline ::TST::TableRBTree* DataStore::mutable_columntiletree() {
  set_has_columntiletree();
  if (columntiletree_ == NULL) columntiletree_ = new ::TST::TableRBTree;
  return columntiletree_;
}
inline ::TST::TableRBTree* DataStore::release_columntiletree() {
  clear_has_columntiletree();
  ::TST::TableRBTree* temp = columntiletree_;
  columntiletree_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_columntiletree(::TST::TableRBTree* columntiletree) {
  delete columntiletree_;
  columntiletree_ = columntiletree;
  if (columntiletree) {
    set_has_columntiletree();
  } else {
    clear_has_columntiletree();
  }
}

// optional uint32 storage_version = 14;
inline bool DataStore::has_storage_version() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataStore::set_has_storage_version() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataStore::clear_has_storage_version() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataStore::clear_storage_version() {
  storage_version_ = 0u;
  clear_has_storage_version();
}
inline ::google::protobuf::uint32 DataStore::storage_version() const {
  return storage_version_;
}
inline void DataStore::set_storage_version(::google::protobuf::uint32 value) {
  set_has_storage_version();
  storage_version_ = value;
}

// optional .TSP.Reference richTextPayloadTable = 17;
inline bool DataStore::has_richtextpayloadtable() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataStore::set_has_richtextpayloadtable() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataStore::clear_has_richtextpayloadtable() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataStore::clear_richtextpayloadtable() {
  if (richtextpayloadtable_ != NULL) richtextpayloadtable_->::TSP::Reference::Clear();
  clear_has_richtextpayloadtable();
}
inline const ::TSP::Reference& DataStore::richtextpayloadtable() const {
  return richtextpayloadtable_ != NULL ? *richtextpayloadtable_ : *default_instance_->richtextpayloadtable_;
}
inline ::TSP::Reference* DataStore::mutable_richtextpayloadtable() {
  set_has_richtextpayloadtable();
  if (richtextpayloadtable_ == NULL) richtextpayloadtable_ = new ::TSP::Reference;
  return richtextpayloadtable_;
}
inline ::TSP::Reference* DataStore::release_richtextpayloadtable() {
  clear_has_richtextpayloadtable();
  ::TSP::Reference* temp = richtextpayloadtable_;
  richtextpayloadtable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_richtextpayloadtable(::TSP::Reference* richtextpayloadtable) {
  delete richtextpayloadtable_;
  richtextpayloadtable_ = richtextpayloadtable;
  if (richtextpayloadtable) {
    set_has_richtextpayloadtable();
  } else {
    clear_has_richtextpayloadtable();
  }
}

// optional .TSP.Reference conditionalstyletable = 18;
inline bool DataStore::has_conditionalstyletable() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DataStore::set_has_conditionalstyletable() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DataStore::clear_has_conditionalstyletable() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DataStore::clear_conditionalstyletable() {
  if (conditionalstyletable_ != NULL) conditionalstyletable_->::TSP::Reference::Clear();
  clear_has_conditionalstyletable();
}
inline const ::TSP::Reference& DataStore::conditionalstyletable() const {
  return conditionalstyletable_ != NULL ? *conditionalstyletable_ : *default_instance_->conditionalstyletable_;
}
inline ::TSP::Reference* DataStore::mutable_conditionalstyletable() {
  set_has_conditionalstyletable();
  if (conditionalstyletable_ == NULL) conditionalstyletable_ = new ::TSP::Reference;
  return conditionalstyletable_;
}
inline ::TSP::Reference* DataStore::release_conditionalstyletable() {
  clear_has_conditionalstyletable();
  ::TSP::Reference* temp = conditionalstyletable_;
  conditionalstyletable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_conditionalstyletable(::TSP::Reference* conditionalstyletable) {
  delete conditionalstyletable_;
  conditionalstyletable_ = conditionalstyletable;
  if (conditionalstyletable) {
    set_has_conditionalstyletable();
  } else {
    clear_has_conditionalstyletable();
  }
}

// optional .TSP.Reference commentStorageTable = 19;
inline bool DataStore::has_commentstoragetable() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DataStore::set_has_commentstoragetable() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DataStore::clear_has_commentstoragetable() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DataStore::clear_commentstoragetable() {
  if (commentstoragetable_ != NULL) commentstoragetable_->::TSP::Reference::Clear();
  clear_has_commentstoragetable();
}
inline const ::TSP::Reference& DataStore::commentstoragetable() const {
  return commentstoragetable_ != NULL ? *commentstoragetable_ : *default_instance_->commentstoragetable_;
}
inline ::TSP::Reference* DataStore::mutable_commentstoragetable() {
  set_has_commentstoragetable();
  if (commentstoragetable_ == NULL) commentstoragetable_ = new ::TSP::Reference;
  return commentstoragetable_;
}
inline ::TSP::Reference* DataStore::release_commentstoragetable() {
  clear_has_commentstoragetable();
  ::TSP::Reference* temp = commentstoragetable_;
  commentstoragetable_ = NULL;
  return temp;
}
inline void DataStore::set_allocated_commentstoragetable(::TSP::Reference* commentstoragetable) {
  delete commentstoragetable_;
  commentstoragetable_ = commentstoragetable;
  if (commentstoragetable) {
    set_has_commentstoragetable();
  } else {
    clear_has_commentstoragetable();
  }
}

// -------------------------------------------------------------------

// TableInfoArchive

// required .TSD.DrawableArchive super = 1;
inline bool TableInfoArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableInfoArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableInfoArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableInfoArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::DrawableArchive::Clear();
  clear_has_super();
}
inline const ::TSD::DrawableArchive& TableInfoArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::DrawableArchive* TableInfoArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::DrawableArchive;
  return super_;
}
inline ::TSD::DrawableArchive* TableInfoArchive::release_super() {
  clear_has_super();
  ::TSD::DrawableArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TableInfoArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference tableModel = 2;
inline bool TableInfoArchive::has_tablemodel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableInfoArchive::set_has_tablemodel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableInfoArchive::clear_has_tablemodel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableInfoArchive::clear_tablemodel() {
  if (tablemodel_ != NULL) tablemodel_->::TSP::Reference::Clear();
  clear_has_tablemodel();
}
inline const ::TSP::Reference& TableInfoArchive::tablemodel() const {
  return tablemodel_ != NULL ? *tablemodel_ : *default_instance_->tablemodel_;
}
inline ::TSP::Reference* TableInfoArchive::mutable_tablemodel() {
  set_has_tablemodel();
  if (tablemodel_ == NULL) tablemodel_ = new ::TSP::Reference;
  return tablemodel_;
}
inline ::TSP::Reference* TableInfoArchive::release_tablemodel() {
  clear_has_tablemodel();
  ::TSP::Reference* temp = tablemodel_;
  tablemodel_ = NULL;
  return temp;
}
inline void TableInfoArchive::set_allocated_tablemodel(::TSP::Reference* tablemodel) {
  delete tablemodel_;
  tablemodel_ = tablemodel;
  if (tablemodel) {
    set_has_tablemodel();
  } else {
    clear_has_tablemodel();
  }
}

// optional .TSP.Reference editingState = 3;
inline bool TableInfoArchive::has_editingstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableInfoArchive::set_has_editingstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableInfoArchive::clear_has_editingstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableInfoArchive::clear_editingstate() {
  if (editingstate_ != NULL) editingstate_->::TSP::Reference::Clear();
  clear_has_editingstate();
}
inline const ::TSP::Reference& TableInfoArchive::editingstate() const {
  return editingstate_ != NULL ? *editingstate_ : *default_instance_->editingstate_;
}
inline ::TSP::Reference* TableInfoArchive::mutable_editingstate() {
  set_has_editingstate();
  if (editingstate_ == NULL) editingstate_ = new ::TSP::Reference;
  return editingstate_;
}
inline ::TSP::Reference* TableInfoArchive::release_editingstate() {
  clear_has_editingstate();
  ::TSP::Reference* temp = editingstate_;
  editingstate_ = NULL;
  return temp;
}
inline void TableInfoArchive::set_allocated_editingstate(::TSP::Reference* editingstate) {
  delete editingstate_;
  editingstate_ = editingstate;
  if (editingstate) {
    set_has_editingstate();
  } else {
    clear_has_editingstate();
  }
}

// -------------------------------------------------------------------

// EditingStateArchive

// optional .TSP.Reference editingStorage = 1;
inline bool EditingStateArchive::has_editingstorage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EditingStateArchive::set_has_editingstorage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EditingStateArchive::clear_has_editingstorage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EditingStateArchive::clear_editingstorage() {
  if (editingstorage_ != NULL) editingstorage_->::TSP::Reference::Clear();
  clear_has_editingstorage();
}
inline const ::TSP::Reference& EditingStateArchive::editingstorage() const {
  return editingstorage_ != NULL ? *editingstorage_ : *default_instance_->editingstorage_;
}
inline ::TSP::Reference* EditingStateArchive::mutable_editingstorage() {
  set_has_editingstorage();
  if (editingstorage_ == NULL) editingstorage_ = new ::TSP::Reference;
  return editingstorage_;
}
inline ::TSP::Reference* EditingStateArchive::release_editingstorage() {
  clear_has_editingstorage();
  ::TSP::Reference* temp = editingstorage_;
  editingstorage_ = NULL;
  return temp;
}
inline void EditingStateArchive::set_allocated_editingstorage(::TSP::Reference* editingstorage) {
  delete editingstorage_;
  editingstorage_ = editingstorage;
  if (editingstorage) {
    set_has_editingstorage();
  } else {
    clear_has_editingstorage();
  }
}

// required .TST.Cell editingCell = 2;
inline bool EditingStateArchive::has_editingcell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditingStateArchive::set_has_editingcell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditingStateArchive::clear_has_editingcell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditingStateArchive::clear_editingcell() {
  if (editingcell_ != NULL) editingcell_->::TST::Cell::Clear();
  clear_has_editingcell();
}
inline const ::TST::Cell& EditingStateArchive::editingcell() const {
  return editingcell_ != NULL ? *editingcell_ : *default_instance_->editingcell_;
}
inline ::TST::Cell* EditingStateArchive::mutable_editingcell() {
  set_has_editingcell();
  if (editingcell_ == NULL) editingcell_ = new ::TST::Cell;
  return editingcell_;
}
inline ::TST::Cell* EditingStateArchive::release_editingcell() {
  clear_has_editingcell();
  ::TST::Cell* temp = editingcell_;
  editingcell_ = NULL;
  return temp;
}
inline void EditingStateArchive::set_allocated_editingcell(::TST::Cell* editingcell) {
  delete editingcell_;
  editingcell_ = editingcell;
  if (editingcell) {
    set_has_editingcell();
  } else {
    clear_has_editingcell();
  }
}

// optional .TST.SelectionArchive selection = 3;
inline bool EditingStateArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EditingStateArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EditingStateArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EditingStateArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& EditingStateArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* EditingStateArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* EditingStateArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void EditingStateArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// optional .TST.CellID lasteditingcellid = 4;
inline bool EditingStateArchive::has_lasteditingcellid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EditingStateArchive::set_has_lasteditingcellid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EditingStateArchive::clear_has_lasteditingcellid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EditingStateArchive::clear_lasteditingcellid() {
  if (lasteditingcellid_ != NULL) lasteditingcellid_->::TST::CellID::Clear();
  clear_has_lasteditingcellid();
}
inline const ::TST::CellID& EditingStateArchive::lasteditingcellid() const {
  return lasteditingcellid_ != NULL ? *lasteditingcellid_ : *default_instance_->lasteditingcellid_;
}
inline ::TST::CellID* EditingStateArchive::mutable_lasteditingcellid() {
  set_has_lasteditingcellid();
  if (lasteditingcellid_ == NULL) lasteditingcellid_ = new ::TST::CellID;
  return lasteditingcellid_;
}
inline ::TST::CellID* EditingStateArchive::release_lasteditingcellid() {
  clear_has_lasteditingcellid();
  ::TST::CellID* temp = lasteditingcellid_;
  lasteditingcellid_ = NULL;
  return temp;
}
inline void EditingStateArchive::set_allocated_lasteditingcellid(::TST::CellID* lasteditingcellid) {
  delete lasteditingcellid_;
  lasteditingcellid_ = lasteditingcellid;
  if (lasteditingcellid) {
    set_has_lasteditingcellid();
  } else {
    clear_has_lasteditingcellid();
  }
}

// optional .TST.CellID editingcellid = 5;
inline bool EditingStateArchive::has_editingcellid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EditingStateArchive::set_has_editingcellid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EditingStateArchive::clear_has_editingcellid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EditingStateArchive::clear_editingcellid() {
  if (editingcellid_ != NULL) editingcellid_->::TST::CellID::Clear();
  clear_has_editingcellid();
}
inline const ::TST::CellID& EditingStateArchive::editingcellid() const {
  return editingcellid_ != NULL ? *editingcellid_ : *default_instance_->editingcellid_;
}
inline ::TST::CellID* EditingStateArchive::mutable_editingcellid() {
  set_has_editingcellid();
  if (editingcellid_ == NULL) editingcellid_ = new ::TST::CellID;
  return editingcellid_;
}
inline ::TST::CellID* EditingStateArchive::release_editingcellid() {
  clear_has_editingcellid();
  ::TST::CellID* temp = editingcellid_;
  editingcellid_ = NULL;
  return temp;
}
inline void EditingStateArchive::set_allocated_editingcellid(::TST::CellID* editingcellid) {
  delete editingcellid_;
  editingcellid_ = editingcellid;
  if (editingcellid) {
    set_has_editingcellid();
  } else {
    clear_has_editingcellid();
  }
}

// optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
inline bool EditingStateArchive::has_deprecated_setup_textundoredotransaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EditingStateArchive::set_has_deprecated_setup_textundoredotransaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EditingStateArchive::clear_has_deprecated_setup_textundoredotransaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EditingStateArchive::clear_deprecated_setup_textundoredotransaction() {
  if (deprecated_setup_textundoredotransaction_ != NULL) deprecated_setup_textundoredotransaction_->::TSWP::UndoTransaction::Clear();
  clear_has_deprecated_setup_textundoredotransaction();
}
inline const ::TSWP::UndoTransaction& EditingStateArchive::deprecated_setup_textundoredotransaction() const {
  return deprecated_setup_textundoredotransaction_ != NULL ? *deprecated_setup_textundoredotransaction_ : *default_instance_->deprecated_setup_textundoredotransaction_;
}
inline ::TSWP::UndoTransaction* EditingStateArchive::mutable_deprecated_setup_textundoredotransaction() {
  set_has_deprecated_setup_textundoredotransaction();
  if (deprecated_setup_textundoredotransaction_ == NULL) deprecated_setup_textundoredotransaction_ = new ::TSWP::UndoTransaction;
  return deprecated_setup_textundoredotransaction_;
}
inline ::TSWP::UndoTransaction* EditingStateArchive::release_deprecated_setup_textundoredotransaction() {
  clear_has_deprecated_setup_textundoredotransaction();
  ::TSWP::UndoTransaction* temp = deprecated_setup_textundoredotransaction_;
  deprecated_setup_textundoredotransaction_ = NULL;
  return temp;
}
inline void EditingStateArchive::set_allocated_deprecated_setup_textundoredotransaction(::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction) {
  delete deprecated_setup_textundoredotransaction_;
  deprecated_setup_textundoredotransaction_ = deprecated_setup_textundoredotransaction;
  if (deprecated_setup_textundoredotransaction) {
    set_has_deprecated_setup_textundoredotransaction();
  } else {
    clear_has_deprecated_setup_textundoredotransaction();
  }
}

// optional bool cell_was_edited_in_current_session = 7;
inline bool EditingStateArchive::has_cell_was_edited_in_current_session() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EditingStateArchive::set_has_cell_was_edited_in_current_session() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EditingStateArchive::clear_has_cell_was_edited_in_current_session() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EditingStateArchive::clear_cell_was_edited_in_current_session() {
  cell_was_edited_in_current_session_ = false;
  clear_has_cell_was_edited_in_current_session();
}
inline bool EditingStateArchive::cell_was_edited_in_current_session() const {
  return cell_was_edited_in_current_session_;
}
inline void EditingStateArchive::set_cell_was_edited_in_current_session(bool value) {
  set_has_cell_was_edited_in_current_session();
  cell_was_edited_in_current_session_ = value;
}

// -------------------------------------------------------------------

// WPTableInfoArchive

// required .TST.TableInfoArchive super = 1;
inline bool WPTableInfoArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WPTableInfoArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WPTableInfoArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WPTableInfoArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableInfoArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableInfoArchive& WPTableInfoArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableInfoArchive* WPTableInfoArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableInfoArchive;
  return super_;
}
inline ::TST::TableInfoArchive* WPTableInfoArchive::release_super() {
  clear_has_super();
  ::TST::TableInfoArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void WPTableInfoArchive::set_allocated_super(::TST::TableInfoArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool WPTableInfoArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WPTableInfoArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WPTableInfoArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WPTableInfoArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& WPTableInfoArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* WPTableInfoArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* WPTableInfoArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void WPTableInfoArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// -------------------------------------------------------------------

// TableStyleNetworkArchive

// required .TSP.Reference table_style = 9;
inline bool TableStyleNetworkArchive::has_table_style() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableStyleNetworkArchive::set_has_table_style() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableStyleNetworkArchive::clear_has_table_style() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableStyleNetworkArchive::clear_table_style() {
  if (table_style_ != NULL) table_style_->::TSP::Reference::Clear();
  clear_has_table_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::table_style() const {
  return table_style_ != NULL ? *table_style_ : *default_instance_->table_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_table_style() {
  set_has_table_style();
  if (table_style_ == NULL) table_style_ = new ::TSP::Reference;
  return table_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_table_style() {
  clear_has_table_style();
  ::TSP::Reference* temp = table_style_;
  table_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_table_style(::TSP::Reference* table_style) {
  delete table_style_;
  table_style_ = table_style;
  if (table_style) {
    set_has_table_style();
  } else {
    clear_has_table_style();
  }
}

// required .TSP.Reference body_text_style = 1;
inline bool TableStyleNetworkArchive::has_body_text_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableStyleNetworkArchive::set_has_body_text_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableStyleNetworkArchive::clear_has_body_text_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableStyleNetworkArchive::clear_body_text_style() {
  if (body_text_style_ != NULL) body_text_style_->::TSP::Reference::Clear();
  clear_has_body_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::body_text_style() const {
  return body_text_style_ != NULL ? *body_text_style_ : *default_instance_->body_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_body_text_style() {
  set_has_body_text_style();
  if (body_text_style_ == NULL) body_text_style_ = new ::TSP::Reference;
  return body_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_body_text_style() {
  clear_has_body_text_style();
  ::TSP::Reference* temp = body_text_style_;
  body_text_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_body_text_style(::TSP::Reference* body_text_style) {
  delete body_text_style_;
  body_text_style_ = body_text_style;
  if (body_text_style) {
    set_has_body_text_style();
  } else {
    clear_has_body_text_style();
  }
}

// required .TSP.Reference header_row_text_style = 2;
inline bool TableStyleNetworkArchive::has_header_row_text_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableStyleNetworkArchive::set_has_header_row_text_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableStyleNetworkArchive::clear_has_header_row_text_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableStyleNetworkArchive::clear_header_row_text_style() {
  if (header_row_text_style_ != NULL) header_row_text_style_->::TSP::Reference::Clear();
  clear_has_header_row_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_row_text_style() const {
  return header_row_text_style_ != NULL ? *header_row_text_style_ : *default_instance_->header_row_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_row_text_style() {
  set_has_header_row_text_style();
  if (header_row_text_style_ == NULL) header_row_text_style_ = new ::TSP::Reference;
  return header_row_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_row_text_style() {
  clear_has_header_row_text_style();
  ::TSP::Reference* temp = header_row_text_style_;
  header_row_text_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style) {
  delete header_row_text_style_;
  header_row_text_style_ = header_row_text_style;
  if (header_row_text_style) {
    set_has_header_row_text_style();
  } else {
    clear_has_header_row_text_style();
  }
}

// required .TSP.Reference header_column_text_style = 3;
inline bool TableStyleNetworkArchive::has_header_column_text_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableStyleNetworkArchive::set_has_header_column_text_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableStyleNetworkArchive::clear_has_header_column_text_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableStyleNetworkArchive::clear_header_column_text_style() {
  if (header_column_text_style_ != NULL) header_column_text_style_->::TSP::Reference::Clear();
  clear_has_header_column_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_column_text_style() const {
  return header_column_text_style_ != NULL ? *header_column_text_style_ : *default_instance_->header_column_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_column_text_style() {
  set_has_header_column_text_style();
  if (header_column_text_style_ == NULL) header_column_text_style_ = new ::TSP::Reference;
  return header_column_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_column_text_style() {
  clear_has_header_column_text_style();
  ::TSP::Reference* temp = header_column_text_style_;
  header_column_text_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style) {
  delete header_column_text_style_;
  header_column_text_style_ = header_column_text_style;
  if (header_column_text_style) {
    set_has_header_column_text_style();
  } else {
    clear_has_header_column_text_style();
  }
}

// required .TSP.Reference footer_row_text_style = 4;
inline bool TableStyleNetworkArchive::has_footer_row_text_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableStyleNetworkArchive::set_has_footer_row_text_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableStyleNetworkArchive::clear_has_footer_row_text_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableStyleNetworkArchive::clear_footer_row_text_style() {
  if (footer_row_text_style_ != NULL) footer_row_text_style_->::TSP::Reference::Clear();
  clear_has_footer_row_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::footer_row_text_style() const {
  return footer_row_text_style_ != NULL ? *footer_row_text_style_ : *default_instance_->footer_row_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_footer_row_text_style() {
  set_has_footer_row_text_style();
  if (footer_row_text_style_ == NULL) footer_row_text_style_ = new ::TSP::Reference;
  return footer_row_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_footer_row_text_style() {
  clear_has_footer_row_text_style();
  ::TSP::Reference* temp = footer_row_text_style_;
  footer_row_text_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style) {
  delete footer_row_text_style_;
  footer_row_text_style_ = footer_row_text_style;
  if (footer_row_text_style) {
    set_has_footer_row_text_style();
  } else {
    clear_has_footer_row_text_style();
  }
}

// required .TSP.Reference body_cell_style = 5;
inline bool TableStyleNetworkArchive::has_body_cell_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableStyleNetworkArchive::set_has_body_cell_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableStyleNetworkArchive::clear_has_body_cell_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableStyleNetworkArchive::clear_body_cell_style() {
  if (body_cell_style_ != NULL) body_cell_style_->::TSP::Reference::Clear();
  clear_has_body_cell_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::body_cell_style() const {
  return body_cell_style_ != NULL ? *body_cell_style_ : *default_instance_->body_cell_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_body_cell_style() {
  set_has_body_cell_style();
  if (body_cell_style_ == NULL) body_cell_style_ = new ::TSP::Reference;
  return body_cell_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_body_cell_style() {
  clear_has_body_cell_style();
  ::TSP::Reference* temp = body_cell_style_;
  body_cell_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_body_cell_style(::TSP::Reference* body_cell_style) {
  delete body_cell_style_;
  body_cell_style_ = body_cell_style;
  if (body_cell_style) {
    set_has_body_cell_style();
  } else {
    clear_has_body_cell_style();
  }
}

// required .TSP.Reference header_row_style = 6;
inline bool TableStyleNetworkArchive::has_header_row_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TableStyleNetworkArchive::set_has_header_row_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TableStyleNetworkArchive::clear_has_header_row_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TableStyleNetworkArchive::clear_header_row_style() {
  if (header_row_style_ != NULL) header_row_style_->::TSP::Reference::Clear();
  clear_has_header_row_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_row_style() const {
  return header_row_style_ != NULL ? *header_row_style_ : *default_instance_->header_row_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_row_style() {
  set_has_header_row_style();
  if (header_row_style_ == NULL) header_row_style_ = new ::TSP::Reference;
  return header_row_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_row_style() {
  clear_has_header_row_style();
  ::TSP::Reference* temp = header_row_style_;
  header_row_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_header_row_style(::TSP::Reference* header_row_style) {
  delete header_row_style_;
  header_row_style_ = header_row_style;
  if (header_row_style) {
    set_has_header_row_style();
  } else {
    clear_has_header_row_style();
  }
}

// required .TSP.Reference header_column_style = 7;
inline bool TableStyleNetworkArchive::has_header_column_style() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TableStyleNetworkArchive::set_has_header_column_style() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TableStyleNetworkArchive::clear_has_header_column_style() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TableStyleNetworkArchive::clear_header_column_style() {
  if (header_column_style_ != NULL) header_column_style_->::TSP::Reference::Clear();
  clear_has_header_column_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_column_style() const {
  return header_column_style_ != NULL ? *header_column_style_ : *default_instance_->header_column_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_column_style() {
  set_has_header_column_style();
  if (header_column_style_ == NULL) header_column_style_ = new ::TSP::Reference;
  return header_column_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_column_style() {
  clear_has_header_column_style();
  ::TSP::Reference* temp = header_column_style_;
  header_column_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_header_column_style(::TSP::Reference* header_column_style) {
  delete header_column_style_;
  header_column_style_ = header_column_style;
  if (header_column_style) {
    set_has_header_column_style();
  } else {
    clear_has_header_column_style();
  }
}

// required .TSP.Reference footer_row_style = 8;
inline bool TableStyleNetworkArchive::has_footer_row_style() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TableStyleNetworkArchive::set_has_footer_row_style() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TableStyleNetworkArchive::clear_has_footer_row_style() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TableStyleNetworkArchive::clear_footer_row_style() {
  if (footer_row_style_ != NULL) footer_row_style_->::TSP::Reference::Clear();
  clear_has_footer_row_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::footer_row_style() const {
  return footer_row_style_ != NULL ? *footer_row_style_ : *default_instance_->footer_row_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_footer_row_style() {
  set_has_footer_row_style();
  if (footer_row_style_ == NULL) footer_row_style_ = new ::TSP::Reference;
  return footer_row_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_footer_row_style() {
  clear_has_footer_row_style();
  ::TSP::Reference* temp = footer_row_style_;
  footer_row_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_footer_row_style(::TSP::Reference* footer_row_style) {
  delete footer_row_style_;
  footer_row_style_ = footer_row_style;
  if (footer_row_style) {
    set_has_footer_row_style();
  } else {
    clear_has_footer_row_style();
  }
}

// optional .TSP.Reference table_name_style = 10;
inline bool TableStyleNetworkArchive::has_table_name_style() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TableStyleNetworkArchive::set_has_table_name_style() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TableStyleNetworkArchive::clear_has_table_name_style() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TableStyleNetworkArchive::clear_table_name_style() {
  if (table_name_style_ != NULL) table_name_style_->::TSP::Reference::Clear();
  clear_has_table_name_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::table_name_style() const {
  return table_name_style_ != NULL ? *table_name_style_ : *default_instance_->table_name_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_table_name_style() {
  set_has_table_name_style();
  if (table_name_style_ == NULL) table_name_style_ = new ::TSP::Reference;
  return table_name_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_table_name_style() {
  clear_has_table_name_style();
  ::TSP::Reference* temp = table_name_style_;
  table_name_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_table_name_style(::TSP::Reference* table_name_style) {
  delete table_name_style_;
  table_name_style_ = table_name_style;
  if (table_name_style) {
    set_has_table_name_style();
  } else {
    clear_has_table_name_style();
  }
}

// optional .TSP.Reference table_name_shape_style = 11;
inline bool TableStyleNetworkArchive::has_table_name_shape_style() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TableStyleNetworkArchive::set_has_table_name_shape_style() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TableStyleNetworkArchive::clear_has_table_name_shape_style() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TableStyleNetworkArchive::clear_table_name_shape_style() {
  if (table_name_shape_style_ != NULL) table_name_shape_style_->::TSP::Reference::Clear();
  clear_has_table_name_shape_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::table_name_shape_style() const {
  return table_name_shape_style_ != NULL ? *table_name_shape_style_ : *default_instance_->table_name_shape_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_table_name_shape_style() {
  set_has_table_name_shape_style();
  if (table_name_shape_style_ == NULL) table_name_shape_style_ = new ::TSP::Reference;
  return table_name_shape_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_table_name_shape_style() {
  clear_has_table_name_shape_style();
  ::TSP::Reference* temp = table_name_shape_style_;
  table_name_shape_style_ = NULL;
  return temp;
}
inline void TableStyleNetworkArchive::set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style) {
  delete table_name_shape_style_;
  table_name_shape_style_ = table_name_shape_style;
  if (table_name_shape_style) {
    set_has_table_name_shape_style();
  } else {
    clear_has_table_name_shape_style();
  }
}

// optional uint32 preset_index = 12;
inline bool TableStyleNetworkArchive::has_preset_index() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TableStyleNetworkArchive::set_has_preset_index() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TableStyleNetworkArchive::clear_has_preset_index() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TableStyleNetworkArchive::clear_preset_index() {
  preset_index_ = 0u;
  clear_has_preset_index();
}
inline ::google::protobuf::uint32 TableStyleNetworkArchive::preset_index() const {
  return preset_index_;
}
inline void TableStyleNetworkArchive::set_preset_index(::google::protobuf::uint32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// -------------------------------------------------------------------

// TableModelArchive

// required string table_id = 1;
inline bool TableModelArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableModelArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableModelArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableModelArchive::clear_table_id() {
  if (table_id_ != &::google::protobuf::internal::kEmptyString) {
    table_id_->clear();
  }
  clear_has_table_id();
}
inline const ::std::string& TableModelArchive::table_id() const {
  return *table_id_;
}
inline void TableModelArchive::set_table_id(const ::std::string& value) {
  set_has_table_id();
  if (table_id_ == &::google::protobuf::internal::kEmptyString) {
    table_id_ = new ::std::string;
  }
  table_id_->assign(value);
}
inline void TableModelArchive::set_table_id(const char* value) {
  set_has_table_id();
  if (table_id_ == &::google::protobuf::internal::kEmptyString) {
    table_id_ = new ::std::string;
  }
  table_id_->assign(value);
}
inline void TableModelArchive::set_table_id(const char* value, size_t size) {
  set_has_table_id();
  if (table_id_ == &::google::protobuf::internal::kEmptyString) {
    table_id_ = new ::std::string;
  }
  table_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableModelArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == &::google::protobuf::internal::kEmptyString) {
    table_id_ = new ::std::string;
  }
  return table_id_;
}
inline ::std::string* TableModelArchive::release_table_id() {
  clear_has_table_id();
  if (table_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_id_;
    table_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableModelArchive::set_allocated_table_id(::std::string* table_id) {
  if (table_id_ != &::google::protobuf::internal::kEmptyString) {
    delete table_id_;
  }
  if (table_id) {
    set_has_table_id();
    table_id_ = table_id;
  } else {
    clear_has_table_id();
    table_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string from_table_id = 43;
inline bool TableModelArchive::has_from_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableModelArchive::set_has_from_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableModelArchive::clear_has_from_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableModelArchive::clear_from_table_id() {
  if (from_table_id_ != &::google::protobuf::internal::kEmptyString) {
    from_table_id_->clear();
  }
  clear_has_from_table_id();
}
inline const ::std::string& TableModelArchive::from_table_id() const {
  return *from_table_id_;
}
inline void TableModelArchive::set_from_table_id(const ::std::string& value) {
  set_has_from_table_id();
  if (from_table_id_ == &::google::protobuf::internal::kEmptyString) {
    from_table_id_ = new ::std::string;
  }
  from_table_id_->assign(value);
}
inline void TableModelArchive::set_from_table_id(const char* value) {
  set_has_from_table_id();
  if (from_table_id_ == &::google::protobuf::internal::kEmptyString) {
    from_table_id_ = new ::std::string;
  }
  from_table_id_->assign(value);
}
inline void TableModelArchive::set_from_table_id(const char* value, size_t size) {
  set_has_from_table_id();
  if (from_table_id_ == &::google::protobuf::internal::kEmptyString) {
    from_table_id_ = new ::std::string;
  }
  from_table_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableModelArchive::mutable_from_table_id() {
  set_has_from_table_id();
  if (from_table_id_ == &::google::protobuf::internal::kEmptyString) {
    from_table_id_ = new ::std::string;
  }
  return from_table_id_;
}
inline ::std::string* TableModelArchive::release_from_table_id() {
  clear_has_from_table_id();
  if (from_table_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_table_id_;
    from_table_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableModelArchive::set_allocated_from_table_id(::std::string* from_table_id) {
  if (from_table_id_ != &::google::protobuf::internal::kEmptyString) {
    delete from_table_id_;
  }
  if (from_table_id) {
    set_has_from_table_id();
    from_table_id_ = from_table_id;
  } else {
    clear_has_from_table_id();
    from_table_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSP.Reference table_style = 3;
inline bool TableModelArchive::has_table_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableModelArchive::set_has_table_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableModelArchive::clear_has_table_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableModelArchive::clear_table_style() {
  if (table_style_ != NULL) table_style_->::TSP::Reference::Clear();
  clear_has_table_style();
}
inline const ::TSP::Reference& TableModelArchive::table_style() const {
  return table_style_ != NULL ? *table_style_ : *default_instance_->table_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_table_style() {
  set_has_table_style();
  if (table_style_ == NULL) table_style_ = new ::TSP::Reference;
  return table_style_;
}
inline ::TSP::Reference* TableModelArchive::release_table_style() {
  clear_has_table_style();
  ::TSP::Reference* temp = table_style_;
  table_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_table_style(::TSP::Reference* table_style) {
  delete table_style_;
  table_style_ = table_style;
  if (table_style) {
    set_has_table_style();
  } else {
    clear_has_table_style();
  }
}

// required .TSP.Reference body_text_style = 24;
inline bool TableModelArchive::has_body_text_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableModelArchive::set_has_body_text_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableModelArchive::clear_has_body_text_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableModelArchive::clear_body_text_style() {
  if (body_text_style_ != NULL) body_text_style_->::TSP::Reference::Clear();
  clear_has_body_text_style();
}
inline const ::TSP::Reference& TableModelArchive::body_text_style() const {
  return body_text_style_ != NULL ? *body_text_style_ : *default_instance_->body_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_body_text_style() {
  set_has_body_text_style();
  if (body_text_style_ == NULL) body_text_style_ = new ::TSP::Reference;
  return body_text_style_;
}
inline ::TSP::Reference* TableModelArchive::release_body_text_style() {
  clear_has_body_text_style();
  ::TSP::Reference* temp = body_text_style_;
  body_text_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_body_text_style(::TSP::Reference* body_text_style) {
  delete body_text_style_;
  body_text_style_ = body_text_style;
  if (body_text_style) {
    set_has_body_text_style();
  } else {
    clear_has_body_text_style();
  }
}

// required .TSP.Reference header_row_text_style = 25;
inline bool TableModelArchive::has_header_row_text_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableModelArchive::set_has_header_row_text_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableModelArchive::clear_has_header_row_text_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableModelArchive::clear_header_row_text_style() {
  if (header_row_text_style_ != NULL) header_row_text_style_->::TSP::Reference::Clear();
  clear_has_header_row_text_style();
}
inline const ::TSP::Reference& TableModelArchive::header_row_text_style() const {
  return header_row_text_style_ != NULL ? *header_row_text_style_ : *default_instance_->header_row_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_row_text_style() {
  set_has_header_row_text_style();
  if (header_row_text_style_ == NULL) header_row_text_style_ = new ::TSP::Reference;
  return header_row_text_style_;
}
inline ::TSP::Reference* TableModelArchive::release_header_row_text_style() {
  clear_has_header_row_text_style();
  ::TSP::Reference* temp = header_row_text_style_;
  header_row_text_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style) {
  delete header_row_text_style_;
  header_row_text_style_ = header_row_text_style;
  if (header_row_text_style) {
    set_has_header_row_text_style();
  } else {
    clear_has_header_row_text_style();
  }
}

// required .TSP.Reference header_column_text_style = 26;
inline bool TableModelArchive::has_header_column_text_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableModelArchive::set_has_header_column_text_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableModelArchive::clear_has_header_column_text_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableModelArchive::clear_header_column_text_style() {
  if (header_column_text_style_ != NULL) header_column_text_style_->::TSP::Reference::Clear();
  clear_has_header_column_text_style();
}
inline const ::TSP::Reference& TableModelArchive::header_column_text_style() const {
  return header_column_text_style_ != NULL ? *header_column_text_style_ : *default_instance_->header_column_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_column_text_style() {
  set_has_header_column_text_style();
  if (header_column_text_style_ == NULL) header_column_text_style_ = new ::TSP::Reference;
  return header_column_text_style_;
}
inline ::TSP::Reference* TableModelArchive::release_header_column_text_style() {
  clear_has_header_column_text_style();
  ::TSP::Reference* temp = header_column_text_style_;
  header_column_text_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style) {
  delete header_column_text_style_;
  header_column_text_style_ = header_column_text_style;
  if (header_column_text_style) {
    set_has_header_column_text_style();
  } else {
    clear_has_header_column_text_style();
  }
}

// required .TSP.Reference footer_row_text_style = 27;
inline bool TableModelArchive::has_footer_row_text_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TableModelArchive::set_has_footer_row_text_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TableModelArchive::clear_has_footer_row_text_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TableModelArchive::clear_footer_row_text_style() {
  if (footer_row_text_style_ != NULL) footer_row_text_style_->::TSP::Reference::Clear();
  clear_has_footer_row_text_style();
}
inline const ::TSP::Reference& TableModelArchive::footer_row_text_style() const {
  return footer_row_text_style_ != NULL ? *footer_row_text_style_ : *default_instance_->footer_row_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_footer_row_text_style() {
  set_has_footer_row_text_style();
  if (footer_row_text_style_ == NULL) footer_row_text_style_ = new ::TSP::Reference;
  return footer_row_text_style_;
}
inline ::TSP::Reference* TableModelArchive::release_footer_row_text_style() {
  clear_has_footer_row_text_style();
  ::TSP::Reference* temp = footer_row_text_style_;
  footer_row_text_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style) {
  delete footer_row_text_style_;
  footer_row_text_style_ = footer_row_text_style;
  if (footer_row_text_style) {
    set_has_footer_row_text_style();
  } else {
    clear_has_footer_row_text_style();
  }
}

// required .TSP.Reference body_cell_style = 18;
inline bool TableModelArchive::has_body_cell_style() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TableModelArchive::set_has_body_cell_style() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TableModelArchive::clear_has_body_cell_style() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TableModelArchive::clear_body_cell_style() {
  if (body_cell_style_ != NULL) body_cell_style_->::TSP::Reference::Clear();
  clear_has_body_cell_style();
}
inline const ::TSP::Reference& TableModelArchive::body_cell_style() const {
  return body_cell_style_ != NULL ? *body_cell_style_ : *default_instance_->body_cell_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_body_cell_style() {
  set_has_body_cell_style();
  if (body_cell_style_ == NULL) body_cell_style_ = new ::TSP::Reference;
  return body_cell_style_;
}
inline ::TSP::Reference* TableModelArchive::release_body_cell_style() {
  clear_has_body_cell_style();
  ::TSP::Reference* temp = body_cell_style_;
  body_cell_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_body_cell_style(::TSP::Reference* body_cell_style) {
  delete body_cell_style_;
  body_cell_style_ = body_cell_style;
  if (body_cell_style) {
    set_has_body_cell_style();
  } else {
    clear_has_body_cell_style();
  }
}

// required .TSP.Reference header_row_style = 19;
inline bool TableModelArchive::has_header_row_style() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TableModelArchive::set_has_header_row_style() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TableModelArchive::clear_has_header_row_style() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TableModelArchive::clear_header_row_style() {
  if (header_row_style_ != NULL) header_row_style_->::TSP::Reference::Clear();
  clear_has_header_row_style();
}
inline const ::TSP::Reference& TableModelArchive::header_row_style() const {
  return header_row_style_ != NULL ? *header_row_style_ : *default_instance_->header_row_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_row_style() {
  set_has_header_row_style();
  if (header_row_style_ == NULL) header_row_style_ = new ::TSP::Reference;
  return header_row_style_;
}
inline ::TSP::Reference* TableModelArchive::release_header_row_style() {
  clear_has_header_row_style();
  ::TSP::Reference* temp = header_row_style_;
  header_row_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_header_row_style(::TSP::Reference* header_row_style) {
  delete header_row_style_;
  header_row_style_ = header_row_style;
  if (header_row_style) {
    set_has_header_row_style();
  } else {
    clear_has_header_row_style();
  }
}

// required .TSP.Reference header_column_style = 20;
inline bool TableModelArchive::has_header_column_style() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TableModelArchive::set_has_header_column_style() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TableModelArchive::clear_has_header_column_style() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TableModelArchive::clear_header_column_style() {
  if (header_column_style_ != NULL) header_column_style_->::TSP::Reference::Clear();
  clear_has_header_column_style();
}
inline const ::TSP::Reference& TableModelArchive::header_column_style() const {
  return header_column_style_ != NULL ? *header_column_style_ : *default_instance_->header_column_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_column_style() {
  set_has_header_column_style();
  if (header_column_style_ == NULL) header_column_style_ = new ::TSP::Reference;
  return header_column_style_;
}
inline ::TSP::Reference* TableModelArchive::release_header_column_style() {
  clear_has_header_column_style();
  ::TSP::Reference* temp = header_column_style_;
  header_column_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_header_column_style(::TSP::Reference* header_column_style) {
  delete header_column_style_;
  header_column_style_ = header_column_style;
  if (header_column_style) {
    set_has_header_column_style();
  } else {
    clear_has_header_column_style();
  }
}

// required .TSP.Reference footer_row_style = 21;
inline bool TableModelArchive::has_footer_row_style() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TableModelArchive::set_has_footer_row_style() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TableModelArchive::clear_has_footer_row_style() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TableModelArchive::clear_footer_row_style() {
  if (footer_row_style_ != NULL) footer_row_style_->::TSP::Reference::Clear();
  clear_has_footer_row_style();
}
inline const ::TSP::Reference& TableModelArchive::footer_row_style() const {
  return footer_row_style_ != NULL ? *footer_row_style_ : *default_instance_->footer_row_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_footer_row_style() {
  set_has_footer_row_style();
  if (footer_row_style_ == NULL) footer_row_style_ = new ::TSP::Reference;
  return footer_row_style_;
}
inline ::TSP::Reference* TableModelArchive::release_footer_row_style() {
  clear_has_footer_row_style();
  ::TSP::Reference* temp = footer_row_style_;
  footer_row_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_footer_row_style(::TSP::Reference* footer_row_style) {
  delete footer_row_style_;
  footer_row_style_ = footer_row_style;
  if (footer_row_style) {
    set_has_footer_row_style();
  } else {
    clear_has_footer_row_style();
  }
}

// optional .TSP.Reference table_name_style = 30;
inline bool TableModelArchive::has_table_name_style() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TableModelArchive::set_has_table_name_style() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TableModelArchive::clear_has_table_name_style() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TableModelArchive::clear_table_name_style() {
  if (table_name_style_ != NULL) table_name_style_->::TSP::Reference::Clear();
  clear_has_table_name_style();
}
inline const ::TSP::Reference& TableModelArchive::table_name_style() const {
  return table_name_style_ != NULL ? *table_name_style_ : *default_instance_->table_name_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_table_name_style() {
  set_has_table_name_style();
  if (table_name_style_ == NULL) table_name_style_ = new ::TSP::Reference;
  return table_name_style_;
}
inline ::TSP::Reference* TableModelArchive::release_table_name_style() {
  clear_has_table_name_style();
  ::TSP::Reference* temp = table_name_style_;
  table_name_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_table_name_style(::TSP::Reference* table_name_style) {
  delete table_name_style_;
  table_name_style_ = table_name_style;
  if (table_name_style) {
    set_has_table_name_style();
  } else {
    clear_has_table_name_style();
  }
}

// optional .TSP.Reference table_name_shape_style = 36;
inline bool TableModelArchive::has_table_name_shape_style() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TableModelArchive::set_has_table_name_shape_style() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TableModelArchive::clear_has_table_name_shape_style() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TableModelArchive::clear_table_name_shape_style() {
  if (table_name_shape_style_ != NULL) table_name_shape_style_->::TSP::Reference::Clear();
  clear_has_table_name_shape_style();
}
inline const ::TSP::Reference& TableModelArchive::table_name_shape_style() const {
  return table_name_shape_style_ != NULL ? *table_name_shape_style_ : *default_instance_->table_name_shape_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_table_name_shape_style() {
  set_has_table_name_shape_style();
  if (table_name_shape_style_ == NULL) table_name_shape_style_ = new ::TSP::Reference;
  return table_name_shape_style_;
}
inline ::TSP::Reference* TableModelArchive::release_table_name_shape_style() {
  clear_has_table_name_shape_style();
  ::TSP::Reference* temp = table_name_shape_style_;
  table_name_shape_style_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style) {
  delete table_name_shape_style_;
  table_name_shape_style_ = table_name_shape_style;
  if (table_name_shape_style) {
    set_has_table_name_shape_style();
  } else {
    clear_has_table_name_shape_style();
  }
}

// required .TST.DataStore data_store = 4;
inline bool TableModelArchive::has_data_store() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TableModelArchive::set_has_data_store() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TableModelArchive::clear_has_data_store() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TableModelArchive::clear_data_store() {
  if (data_store_ != NULL) data_store_->::TST::DataStore::Clear();
  clear_has_data_store();
}
inline const ::TST::DataStore& TableModelArchive::data_store() const {
  return data_store_ != NULL ? *data_store_ : *default_instance_->data_store_;
}
inline ::TST::DataStore* TableModelArchive::mutable_data_store() {
  set_has_data_store();
  if (data_store_ == NULL) data_store_ = new ::TST::DataStore;
  return data_store_;
}
inline ::TST::DataStore* TableModelArchive::release_data_store() {
  clear_has_data_store();
  ::TST::DataStore* temp = data_store_;
  data_store_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_data_store(::TST::DataStore* data_store) {
  delete data_store_;
  data_store_ = data_store;
  if (data_store) {
    set_has_data_store();
  } else {
    clear_has_data_store();
  }
}

// optional .TSP.Reference provider = 5;
inline bool TableModelArchive::has_provider() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TableModelArchive::set_has_provider() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TableModelArchive::clear_has_provider() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TableModelArchive::clear_provider() {
  if (provider_ != NULL) provider_->::TSP::Reference::Clear();
  clear_has_provider();
}
inline const ::TSP::Reference& TableModelArchive::provider() const {
  return provider_ != NULL ? *provider_ : *default_instance_->provider_;
}
inline ::TSP::Reference* TableModelArchive::mutable_provider() {
  set_has_provider();
  if (provider_ == NULL) provider_ = new ::TSP::Reference;
  return provider_;
}
inline ::TSP::Reference* TableModelArchive::release_provider() {
  clear_has_provider();
  ::TSP::Reference* temp = provider_;
  provider_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_provider(::TSP::Reference* provider) {
  delete provider_;
  provider_ = provider;
  if (provider) {
    set_has_provider();
  } else {
    clear_has_provider();
  }
}

// required uint32 number_of_rows = 6;
inline bool TableModelArchive::has_number_of_rows() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TableModelArchive::set_has_number_of_rows() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TableModelArchive::clear_has_number_of_rows() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TableModelArchive::clear_number_of_rows() {
  number_of_rows_ = 0u;
  clear_has_number_of_rows();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_rows() const {
  return number_of_rows_;
}
inline void TableModelArchive::set_number_of_rows(::google::protobuf::uint32 value) {
  set_has_number_of_rows();
  number_of_rows_ = value;
}

// required uint32 number_of_columns = 7;
inline bool TableModelArchive::has_number_of_columns() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TableModelArchive::set_has_number_of_columns() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TableModelArchive::clear_has_number_of_columns() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TableModelArchive::clear_number_of_columns() {
  number_of_columns_ = 0u;
  clear_has_number_of_columns();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_columns() const {
  return number_of_columns_;
}
inline void TableModelArchive::set_number_of_columns(::google::protobuf::uint32 value) {
  set_has_number_of_columns();
  number_of_columns_ = value;
}

// required string table_name = 8;
inline bool TableModelArchive::has_table_name() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TableModelArchive::set_has_table_name() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TableModelArchive::clear_has_table_name() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TableModelArchive::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& TableModelArchive::table_name() const {
  return *table_name_;
}
inline void TableModelArchive::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void TableModelArchive::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void TableModelArchive::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableModelArchive::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* TableModelArchive::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableModelArchive::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool table_name_enabled = 22;
inline bool TableModelArchive::has_table_name_enabled() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TableModelArchive::set_has_table_name_enabled() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TableModelArchive::clear_has_table_name_enabled() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TableModelArchive::clear_table_name_enabled() {
  table_name_enabled_ = false;
  clear_has_table_name_enabled();
}
inline bool TableModelArchive::table_name_enabled() const {
  return table_name_enabled_;
}
inline void TableModelArchive::set_table_name_enabled(bool value) {
  set_has_table_name_enabled();
  table_name_enabled_ = value;
}

// optional double table_name_height = 33;
inline bool TableModelArchive::has_table_name_height() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TableModelArchive::set_has_table_name_height() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TableModelArchive::clear_has_table_name_height() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TableModelArchive::clear_table_name_height() {
  table_name_height_ = 0;
  clear_has_table_name_height();
}
inline double TableModelArchive::table_name_height() const {
  return table_name_height_;
}
inline void TableModelArchive::set_table_name_height(double value) {
  set_has_table_name_height();
  table_name_height_ = value;
}

// optional bool table_name_border_enabled = 37;
inline bool TableModelArchive::has_table_name_border_enabled() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TableModelArchive::set_has_table_name_border_enabled() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TableModelArchive::clear_has_table_name_border_enabled() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TableModelArchive::clear_table_name_border_enabled() {
  table_name_border_enabled_ = false;
  clear_has_table_name_border_enabled();
}
inline bool TableModelArchive::table_name_border_enabled() const {
  return table_name_border_enabled_;
}
inline void TableModelArchive::set_table_name_border_enabled(bool value) {
  set_has_table_name_border_enabled();
  table_name_border_enabled_ = value;
}

// optional uint32 number_of_header_rows = 9;
inline bool TableModelArchive::has_number_of_header_rows() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TableModelArchive::set_has_number_of_header_rows() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TableModelArchive::clear_has_number_of_header_rows() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TableModelArchive::clear_number_of_header_rows() {
  number_of_header_rows_ = 0u;
  clear_has_number_of_header_rows();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_header_rows() const {
  return number_of_header_rows_;
}
inline void TableModelArchive::set_number_of_header_rows(::google::protobuf::uint32 value) {
  set_has_number_of_header_rows();
  number_of_header_rows_ = value;
}

// optional uint32 number_of_header_columns = 10;
inline bool TableModelArchive::has_number_of_header_columns() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TableModelArchive::set_has_number_of_header_columns() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TableModelArchive::clear_has_number_of_header_columns() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TableModelArchive::clear_number_of_header_columns() {
  number_of_header_columns_ = 0u;
  clear_has_number_of_header_columns();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_header_columns() const {
  return number_of_header_columns_;
}
inline void TableModelArchive::set_number_of_header_columns(::google::protobuf::uint32 value) {
  set_has_number_of_header_columns();
  number_of_header_columns_ = value;
}

// optional uint32 number_of_footer_rows = 11;
inline bool TableModelArchive::has_number_of_footer_rows() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TableModelArchive::set_has_number_of_footer_rows() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TableModelArchive::clear_has_number_of_footer_rows() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TableModelArchive::clear_number_of_footer_rows() {
  number_of_footer_rows_ = 0u;
  clear_has_number_of_footer_rows();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_footer_rows() const {
  return number_of_footer_rows_;
}
inline void TableModelArchive::set_number_of_footer_rows(::google::protobuf::uint32 value) {
  set_has_number_of_footer_rows();
  number_of_footer_rows_ = value;
}

// optional bool header_rows_frozen = 12;
inline bool TableModelArchive::has_header_rows_frozen() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TableModelArchive::set_has_header_rows_frozen() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TableModelArchive::clear_has_header_rows_frozen() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TableModelArchive::clear_header_rows_frozen() {
  header_rows_frozen_ = false;
  clear_has_header_rows_frozen();
}
inline bool TableModelArchive::header_rows_frozen() const {
  return header_rows_frozen_;
}
inline void TableModelArchive::set_header_rows_frozen(bool value) {
  set_has_header_rows_frozen();
  header_rows_frozen_ = value;
}

// optional bool header_columns_frozen = 13;
inline bool TableModelArchive::has_header_columns_frozen() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TableModelArchive::set_has_header_columns_frozen() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TableModelArchive::clear_has_header_columns_frozen() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TableModelArchive::clear_header_columns_frozen() {
  header_columns_frozen_ = false;
  clear_has_header_columns_frozen();
}
inline bool TableModelArchive::header_columns_frozen() const {
  return header_columns_frozen_;
}
inline void TableModelArchive::set_header_columns_frozen(bool value) {
  set_has_header_columns_frozen();
  header_columns_frozen_ = value;
}

// optional uint32 number_of_hidden_rows = 14;
inline bool TableModelArchive::has_number_of_hidden_rows() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TableModelArchive::set_has_number_of_hidden_rows() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TableModelArchive::clear_has_number_of_hidden_rows() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TableModelArchive::clear_number_of_hidden_rows() {
  number_of_hidden_rows_ = 0u;
  clear_has_number_of_hidden_rows();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_hidden_rows() const {
  return number_of_hidden_rows_;
}
inline void TableModelArchive::set_number_of_hidden_rows(::google::protobuf::uint32 value) {
  set_has_number_of_hidden_rows();
  number_of_hidden_rows_ = value;
}

// optional uint32 number_of_hidden_columns = 15;
inline bool TableModelArchive::has_number_of_hidden_columns() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TableModelArchive::set_has_number_of_hidden_columns() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TableModelArchive::clear_has_number_of_hidden_columns() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TableModelArchive::clear_number_of_hidden_columns() {
  number_of_hidden_columns_ = 0u;
  clear_has_number_of_hidden_columns();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_hidden_columns() const {
  return number_of_hidden_columns_;
}
inline void TableModelArchive::set_number_of_hidden_columns(::google::protobuf::uint32 value) {
  set_has_number_of_hidden_columns();
  number_of_hidden_columns_ = value;
}

// optional uint32 number_of_user_hidden_rows = 41;
inline bool TableModelArchive::has_number_of_user_hidden_rows() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TableModelArchive::set_has_number_of_user_hidden_rows() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TableModelArchive::clear_has_number_of_user_hidden_rows() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TableModelArchive::clear_number_of_user_hidden_rows() {
  number_of_user_hidden_rows_ = 0u;
  clear_has_number_of_user_hidden_rows();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_user_hidden_rows() const {
  return number_of_user_hidden_rows_;
}
inline void TableModelArchive::set_number_of_user_hidden_rows(::google::protobuf::uint32 value) {
  set_has_number_of_user_hidden_rows();
  number_of_user_hidden_rows_ = value;
}

// optional uint32 number_of_user_hidden_columns = 42;
inline bool TableModelArchive::has_number_of_user_hidden_columns() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TableModelArchive::set_has_number_of_user_hidden_columns() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TableModelArchive::clear_has_number_of_user_hidden_columns() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TableModelArchive::clear_number_of_user_hidden_columns() {
  number_of_user_hidden_columns_ = 0u;
  clear_has_number_of_user_hidden_columns();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_user_hidden_columns() const {
  return number_of_user_hidden_columns_;
}
inline void TableModelArchive::set_number_of_user_hidden_columns(::google::protobuf::uint32 value) {
  set_has_number_of_user_hidden_columns();
  number_of_user_hidden_columns_ = value;
}

// optional uint32 number_of_filtered_rows = 40;
inline bool TableModelArchive::has_number_of_filtered_rows() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TableModelArchive::set_has_number_of_filtered_rows() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TableModelArchive::clear_has_number_of_filtered_rows() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TableModelArchive::clear_number_of_filtered_rows() {
  number_of_filtered_rows_ = 0u;
  clear_has_number_of_filtered_rows();
}
inline ::google::protobuf::uint32 TableModelArchive::number_of_filtered_rows() const {
  return number_of_filtered_rows_;
}
inline void TableModelArchive::set_number_of_filtered_rows(::google::protobuf::uint32 value) {
  set_has_number_of_filtered_rows();
  number_of_filtered_rows_ = value;
}

// required double default_row_height = 16;
inline bool TableModelArchive::has_default_row_height() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TableModelArchive::set_has_default_row_height() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TableModelArchive::clear_has_default_row_height() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TableModelArchive::clear_default_row_height() {
  default_row_height_ = 0;
  clear_has_default_row_height();
}
inline double TableModelArchive::default_row_height() const {
  return default_row_height_;
}
inline void TableModelArchive::set_default_row_height(double value) {
  set_has_default_row_height();
  default_row_height_ = value;
}

// required double default_column_width = 17;
inline bool TableModelArchive::has_default_column_width() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TableModelArchive::set_has_default_column_width() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TableModelArchive::clear_has_default_column_width() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TableModelArchive::clear_default_column_width() {
  default_column_width_ = 0;
  clear_has_default_column_width();
}
inline double TableModelArchive::default_column_width() const {
  return default_column_width_;
}
inline void TableModelArchive::set_default_column_width(double value) {
  set_has_default_column_width();
  default_column_width_ = value;
}

// optional .TST.CellID origin_offset = 23 [deprecated = true];
inline bool TableModelArchive::has_origin_offset() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TableModelArchive::set_has_origin_offset() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TableModelArchive::clear_has_origin_offset() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TableModelArchive::clear_origin_offset() {
  if (origin_offset_ != NULL) origin_offset_->::TST::CellID::Clear();
  clear_has_origin_offset();
}
inline const ::TST::CellID& TableModelArchive::origin_offset() const {
  return origin_offset_ != NULL ? *origin_offset_ : *default_instance_->origin_offset_;
}
inline ::TST::CellID* TableModelArchive::mutable_origin_offset() {
  set_has_origin_offset();
  if (origin_offset_ == NULL) origin_offset_ = new ::TST::CellID;
  return origin_offset_;
}
inline ::TST::CellID* TableModelArchive::release_origin_offset() {
  clear_has_origin_offset();
  ::TST::CellID* temp = origin_offset_;
  origin_offset_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_origin_offset(::TST::CellID* origin_offset) {
  delete origin_offset_;
  origin_offset_ = origin_offset;
  if (origin_offset) {
    set_has_origin_offset();
  } else {
    clear_has_origin_offset();
  }
}

// required uint32 preset_index = 28;
inline bool TableModelArchive::has_preset_index() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TableModelArchive::set_has_preset_index() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TableModelArchive::clear_has_preset_index() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TableModelArchive::clear_preset_index() {
  preset_index_ = 0u;
  clear_has_preset_index();
}
inline ::google::protobuf::uint32 TableModelArchive::preset_index() const {
  return preset_index_;
}
inline void TableModelArchive::set_preset_index(::google::protobuf::uint32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// optional bool repeating_header_rows_enabled = 29;
inline bool TableModelArchive::has_repeating_header_rows_enabled() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TableModelArchive::set_has_repeating_header_rows_enabled() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TableModelArchive::clear_has_repeating_header_rows_enabled() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TableModelArchive::clear_repeating_header_rows_enabled() {
  repeating_header_rows_enabled_ = false;
  clear_has_repeating_header_rows_enabled();
}
inline bool TableModelArchive::repeating_header_rows_enabled() const {
  return repeating_header_rows_enabled_;
}
inline void TableModelArchive::set_repeating_header_rows_enabled(bool value) {
  set_has_repeating_header_rows_enabled();
  repeating_header_rows_enabled_ = value;
}

// optional bool repeating_header_columns_enabled = 32;
inline bool TableModelArchive::has_repeating_header_columns_enabled() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TableModelArchive::set_has_repeating_header_columns_enabled() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TableModelArchive::clear_has_repeating_header_columns_enabled() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TableModelArchive::clear_repeating_header_columns_enabled() {
  repeating_header_columns_enabled_ = false;
  clear_has_repeating_header_columns_enabled();
}
inline bool TableModelArchive::repeating_header_columns_enabled() const {
  return repeating_header_columns_enabled_;
}
inline void TableModelArchive::set_repeating_header_columns_enabled(bool value) {
  set_has_repeating_header_columns_enabled();
  repeating_header_columns_enabled_ = value;
}

// optional bool style_apply_clears_all = 31;
inline bool TableModelArchive::has_style_apply_clears_all() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TableModelArchive::set_has_style_apply_clears_all() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TableModelArchive::clear_has_style_apply_clears_all() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TableModelArchive::clear_style_apply_clears_all() {
  style_apply_clears_all_ = false;
  clear_has_style_apply_clears_all();
}
inline bool TableModelArchive::style_apply_clears_all() const {
  return style_apply_clears_all_;
}
inline void TableModelArchive::set_style_apply_clears_all(bool value) {
  set_has_style_apply_clears_all();
  style_apply_clears_all_ = value;
}

// optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
inline bool TableModelArchive::has_hidden_state_formula_owner_for_columns() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TableModelArchive::set_has_hidden_state_formula_owner_for_columns() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TableModelArchive::clear_has_hidden_state_formula_owner_for_columns() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TableModelArchive::clear_hidden_state_formula_owner_for_columns() {
  if (hidden_state_formula_owner_for_columns_ != NULL) hidden_state_formula_owner_for_columns_->::TSP::Reference::Clear();
  clear_has_hidden_state_formula_owner_for_columns();
}
inline const ::TSP::Reference& TableModelArchive::hidden_state_formula_owner_for_columns() const {
  return hidden_state_formula_owner_for_columns_ != NULL ? *hidden_state_formula_owner_for_columns_ : *default_instance_->hidden_state_formula_owner_for_columns_;
}
inline ::TSP::Reference* TableModelArchive::mutable_hidden_state_formula_owner_for_columns() {
  set_has_hidden_state_formula_owner_for_columns();
  if (hidden_state_formula_owner_for_columns_ == NULL) hidden_state_formula_owner_for_columns_ = new ::TSP::Reference;
  return hidden_state_formula_owner_for_columns_;
}
inline ::TSP::Reference* TableModelArchive::release_hidden_state_formula_owner_for_columns() {
  clear_has_hidden_state_formula_owner_for_columns();
  ::TSP::Reference* temp = hidden_state_formula_owner_for_columns_;
  hidden_state_formula_owner_for_columns_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_hidden_state_formula_owner_for_columns(::TSP::Reference* hidden_state_formula_owner_for_columns) {
  delete hidden_state_formula_owner_for_columns_;
  hidden_state_formula_owner_for_columns_ = hidden_state_formula_owner_for_columns;
  if (hidden_state_formula_owner_for_columns) {
    set_has_hidden_state_formula_owner_for_columns();
  } else {
    clear_has_hidden_state_formula_owner_for_columns();
  }
}

// optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
inline bool TableModelArchive::has_hidden_state_formula_owner_for_rows() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TableModelArchive::set_has_hidden_state_formula_owner_for_rows() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TableModelArchive::clear_has_hidden_state_formula_owner_for_rows() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TableModelArchive::clear_hidden_state_formula_owner_for_rows() {
  if (hidden_state_formula_owner_for_rows_ != NULL) hidden_state_formula_owner_for_rows_->::TSP::Reference::Clear();
  clear_has_hidden_state_formula_owner_for_rows();
}
inline const ::TSP::Reference& TableModelArchive::hidden_state_formula_owner_for_rows() const {
  return hidden_state_formula_owner_for_rows_ != NULL ? *hidden_state_formula_owner_for_rows_ : *default_instance_->hidden_state_formula_owner_for_rows_;
}
inline ::TSP::Reference* TableModelArchive::mutable_hidden_state_formula_owner_for_rows() {
  set_has_hidden_state_formula_owner_for_rows();
  if (hidden_state_formula_owner_for_rows_ == NULL) hidden_state_formula_owner_for_rows_ = new ::TSP::Reference;
  return hidden_state_formula_owner_for_rows_;
}
inline ::TSP::Reference* TableModelArchive::release_hidden_state_formula_owner_for_rows() {
  clear_has_hidden_state_formula_owner_for_rows();
  ::TSP::Reference* temp = hidden_state_formula_owner_for_rows_;
  hidden_state_formula_owner_for_rows_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_hidden_state_formula_owner_for_rows(::TSP::Reference* hidden_state_formula_owner_for_rows) {
  delete hidden_state_formula_owner_for_rows_;
  hidden_state_formula_owner_for_rows_ = hidden_state_formula_owner_for_rows;
  if (hidden_state_formula_owner_for_rows) {
    set_has_hidden_state_formula_owner_for_rows();
  } else {
    clear_has_hidden_state_formula_owner_for_rows();
  }
}

// optional .TSP.Reference filter_set = 38;
inline bool TableModelArchive::has_filter_set() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TableModelArchive::set_has_filter_set() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TableModelArchive::clear_has_filter_set() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TableModelArchive::clear_filter_set() {
  if (filter_set_ != NULL) filter_set_->::TSP::Reference::Clear();
  clear_has_filter_set();
}
inline const ::TSP::Reference& TableModelArchive::filter_set() const {
  return filter_set_ != NULL ? *filter_set_ : *default_instance_->filter_set_;
}
inline ::TSP::Reference* TableModelArchive::mutable_filter_set() {
  set_has_filter_set();
  if (filter_set_ == NULL) filter_set_ = new ::TSP::Reference;
  return filter_set_;
}
inline ::TSP::Reference* TableModelArchive::release_filter_set() {
  clear_has_filter_set();
  ::TSP::Reference* temp = filter_set_;
  filter_set_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_filter_set(::TSP::Reference* filter_set) {
  delete filter_set_;
  filter_set_ = filter_set;
  if (filter_set) {
    set_has_filter_set();
  } else {
    clear_has_filter_set();
  }
}

// optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
inline bool TableModelArchive::has_conditional_style_formula_owner_id() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void TableModelArchive::set_has_conditional_style_formula_owner_id() {
  _has_bits_[1] |= 0x00000200u;
}
inline void TableModelArchive::clear_has_conditional_style_formula_owner_id() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void TableModelArchive::clear_conditional_style_formula_owner_id() {
  if (conditional_style_formula_owner_id_ != NULL) conditional_style_formula_owner_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_conditional_style_formula_owner_id();
}
inline const ::TSCE::CFUUIDArchive& TableModelArchive::conditional_style_formula_owner_id() const {
  return conditional_style_formula_owner_id_ != NULL ? *conditional_style_formula_owner_id_ : *default_instance_->conditional_style_formula_owner_id_;
}
inline ::TSCE::CFUUIDArchive* TableModelArchive::mutable_conditional_style_formula_owner_id() {
  set_has_conditional_style_formula_owner_id();
  if (conditional_style_formula_owner_id_ == NULL) conditional_style_formula_owner_id_ = new ::TSCE::CFUUIDArchive;
  return conditional_style_formula_owner_id_;
}
inline ::TSCE::CFUUIDArchive* TableModelArchive::release_conditional_style_formula_owner_id() {
  clear_has_conditional_style_formula_owner_id();
  ::TSCE::CFUUIDArchive* temp = conditional_style_formula_owner_id_;
  conditional_style_formula_owner_id_ = NULL;
  return temp;
}
inline void TableModelArchive::set_allocated_conditional_style_formula_owner_id(::TSCE::CFUUIDArchive* conditional_style_formula_owner_id) {
  delete conditional_style_formula_owner_id_;
  conditional_style_formula_owner_id_ = conditional_style_formula_owner_id;
  if (conditional_style_formula_owner_id) {
    set_has_conditional_style_formula_owner_id();
  } else {
    clear_has_conditional_style_formula_owner_id();
  }
}

// -------------------------------------------------------------------

// DurationWrapperArchive

// -------------------------------------------------------------------

// Cell

// required .TST.CellValueType valueType = 2;
inline bool Cell::has_valuetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cell::set_has_valuetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cell::clear_has_valuetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cell::clear_valuetype() {
  valuetype_ = 0;
  clear_has_valuetype();
}
inline ::TST::CellValueType Cell::valuetype() const {
  return static_cast< ::TST::CellValueType >(valuetype_);
}
inline void Cell::set_valuetype(::TST::CellValueType value) {
  assert(::TST::CellValueType_IsValid(value));
  set_has_valuetype();
  valuetype_ = value;
}

// optional double numberValue = 5;
inline bool Cell::has_numbervalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cell::set_has_numbervalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cell::clear_has_numbervalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cell::clear_numbervalue() {
  numbervalue_ = 0;
  clear_has_numbervalue();
}
inline double Cell::numbervalue() const {
  return numbervalue_;
}
inline void Cell::set_numbervalue(double value) {
  set_has_numbervalue();
  numbervalue_ = value;
}

// optional string stringValue = 6;
inline bool Cell::has_stringvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cell::set_has_stringvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cell::clear_has_stringvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cell::clear_stringvalue() {
  if (stringvalue_ != &::google::protobuf::internal::kEmptyString) {
    stringvalue_->clear();
  }
  clear_has_stringvalue();
}
inline const ::std::string& Cell::stringvalue() const {
  return *stringvalue_;
}
inline void Cell::set_stringvalue(const ::std::string& value) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(value);
}
inline void Cell::set_stringvalue(const char* value) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(value);
}
inline void Cell::set_stringvalue(const char* value, size_t size) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cell::mutable_stringvalue() {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  return stringvalue_;
}
inline ::std::string* Cell::release_stringvalue() {
  clear_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stringvalue_;
    stringvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Cell::set_allocated_stringvalue(::std::string* stringvalue) {
  if (stringvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete stringvalue_;
  }
  if (stringvalue) {
    set_has_stringvalue();
    stringvalue_ = stringvalue;
  } else {
    clear_has_stringvalue();
    stringvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool boolValue = 7;
inline bool Cell::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cell::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cell::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cell::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool Cell::boolvalue() const {
  return boolvalue_;
}
inline void Cell::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// optional .TSP.Reference cell_style = 3;
inline bool Cell::has_cell_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Cell::set_has_cell_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Cell::clear_has_cell_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Cell::clear_cell_style() {
  if (cell_style_ != NULL) cell_style_->::TSP::Reference::Clear();
  clear_has_cell_style();
}
inline const ::TSP::Reference& Cell::cell_style() const {
  return cell_style_ != NULL ? *cell_style_ : *default_instance_->cell_style_;
}
inline ::TSP::Reference* Cell::mutable_cell_style() {
  set_has_cell_style();
  if (cell_style_ == NULL) cell_style_ = new ::TSP::Reference;
  return cell_style_;
}
inline ::TSP::Reference* Cell::release_cell_style() {
  clear_has_cell_style();
  ::TSP::Reference* temp = cell_style_;
  cell_style_ = NULL;
  return temp;
}
inline void Cell::set_allocated_cell_style(::TSP::Reference* cell_style) {
  delete cell_style_;
  cell_style_ = cell_style;
  if (cell_style) {
    set_has_cell_style();
  } else {
    clear_has_cell_style();
  }
}

// optional .TSP.Reference text_style = 4;
inline bool Cell::has_text_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Cell::set_has_text_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Cell::clear_has_text_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Cell::clear_text_style() {
  if (text_style_ != NULL) text_style_->::TSP::Reference::Clear();
  clear_has_text_style();
}
inline const ::TSP::Reference& Cell::text_style() const {
  return text_style_ != NULL ? *text_style_ : *default_instance_->text_style_;
}
inline ::TSP::Reference* Cell::mutable_text_style() {
  set_has_text_style();
  if (text_style_ == NULL) text_style_ = new ::TSP::Reference;
  return text_style_;
}
inline ::TSP::Reference* Cell::release_text_style() {
  clear_has_text_style();
  ::TSP::Reference* temp = text_style_;
  text_style_ = NULL;
  return temp;
}
inline void Cell::set_allocated_text_style(::TSP::Reference* text_style) {
  delete text_style_;
  text_style_ = text_style;
  if (text_style) {
    set_has_text_style();
  } else {
    clear_has_text_style();
  }
}

// optional .TSCE.FormulaArchive formula = 8;
inline bool Cell::has_formula() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Cell::set_has_formula() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Cell::clear_has_formula() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Cell::clear_formula() {
  if (formula_ != NULL) formula_->::TSCE::FormulaArchive::Clear();
  clear_has_formula();
}
inline const ::TSCE::FormulaArchive& Cell::formula() const {
  return formula_ != NULL ? *formula_ : *default_instance_->formula_;
}
inline ::TSCE::FormulaArchive* Cell::mutable_formula() {
  set_has_formula();
  if (formula_ == NULL) formula_ = new ::TSCE::FormulaArchive;
  return formula_;
}
inline ::TSCE::FormulaArchive* Cell::release_formula() {
  clear_has_formula();
  ::TSCE::FormulaArchive* temp = formula_;
  formula_ = NULL;
  return temp;
}
inline void Cell::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  delete formula_;
  formula_ = formula;
  if (formula) {
    set_has_formula();
  } else {
    clear_has_formula();
  }
}

// optional .TSP.Reference formulaError = 10;
inline bool Cell::has_formulaerror() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Cell::set_has_formulaerror() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Cell::clear_has_formulaerror() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Cell::clear_formulaerror() {
  if (formulaerror_ != NULL) formulaerror_->::TSP::Reference::Clear();
  clear_has_formulaerror();
}
inline const ::TSP::Reference& Cell::formulaerror() const {
  return formulaerror_ != NULL ? *formulaerror_ : *default_instance_->formulaerror_;
}
inline ::TSP::Reference* Cell::mutable_formulaerror() {
  set_has_formulaerror();
  if (formulaerror_ == NULL) formulaerror_ = new ::TSP::Reference;
  return formulaerror_;
}
inline ::TSP::Reference* Cell::release_formulaerror() {
  clear_has_formulaerror();
  ::TSP::Reference* temp = formulaerror_;
  formulaerror_ = NULL;
  return temp;
}
inline void Cell::set_allocated_formulaerror(::TSP::Reference* formulaerror) {
  delete formulaerror_;
  formulaerror_ = formulaerror;
  if (formulaerror) {
    set_has_formulaerror();
  } else {
    clear_has_formulaerror();
  }
}

// optional .TSK.FormatStructArchive current_format = 9;
inline bool Cell::has_current_format() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Cell::set_has_current_format() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Cell::clear_has_current_format() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Cell::clear_current_format() {
  if (current_format_ != NULL) current_format_->::TSK::FormatStructArchive::Clear();
  clear_has_current_format();
}
inline const ::TSK::FormatStructArchive& Cell::current_format() const {
  return current_format_ != NULL ? *current_format_ : *default_instance_->current_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_current_format() {
  set_has_current_format();
  if (current_format_ == NULL) current_format_ = new ::TSK::FormatStructArchive;
  return current_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_current_format() {
  clear_has_current_format();
  ::TSK::FormatStructArchive* temp = current_format_;
  current_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_current_format(::TSK::FormatStructArchive* current_format) {
  delete current_format_;
  current_format_ = current_format;
  if (current_format) {
    set_has_current_format();
  } else {
    clear_has_current_format();
  }
}

// optional .TSK.FormatStructArchive number_format = 11;
inline bool Cell::has_number_format() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Cell::set_has_number_format() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Cell::clear_has_number_format() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Cell::clear_number_format() {
  if (number_format_ != NULL) number_format_->::TSK::FormatStructArchive::Clear();
  clear_has_number_format();
}
inline const ::TSK::FormatStructArchive& Cell::number_format() const {
  return number_format_ != NULL ? *number_format_ : *default_instance_->number_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_number_format() {
  set_has_number_format();
  if (number_format_ == NULL) number_format_ = new ::TSK::FormatStructArchive;
  return number_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_number_format() {
  clear_has_number_format();
  ::TSK::FormatStructArchive* temp = number_format_;
  number_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_number_format(::TSK::FormatStructArchive* number_format) {
  delete number_format_;
  number_format_ = number_format;
  if (number_format) {
    set_has_number_format();
  } else {
    clear_has_number_format();
  }
}

// optional .TSK.FormatStructArchive currency_format = 12;
inline bool Cell::has_currency_format() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Cell::set_has_currency_format() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Cell::clear_has_currency_format() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Cell::clear_currency_format() {
  if (currency_format_ != NULL) currency_format_->::TSK::FormatStructArchive::Clear();
  clear_has_currency_format();
}
inline const ::TSK::FormatStructArchive& Cell::currency_format() const {
  return currency_format_ != NULL ? *currency_format_ : *default_instance_->currency_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_currency_format() {
  set_has_currency_format();
  if (currency_format_ == NULL) currency_format_ = new ::TSK::FormatStructArchive;
  return currency_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_currency_format() {
  clear_has_currency_format();
  ::TSK::FormatStructArchive* temp = currency_format_;
  currency_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_currency_format(::TSK::FormatStructArchive* currency_format) {
  delete currency_format_;
  currency_format_ = currency_format;
  if (currency_format) {
    set_has_currency_format();
  } else {
    clear_has_currency_format();
  }
}

// optional .TSK.FormatStructArchive duration_format = 13;
inline bool Cell::has_duration_format() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Cell::set_has_duration_format() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Cell::clear_has_duration_format() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Cell::clear_duration_format() {
  if (duration_format_ != NULL) duration_format_->::TSK::FormatStructArchive::Clear();
  clear_has_duration_format();
}
inline const ::TSK::FormatStructArchive& Cell::duration_format() const {
  return duration_format_ != NULL ? *duration_format_ : *default_instance_->duration_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_duration_format() {
  set_has_duration_format();
  if (duration_format_ == NULL) duration_format_ = new ::TSK::FormatStructArchive;
  return duration_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_duration_format() {
  clear_has_duration_format();
  ::TSK::FormatStructArchive* temp = duration_format_;
  duration_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_duration_format(::TSK::FormatStructArchive* duration_format) {
  delete duration_format_;
  duration_format_ = duration_format;
  if (duration_format) {
    set_has_duration_format();
  } else {
    clear_has_duration_format();
  }
}

// optional .TSK.FormatStructArchive date_format = 14;
inline bool Cell::has_date_format() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Cell::set_has_date_format() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Cell::clear_has_date_format() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Cell::clear_date_format() {
  if (date_format_ != NULL) date_format_->::TSK::FormatStructArchive::Clear();
  clear_has_date_format();
}
inline const ::TSK::FormatStructArchive& Cell::date_format() const {
  return date_format_ != NULL ? *date_format_ : *default_instance_->date_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_date_format() {
  set_has_date_format();
  if (date_format_ == NULL) date_format_ = new ::TSK::FormatStructArchive;
  return date_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_date_format() {
  clear_has_date_format();
  ::TSK::FormatStructArchive* temp = date_format_;
  date_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_date_format(::TSK::FormatStructArchive* date_format) {
  delete date_format_;
  date_format_ = date_format;
  if (date_format) {
    set_has_date_format();
  } else {
    clear_has_date_format();
  }
}

// optional .TSK.FormatStructArchive control_format = 15;
inline bool Cell::has_control_format() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Cell::set_has_control_format() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Cell::clear_has_control_format() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Cell::clear_control_format() {
  if (control_format_ != NULL) control_format_->::TSK::FormatStructArchive::Clear();
  clear_has_control_format();
}
inline const ::TSK::FormatStructArchive& Cell::control_format() const {
  return control_format_ != NULL ? *control_format_ : *default_instance_->control_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_control_format() {
  set_has_control_format();
  if (control_format_ == NULL) control_format_ = new ::TSK::FormatStructArchive;
  return control_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_control_format() {
  clear_has_control_format();
  ::TSK::FormatStructArchive* temp = control_format_;
  control_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_control_format(::TSK::FormatStructArchive* control_format) {
  delete control_format_;
  control_format_ = control_format;
  if (control_format) {
    set_has_control_format();
  } else {
    clear_has_control_format();
  }
}

// optional .TSK.FormatStructArchive custom_format = 16;
inline bool Cell::has_custom_format() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Cell::set_has_custom_format() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Cell::clear_has_custom_format() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Cell::clear_custom_format() {
  if (custom_format_ != NULL) custom_format_->::TSK::FormatStructArchive::Clear();
  clear_has_custom_format();
}
inline const ::TSK::FormatStructArchive& Cell::custom_format() const {
  return custom_format_ != NULL ? *custom_format_ : *default_instance_->custom_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_custom_format() {
  set_has_custom_format();
  if (custom_format_ == NULL) custom_format_ = new ::TSK::FormatStructArchive;
  return custom_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_custom_format() {
  clear_has_custom_format();
  ::TSK::FormatStructArchive* temp = custom_format_;
  custom_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_custom_format(::TSK::FormatStructArchive* custom_format) {
  delete custom_format_;
  custom_format_ = custom_format;
  if (custom_format) {
    set_has_custom_format();
  } else {
    clear_has_custom_format();
  }
}

// optional .TSK.FormatStructArchive base_format = 17;
inline bool Cell::has_base_format() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Cell::set_has_base_format() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Cell::clear_has_base_format() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Cell::clear_base_format() {
  if (base_format_ != NULL) base_format_->::TSK::FormatStructArchive::Clear();
  clear_has_base_format();
}
inline const ::TSK::FormatStructArchive& Cell::base_format() const {
  return base_format_ != NULL ? *base_format_ : *default_instance_->base_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_base_format() {
  set_has_base_format();
  if (base_format_ == NULL) base_format_ = new ::TSK::FormatStructArchive;
  return base_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_base_format() {
  clear_has_base_format();
  ::TSK::FormatStructArchive* temp = base_format_;
  base_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_base_format(::TSK::FormatStructArchive* base_format) {
  delete base_format_;
  base_format_ = base_format;
  if (base_format) {
    set_has_base_format();
  } else {
    clear_has_base_format();
  }
}

// optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
inline bool Cell::has_multiple_choice_list_format() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Cell::set_has_multiple_choice_list_format() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Cell::clear_has_multiple_choice_list_format() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Cell::clear_multiple_choice_list_format() {
  if (multiple_choice_list_format_ != NULL) multiple_choice_list_format_->::TSK::FormatStructArchive::Clear();
  clear_has_multiple_choice_list_format();
}
inline const ::TSK::FormatStructArchive& Cell::multiple_choice_list_format() const {
  return multiple_choice_list_format_ != NULL ? *multiple_choice_list_format_ : *default_instance_->multiple_choice_list_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_multiple_choice_list_format() {
  set_has_multiple_choice_list_format();
  if (multiple_choice_list_format_ == NULL) multiple_choice_list_format_ = new ::TSK::FormatStructArchive;
  return multiple_choice_list_format_;
}
inline ::TSK::FormatStructArchive* Cell::release_multiple_choice_list_format() {
  clear_has_multiple_choice_list_format();
  ::TSK::FormatStructArchive* temp = multiple_choice_list_format_;
  multiple_choice_list_format_ = NULL;
  return temp;
}
inline void Cell::set_allocated_multiple_choice_list_format(::TSK::FormatStructArchive* multiple_choice_list_format) {
  delete multiple_choice_list_format_;
  multiple_choice_list_format_ = multiple_choice_list_format;
  if (multiple_choice_list_format) {
    set_has_multiple_choice_list_format();
  } else {
    clear_has_multiple_choice_list_format();
  }
}

// optional uint32 explicit_format_flags = 19;
inline bool Cell::has_explicit_format_flags() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Cell::set_has_explicit_format_flags() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Cell::clear_has_explicit_format_flags() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Cell::clear_explicit_format_flags() {
  explicit_format_flags_ = 0u;
  clear_has_explicit_format_flags();
}
inline ::google::protobuf::uint32 Cell::explicit_format_flags() const {
  return explicit_format_flags_;
}
inline void Cell::set_explicit_format_flags(::google::protobuf::uint32 value) {
  set_has_explicit_format_flags();
  explicit_format_flags_ = value;
}

// optional .TSP.Reference richTextPayload = 20;
inline bool Cell::has_richtextpayload() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Cell::set_has_richtextpayload() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Cell::clear_has_richtextpayload() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Cell::clear_richtextpayload() {
  if (richtextpayload_ != NULL) richtextpayload_->::TSP::Reference::Clear();
  clear_has_richtextpayload();
}
inline const ::TSP::Reference& Cell::richtextpayload() const {
  return richtextpayload_ != NULL ? *richtextpayload_ : *default_instance_->richtextpayload_;
}
inline ::TSP::Reference* Cell::mutable_richtextpayload() {
  set_has_richtextpayload();
  if (richtextpayload_ == NULL) richtextpayload_ = new ::TSP::Reference;
  return richtextpayload_;
}
inline ::TSP::Reference* Cell::release_richtextpayload() {
  clear_has_richtextpayload();
  ::TSP::Reference* temp = richtextpayload_;
  richtextpayload_ = NULL;
  return temp;
}
inline void Cell::set_allocated_richtextpayload(::TSP::Reference* richtextpayload) {
  delete richtextpayload_;
  richtextpayload_ = richtextpayload;
  if (richtextpayload) {
    set_has_richtextpayload();
  } else {
    clear_has_richtextpayload();
  }
}

// optional .TSP.Reference conditional_style = 21;
inline bool Cell::has_conditional_style() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Cell::set_has_conditional_style() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Cell::clear_has_conditional_style() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Cell::clear_conditional_style() {
  if (conditional_style_ != NULL) conditional_style_->::TSP::Reference::Clear();
  clear_has_conditional_style();
}
inline const ::TSP::Reference& Cell::conditional_style() const {
  return conditional_style_ != NULL ? *conditional_style_ : *default_instance_->conditional_style_;
}
inline ::TSP::Reference* Cell::mutable_conditional_style() {
  set_has_conditional_style();
  if (conditional_style_ == NULL) conditional_style_ = new ::TSP::Reference;
  return conditional_style_;
}
inline ::TSP::Reference* Cell::release_conditional_style() {
  clear_has_conditional_style();
  ::TSP::Reference* temp = conditional_style_;
  conditional_style_ = NULL;
  return temp;
}
inline void Cell::set_allocated_conditional_style(::TSP::Reference* conditional_style) {
  delete conditional_style_;
  conditional_style_ = conditional_style;
  if (conditional_style) {
    set_has_conditional_style();
  } else {
    clear_has_conditional_style();
  }
}

// optional .TSP.Reference multiple_choice_list = 22;
inline bool Cell::has_multiple_choice_list() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Cell::set_has_multiple_choice_list() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Cell::clear_has_multiple_choice_list() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Cell::clear_multiple_choice_list() {
  if (multiple_choice_list_ != NULL) multiple_choice_list_->::TSP::Reference::Clear();
  clear_has_multiple_choice_list();
}
inline const ::TSP::Reference& Cell::multiple_choice_list() const {
  return multiple_choice_list_ != NULL ? *multiple_choice_list_ : *default_instance_->multiple_choice_list_;
}
inline ::TSP::Reference* Cell::mutable_multiple_choice_list() {
  set_has_multiple_choice_list();
  if (multiple_choice_list_ == NULL) multiple_choice_list_ = new ::TSP::Reference;
  return multiple_choice_list_;
}
inline ::TSP::Reference* Cell::release_multiple_choice_list() {
  clear_has_multiple_choice_list();
  ::TSP::Reference* temp = multiple_choice_list_;
  multiple_choice_list_ = NULL;
  return temp;
}
inline void Cell::set_allocated_multiple_choice_list(::TSP::Reference* multiple_choice_list) {
  delete multiple_choice_list_;
  multiple_choice_list_ = multiple_choice_list;
  if (multiple_choice_list) {
    set_has_multiple_choice_list();
  } else {
    clear_has_multiple_choice_list();
  }
}

// optional .TSP.Reference comment_storage = 23;
inline bool Cell::has_comment_storage() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Cell::set_has_comment_storage() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Cell::clear_has_comment_storage() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Cell::clear_comment_storage() {
  if (comment_storage_ != NULL) comment_storage_->::TSP::Reference::Clear();
  clear_has_comment_storage();
}
inline const ::TSP::Reference& Cell::comment_storage() const {
  return comment_storage_ != NULL ? *comment_storage_ : *default_instance_->comment_storage_;
}
inline ::TSP::Reference* Cell::mutable_comment_storage() {
  set_has_comment_storage();
  if (comment_storage_ == NULL) comment_storage_ = new ::TSP::Reference;
  return comment_storage_;
}
inline ::TSP::Reference* Cell::release_comment_storage() {
  clear_has_comment_storage();
  ::TSP::Reference* temp = comment_storage_;
  comment_storage_ = NULL;
  return temp;
}
inline void Cell::set_allocated_comment_storage(::TSP::Reference* comment_storage) {
  delete comment_storage_;
  comment_storage_ = comment_storage;
  if (comment_storage) {
    set_has_comment_storage();
  } else {
    clear_has_comment_storage();
  }
}

// optional uint32 conditional_style_applied_rule = 24;
inline bool Cell::has_conditional_style_applied_rule() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Cell::set_has_conditional_style_applied_rule() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Cell::clear_has_conditional_style_applied_rule() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Cell::clear_conditional_style_applied_rule() {
  conditional_style_applied_rule_ = 0u;
  clear_has_conditional_style_applied_rule();
}
inline ::google::protobuf::uint32 Cell::conditional_style_applied_rule() const {
  return conditional_style_applied_rule_;
}
inline void Cell::set_conditional_style_applied_rule(::google::protobuf::uint32 value) {
  set_has_conditional_style_applied_rule();
  conditional_style_applied_rule_ = value;
}

// -------------------------------------------------------------------

// MergeRegionMapArchive

// repeated .TST.CellRange cell_range = 1;
inline int MergeRegionMapArchive::cell_range_size() const {
  return cell_range_.size();
}
inline void MergeRegionMapArchive::clear_cell_range() {
  cell_range_.Clear();
}
inline const ::TST::CellRange& MergeRegionMapArchive::cell_range(int index) const {
  return cell_range_.Get(index);
}
inline ::TST::CellRange* MergeRegionMapArchive::mutable_cell_range(int index) {
  return cell_range_.Mutable(index);
}
inline ::TST::CellRange* MergeRegionMapArchive::add_cell_range() {
  return cell_range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
MergeRegionMapArchive::cell_range() const {
  return cell_range_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
MergeRegionMapArchive::mutable_cell_range() {
  return &cell_range_;
}

// -------------------------------------------------------------------

// CellMapArchive_CellMapEntry

// required .TST.CellID cellID = 1;
inline bool CellMapArchive_CellMapEntry::has_cellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellMapArchive_CellMapEntry::set_has_cellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellMapArchive_CellMapEntry::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellMapArchive_CellMapEntry::clear_cellid() {
  if (cellid_ != NULL) cellid_->::TST::CellID::Clear();
  clear_has_cellid();
}
inline const ::TST::CellID& CellMapArchive_CellMapEntry::cellid() const {
  return cellid_ != NULL ? *cellid_ : *default_instance_->cellid_;
}
inline ::TST::CellID* CellMapArchive_CellMapEntry::mutable_cellid() {
  set_has_cellid();
  if (cellid_ == NULL) cellid_ = new ::TST::CellID;
  return cellid_;
}
inline ::TST::CellID* CellMapArchive_CellMapEntry::release_cellid() {
  clear_has_cellid();
  ::TST::CellID* temp = cellid_;
  cellid_ = NULL;
  return temp;
}
inline void CellMapArchive_CellMapEntry::set_allocated_cellid(::TST::CellID* cellid) {
  delete cellid_;
  cellid_ = cellid;
  if (cellid) {
    set_has_cellid();
  } else {
    clear_has_cellid();
  }
}

// optional .TST.Cell cell = 2;
inline bool CellMapArchive_CellMapEntry::has_cell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellMapArchive_CellMapEntry::set_has_cell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellMapArchive_CellMapEntry::clear_has_cell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellMapArchive_CellMapEntry::clear_cell() {
  if (cell_ != NULL) cell_->::TST::Cell::Clear();
  clear_has_cell();
}
inline const ::TST::Cell& CellMapArchive_CellMapEntry::cell() const {
  return cell_ != NULL ? *cell_ : *default_instance_->cell_;
}
inline ::TST::Cell* CellMapArchive_CellMapEntry::mutable_cell() {
  set_has_cell();
  if (cell_ == NULL) cell_ = new ::TST::Cell;
  return cell_;
}
inline ::TST::Cell* CellMapArchive_CellMapEntry::release_cell() {
  clear_has_cell();
  ::TST::Cell* temp = cell_;
  cell_ = NULL;
  return temp;
}
inline void CellMapArchive_CellMapEntry::set_allocated_cell(::TST::Cell* cell) {
  delete cell_;
  cell_ = cell;
  if (cell) {
    set_has_cell();
  } else {
    clear_has_cell();
  }
}

// -------------------------------------------------------------------

// CellMapArchive

// required uint32 capacity = 1;
inline bool CellMapArchive::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellMapArchive::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellMapArchive::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellMapArchive::clear_capacity() {
  capacity_ = 0u;
  clear_has_capacity();
}
inline ::google::protobuf::uint32 CellMapArchive::capacity() const {
  return capacity_;
}
inline void CellMapArchive::set_capacity(::google::protobuf::uint32 value) {
  set_has_capacity();
  capacity_ = value;
}

// required uint32 count = 2;
inline bool CellMapArchive::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellMapArchive::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellMapArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellMapArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CellMapArchive::count() const {
  return count_;
}
inline void CellMapArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
inline int CellMapArchive::cellmapentry_size() const {
  return cellmapentry_.size();
}
inline void CellMapArchive::clear_cellmapentry() {
  cellmapentry_.Clear();
}
inline const ::TST::CellMapArchive_CellMapEntry& CellMapArchive::cellmapentry(int index) const {
  return cellmapentry_.Get(index);
}
inline ::TST::CellMapArchive_CellMapEntry* CellMapArchive::mutable_cellmapentry(int index) {
  return cellmapentry_.Mutable(index);
}
inline ::TST::CellMapArchive_CellMapEntry* CellMapArchive::add_cellmapentry() {
  return cellmapentry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >&
CellMapArchive::cellmapentry() const {
  return cellmapentry_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >*
CellMapArchive::mutable_cellmapentry() {
  return &cellmapentry_;
}

// optional bool may_modify_formulas_in_cells = 4 [default = true];
inline bool CellMapArchive::has_may_modify_formulas_in_cells() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CellMapArchive::set_has_may_modify_formulas_in_cells() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CellMapArchive::clear_has_may_modify_formulas_in_cells() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CellMapArchive::clear_may_modify_formulas_in_cells() {
  may_modify_formulas_in_cells_ = true;
  clear_has_may_modify_formulas_in_cells();
}
inline bool CellMapArchive::may_modify_formulas_in_cells() const {
  return may_modify_formulas_in_cells_;
}
inline void CellMapArchive::set_may_modify_formulas_in_cells(bool value) {
  set_has_may_modify_formulas_in_cells();
  may_modify_formulas_in_cells_ = value;
}

// optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
inline bool CellMapArchive::has_may_modify_values_referenced_by_formulas() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CellMapArchive::set_has_may_modify_values_referenced_by_formulas() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CellMapArchive::clear_has_may_modify_values_referenced_by_formulas() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CellMapArchive::clear_may_modify_values_referenced_by_formulas() {
  may_modify_values_referenced_by_formulas_ = true;
  clear_has_may_modify_values_referenced_by_formulas();
}
inline bool CellMapArchive::may_modify_values_referenced_by_formulas() const {
  return may_modify_values_referenced_by_formulas_;
}
inline void CellMapArchive::set_may_modify_values_referenced_by_formulas(bool value) {
  set_has_may_modify_values_referenced_by_formulas();
  may_modify_values_referenced_by_formulas_ = value;
}

// optional bool applies_to_hidden = 6 [default = false];
inline bool CellMapArchive::has_applies_to_hidden() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CellMapArchive::set_has_applies_to_hidden() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CellMapArchive::clear_has_applies_to_hidden() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CellMapArchive::clear_applies_to_hidden() {
  applies_to_hidden_ = false;
  clear_has_applies_to_hidden();
}
inline bool CellMapArchive::applies_to_hidden() const {
  return applies_to_hidden_;
}
inline void CellMapArchive::set_applies_to_hidden(bool value) {
  set_has_applies_to_hidden();
  applies_to_hidden_ = value;
}

// -------------------------------------------------------------------

// DoubleStyleMapArchive_DoubleStyleMapEntryArchive

// required .TST.CellID cell_id = 1;
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::has_cell_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_has_cell_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_cell_id() {
  if (cell_id_ != NULL) cell_id_->::TST::CellID::Clear();
  clear_has_cell_id();
}
inline const ::TST::CellID& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::cell_id() const {
  return cell_id_ != NULL ? *cell_id_ : *default_instance_->cell_id_;
}
inline ::TST::CellID* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::mutable_cell_id() {
  set_has_cell_id();
  if (cell_id_ == NULL) cell_id_ = new ::TST::CellID;
  return cell_id_;
}
inline ::TST::CellID* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::release_cell_id() {
  clear_has_cell_id();
  ::TST::CellID* temp = cell_id_;
  cell_id_ = NULL;
  return temp;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_allocated_cell_id(::TST::CellID* cell_id) {
  delete cell_id_;
  cell_id_ = cell_id;
  if (cell_id) {
    set_has_cell_id();
  } else {
    clear_has_cell_id();
  }
}

// required .TSP.Reference old_style = 2;
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::has_old_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_has_old_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_has_old_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_old_style() {
  if (old_style_ != NULL) old_style_->::TSP::Reference::Clear();
  clear_has_old_style();
}
inline const ::TSP::Reference& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::old_style() const {
  return old_style_ != NULL ? *old_style_ : *default_instance_->old_style_;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::mutable_old_style() {
  set_has_old_style();
  if (old_style_ == NULL) old_style_ = new ::TSP::Reference;
  return old_style_;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::release_old_style() {
  clear_has_old_style();
  ::TSP::Reference* temp = old_style_;
  old_style_ = NULL;
  return temp;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_allocated_old_style(::TSP::Reference* old_style) {
  delete old_style_;
  old_style_ = old_style;
  if (old_style) {
    set_has_old_style();
  } else {
    clear_has_old_style();
  }
}

// required .TSP.Reference new_style = 3;
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::has_new_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_has_new_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_has_new_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_new_style() {
  if (new_style_ != NULL) new_style_->::TSP::Reference::Clear();
  clear_has_new_style();
}
inline const ::TSP::Reference& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::new_style() const {
  return new_style_ != NULL ? *new_style_ : *default_instance_->new_style_;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::mutable_new_style() {
  set_has_new_style();
  if (new_style_ == NULL) new_style_ = new ::TSP::Reference;
  return new_style_;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::release_new_style() {
  clear_has_new_style();
  ::TSP::Reference* temp = new_style_;
  new_style_ = NULL;
  return temp;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_allocated_new_style(::TSP::Reference* new_style) {
  delete new_style_;
  new_style_ = new_style;
  if (new_style) {
    set_has_new_style();
  } else {
    clear_has_new_style();
  }
}

// -------------------------------------------------------------------

// DoubleStyleMapArchive

// required uint32 capacity = 1;
inline bool DoubleStyleMapArchive::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleStyleMapArchive::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleStyleMapArchive::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleStyleMapArchive::clear_capacity() {
  capacity_ = 0u;
  clear_has_capacity();
}
inline ::google::protobuf::uint32 DoubleStyleMapArchive::capacity() const {
  return capacity_;
}
inline void DoubleStyleMapArchive::set_capacity(::google::protobuf::uint32 value) {
  set_has_capacity();
  capacity_ = value;
}

// required uint32 count = 2;
inline bool DoubleStyleMapArchive::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleStyleMapArchive::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleStyleMapArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleStyleMapArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 DoubleStyleMapArchive::count() const {
  return count_;
}
inline void DoubleStyleMapArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
inline int DoubleStyleMapArchive::cell_map_entry_size() const {
  return cell_map_entry_.size();
}
inline void DoubleStyleMapArchive::clear_cell_map_entry() {
  cell_map_entry_.Clear();
}
inline const ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive& DoubleStyleMapArchive::cell_map_entry(int index) const {
  return cell_map_entry_.Get(index);
}
inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* DoubleStyleMapArchive::mutable_cell_map_entry(int index) {
  return cell_map_entry_.Mutable(index);
}
inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* DoubleStyleMapArchive::add_cell_map_entry() {
  return cell_map_entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >&
DoubleStyleMapArchive::cell_map_entry() const {
  return cell_map_entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >*
DoubleStyleMapArchive::mutable_cell_map_entry() {
  return &cell_map_entry_;
}

// -------------------------------------------------------------------

// StyleTableMapArchive_StyleTableMapEntryArchive

// required uint32 key = 1;
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 StyleTableMapArchive_StyleTableMapEntryArchive::key() const {
  return key_;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// required .TSP.Reference old_style = 2;
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::has_old_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_has_old_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_has_old_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_old_style() {
  if (old_style_ != NULL) old_style_->::TSP::Reference::Clear();
  clear_has_old_style();
}
inline const ::TSP::Reference& StyleTableMapArchive_StyleTableMapEntryArchive::old_style() const {
  return old_style_ != NULL ? *old_style_ : *default_instance_->old_style_;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::mutable_old_style() {
  set_has_old_style();
  if (old_style_ == NULL) old_style_ = new ::TSP::Reference;
  return old_style_;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::release_old_style() {
  clear_has_old_style();
  ::TSP::Reference* temp = old_style_;
  old_style_ = NULL;
  return temp;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_allocated_old_style(::TSP::Reference* old_style) {
  delete old_style_;
  old_style_ = old_style;
  if (old_style) {
    set_has_old_style();
  } else {
    clear_has_old_style();
  }
}

// required .TSP.Reference new_style = 3;
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::has_new_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_has_new_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_has_new_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_new_style() {
  if (new_style_ != NULL) new_style_->::TSP::Reference::Clear();
  clear_has_new_style();
}
inline const ::TSP::Reference& StyleTableMapArchive_StyleTableMapEntryArchive::new_style() const {
  return new_style_ != NULL ? *new_style_ : *default_instance_->new_style_;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::mutable_new_style() {
  set_has_new_style();
  if (new_style_ == NULL) new_style_ = new ::TSP::Reference;
  return new_style_;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::release_new_style() {
  clear_has_new_style();
  ::TSP::Reference* temp = new_style_;
  new_style_ = NULL;
  return temp;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_allocated_new_style(::TSP::Reference* new_style) {
  delete new_style_;
  new_style_ = new_style;
  if (new_style) {
    set_has_new_style();
  } else {
    clear_has_new_style();
  }
}

// -------------------------------------------------------------------

// StyleTableMapArchive

// required uint32 capacity = 1;
inline bool StyleTableMapArchive::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleTableMapArchive::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleTableMapArchive::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleTableMapArchive::clear_capacity() {
  capacity_ = 0u;
  clear_has_capacity();
}
inline ::google::protobuf::uint32 StyleTableMapArchive::capacity() const {
  return capacity_;
}
inline void StyleTableMapArchive::set_capacity(::google::protobuf::uint32 value) {
  set_has_capacity();
  capacity_ = value;
}

// required uint32 count = 2;
inline bool StyleTableMapArchive::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleTableMapArchive::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleTableMapArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleTableMapArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 StyleTableMapArchive::count() const {
  return count_;
}
inline void StyleTableMapArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
inline int StyleTableMapArchive::map_entry_size() const {
  return map_entry_.size();
}
inline void StyleTableMapArchive::clear_map_entry() {
  map_entry_.Clear();
}
inline const ::TST::StyleTableMapArchive_StyleTableMapEntryArchive& StyleTableMapArchive::map_entry(int index) const {
  return map_entry_.Get(index);
}
inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* StyleTableMapArchive::mutable_map_entry(int index) {
  return map_entry_.Mutable(index);
}
inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* StyleTableMapArchive::add_map_entry() {
  return map_entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >&
StyleTableMapArchive::map_entry() const {
  return map_entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >*
StyleTableMapArchive::mutable_map_entry() {
  return &map_entry_;
}

// -------------------------------------------------------------------

// SelectionArchive

// optional .TSP.Reference tableModel = 1 [deprecated = true];
inline bool SelectionArchive::has_tablemodel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectionArchive::set_has_tablemodel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectionArchive::clear_has_tablemodel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectionArchive::clear_tablemodel() {
  if (tablemodel_ != NULL) tablemodel_->::TSP::Reference::Clear();
  clear_has_tablemodel();
}
inline const ::TSP::Reference& SelectionArchive::tablemodel() const {
  return tablemodel_ != NULL ? *tablemodel_ : *default_instance_->tablemodel_;
}
inline ::TSP::Reference* SelectionArchive::mutable_tablemodel() {
  set_has_tablemodel();
  if (tablemodel_ == NULL) tablemodel_ = new ::TSP::Reference;
  return tablemodel_;
}
inline ::TSP::Reference* SelectionArchive::release_tablemodel() {
  clear_has_tablemodel();
  ::TSP::Reference* temp = tablemodel_;
  tablemodel_ = NULL;
  return temp;
}
inline void SelectionArchive::set_allocated_tablemodel(::TSP::Reference* tablemodel) {
  delete tablemodel_;
  tablemodel_ = tablemodel;
  if (tablemodel) {
    set_has_tablemodel();
  } else {
    clear_has_tablemodel();
  }
}

// required .TST.SelectionTypeArchive selection_type = 4;
inline bool SelectionArchive::has_selection_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectionArchive::set_has_selection_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectionArchive::clear_has_selection_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectionArchive::clear_selection_type() {
  selection_type_ = 0;
  clear_has_selection_type();
}
inline ::TST::SelectionTypeArchive SelectionArchive::selection_type() const {
  return static_cast< ::TST::SelectionTypeArchive >(selection_type_);
}
inline void SelectionArchive::set_selection_type(::TST::SelectionTypeArchive value) {
  assert(::TST::SelectionTypeArchive_IsValid(value));
  set_has_selection_type();
  selection_type_ = value;
}

// optional .TST.CellID anchor_cell = 5;
inline bool SelectionArchive::has_anchor_cell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelectionArchive::set_has_anchor_cell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelectionArchive::clear_has_anchor_cell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelectionArchive::clear_anchor_cell() {
  if (anchor_cell_ != NULL) anchor_cell_->::TST::CellID::Clear();
  clear_has_anchor_cell();
}
inline const ::TST::CellID& SelectionArchive::anchor_cell() const {
  return anchor_cell_ != NULL ? *anchor_cell_ : *default_instance_->anchor_cell_;
}
inline ::TST::CellID* SelectionArchive::mutable_anchor_cell() {
  set_has_anchor_cell();
  if (anchor_cell_ == NULL) anchor_cell_ = new ::TST::CellID;
  return anchor_cell_;
}
inline ::TST::CellID* SelectionArchive::release_anchor_cell() {
  clear_has_anchor_cell();
  ::TST::CellID* temp = anchor_cell_;
  anchor_cell_ = NULL;
  return temp;
}
inline void SelectionArchive::set_allocated_anchor_cell(::TST::CellID* anchor_cell) {
  delete anchor_cell_;
  anchor_cell_ = anchor_cell;
  if (anchor_cell) {
    set_has_anchor_cell();
  } else {
    clear_has_anchor_cell();
  }
}

// repeated .TST.CellRange cell_ranges = 6;
inline int SelectionArchive::cell_ranges_size() const {
  return cell_ranges_.size();
}
inline void SelectionArchive::clear_cell_ranges() {
  cell_ranges_.Clear();
}
inline const ::TST::CellRange& SelectionArchive::cell_ranges(int index) const {
  return cell_ranges_.Get(index);
}
inline ::TST::CellRange* SelectionArchive::mutable_cell_ranges(int index) {
  return cell_ranges_.Mutable(index);
}
inline ::TST::CellRange* SelectionArchive::add_cell_ranges() {
  return cell_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
SelectionArchive::cell_ranges() const {
  return cell_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
SelectionArchive::mutable_cell_ranges() {
  return &cell_ranges_;
}

// repeated .TST.CellRange base_ranges = 7;
inline int SelectionArchive::base_ranges_size() const {
  return base_ranges_.size();
}
inline void SelectionArchive::clear_base_ranges() {
  base_ranges_.Clear();
}
inline const ::TST::CellRange& SelectionArchive::base_ranges(int index) const {
  return base_ranges_.Get(index);
}
inline ::TST::CellRange* SelectionArchive::mutable_base_ranges(int index) {
  return base_ranges_.Mutable(index);
}
inline ::TST::CellRange* SelectionArchive::add_base_ranges() {
  return base_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
SelectionArchive::base_ranges() const {
  return base_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
SelectionArchive::mutable_base_ranges() {
  return &base_ranges_;
}

// optional .TST.CellID cursor_cell = 8;
inline bool SelectionArchive::has_cursor_cell() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SelectionArchive::set_has_cursor_cell() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SelectionArchive::clear_has_cursor_cell() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SelectionArchive::clear_cursor_cell() {
  if (cursor_cell_ != NULL) cursor_cell_->::TST::CellID::Clear();
  clear_has_cursor_cell();
}
inline const ::TST::CellID& SelectionArchive::cursor_cell() const {
  return cursor_cell_ != NULL ? *cursor_cell_ : *default_instance_->cursor_cell_;
}
inline ::TST::CellID* SelectionArchive::mutable_cursor_cell() {
  set_has_cursor_cell();
  if (cursor_cell_ == NULL) cursor_cell_ = new ::TST::CellID;
  return cursor_cell_;
}
inline ::TST::CellID* SelectionArchive::release_cursor_cell() {
  clear_has_cursor_cell();
  ::TST::CellID* temp = cursor_cell_;
  cursor_cell_ = NULL;
  return temp;
}
inline void SelectionArchive::set_allocated_cursor_cell(::TST::CellID* cursor_cell) {
  delete cursor_cell_;
  cursor_cell_ = cursor_cell;
  if (cursor_cell) {
    set_has_cursor_cell();
  } else {
    clear_has_cursor_cell();
  }
}

// -------------------------------------------------------------------

// FilterRuleArchive

// required .TST.FormulaPredicateArchive predicate = 1;
inline bool FilterRuleArchive::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterRuleArchive::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterRuleArchive::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterRuleArchive::clear_predicate() {
  if (predicate_ != NULL) predicate_->::TST::FormulaPredicateArchive::Clear();
  clear_has_predicate();
}
inline const ::TST::FormulaPredicateArchive& FilterRuleArchive::predicate() const {
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::TST::FormulaPredicateArchive* FilterRuleArchive::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::TST::FormulaPredicateArchive;
  return predicate_;
}
inline ::TST::FormulaPredicateArchive* FilterRuleArchive::release_predicate() {
  clear_has_predicate();
  ::TST::FormulaPredicateArchive* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void FilterRuleArchive::set_allocated_predicate(::TST::FormulaPredicateArchive* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
}

// optional bool disabled = 2;
inline bool FilterRuleArchive::has_disabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterRuleArchive::set_has_disabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterRuleArchive::clear_has_disabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterRuleArchive::clear_disabled() {
  disabled_ = false;
  clear_has_disabled();
}
inline bool FilterRuleArchive::disabled() const {
  return disabled_;
}
inline void FilterRuleArchive::set_disabled(bool value) {
  set_has_disabled();
  disabled_ = value;
}

// -------------------------------------------------------------------

// TableStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool TableStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& TableStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* TableStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* TableStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TableStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool TableStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 TableStyleArchive::override_count() const {
  return override_count_;
}
inline void TableStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TST.TableStylePropertiesArchive table_properties = 11;
inline bool TableStyleArchive::has_table_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableStyleArchive::set_has_table_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableStyleArchive::clear_has_table_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableStyleArchive::clear_table_properties() {
  if (table_properties_ != NULL) table_properties_->::TST::TableStylePropertiesArchive::Clear();
  clear_has_table_properties();
}
inline const ::TST::TableStylePropertiesArchive& TableStyleArchive::table_properties() const {
  return table_properties_ != NULL ? *table_properties_ : *default_instance_->table_properties_;
}
inline ::TST::TableStylePropertiesArchive* TableStyleArchive::mutable_table_properties() {
  set_has_table_properties();
  if (table_properties_ == NULL) table_properties_ = new ::TST::TableStylePropertiesArchive;
  return table_properties_;
}
inline ::TST::TableStylePropertiesArchive* TableStyleArchive::release_table_properties() {
  clear_has_table_properties();
  ::TST::TableStylePropertiesArchive* temp = table_properties_;
  table_properties_ = NULL;
  return temp;
}
inline void TableStyleArchive::set_allocated_table_properties(::TST::TableStylePropertiesArchive* table_properties) {
  delete table_properties_;
  table_properties_ = table_properties;
  if (table_properties) {
    set_has_table_properties();
  } else {
    clear_has_table_properties();
  }
}

// -------------------------------------------------------------------

// CellStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool CellStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& CellStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* CellStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* CellStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CellStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool CellStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 CellStyleArchive::override_count() const {
  return override_count_;
}
inline void CellStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TST.CellStylePropertiesArchive cell_properties = 11;
inline bool CellStyleArchive::has_cell_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellStyleArchive::set_has_cell_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellStyleArchive::clear_has_cell_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellStyleArchive::clear_cell_properties() {
  if (cell_properties_ != NULL) cell_properties_->::TST::CellStylePropertiesArchive::Clear();
  clear_has_cell_properties();
}
inline const ::TST::CellStylePropertiesArchive& CellStyleArchive::cell_properties() const {
  return cell_properties_ != NULL ? *cell_properties_ : *default_instance_->cell_properties_;
}
inline ::TST::CellStylePropertiesArchive* CellStyleArchive::mutable_cell_properties() {
  set_has_cell_properties();
  if (cell_properties_ == NULL) cell_properties_ = new ::TST::CellStylePropertiesArchive;
  return cell_properties_;
}
inline ::TST::CellStylePropertiesArchive* CellStyleArchive::release_cell_properties() {
  clear_has_cell_properties();
  ::TST::CellStylePropertiesArchive* temp = cell_properties_;
  cell_properties_ = NULL;
  return temp;
}
inline void CellStyleArchive::set_allocated_cell_properties(::TST::CellStylePropertiesArchive* cell_properties) {
  delete cell_properties_;
  cell_properties_ = cell_properties;
  if (cell_properties) {
    set_has_cell_properties();
  } else {
    clear_has_cell_properties();
  }
}

// -------------------------------------------------------------------

// FormulaPredicateArchive

// required .TSCE.FormulaArchive formula = 1;
inline bool FormulaPredicateArchive::has_formula() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaPredicateArchive::set_has_formula() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaPredicateArchive::clear_has_formula() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaPredicateArchive::clear_formula() {
  if (formula_ != NULL) formula_->::TSCE::FormulaArchive::Clear();
  clear_has_formula();
}
inline const ::TSCE::FormulaArchive& FormulaPredicateArchive::formula() const {
  return formula_ != NULL ? *formula_ : *default_instance_->formula_;
}
inline ::TSCE::FormulaArchive* FormulaPredicateArchive::mutable_formula() {
  set_has_formula();
  if (formula_ == NULL) formula_ = new ::TSCE::FormulaArchive;
  return formula_;
}
inline ::TSCE::FormulaArchive* FormulaPredicateArchive::release_formula() {
  clear_has_formula();
  ::TSCE::FormulaArchive* temp = formula_;
  formula_ = NULL;
  return temp;
}
inline void FormulaPredicateArchive::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  delete formula_;
  formula_ = formula;
  if (formula) {
    set_has_formula();
  } else {
    clear_has_formula();
  }
}

// required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
inline bool FormulaPredicateArchive::has_predicate_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaPredicateArchive::set_has_predicate_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaPredicateArchive::clear_has_predicate_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaPredicateArchive::clear_predicate_type() {
  predicate_type_ = 0;
  clear_has_predicate_type();
}
inline ::TST::FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::predicate_type() const {
  return static_cast< ::TST::FormulaPredicateArchive_FormulaPredicateType >(predicate_type_);
}
inline void FormulaPredicateArchive::set_predicate_type(::TST::FormulaPredicateArchive_FormulaPredicateType value) {
  assert(::TST::FormulaPredicateArchive_FormulaPredicateType_IsValid(value));
  set_has_predicate_type();
  predicate_type_ = value;
}

// required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
inline bool FormulaPredicateArchive::has_qualifier1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormulaPredicateArchive::set_has_qualifier1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormulaPredicateArchive::clear_has_qualifier1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormulaPredicateArchive::clear_qualifier1() {
  qualifier1_ = 0;
  clear_has_qualifier1();
}
inline ::TST::FormulaPredicateArchive_QualifierType FormulaPredicateArchive::qualifier1() const {
  return static_cast< ::TST::FormulaPredicateArchive_QualifierType >(qualifier1_);
}
inline void FormulaPredicateArchive::set_qualifier1(::TST::FormulaPredicateArchive_QualifierType value) {
  assert(::TST::FormulaPredicateArchive_QualifierType_IsValid(value));
  set_has_qualifier1();
  qualifier1_ = value;
}

// required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
inline bool FormulaPredicateArchive::has_qualifier2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormulaPredicateArchive::set_has_qualifier2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormulaPredicateArchive::clear_has_qualifier2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormulaPredicateArchive::clear_qualifier2() {
  qualifier2_ = 0;
  clear_has_qualifier2();
}
inline ::TST::FormulaPredicateArchive_QualifierType FormulaPredicateArchive::qualifier2() const {
  return static_cast< ::TST::FormulaPredicateArchive_QualifierType >(qualifier2_);
}
inline void FormulaPredicateArchive::set_qualifier2(::TST::FormulaPredicateArchive_QualifierType value) {
  assert(::TST::FormulaPredicateArchive_QualifierType_IsValid(value));
  set_has_qualifier2();
  qualifier2_ = value;
}

// required int32 param_index1 = 5;
inline bool FormulaPredicateArchive::has_param_index1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormulaPredicateArchive::set_has_param_index1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormulaPredicateArchive::clear_has_param_index1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormulaPredicateArchive::clear_param_index1() {
  param_index1_ = 0;
  clear_has_param_index1();
}
inline ::google::protobuf::int32 FormulaPredicateArchive::param_index1() const {
  return param_index1_;
}
inline void FormulaPredicateArchive::set_param_index1(::google::protobuf::int32 value) {
  set_has_param_index1();
  param_index1_ = value;
}

// required int32 param_index2 = 6;
inline bool FormulaPredicateArchive::has_param_index2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormulaPredicateArchive::set_has_param_index2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormulaPredicateArchive::clear_has_param_index2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormulaPredicateArchive::clear_param_index2() {
  param_index2_ = 0;
  clear_has_param_index2();
}
inline ::google::protobuf::int32 FormulaPredicateArchive::param_index2() const {
  return param_index2_;
}
inline void FormulaPredicateArchive::set_param_index2(::google::protobuf::int32 value) {
  set_has_param_index2();
  param_index2_ = value;
}

// required int32 param_index0 = 7;
inline bool FormulaPredicateArchive::has_param_index0() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormulaPredicateArchive::set_has_param_index0() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormulaPredicateArchive::clear_has_param_index0() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormulaPredicateArchive::clear_param_index0() {
  param_index0_ = 0;
  clear_has_param_index0();
}
inline ::google::protobuf::int32 FormulaPredicateArchive::param_index0() const {
  return param_index0_;
}
inline void FormulaPredicateArchive::set_param_index0(::google::protobuf::int32 value) {
  set_has_param_index0();
  param_index0_ = value;
}

// -------------------------------------------------------------------

// ConditionalStyleSetArchive_ConditionalStyleRule

// required .TST.FormulaPredicateArchive predicate = 1;
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_predicate() {
  if (predicate_ != NULL) predicate_->::TST::FormulaPredicateArchive::Clear();
  clear_has_predicate();
}
inline const ::TST::FormulaPredicateArchive& ConditionalStyleSetArchive_ConditionalStyleRule::predicate() const {
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::TST::FormulaPredicateArchive* ConditionalStyleSetArchive_ConditionalStyleRule::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::TST::FormulaPredicateArchive;
  return predicate_;
}
inline ::TST::FormulaPredicateArchive* ConditionalStyleSetArchive_ConditionalStyleRule::release_predicate() {
  clear_has_predicate();
  ::TST::FormulaPredicateArchive* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_allocated_predicate(::TST::FormulaPredicateArchive* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
}

// required .TSP.Reference cell_style = 2;
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::has_cell_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_has_cell_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_has_cell_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_cell_style() {
  if (cell_style_ != NULL) cell_style_->::TSP::Reference::Clear();
  clear_has_cell_style();
}
inline const ::TSP::Reference& ConditionalStyleSetArchive_ConditionalStyleRule::cell_style() const {
  return cell_style_ != NULL ? *cell_style_ : *default_instance_->cell_style_;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::mutable_cell_style() {
  set_has_cell_style();
  if (cell_style_ == NULL) cell_style_ = new ::TSP::Reference;
  return cell_style_;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::release_cell_style() {
  clear_has_cell_style();
  ::TSP::Reference* temp = cell_style_;
  cell_style_ = NULL;
  return temp;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_allocated_cell_style(::TSP::Reference* cell_style) {
  delete cell_style_;
  cell_style_ = cell_style;
  if (cell_style) {
    set_has_cell_style();
  } else {
    clear_has_cell_style();
  }
}

// required .TSP.Reference text_style = 3;
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::has_text_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_has_text_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_has_text_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_text_style() {
  if (text_style_ != NULL) text_style_->::TSP::Reference::Clear();
  clear_has_text_style();
}
inline const ::TSP::Reference& ConditionalStyleSetArchive_ConditionalStyleRule::text_style() const {
  return text_style_ != NULL ? *text_style_ : *default_instance_->text_style_;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::mutable_text_style() {
  set_has_text_style();
  if (text_style_ == NULL) text_style_ = new ::TSP::Reference;
  return text_style_;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::release_text_style() {
  clear_has_text_style();
  ::TSP::Reference* temp = text_style_;
  text_style_ = NULL;
  return temp;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_allocated_text_style(::TSP::Reference* text_style) {
  delete text_style_;
  text_style_ = text_style;
  if (text_style) {
    set_has_text_style();
  } else {
    clear_has_text_style();
  }
}

// -------------------------------------------------------------------

// ConditionalStyleSetArchive

// required uint32 ruleCount = 1;
inline bool ConditionalStyleSetArchive::has_rulecount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalStyleSetArchive::set_has_rulecount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalStyleSetArchive::clear_has_rulecount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalStyleSetArchive::clear_rulecount() {
  rulecount_ = 0u;
  clear_has_rulecount();
}
inline ::google::protobuf::uint32 ConditionalStyleSetArchive::rulecount() const {
  return rulecount_;
}
inline void ConditionalStyleSetArchive::set_rulecount(::google::protobuf::uint32 value) {
  set_has_rulecount();
  rulecount_ = value;
}

// repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
inline int ConditionalStyleSetArchive::rules_size() const {
  return rules_.size();
}
inline void ConditionalStyleSetArchive::clear_rules() {
  rules_.Clear();
}
inline const ::TST::ConditionalStyleSetArchive_ConditionalStyleRule& ConditionalStyleSetArchive::rules(int index) const {
  return rules_.Get(index);
}
inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* ConditionalStyleSetArchive::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* ConditionalStyleSetArchive::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >&
ConditionalStyleSetArchive::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >*
ConditionalStyleSetArchive::mutable_rules() {
  return &rules_;
}

// optional .TST.CellID cellID = 3;
inline bool ConditionalStyleSetArchive::has_cellid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConditionalStyleSetArchive::set_has_cellid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConditionalStyleSetArchive::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConditionalStyleSetArchive::clear_cellid() {
  if (cellid_ != NULL) cellid_->::TST::CellID::Clear();
  clear_has_cellid();
}
inline const ::TST::CellID& ConditionalStyleSetArchive::cellid() const {
  return cellid_ != NULL ? *cellid_ : *default_instance_->cellid_;
}
inline ::TST::CellID* ConditionalStyleSetArchive::mutable_cellid() {
  set_has_cellid();
  if (cellid_ == NULL) cellid_ = new ::TST::CellID;
  return cellid_;
}
inline ::TST::CellID* ConditionalStyleSetArchive::release_cellid() {
  clear_has_cellid();
  ::TST::CellID* temp = cellid_;
  cellid_ = NULL;
  return temp;
}
inline void ConditionalStyleSetArchive::set_allocated_cellid(::TST::CellID* cellid) {
  delete cellid_;
  cellid_ = cellid;
  if (cellid) {
    set_has_cellid();
  } else {
    clear_has_cellid();
  }
}

// -------------------------------------------------------------------

// FilterSetArchive

// optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
inline bool FilterSetArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterSetArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterSetArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterSetArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TST::FilterSetArchive_FilterSetType FilterSetArchive::type() const {
  return static_cast< ::TST::FilterSetArchive_FilterSetType >(type_);
}
inline void FilterSetArchive::set_type(::TST::FilterSetArchive_FilterSetType value) {
  assert(::TST::FilterSetArchive_FilterSetType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool is_enabled = 2 [default = true];
inline bool FilterSetArchive::has_is_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterSetArchive::set_has_is_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterSetArchive::clear_has_is_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterSetArchive::clear_is_enabled() {
  is_enabled_ = true;
  clear_has_is_enabled();
}
inline bool FilterSetArchive::is_enabled() const {
  return is_enabled_;
}
inline void FilterSetArchive::set_is_enabled(bool value) {
  set_has_is_enabled();
  is_enabled_ = value;
}

// repeated .TST.FilterRuleArchive filter_rules = 3;
inline int FilterSetArchive::filter_rules_size() const {
  return filter_rules_.size();
}
inline void FilterSetArchive::clear_filter_rules() {
  filter_rules_.Clear();
}
inline const ::TST::FilterRuleArchive& FilterSetArchive::filter_rules(int index) const {
  return filter_rules_.Get(index);
}
inline ::TST::FilterRuleArchive* FilterSetArchive::mutable_filter_rules(int index) {
  return filter_rules_.Mutable(index);
}
inline ::TST::FilterRuleArchive* FilterSetArchive::add_filter_rules() {
  return filter_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >&
FilterSetArchive::filter_rules() const {
  return filter_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >*
FilterSetArchive::mutable_filter_rules() {
  return &filter_rules_;
}

// optional bool needs_formula_rewrite_for_import = 4 [default = false];
inline bool FilterSetArchive::has_needs_formula_rewrite_for_import() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterSetArchive::set_has_needs_formula_rewrite_for_import() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterSetArchive::clear_has_needs_formula_rewrite_for_import() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterSetArchive::clear_needs_formula_rewrite_for_import() {
  needs_formula_rewrite_for_import_ = false;
  clear_has_needs_formula_rewrite_for_import();
}
inline bool FilterSetArchive::needs_formula_rewrite_for_import() const {
  return needs_formula_rewrite_for_import_;
}
inline void FilterSetArchive::set_needs_formula_rewrite_for_import(bool value) {
  set_has_needs_formula_rewrite_for_import();
  needs_formula_rewrite_for_import_ = value;
}

// repeated uint32 filter_offsets = 5;
inline int FilterSetArchive::filter_offsets_size() const {
  return filter_offsets_.size();
}
inline void FilterSetArchive::clear_filter_offsets() {
  filter_offsets_.Clear();
}
inline ::google::protobuf::uint32 FilterSetArchive::filter_offsets(int index) const {
  return filter_offsets_.Get(index);
}
inline void FilterSetArchive::set_filter_offsets(int index, ::google::protobuf::uint32 value) {
  filter_offsets_.Set(index, value);
}
inline void FilterSetArchive::add_filter_offsets(::google::protobuf::uint32 value) {
  filter_offsets_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FilterSetArchive::filter_offsets() const {
  return filter_offsets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FilterSetArchive::mutable_filter_offsets() {
  return &filter_offsets_;
}

// repeated bool filter_enabled = 6;
inline int FilterSetArchive::filter_enabled_size() const {
  return filter_enabled_.size();
}
inline void FilterSetArchive::clear_filter_enabled() {
  filter_enabled_.Clear();
}
inline bool FilterSetArchive::filter_enabled(int index) const {
  return filter_enabled_.Get(index);
}
inline void FilterSetArchive::set_filter_enabled(int index, bool value) {
  filter_enabled_.Set(index, value);
}
inline void FilterSetArchive::add_filter_enabled(bool value) {
  filter_enabled_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
FilterSetArchive::filter_enabled() const {
  return filter_enabled_;
}
inline ::google::protobuf::RepeatedField< bool >*
FilterSetArchive::mutable_filter_enabled() {
  return &filter_enabled_;
}

// -------------------------------------------------------------------

// TokenAttachmentArchive

// required .TSWP.UIGraphicalAttachment super = 1;
inline bool TokenAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::UIGraphicalAttachment::Clear();
  clear_has_super();
}
inline const ::TSWP::UIGraphicalAttachment& TokenAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::UIGraphicalAttachment* TokenAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::UIGraphicalAttachment;
  return super_;
}
inline ::TSWP::UIGraphicalAttachment* TokenAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::UIGraphicalAttachment* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TokenAttachmentArchive::set_allocated_super(::TSWP::UIGraphicalAttachment* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference expressionNode = 2;
inline bool TokenAttachmentArchive::has_expressionnode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenAttachmentArchive::set_has_expressionnode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenAttachmentArchive::clear_has_expressionnode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenAttachmentArchive::clear_expressionnode() {
  if (expressionnode_ != NULL) expressionnode_->::TSP::Reference::Clear();
  clear_has_expressionnode();
}
inline const ::TSP::Reference& TokenAttachmentArchive::expressionnode() const {
  return expressionnode_ != NULL ? *expressionnode_ : *default_instance_->expressionnode_;
}
inline ::TSP::Reference* TokenAttachmentArchive::mutable_expressionnode() {
  set_has_expressionnode();
  if (expressionnode_ == NULL) expressionnode_ = new ::TSP::Reference;
  return expressionnode_;
}
inline ::TSP::Reference* TokenAttachmentArchive::release_expressionnode() {
  clear_has_expressionnode();
  ::TSP::Reference* temp = expressionnode_;
  expressionnode_ = NULL;
  return temp;
}
inline void TokenAttachmentArchive::set_allocated_expressionnode(::TSP::Reference* expressionnode) {
  delete expressionnode_;
  expressionnode_ = expressionnode;
  if (expressionnode) {
    set_has_expressionnode();
  } else {
    clear_has_expressionnode();
  }
}

// -------------------------------------------------------------------

// FormulaArchive

// optional .TSP.Reference expressionTree = 1;
inline bool FormulaArchive::has_expressiontree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaArchive::set_has_expressiontree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaArchive::clear_has_expressiontree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaArchive::clear_expressiontree() {
  if (expressiontree_ != NULL) expressiontree_->::TSP::Reference::Clear();
  clear_has_expressiontree();
}
inline const ::TSP::Reference& FormulaArchive::expressiontree() const {
  return expressiontree_ != NULL ? *expressiontree_ : *default_instance_->expressiontree_;
}
inline ::TSP::Reference* FormulaArchive::mutable_expressiontree() {
  set_has_expressiontree();
  if (expressiontree_ == NULL) expressiontree_ = new ::TSP::Reference;
  return expressiontree_;
}
inline ::TSP::Reference* FormulaArchive::release_expressiontree() {
  clear_has_expressiontree();
  ::TSP::Reference* temp = expressiontree_;
  expressiontree_ = NULL;
  return temp;
}
inline void FormulaArchive::set_allocated_expressiontree(::TSP::Reference* expressiontree) {
  delete expressiontree_;
  expressiontree_ = expressiontree;
  if (expressiontree) {
    set_has_expressiontree();
  } else {
    clear_has_expressiontree();
  }
}

// -------------------------------------------------------------------

// ExpressionNodeArchive

// repeated .TSP.Reference children = 1;
inline int ExpressionNodeArchive::children_size() const {
  return children_.size();
}
inline void ExpressionNodeArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& ExpressionNodeArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* ExpressionNodeArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* ExpressionNodeArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ExpressionNodeArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ExpressionNodeArchive::mutable_children() {
  return &children_;
}

// optional uint64 first_index = 2 [default = 0];
inline bool ExpressionNodeArchive::has_first_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExpressionNodeArchive::set_has_first_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExpressionNodeArchive::clear_has_first_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExpressionNodeArchive::clear_first_index() {
  first_index_ = GOOGLE_ULONGLONG(0);
  clear_has_first_index();
}
inline ::google::protobuf::uint64 ExpressionNodeArchive::first_index() const {
  return first_index_;
}
inline void ExpressionNodeArchive::set_first_index(::google::protobuf::uint64 value) {
  set_has_first_index();
  first_index_ = value;
}

// optional uint64 last_index = 3 [default = 0];
inline bool ExpressionNodeArchive::has_last_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExpressionNodeArchive::set_has_last_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExpressionNodeArchive::clear_has_last_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExpressionNodeArchive::clear_last_index() {
  last_index_ = GOOGLE_ULONGLONG(0);
  clear_has_last_index();
}
inline ::google::protobuf::uint64 ExpressionNodeArchive::last_index() const {
  return last_index_;
}
inline void ExpressionNodeArchive::set_last_index(::google::protobuf::uint64 value) {
  set_has_last_index();
  last_index_ = value;
}

// -------------------------------------------------------------------

// BooleanNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool BooleanNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BooleanNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BooleanNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BooleanNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& BooleanNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* BooleanNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* BooleanNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void BooleanNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool value = 2;
inline bool BooleanNodeArchive::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BooleanNodeArchive::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BooleanNodeArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BooleanNodeArchive::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool BooleanNodeArchive::value() const {
  return value_;
}
inline void BooleanNodeArchive::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// NumberNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool NumberNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumberNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumberNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumberNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& NumberNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* NumberNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* NumberNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void NumberNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required double number = 2;
inline bool NumberNodeArchive::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NumberNodeArchive::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NumberNodeArchive::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NumberNodeArchive::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline double NumberNodeArchive::number() const {
  return number_;
}
inline void NumberNodeArchive::set_number(double value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// StringNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool StringNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& StringNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* StringNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* StringNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StringNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required string value = 2;
inline bool StringNodeArchive::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringNodeArchive::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringNodeArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringNodeArchive::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StringNodeArchive::value() const {
  return *value_;
}
inline void StringNodeArchive::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StringNodeArchive::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StringNodeArchive::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringNodeArchive::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* StringNodeArchive::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StringNodeArchive::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IdentifierNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool IdentifierNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdentifierNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdentifierNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdentifierNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& IdentifierNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* IdentifierNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* IdentifierNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void IdentifierNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string identifier = 2;
inline bool IdentifierNodeArchive::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdentifierNodeArchive::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdentifierNodeArchive::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdentifierNodeArchive::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& IdentifierNodeArchive::identifier() const {
  return *identifier_;
}
inline void IdentifierNodeArchive::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void IdentifierNodeArchive::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void IdentifierNodeArchive::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentifierNodeArchive::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* IdentifierNodeArchive::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentifierNodeArchive::set_allocated_identifier(::std::string* identifier) {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_;
  }
  if (identifier) {
    set_has_identifier();
    identifier_ = identifier;
  } else {
    clear_has_identifier();
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ArrayNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ArrayNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArrayNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArrayNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArrayNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& ArrayNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* ArrayNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* ArrayNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ArrayNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 columns = 2;
inline bool ArrayNodeArchive::has_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArrayNodeArchive::set_has_columns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArrayNodeArchive::clear_has_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArrayNodeArchive::clear_columns() {
  columns_ = 0u;
  clear_has_columns();
}
inline ::google::protobuf::uint32 ArrayNodeArchive::columns() const {
  return columns_;
}
inline void ArrayNodeArchive::set_columns(::google::protobuf::uint32 value) {
  set_has_columns();
  columns_ = value;
}

// optional uint32 rows = 3;
inline bool ArrayNodeArchive::has_rows() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArrayNodeArchive::set_has_rows() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArrayNodeArchive::clear_has_rows() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArrayNodeArchive::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 ArrayNodeArchive::rows() const {
  return rows_;
}
inline void ArrayNodeArchive::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
}

// -------------------------------------------------------------------

// ListNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ListNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& ListNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* ListNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* ListNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ListNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// OperatorNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool OperatorNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperatorNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperatorNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperatorNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& OperatorNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* OperatorNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* OperatorNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void OperatorNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 operatorChar = 2;
inline bool OperatorNodeArchive::has_operatorchar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperatorNodeArchive::set_has_operatorchar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperatorNodeArchive::clear_has_operatorchar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperatorNodeArchive::clear_operatorchar() {
  operatorchar_ = 0u;
  clear_has_operatorchar();
}
inline ::google::protobuf::uint32 OperatorNodeArchive::operatorchar() const {
  return operatorchar_;
}
inline void OperatorNodeArchive::set_operatorchar(::google::protobuf::uint32 value) {
  set_has_operatorchar();
  operatorchar_ = value;
}

// -------------------------------------------------------------------

// PostfixOperatorNodeArchive

// required .TST.OperatorNodeArchive super = 1;
inline bool PostfixOperatorNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostfixOperatorNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostfixOperatorNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostfixOperatorNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::OperatorNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::OperatorNodeArchive& PostfixOperatorNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::OperatorNodeArchive* PostfixOperatorNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::OperatorNodeArchive;
  return super_;
}
inline ::TST::OperatorNodeArchive* PostfixOperatorNodeArchive::release_super() {
  clear_has_super();
  ::TST::OperatorNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PostfixOperatorNodeArchive::set_allocated_super(::TST::OperatorNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// PrefixOperatorNodeArchive

// required .TST.OperatorNodeArchive super = 1;
inline bool PrefixOperatorNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrefixOperatorNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrefixOperatorNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrefixOperatorNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::OperatorNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::OperatorNodeArchive& PrefixOperatorNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::OperatorNodeArchive* PrefixOperatorNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::OperatorNodeArchive;
  return super_;
}
inline ::TST::OperatorNodeArchive* PrefixOperatorNodeArchive::release_super() {
  clear_has_super();
  ::TST::OperatorNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PrefixOperatorNodeArchive::set_allocated_super(::TST::OperatorNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// FunctionNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool FunctionNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& FunctionNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* FunctionNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* FunctionNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FunctionNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 functionIndex = 2;
inline bool FunctionNodeArchive::has_functionindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionNodeArchive::set_has_functionindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionNodeArchive::clear_has_functionindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionNodeArchive::clear_functionindex() {
  functionindex_ = 0u;
  clear_has_functionindex();
}
inline ::google::protobuf::uint32 FunctionNodeArchive::functionindex() const {
  return functionindex_;
}
inline void FunctionNodeArchive::set_functionindex(::google::protobuf::uint32 value) {
  set_has_functionindex();
  functionindex_ = value;
}

// optional string invalidFunctionName = 3;
inline bool FunctionNodeArchive::has_invalidfunctionname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionNodeArchive::set_has_invalidfunctionname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionNodeArchive::clear_has_invalidfunctionname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionNodeArchive::clear_invalidfunctionname() {
  if (invalidfunctionname_ != &::google::protobuf::internal::kEmptyString) {
    invalidfunctionname_->clear();
  }
  clear_has_invalidfunctionname();
}
inline const ::std::string& FunctionNodeArchive::invalidfunctionname() const {
  return *invalidfunctionname_;
}
inline void FunctionNodeArchive::set_invalidfunctionname(const ::std::string& value) {
  set_has_invalidfunctionname();
  if (invalidfunctionname_ == &::google::protobuf::internal::kEmptyString) {
    invalidfunctionname_ = new ::std::string;
  }
  invalidfunctionname_->assign(value);
}
inline void FunctionNodeArchive::set_invalidfunctionname(const char* value) {
  set_has_invalidfunctionname();
  if (invalidfunctionname_ == &::google::protobuf::internal::kEmptyString) {
    invalidfunctionname_ = new ::std::string;
  }
  invalidfunctionname_->assign(value);
}
inline void FunctionNodeArchive::set_invalidfunctionname(const char* value, size_t size) {
  set_has_invalidfunctionname();
  if (invalidfunctionname_ == &::google::protobuf::internal::kEmptyString) {
    invalidfunctionname_ = new ::std::string;
  }
  invalidfunctionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionNodeArchive::mutable_invalidfunctionname() {
  set_has_invalidfunctionname();
  if (invalidfunctionname_ == &::google::protobuf::internal::kEmptyString) {
    invalidfunctionname_ = new ::std::string;
  }
  return invalidfunctionname_;
}
inline ::std::string* FunctionNodeArchive::release_invalidfunctionname() {
  clear_has_invalidfunctionname();
  if (invalidfunctionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invalidfunctionname_;
    invalidfunctionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FunctionNodeArchive::set_allocated_invalidfunctionname(::std::string* invalidfunctionname) {
  if (invalidfunctionname_ != &::google::protobuf::internal::kEmptyString) {
    delete invalidfunctionname_;
  }
  if (invalidfunctionname) {
    set_has_invalidfunctionname();
    invalidfunctionname_ = invalidfunctionname;
  } else {
    clear_has_invalidfunctionname();
    invalidfunctionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FunctionEndNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool FunctionEndNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionEndNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionEndNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionEndNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& FunctionEndNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* FunctionEndNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* FunctionEndNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FunctionEndNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// DateNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool DateNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& DateNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* DateNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* DateNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DateNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required string value = 2;
inline bool DateNodeArchive::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateNodeArchive::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateNodeArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateNodeArchive::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DateNodeArchive::value() const {
  return *value_;
}
inline void DateNodeArchive::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DateNodeArchive::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DateNodeArchive::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DateNodeArchive::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* DateNodeArchive::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DateNodeArchive::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string format = 3;
inline bool DateNodeArchive::has_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DateNodeArchive::set_has_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DateNodeArchive::clear_has_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DateNodeArchive::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& DateNodeArchive::format() const {
  return *format_;
}
inline void DateNodeArchive::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void DateNodeArchive::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void DateNodeArchive::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DateNodeArchive::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* DateNodeArchive::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DateNodeArchive::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReferenceNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ReferenceNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& ReferenceNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* ReferenceNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* ReferenceNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ReferenceNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.RangeReferenceArchive rangeReference = 2;
inline bool ReferenceNodeArchive::has_rangereference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceNodeArchive::set_has_rangereference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceNodeArchive::clear_has_rangereference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceNodeArchive::clear_rangereference() {
  if (rangereference_ != NULL) rangereference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_rangereference();
}
inline const ::TSCE::RangeReferenceArchive& ReferenceNodeArchive::rangereference() const {
  return rangereference_ != NULL ? *rangereference_ : *default_instance_->rangereference_;
}
inline ::TSCE::RangeReferenceArchive* ReferenceNodeArchive::mutable_rangereference() {
  set_has_rangereference();
  if (rangereference_ == NULL) rangereference_ = new ::TSCE::RangeReferenceArchive;
  return rangereference_;
}
inline ::TSCE::RangeReferenceArchive* ReferenceNodeArchive::release_rangereference() {
  clear_has_rangereference();
  ::TSCE::RangeReferenceArchive* temp = rangereference_;
  rangereference_ = NULL;
  return temp;
}
inline void ReferenceNodeArchive::set_allocated_rangereference(::TSCE::RangeReferenceArchive* rangereference) {
  delete rangereference_;
  rangereference_ = rangereference;
  if (rangereference) {
    set_has_rangereference();
  } else {
    clear_has_rangereference();
  }
}

// required uint32 stickyBits = 3;
inline bool ReferenceNodeArchive::has_stickybits() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReferenceNodeArchive::set_has_stickybits() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReferenceNodeArchive::clear_has_stickybits() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReferenceNodeArchive::clear_stickybits() {
  stickybits_ = 0u;
  clear_has_stickybits();
}
inline ::google::protobuf::uint32 ReferenceNodeArchive::stickybits() const {
  return stickybits_;
}
inline void ReferenceNodeArchive::set_stickybits(::google::protobuf::uint32 value) {
  set_has_stickybits();
  stickybits_ = value;
}

// optional string hostTableID = 4;
inline bool ReferenceNodeArchive::has_hosttableid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReferenceNodeArchive::set_has_hosttableid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReferenceNodeArchive::clear_has_hosttableid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReferenceNodeArchive::clear_hosttableid() {
  if (hosttableid_ != &::google::protobuf::internal::kEmptyString) {
    hosttableid_->clear();
  }
  clear_has_hosttableid();
}
inline const ::std::string& ReferenceNodeArchive::hosttableid() const {
  return *hosttableid_;
}
inline void ReferenceNodeArchive::set_hosttableid(const ::std::string& value) {
  set_has_hosttableid();
  if (hosttableid_ == &::google::protobuf::internal::kEmptyString) {
    hosttableid_ = new ::std::string;
  }
  hosttableid_->assign(value);
}
inline void ReferenceNodeArchive::set_hosttableid(const char* value) {
  set_has_hosttableid();
  if (hosttableid_ == &::google::protobuf::internal::kEmptyString) {
    hosttableid_ = new ::std::string;
  }
  hosttableid_->assign(value);
}
inline void ReferenceNodeArchive::set_hosttableid(const char* value, size_t size) {
  set_has_hosttableid();
  if (hosttableid_ == &::google::protobuf::internal::kEmptyString) {
    hosttableid_ = new ::std::string;
  }
  hosttableid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReferenceNodeArchive::mutable_hosttableid() {
  set_has_hosttableid();
  if (hosttableid_ == &::google::protobuf::internal::kEmptyString) {
    hosttableid_ = new ::std::string;
  }
  return hosttableid_;
}
inline ::std::string* ReferenceNodeArchive::release_hosttableid() {
  clear_has_hosttableid();
  if (hosttableid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hosttableid_;
    hosttableid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReferenceNodeArchive::set_allocated_hosttableid(::std::string* hosttableid) {
  if (hosttableid_ != &::google::protobuf::internal::kEmptyString) {
    delete hosttableid_;
  }
  if (hosttableid) {
    set_has_hosttableid();
    hosttableid_ = hosttableid;
  } else {
    clear_has_hosttableid();
    hosttableid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DurationNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool DurationNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DurationNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DurationNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DurationNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& DurationNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* DurationNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* DurationNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DurationNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required double timeinterval = 2;
inline bool DurationNodeArchive::has_timeinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DurationNodeArchive::set_has_timeinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DurationNodeArchive::clear_has_timeinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DurationNodeArchive::clear_timeinterval() {
  timeinterval_ = 0;
  clear_has_timeinterval();
}
inline double DurationNodeArchive::timeinterval() const {
  return timeinterval_;
}
inline void DurationNodeArchive::set_timeinterval(double value) {
  set_has_timeinterval();
  timeinterval_ = value;
}

// required uint32 smallest = 3;
inline bool DurationNodeArchive::has_smallest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DurationNodeArchive::set_has_smallest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DurationNodeArchive::clear_has_smallest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DurationNodeArchive::clear_smallest() {
  smallest_ = 0u;
  clear_has_smallest();
}
inline ::google::protobuf::uint32 DurationNodeArchive::smallest() const {
  return smallest_;
}
inline void DurationNodeArchive::set_smallest(::google::protobuf::uint32 value) {
  set_has_smallest();
  smallest_ = value;
}

// required uint32 largest = 4;
inline bool DurationNodeArchive::has_largest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DurationNodeArchive::set_has_largest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DurationNodeArchive::clear_has_largest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DurationNodeArchive::clear_largest() {
  largest_ = 0u;
  clear_has_largest();
}
inline ::google::protobuf::uint32 DurationNodeArchive::largest() const {
  return largest_;
}
inline void DurationNodeArchive::set_largest(::google::protobuf::uint32 value) {
  set_has_largest();
  largest_ = value;
}

// required uint32 style = 5;
inline bool DurationNodeArchive::has_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DurationNodeArchive::set_has_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DurationNodeArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DurationNodeArchive::clear_style() {
  style_ = 0u;
  clear_has_style();
}
inline ::google::protobuf::uint32 DurationNodeArchive::style() const {
  return style_;
}
inline void DurationNodeArchive::set_style(::google::protobuf::uint32 value) {
  set_has_style();
  style_ = value;
}

// -------------------------------------------------------------------

// ArgumentPlaceholderNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ArgumentPlaceholderNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArgumentPlaceholderNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArgumentPlaceholderNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArgumentPlaceholderNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& ArgumentPlaceholderNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* ArgumentPlaceholderNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* ArgumentPlaceholderNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ArgumentPlaceholderNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 functionIndex = 2;
inline bool ArgumentPlaceholderNodeArchive::has_functionindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArgumentPlaceholderNodeArchive::set_has_functionindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArgumentPlaceholderNodeArchive::clear_has_functionindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArgumentPlaceholderNodeArchive::clear_functionindex() {
  functionindex_ = 0u;
  clear_has_functionindex();
}
inline ::google::protobuf::uint32 ArgumentPlaceholderNodeArchive::functionindex() const {
  return functionindex_;
}
inline void ArgumentPlaceholderNodeArchive::set_functionindex(::google::protobuf::uint32 value) {
  set_has_functionindex();
  functionindex_ = value;
}

// required uint32 argumentIndex = 3;
inline bool ArgumentPlaceholderNodeArchive::has_argumentindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArgumentPlaceholderNodeArchive::set_has_argumentindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArgumentPlaceholderNodeArchive::clear_has_argumentindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArgumentPlaceholderNodeArchive::clear_argumentindex() {
  argumentindex_ = 0u;
  clear_has_argumentindex();
}
inline ::google::protobuf::uint32 ArgumentPlaceholderNodeArchive::argumentindex() const {
  return argumentindex_;
}
inline void ArgumentPlaceholderNodeArchive::set_argumentindex(::google::protobuf::uint32 value) {
  set_has_argumentindex();
  argumentindex_ = value;
}

// optional uint32 mode = 4;
inline bool ArgumentPlaceholderNodeArchive::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArgumentPlaceholderNodeArchive::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArgumentPlaceholderNodeArchive::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArgumentPlaceholderNodeArchive::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 ArgumentPlaceholderNodeArchive::mode() const {
  return mode_;
}
inline void ArgumentPlaceholderNodeArchive::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// EmptyExpressionNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool EmptyExpressionNodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmptyExpressionNodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmptyExpressionNodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmptyExpressionNodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::ExpressionNodeArchive::Clear();
  clear_has_super();
}
inline const ::TST::ExpressionNodeArchive& EmptyExpressionNodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::ExpressionNodeArchive* EmptyExpressionNodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::ExpressionNodeArchive;
  return super_;
}
inline ::TST::ExpressionNodeArchive* EmptyExpressionNodeArchive::release_super() {
  clear_has_super();
  ::TST::ExpressionNodeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void EmptyExpressionNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// LayoutHintArchive

// required bool isValid = 1;
inline bool LayoutHintArchive::has_isvalid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayoutHintArchive::set_has_isvalid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayoutHintArchive::clear_has_isvalid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayoutHintArchive::clear_isvalid() {
  isvalid_ = false;
  clear_has_isvalid();
}
inline bool LayoutHintArchive::isvalid() const {
  return isvalid_;
}
inline void LayoutHintArchive::set_isvalid(bool value) {
  set_has_isvalid();
  isvalid_ = value;
}

// required .TST.CellRange cellRange = 2;
inline bool LayoutHintArchive::has_cellrange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayoutHintArchive::set_has_cellrange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayoutHintArchive::clear_has_cellrange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayoutHintArchive::clear_cellrange() {
  if (cellrange_ != NULL) cellrange_->::TST::CellRange::Clear();
  clear_has_cellrange();
}
inline const ::TST::CellRange& LayoutHintArchive::cellrange() const {
  return cellrange_ != NULL ? *cellrange_ : *default_instance_->cellrange_;
}
inline ::TST::CellRange* LayoutHintArchive::mutable_cellrange() {
  set_has_cellrange();
  if (cellrange_ == NULL) cellrange_ = new ::TST::CellRange;
  return cellrange_;
}
inline ::TST::CellRange* LayoutHintArchive::release_cellrange() {
  clear_has_cellrange();
  ::TST::CellRange* temp = cellrange_;
  cellrange_ = NULL;
  return temp;
}
inline void LayoutHintArchive::set_allocated_cellrange(::TST::CellRange* cellrange) {
  delete cellrange_;
  cellrange_ = cellrange;
  if (cellrange) {
    set_has_cellrange();
  } else {
    clear_has_cellrange();
  }
}

// required .TST.CellID hintID = 3;
inline bool LayoutHintArchive::has_hintid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayoutHintArchive::set_has_hintid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayoutHintArchive::clear_has_hintid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayoutHintArchive::clear_hintid() {
  if (hintid_ != NULL) hintid_->::TST::CellID::Clear();
  clear_has_hintid();
}
inline const ::TST::CellID& LayoutHintArchive::hintid() const {
  return hintid_ != NULL ? *hintid_ : *default_instance_->hintid_;
}
inline ::TST::CellID* LayoutHintArchive::mutable_hintid() {
  set_has_hintid();
  if (hintid_ == NULL) hintid_ = new ::TST::CellID;
  return hintid_;
}
inline ::TST::CellID* LayoutHintArchive::release_hintid() {
  clear_has_hintid();
  ::TST::CellID* temp = hintid_;
  hintid_ = NULL;
  return temp;
}
inline void LayoutHintArchive::set_allocated_hintid(::TST::CellID* hintid) {
  delete hintid_;
  hintid_ = hintid;
  if (hintid) {
    set_has_hintid();
  } else {
    clear_has_hintid();
  }
}

// required .TSP.Size maximumSize = 4;
inline bool LayoutHintArchive::has_maximumsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayoutHintArchive::set_has_maximumsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayoutHintArchive::clear_has_maximumsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayoutHintArchive::clear_maximumsize() {
  if (maximumsize_ != NULL) maximumsize_->::TSP::Size::Clear();
  clear_has_maximumsize();
}
inline const ::TSP::Size& LayoutHintArchive::maximumsize() const {
  return maximumsize_ != NULL ? *maximumsize_ : *default_instance_->maximumsize_;
}
inline ::TSP::Size* LayoutHintArchive::mutable_maximumsize() {
  set_has_maximumsize();
  if (maximumsize_ == NULL) maximumsize_ = new ::TSP::Size;
  return maximumsize_;
}
inline ::TSP::Size* LayoutHintArchive::release_maximumsize() {
  clear_has_maximumsize();
  ::TSP::Size* temp = maximumsize_;
  maximumsize_ = NULL;
  return temp;
}
inline void LayoutHintArchive::set_allocated_maximumsize(::TSP::Size* maximumsize) {
  delete maximumsize_;
  maximumsize_ = maximumsize;
  if (maximumsize) {
    set_has_maximumsize();
  } else {
    clear_has_maximumsize();
  }
}

// required uint32 partitionPosition = 5;
inline bool LayoutHintArchive::has_partitionposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayoutHintArchive::set_has_partitionposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayoutHintArchive::clear_has_partitionposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayoutHintArchive::clear_partitionposition() {
  partitionposition_ = 0u;
  clear_has_partitionposition();
}
inline ::google::protobuf::uint32 LayoutHintArchive::partitionposition() const {
  return partitionposition_;
}
inline void LayoutHintArchive::set_partitionposition(::google::protobuf::uint32 value) {
  set_has_partitionposition();
  partitionposition_ = value;
}

// required bool horizontal = 6;
inline bool LayoutHintArchive::has_horizontal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayoutHintArchive::set_has_horizontal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayoutHintArchive::clear_has_horizontal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayoutHintArchive::clear_horizontal() {
  horizontal_ = false;
  clear_has_horizontal();
}
inline bool LayoutHintArchive::horizontal() const {
  return horizontal_;
}
inline void LayoutHintArchive::set_horizontal(bool value) {
  set_has_horizontal();
  horizontal_ = value;
}

// optional .TSP.Size effectiveSize = 7;
inline bool LayoutHintArchive::has_effectivesize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayoutHintArchive::set_has_effectivesize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayoutHintArchive::clear_has_effectivesize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayoutHintArchive::clear_effectivesize() {
  if (effectivesize_ != NULL) effectivesize_->::TSP::Size::Clear();
  clear_has_effectivesize();
}
inline const ::TSP::Size& LayoutHintArchive::effectivesize() const {
  return effectivesize_ != NULL ? *effectivesize_ : *default_instance_->effectivesize_;
}
inline ::TSP::Size* LayoutHintArchive::mutable_effectivesize() {
  set_has_effectivesize();
  if (effectivesize_ == NULL) effectivesize_ = new ::TSP::Size;
  return effectivesize_;
}
inline ::TSP::Size* LayoutHintArchive::release_effectivesize() {
  clear_has_effectivesize();
  ::TSP::Size* temp = effectivesize_;
  effectivesize_ = NULL;
  return temp;
}
inline void LayoutHintArchive::set_allocated_effectivesize(::TSP::Size* effectivesize) {
  delete effectivesize_;
  effectivesize_ = effectivesize;
  if (effectivesize) {
    set_has_effectivesize();
  } else {
    clear_has_effectivesize();
  }
}

// optional uint32 partitioningPass = 8;
inline bool LayoutHintArchive::has_partitioningpass() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayoutHintArchive::set_has_partitioningpass() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayoutHintArchive::clear_has_partitioningpass() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayoutHintArchive::clear_partitioningpass() {
  partitioningpass_ = 0u;
  clear_has_partitioningpass();
}
inline ::google::protobuf::uint32 LayoutHintArchive::partitioningpass() const {
  return partitioningpass_;
}
inline void LayoutHintArchive::set_partitioningpass(::google::protobuf::uint32 value) {
  set_has_partitioningpass();
  partitioningpass_ = value;
}

// -------------------------------------------------------------------

// CompletionTokenAttachmentArchive

// required .TST.TokenAttachmentArchive super = 1;
inline bool CompletionTokenAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompletionTokenAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompletionTokenAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompletionTokenAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TokenAttachmentArchive::Clear();
  clear_has_super();
}
inline const ::TST::TokenAttachmentArchive& CompletionTokenAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TokenAttachmentArchive* CompletionTokenAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TokenAttachmentArchive;
  return super_;
}
inline ::TST::TokenAttachmentArchive* CompletionTokenAttachmentArchive::release_super() {
  clear_has_super();
  ::TST::TokenAttachmentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CompletionTokenAttachmentArchive::set_allocated_super(::TST::TokenAttachmentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string completionText = 2;
inline bool CompletionTokenAttachmentArchive::has_completiontext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompletionTokenAttachmentArchive::set_has_completiontext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompletionTokenAttachmentArchive::clear_has_completiontext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompletionTokenAttachmentArchive::clear_completiontext() {
  if (completiontext_ != &::google::protobuf::internal::kEmptyString) {
    completiontext_->clear();
  }
  clear_has_completiontext();
}
inline const ::std::string& CompletionTokenAttachmentArchive::completiontext() const {
  return *completiontext_;
}
inline void CompletionTokenAttachmentArchive::set_completiontext(const ::std::string& value) {
  set_has_completiontext();
  if (completiontext_ == &::google::protobuf::internal::kEmptyString) {
    completiontext_ = new ::std::string;
  }
  completiontext_->assign(value);
}
inline void CompletionTokenAttachmentArchive::set_completiontext(const char* value) {
  set_has_completiontext();
  if (completiontext_ == &::google::protobuf::internal::kEmptyString) {
    completiontext_ = new ::std::string;
  }
  completiontext_->assign(value);
}
inline void CompletionTokenAttachmentArchive::set_completiontext(const char* value, size_t size) {
  set_has_completiontext();
  if (completiontext_ == &::google::protobuf::internal::kEmptyString) {
    completiontext_ = new ::std::string;
  }
  completiontext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompletionTokenAttachmentArchive::mutable_completiontext() {
  set_has_completiontext();
  if (completiontext_ == &::google::protobuf::internal::kEmptyString) {
    completiontext_ = new ::std::string;
  }
  return completiontext_;
}
inline ::std::string* CompletionTokenAttachmentArchive::release_completiontext() {
  clear_has_completiontext();
  if (completiontext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = completiontext_;
    completiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompletionTokenAttachmentArchive::set_allocated_completiontext(::std::string* completiontext) {
  if (completiontext_ != &::google::protobuf::internal::kEmptyString) {
    delete completiontext_;
  }
  if (completiontext) {
    set_has_completiontext();
    completiontext_ = completiontext;
  } else {
    clear_has_completiontext();
    completiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 caretPosition = 3;
inline bool CompletionTokenAttachmentArchive::has_caretposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompletionTokenAttachmentArchive::set_has_caretposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompletionTokenAttachmentArchive::clear_has_caretposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompletionTokenAttachmentArchive::clear_caretposition() {
  caretposition_ = 0u;
  clear_has_caretposition();
}
inline ::google::protobuf::uint32 CompletionTokenAttachmentArchive::caretposition() const {
  return caretposition_;
}
inline void CompletionTokenAttachmentArchive::set_caretposition(::google::protobuf::uint32 value) {
  set_has_caretposition();
  caretposition_ = value;
}

// optional uint32 prefixStart = 4;
inline bool CompletionTokenAttachmentArchive::has_prefixstart() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompletionTokenAttachmentArchive::set_has_prefixstart() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CompletionTokenAttachmentArchive::clear_has_prefixstart() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CompletionTokenAttachmentArchive::clear_prefixstart() {
  prefixstart_ = 0u;
  clear_has_prefixstart();
}
inline ::google::protobuf::uint32 CompletionTokenAttachmentArchive::prefixstart() const {
  return prefixstart_;
}
inline void CompletionTokenAttachmentArchive::set_prefixstart(::google::protobuf::uint32 value) {
  set_has_prefixstart();
  prefixstart_ = value;
}

// -------------------------------------------------------------------

// HiddenStateFormulaOwnerArchive

// optional .TSCE.CFUUIDArchive owner_id = 1;
inline bool HiddenStateFormulaOwnerArchive::has_owner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HiddenStateFormulaOwnerArchive::set_has_owner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HiddenStateFormulaOwnerArchive::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HiddenStateFormulaOwnerArchive::clear_owner_id() {
  if (owner_id_ != NULL) owner_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_owner_id();
}
inline const ::TSCE::CFUUIDArchive& HiddenStateFormulaOwnerArchive::owner_id() const {
  return owner_id_ != NULL ? *owner_id_ : *default_instance_->owner_id_;
}
inline ::TSCE::CFUUIDArchive* HiddenStateFormulaOwnerArchive::mutable_owner_id() {
  set_has_owner_id();
  if (owner_id_ == NULL) owner_id_ = new ::TSCE::CFUUIDArchive;
  return owner_id_;
}
inline ::TSCE::CFUUIDArchive* HiddenStateFormulaOwnerArchive::release_owner_id() {
  clear_has_owner_id();
  ::TSCE::CFUUIDArchive* temp = owner_id_;
  owner_id_ = NULL;
  return temp;
}
inline void HiddenStateFormulaOwnerArchive::set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id) {
  delete owner_id_;
  owner_id_ = owner_id;
  if (owner_id) {
    set_has_owner_id();
  } else {
    clear_has_owner_id();
  }
}

// repeated .TSCE.CellValueArchive threshold_value = 2;
inline int HiddenStateFormulaOwnerArchive::threshold_value_size() const {
  return threshold_value_.size();
}
inline void HiddenStateFormulaOwnerArchive::clear_threshold_value() {
  threshold_value_.Clear();
}
inline const ::TSCE::CellValueArchive& HiddenStateFormulaOwnerArchive::threshold_value(int index) const {
  return threshold_value_.Get(index);
}
inline ::TSCE::CellValueArchive* HiddenStateFormulaOwnerArchive::mutable_threshold_value(int index) {
  return threshold_value_.Mutable(index);
}
inline ::TSCE::CellValueArchive* HiddenStateFormulaOwnerArchive::add_threshold_value() {
  return threshold_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >&
HiddenStateFormulaOwnerArchive::threshold_value() const {
  return threshold_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellValueArchive >*
HiddenStateFormulaOwnerArchive::mutable_threshold_value() {
  return &threshold_value_;
}

// optional bool needs_to_update_filter_set_for_import = 3 [default = false];
inline bool HiddenStateFormulaOwnerArchive::has_needs_to_update_filter_set_for_import() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HiddenStateFormulaOwnerArchive::set_has_needs_to_update_filter_set_for_import() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HiddenStateFormulaOwnerArchive::clear_has_needs_to_update_filter_set_for_import() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HiddenStateFormulaOwnerArchive::clear_needs_to_update_filter_set_for_import() {
  needs_to_update_filter_set_for_import_ = false;
  clear_has_needs_to_update_filter_set_for_import();
}
inline bool HiddenStateFormulaOwnerArchive::needs_to_update_filter_set_for_import() const {
  return needs_to_update_filter_set_for_import_;
}
inline void HiddenStateFormulaOwnerArchive::set_needs_to_update_filter_set_for_import(bool value) {
  set_has_needs_to_update_filter_set_for_import();
  needs_to_update_filter_set_for_import_ = value;
}

// -------------------------------------------------------------------

// RichTextPayloadArchive

// required .TSP.Reference storage = 1;
inline bool RichTextPayloadArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RichTextPayloadArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RichTextPayloadArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RichTextPayloadArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& RichTextPayloadArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* RichTextPayloadArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* RichTextPayloadArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void RichTextPayloadArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSP.Range range = 2;
inline bool RichTextPayloadArchive::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RichTextPayloadArchive::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RichTextPayloadArchive::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RichTextPayloadArchive::clear_range() {
  if (range_ != NULL) range_->::TSP::Range::Clear();
  clear_has_range();
}
inline const ::TSP::Range& RichTextPayloadArchive::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::TSP::Range* RichTextPayloadArchive::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::TSP::Range;
  return range_;
}
inline ::TSP::Range* RichTextPayloadArchive::release_range() {
  clear_has_range();
  ::TSP::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void RichTextPayloadArchive::set_allocated_range(::TSP::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
}

// required .TST.CellID cellid = 3;
inline bool RichTextPayloadArchive::has_cellid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RichTextPayloadArchive::set_has_cellid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RichTextPayloadArchive::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RichTextPayloadArchive::clear_cellid() {
  if (cellid_ != NULL) cellid_->::TST::CellID::Clear();
  clear_has_cellid();
}
inline const ::TST::CellID& RichTextPayloadArchive::cellid() const {
  return cellid_ != NULL ? *cellid_ : *default_instance_->cellid_;
}
inline ::TST::CellID* RichTextPayloadArchive::mutable_cellid() {
  set_has_cellid();
  if (cellid_ == NULL) cellid_ = new ::TST::CellID;
  return cellid_;
}
inline ::TST::CellID* RichTextPayloadArchive::release_cellid() {
  clear_has_cellid();
  ::TST::CellID* temp = cellid_;
  cellid_ = NULL;
  return temp;
}
inline void RichTextPayloadArchive::set_allocated_cellid(::TST::CellID* cellid) {
  delete cellid_;
  cellid_ = cellid;
  if (cellid) {
    set_has_cellid();
  } else {
    clear_has_cellid();
  }
}

// -------------------------------------------------------------------

// FormulaEqualsTokenAttachmentArchive

// required .TSWP.UIGraphicalAttachment super = 1;
inline bool FormulaEqualsTokenAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaEqualsTokenAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaEqualsTokenAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaEqualsTokenAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::UIGraphicalAttachment::Clear();
  clear_has_super();
}
inline const ::TSWP::UIGraphicalAttachment& FormulaEqualsTokenAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::UIGraphicalAttachment* FormulaEqualsTokenAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::UIGraphicalAttachment;
  return super_;
}
inline ::TSWP::UIGraphicalAttachment* FormulaEqualsTokenAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::UIGraphicalAttachment* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FormulaEqualsTokenAttachmentArchive::set_allocated_super(::TSWP::UIGraphicalAttachment* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CellRegion

// repeated .TST.CellRange cell_ranges = 1;
inline int CellRegion::cell_ranges_size() const {
  return cell_ranges_.size();
}
inline void CellRegion::clear_cell_ranges() {
  cell_ranges_.Clear();
}
inline const ::TST::CellRange& CellRegion::cell_ranges(int index) const {
  return cell_ranges_.Get(index);
}
inline ::TST::CellRange* CellRegion::mutable_cell_ranges(int index) {
  return cell_ranges_.Mutable(index);
}
inline ::TST::CellRange* CellRegion::add_cell_ranges() {
  return cell_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CellRange >&
CellRegion::cell_ranges() const {
  return cell_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CellRange >*
CellRegion::mutable_cell_ranges() {
  return &cell_ranges_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TST

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::PopUpMenuModel_CellValueType>() {
  return ::TST::PopUpMenuModel_CellValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::TableDataList_ListType>() {
  return ::TST::TableDataList_ListType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FormulaPredicateArchive_FormulaPredicateType>() {
  return ::TST::FormulaPredicateArchive_FormulaPredicateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FormulaPredicateArchive_QualifierType>() {
  return ::TST::FormulaPredicateArchive_QualifierType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FilterSetArchive_FilterSetType>() {
  return ::TST::FilterSetArchive_FilterSetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::CellType>() {
  return ::TST::CellType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::CellValueType>() {
  return ::TST::CellValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::SelectionTypeArchive>() {
  return ::TST::SelectionTypeArchive_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FillDirectionArchive>() {
  return ::TST::FillDirectionArchive_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::MergeActionArchive>() {
  return ::TST::MergeActionArchive_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::HideShowActionArchive>() {
  return ::TST::HideShowActionArchive_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSTArchives_2eproto__INCLUDED
