// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KNArchives.proto

#ifndef PROTOBUF_KNArchives_2eproto__INCLUDED
#define PROTOBUF_KNArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSWPArchives.pb.h"
#include "TSAArchives.pb.h"
#include "TSCHArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace KN {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_KNArchives_2eproto();
void protobuf_AssignDesc_KNArchives_2eproto();
void protobuf_ShutdownFile_KNArchives_2eproto();

class AnimationAttributesArchive;
class TransitionAttributesArchive;
class TransitionArchive;
class BuildChunkArchive;
class BuildAttributesArchive;
class BuildArchive;
class PlaceholderArchive;
class NoteArchive;
class ClassicStylesheetRecordArchive;
class ClassicThemeRecordArchive;
class SlideArchive;
class SlideArchive_SageTagMapEntry;
class SlideNodeArchive;
class DesktopUILayoutArchive;
class UIStateArchive;
class CanvasSelectionArchive;
class ThemeArchive;
class SlideTreeArchive;
class ShowArchive;
class DocumentArchive;
class SlideStylePropertiesArchive;
class SlideStyleArchive;
class PasteboardNativeStorageArchive;
class MasterChangeBlobArchive;
class RecordingArchive;
class RecordingEventTrackArchive;
class RecordingEventArchive;
class RecordingNavigationEventArchive;
class RecordingLaserEventArchive;
class RecordingPauseEventArchive;
class RecordingMovieEventArchive;
class RecordingMovieTrackArchive;
class MovieSegmentArchive;
class Soundtrack;
class SlideNumberAttachmentArchive;
class SlideCollectionSelectionArchive;
class SlideCollectionSelectionArchive_OutlineSelection;

enum TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType {
  TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeLinear = 1,
  TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseIn = 2,
  TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseOut = 3,
  TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseInEaseOut = 4
};
bool TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_IsValid(int value);
const TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_MIN = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeLinear;
const TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_MAX = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseInEaseOut;
const int TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_ARRAYSIZE = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_descriptor();
inline const ::std::string& TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_Name(TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_descriptor(), value);
}
inline bool TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_Parse(
    const ::std::string& name, TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType>(
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_descriptor(), name, value);
}
enum TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType {
  TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByObject = 1,
  TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByWord = 2,
  TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByCharacter = 3,
  TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByLine = 4
};
bool TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_IsValid(int value);
const TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_MIN = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByObject;
const TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_MAX = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByLine;
const int TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_ARRAYSIZE = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_descriptor();
inline const ::std::string& TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_Name(TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_descriptor(), value);
}
inline bool TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_Parse(
    const ::std::string& name, TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType>(
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_descriptor(), name, value);
}
enum BuildAttributesArchive_BuildAttributesAcceleration {
  BuildAttributesArchive_BuildAttributesAcceleration_kNone = 0,
  BuildAttributesArchive_BuildAttributesAcceleration_kEaseIn = 1,
  BuildAttributesArchive_BuildAttributesAcceleration_kEaseOut = 2,
  BuildAttributesArchive_BuildAttributesAcceleration_kEaseBoth = 3
};
bool BuildAttributesArchive_BuildAttributesAcceleration_IsValid(int value);
const BuildAttributesArchive_BuildAttributesAcceleration BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_MIN = BuildAttributesArchive_BuildAttributesAcceleration_kNone;
const BuildAttributesArchive_BuildAttributesAcceleration BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_MAX = BuildAttributesArchive_BuildAttributesAcceleration_kEaseBoth;
const int BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_ARRAYSIZE = BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildAttributesArchive_BuildAttributesAcceleration_descriptor();
inline const ::std::string& BuildAttributesArchive_BuildAttributesAcceleration_Name(BuildAttributesArchive_BuildAttributesAcceleration value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildAttributesArchive_BuildAttributesAcceleration_descriptor(), value);
}
inline bool BuildAttributesArchive_BuildAttributesAcceleration_Parse(
    const ::std::string& name, BuildAttributesArchive_BuildAttributesAcceleration* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildAttributesArchive_BuildAttributesAcceleration>(
    BuildAttributesArchive_BuildAttributesAcceleration_descriptor(), name, value);
}
enum BuildAttributesArchive_BuildAttributesRotationDirection {
  BuildAttributesArchive_BuildAttributesRotationDirection_kClockwise = 31,
  BuildAttributesArchive_BuildAttributesRotationDirection_kCounterclockwise = 32
};
bool BuildAttributesArchive_BuildAttributesRotationDirection_IsValid(int value);
const BuildAttributesArchive_BuildAttributesRotationDirection BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_MIN = BuildAttributesArchive_BuildAttributesRotationDirection_kClockwise;
const BuildAttributesArchive_BuildAttributesRotationDirection BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_MAX = BuildAttributesArchive_BuildAttributesRotationDirection_kCounterclockwise;
const int BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_ARRAYSIZE = BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildAttributesArchive_BuildAttributesRotationDirection_descriptor();
inline const ::std::string& BuildAttributesArchive_BuildAttributesRotationDirection_Name(BuildAttributesArchive_BuildAttributesRotationDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildAttributesArchive_BuildAttributesRotationDirection_descriptor(), value);
}
inline bool BuildAttributesArchive_BuildAttributesRotationDirection_Parse(
    const ::std::string& name, BuildAttributesArchive_BuildAttributesRotationDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildAttributesArchive_BuildAttributesRotationDirection>(
    BuildAttributesArchive_BuildAttributesRotationDirection_descriptor(), name, value);
}
enum BuildAttributesArchive_BuildAttributesCurveStyle {
  BuildAttributesArchive_BuildAttributesCurveStyle_kStraight = 0,
  BuildAttributesArchive_BuildAttributesCurveStyle_kCurved = 1
};
bool BuildAttributesArchive_BuildAttributesCurveStyle_IsValid(int value);
const BuildAttributesArchive_BuildAttributesCurveStyle BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_MIN = BuildAttributesArchive_BuildAttributesCurveStyle_kStraight;
const BuildAttributesArchive_BuildAttributesCurveStyle BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_MAX = BuildAttributesArchive_BuildAttributesCurveStyle_kCurved;
const int BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_ARRAYSIZE = BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildAttributesArchive_BuildAttributesCurveStyle_descriptor();
inline const ::std::string& BuildAttributesArchive_BuildAttributesCurveStyle_Name(BuildAttributesArchive_BuildAttributesCurveStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildAttributesArchive_BuildAttributesCurveStyle_descriptor(), value);
}
inline bool BuildAttributesArchive_BuildAttributesCurveStyle_Parse(
    const ::std::string& name, BuildAttributesArchive_BuildAttributesCurveStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildAttributesArchive_BuildAttributesCurveStyle>(
    BuildAttributesArchive_BuildAttributesCurveStyle_descriptor(), name, value);
}
enum BuildAttributesArchive_BuildAttributesTextDelivery {
  BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryUndefined = 0,
  BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByObject = 1,
  BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByWord = 2,
  BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByCharacter = 3,
  BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByLine = 4
};
bool BuildAttributesArchive_BuildAttributesTextDelivery_IsValid(int value);
const BuildAttributesArchive_BuildAttributesTextDelivery BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_MIN = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryUndefined;
const BuildAttributesArchive_BuildAttributesTextDelivery BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_MAX = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByLine;
const int BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_ARRAYSIZE = BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildAttributesArchive_BuildAttributesTextDelivery_descriptor();
inline const ::std::string& BuildAttributesArchive_BuildAttributesTextDelivery_Name(BuildAttributesArchive_BuildAttributesTextDelivery value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildAttributesArchive_BuildAttributesTextDelivery_descriptor(), value);
}
inline bool BuildAttributesArchive_BuildAttributesTextDelivery_Parse(
    const ::std::string& name, BuildAttributesArchive_BuildAttributesTextDelivery* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildAttributesArchive_BuildAttributesTextDelivery>(
    BuildAttributesArchive_BuildAttributesTextDelivery_descriptor(), name, value);
}
enum BuildAttributesArchive_BuildAttributesDeliveryOption {
  BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionUndefined = 0,
  BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionForward = 1,
  BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionBackward = 2,
  BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionFromCenter = 3,
  BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionFromEdges = 4,
  BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionRandom = 5
};
bool BuildAttributesArchive_BuildAttributesDeliveryOption_IsValid(int value);
const BuildAttributesArchive_BuildAttributesDeliveryOption BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_MIN = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionUndefined;
const BuildAttributesArchive_BuildAttributesDeliveryOption BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_MAX = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionRandom;
const int BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_ARRAYSIZE = BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildAttributesArchive_BuildAttributesDeliveryOption_descriptor();
inline const ::std::string& BuildAttributesArchive_BuildAttributesDeliveryOption_Name(BuildAttributesArchive_BuildAttributesDeliveryOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildAttributesArchive_BuildAttributesDeliveryOption_descriptor(), value);
}
inline bool BuildAttributesArchive_BuildAttributesDeliveryOption_Parse(
    const ::std::string& name, BuildAttributesArchive_BuildAttributesDeliveryOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildAttributesArchive_BuildAttributesDeliveryOption>(
    BuildAttributesArchive_BuildAttributesDeliveryOption_descriptor(), name, value);
}
enum BuildAttributesArchive_ActionBuildAttributesJiggleIntensity {
  BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensitySmall = 0,
  BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensityMedium = 1,
  BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensityLarge = 2
};
bool BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_IsValid(int value);
const BuildAttributesArchive_ActionBuildAttributesJiggleIntensity BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_MIN = BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensitySmall;
const BuildAttributesArchive_ActionBuildAttributesJiggleIntensity BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_MAX = BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensityLarge;
const int BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_ARRAYSIZE = BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_descriptor();
inline const ::std::string& BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_Name(BuildAttributesArchive_ActionBuildAttributesJiggleIntensity value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_descriptor(), value);
}
inline bool BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_Parse(
    const ::std::string& name, BuildAttributesArchive_ActionBuildAttributesJiggleIntensity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildAttributesArchive_ActionBuildAttributesJiggleIntensity>(
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_descriptor(), name, value);
}
enum PlaceholderArchive_Kind {
  PlaceholderArchive_Kind_kKindPlaceholder = 0,
  PlaceholderArchive_Kind_kKindSlideNumberPlaceholder = 1,
  PlaceholderArchive_Kind_kKindTitlePlaceholder = 2,
  PlaceholderArchive_Kind_kKindBodyPlaceholder = 3,
  PlaceholderArchive_Kind_kKindObjectPlaceholder = 4
};
bool PlaceholderArchive_Kind_IsValid(int value);
const PlaceholderArchive_Kind PlaceholderArchive_Kind_Kind_MIN = PlaceholderArchive_Kind_kKindPlaceholder;
const PlaceholderArchive_Kind PlaceholderArchive_Kind_Kind_MAX = PlaceholderArchive_Kind_kKindObjectPlaceholder;
const int PlaceholderArchive_Kind_Kind_ARRAYSIZE = PlaceholderArchive_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlaceholderArchive_Kind_descriptor();
inline const ::std::string& PlaceholderArchive_Kind_Name(PlaceholderArchive_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlaceholderArchive_Kind_descriptor(), value);
}
inline bool PlaceholderArchive_Kind_Parse(
    const ::std::string& name, PlaceholderArchive_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlaceholderArchive_Kind>(
    PlaceholderArchive_Kind_descriptor(), name, value);
}
enum DesktopUILayoutArchive_SidebarViewMode {
  DesktopUILayoutArchive_SidebarViewMode_kSidebarViewModeNavigator = 0,
  DesktopUILayoutArchive_SidebarViewMode_kSidebarViewModeOutline = 1
};
bool DesktopUILayoutArchive_SidebarViewMode_IsValid(int value);
const DesktopUILayoutArchive_SidebarViewMode DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_MIN = DesktopUILayoutArchive_SidebarViewMode_kSidebarViewModeNavigator;
const DesktopUILayoutArchive_SidebarViewMode DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_MAX = DesktopUILayoutArchive_SidebarViewMode_kSidebarViewModeOutline;
const int DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_ARRAYSIZE = DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* DesktopUILayoutArchive_SidebarViewMode_descriptor();
inline const ::std::string& DesktopUILayoutArchive_SidebarViewMode_Name(DesktopUILayoutArchive_SidebarViewMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    DesktopUILayoutArchive_SidebarViewMode_descriptor(), value);
}
inline bool DesktopUILayoutArchive_SidebarViewMode_Parse(
    const ::std::string& name, DesktopUILayoutArchive_SidebarViewMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DesktopUILayoutArchive_SidebarViewMode>(
    DesktopUILayoutArchive_SidebarViewMode_descriptor(), name, value);
}
enum DesktopUILayoutArchive_InspectorPaneViewMode {
  DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeFormat = 0,
  DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeAnimate = 1,
  DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeSetup = 2
};
bool DesktopUILayoutArchive_InspectorPaneViewMode_IsValid(int value);
const DesktopUILayoutArchive_InspectorPaneViewMode DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_MIN = DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeFormat;
const DesktopUILayoutArchive_InspectorPaneViewMode DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_MAX = DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeSetup;
const int DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_ARRAYSIZE = DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* DesktopUILayoutArchive_InspectorPaneViewMode_descriptor();
inline const ::std::string& DesktopUILayoutArchive_InspectorPaneViewMode_Name(DesktopUILayoutArchive_InspectorPaneViewMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    DesktopUILayoutArchive_InspectorPaneViewMode_descriptor(), value);
}
inline bool DesktopUILayoutArchive_InspectorPaneViewMode_Parse(
    const ::std::string& name, DesktopUILayoutArchive_InspectorPaneViewMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DesktopUILayoutArchive_InspectorPaneViewMode>(
    DesktopUILayoutArchive_InspectorPaneViewMode_descriptor(), name, value);
}
enum ShowArchive_KNShowMode {
  ShowArchive_KNShowMode_kKNShowModeNormal = 0,
  ShowArchive_KNShowMode_kKNShowModeAutoPlay = 1,
  ShowArchive_KNShowMode_kKNShowModeHyperlinksOnly = 2
};
bool ShowArchive_KNShowMode_IsValid(int value);
const ShowArchive_KNShowMode ShowArchive_KNShowMode_KNShowMode_MIN = ShowArchive_KNShowMode_kKNShowModeNormal;
const ShowArchive_KNShowMode ShowArchive_KNShowMode_KNShowMode_MAX = ShowArchive_KNShowMode_kKNShowModeHyperlinksOnly;
const int ShowArchive_KNShowMode_KNShowMode_ARRAYSIZE = ShowArchive_KNShowMode_KNShowMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShowArchive_KNShowMode_descriptor();
inline const ::std::string& ShowArchive_KNShowMode_Name(ShowArchive_KNShowMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShowArchive_KNShowMode_descriptor(), value);
}
inline bool ShowArchive_KNShowMode_Parse(
    const ::std::string& name, ShowArchive_KNShowMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShowArchive_KNShowMode>(
    ShowArchive_KNShowMode_descriptor(), name, value);
}
enum RecordingArchive_RecordingSyncState {
  RecordingArchive_RecordingSyncState_kRecordingSyncStateInSyncWithShow = 0,
  RecordingArchive_RecordingSyncState_kRecordingSyncStateOutOfSyncWithShow = 1
};
bool RecordingArchive_RecordingSyncState_IsValid(int value);
const RecordingArchive_RecordingSyncState RecordingArchive_RecordingSyncState_RecordingSyncState_MIN = RecordingArchive_RecordingSyncState_kRecordingSyncStateInSyncWithShow;
const RecordingArchive_RecordingSyncState RecordingArchive_RecordingSyncState_RecordingSyncState_MAX = RecordingArchive_RecordingSyncState_kRecordingSyncStateOutOfSyncWithShow;
const int RecordingArchive_RecordingSyncState_RecordingSyncState_ARRAYSIZE = RecordingArchive_RecordingSyncState_RecordingSyncState_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordingArchive_RecordingSyncState_descriptor();
inline const ::std::string& RecordingArchive_RecordingSyncState_Name(RecordingArchive_RecordingSyncState value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordingArchive_RecordingSyncState_descriptor(), value);
}
inline bool RecordingArchive_RecordingSyncState_Parse(
    const ::std::string& name, RecordingArchive_RecordingSyncState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordingArchive_RecordingSyncState>(
    RecordingArchive_RecordingSyncState_descriptor(), name, value);
}
enum RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase {
  RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationNone = 0,
  RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationStart = 1,
  RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationEnd = 2
};
bool RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_IsValid(int value);
const RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_MIN = RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationNone;
const RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_MAX = RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationEnd;
const int RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_ARRAYSIZE = RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_descriptor();
inline const ::std::string& RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_Name(RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_descriptor(), value);
}
inline bool RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_Parse(
    const ::std::string& name, RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase>(
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_descriptor(), name, value);
}
enum RecordingPauseEventArchive_RecordingPauseEventType {
  RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeResume = 0,
  RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypePause = 1,
  RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeConcealWithBlack = 2,
  RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeConcealWithWhite = 3
};
bool RecordingPauseEventArchive_RecordingPauseEventType_IsValid(int value);
const RecordingPauseEventArchive_RecordingPauseEventType RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_MIN = RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeResume;
const RecordingPauseEventArchive_RecordingPauseEventType RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_MAX = RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeConcealWithWhite;
const int RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_ARRAYSIZE = RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordingPauseEventArchive_RecordingPauseEventType_descriptor();
inline const ::std::string& RecordingPauseEventArchive_RecordingPauseEventType_Name(RecordingPauseEventArchive_RecordingPauseEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordingPauseEventArchive_RecordingPauseEventType_descriptor(), value);
}
inline bool RecordingPauseEventArchive_RecordingPauseEventType_Parse(
    const ::std::string& name, RecordingPauseEventArchive_RecordingPauseEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordingPauseEventArchive_RecordingPauseEventType>(
    RecordingPauseEventArchive_RecordingPauseEventType_descriptor(), name, value);
}
enum RecordingMovieEventArchive_RecordingMovieEventType {
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventNone = 0,
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventSeek = 1,
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventSetRate = 2,
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventStartPlayback = 3,
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventStopPlayback = 4,
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventBeginScrubbing = 5,
  RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventEndScrubbing = 6
};
bool RecordingMovieEventArchive_RecordingMovieEventType_IsValid(int value);
const RecordingMovieEventArchive_RecordingMovieEventType RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_MIN = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventNone;
const RecordingMovieEventArchive_RecordingMovieEventType RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_MAX = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventEndScrubbing;
const int RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_ARRAYSIZE = RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordingMovieEventArchive_RecordingMovieEventType_descriptor();
inline const ::std::string& RecordingMovieEventArchive_RecordingMovieEventType_Name(RecordingMovieEventArchive_RecordingMovieEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordingMovieEventArchive_RecordingMovieEventType_descriptor(), value);
}
inline bool RecordingMovieEventArchive_RecordingMovieEventType_Parse(
    const ::std::string& name, RecordingMovieEventArchive_RecordingMovieEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordingMovieEventArchive_RecordingMovieEventType>(
    RecordingMovieEventArchive_RecordingMovieEventType_descriptor(), name, value);
}
enum Soundtrack_SoundtrackMode {
  Soundtrack_SoundtrackMode_kKNSoundtrackModePlayOnce = 0,
  Soundtrack_SoundtrackMode_kKNSoundtrackModeLoop = 1,
  Soundtrack_SoundtrackMode_kKNSoundtrackModeDoNotPlay = 2
};
bool Soundtrack_SoundtrackMode_IsValid(int value);
const Soundtrack_SoundtrackMode Soundtrack_SoundtrackMode_SoundtrackMode_MIN = Soundtrack_SoundtrackMode_kKNSoundtrackModePlayOnce;
const Soundtrack_SoundtrackMode Soundtrack_SoundtrackMode_SoundtrackMode_MAX = Soundtrack_SoundtrackMode_kKNSoundtrackModeDoNotPlay;
const int Soundtrack_SoundtrackMode_SoundtrackMode_ARRAYSIZE = Soundtrack_SoundtrackMode_SoundtrackMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Soundtrack_SoundtrackMode_descriptor();
inline const ::std::string& Soundtrack_SoundtrackMode_Name(Soundtrack_SoundtrackMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Soundtrack_SoundtrackMode_descriptor(), value);
}
inline bool Soundtrack_SoundtrackMode_Parse(
    const ::std::string& name, Soundtrack_SoundtrackMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Soundtrack_SoundtrackMode>(
    Soundtrack_SoundtrackMode_descriptor(), name, value);
}
// ===================================================================

class AnimationAttributesArchive : public ::google::protobuf::Message {
 public:
  AnimationAttributesArchive();
  virtual ~AnimationAttributesArchive();

  AnimationAttributesArchive(const AnimationAttributesArchive& from);

  inline AnimationAttributesArchive& operator=(const AnimationAttributesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimationAttributesArchive& default_instance();

  void Swap(AnimationAttributesArchive* other);

  // implements Message ----------------------------------------------

  AnimationAttributesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimationAttributesArchive& from);
  void MergeFrom(const AnimationAttributesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string animationType = 1;
  inline bool has_animationtype() const;
  inline void clear_animationtype();
  static const int kAnimationTypeFieldNumber = 1;
  inline const ::std::string& animationtype() const;
  inline void set_animationtype(const ::std::string& value);
  inline void set_animationtype(const char* value);
  inline void set_animationtype(const char* value, size_t size);
  inline ::std::string* mutable_animationtype();
  inline ::std::string* release_animationtype();
  inline void set_allocated_animationtype(::std::string* animationtype);

  // optional string effect = 2;
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 2;
  inline const ::std::string& effect() const;
  inline void set_effect(const ::std::string& value);
  inline void set_effect(const char* value);
  inline void set_effect(const char* value, size_t size);
  inline ::std::string* mutable_effect();
  inline ::std::string* release_effect();
  inline void set_allocated_effect(::std::string* effect);

  // optional double duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline double duration() const;
  inline void set_duration(double value);

  // optional uint32 direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline ::google::protobuf::uint32 direction() const;
  inline void set_direction(::google::protobuf::uint32 value);

  // optional double delay = 5;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 5;
  inline double delay() const;
  inline void set_delay(double value);

  // optional bool isAutomatic = 6;
  inline bool has_isautomatic() const;
  inline void clear_isautomatic();
  static const int kIsAutomaticFieldNumber = 6;
  inline bool isautomatic() const;
  inline void set_isautomatic(bool value);

  // optional .TSP.Color color = 7;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 7;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // @@protoc_insertion_point(class_scope:KN.AnimationAttributesArchive)
 private:
  inline void set_has_animationtype();
  inline void clear_has_animationtype();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_isautomatic();
  inline void clear_has_isautomatic();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* animationtype_;
  ::std::string* effect_;
  double duration_;
  double delay_;
  ::google::protobuf::uint32 direction_;
  bool isautomatic_;
  ::TSP::Color* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static AnimationAttributesArchive* default_instance_;
};
// -------------------------------------------------------------------

class TransitionAttributesArchive : public ::google::protobuf::Message {
 public:
  TransitionAttributesArchive();
  virtual ~TransitionAttributesArchive();

  TransitionAttributesArchive(const TransitionAttributesArchive& from);

  inline TransitionAttributesArchive& operator=(const TransitionAttributesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitionAttributesArchive& default_instance();

  void Swap(TransitionAttributesArchive* other);

  // implements Message ----------------------------------------------

  TransitionAttributesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransitionAttributesArchive& from);
  void MergeFrom(const TransitionAttributesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveType;
  static const TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveTypeLinear = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeLinear;
  static const TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveTypeEaseIn = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseIn;
  static const TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveTypeEaseOut = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseOut;
  static const TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveTypeEaseInEaseOut = TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveTypeEaseInEaseOut;
  static inline bool TransitionCustomAttributesTimingCurveType_IsValid(int value) {
    return TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_IsValid(value);
  }
  static const TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveType_MIN =
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_MIN;
  static const TransitionCustomAttributesTimingCurveType TransitionCustomAttributesTimingCurveType_MAX =
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_MAX;
  static const int TransitionCustomAttributesTimingCurveType_ARRAYSIZE =
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_TransitionCustomAttributesTimingCurveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransitionCustomAttributesTimingCurveType_descriptor() {
    return TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_descriptor();
  }
  static inline const ::std::string& TransitionCustomAttributesTimingCurveType_Name(TransitionCustomAttributesTimingCurveType value) {
    return TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_Name(value);
  }
  static inline bool TransitionCustomAttributesTimingCurveType_Parse(const ::std::string& name,
      TransitionCustomAttributesTimingCurveType* value) {
    return TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_Parse(name, value);
  }

  typedef TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryType;
  static const TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryTypeByObject = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByObject;
  static const TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryTypeByWord = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByWord;
  static const TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryTypeByCharacter = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByCharacter;
  static const TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryTypeByLine = TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryTypeByLine;
  static inline bool TransitionCustomAttributesTextDeliveryType_IsValid(int value) {
    return TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_IsValid(value);
  }
  static const TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryType_MIN =
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_MIN;
  static const TransitionCustomAttributesTextDeliveryType TransitionCustomAttributesTextDeliveryType_MAX =
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_MAX;
  static const int TransitionCustomAttributesTextDeliveryType_ARRAYSIZE =
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_TransitionCustomAttributesTextDeliveryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransitionCustomAttributesTextDeliveryType_descriptor() {
    return TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_descriptor();
  }
  static inline const ::std::string& TransitionCustomAttributesTextDeliveryType_Name(TransitionCustomAttributesTextDeliveryType value) {
    return TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_Name(value);
  }
  static inline bool TransitionCustomAttributesTextDeliveryType_Parse(const ::std::string& name,
      TransitionCustomAttributesTextDeliveryType* value) {
    return TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .KN.AnimationAttributesArchive animationAttributes = 8;
  inline bool has_animationattributes() const;
  inline void clear_animationattributes();
  static const int kAnimationAttributesFieldNumber = 8;
  inline const ::KN::AnimationAttributesArchive& animationattributes() const;
  inline ::KN::AnimationAttributesArchive* mutable_animationattributes();
  inline ::KN::AnimationAttributesArchive* release_animationattributes();
  inline void set_allocated_animationattributes(::KN::AnimationAttributesArchive* animationattributes);

  // optional bool isAutomatic = 6;
  inline bool has_isautomatic() const;
  inline void clear_isautomatic();
  static const int kIsAutomaticFieldNumber = 6;
  inline bool isautomatic() const;
  inline void set_isautomatic(bool value);

  // optional float custom_twist = 9;
  inline bool has_custom_twist() const;
  inline void clear_custom_twist();
  static const int kCustomTwistFieldNumber = 9;
  inline float custom_twist() const;
  inline void set_custom_twist(float value);

  // optional uint32 custom_mosaic_size = 10;
  inline bool has_custom_mosaic_size() const;
  inline void clear_custom_mosaic_size();
  static const int kCustomMosaicSizeFieldNumber = 10;
  inline ::google::protobuf::uint32 custom_mosaic_size() const;
  inline void set_custom_mosaic_size(::google::protobuf::uint32 value);

  // optional uint32 custom_mosaic_type = 11;
  inline bool has_custom_mosaic_type() const;
  inline void clear_custom_mosaic_type();
  static const int kCustomMosaicTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 custom_mosaic_type() const;
  inline void set_custom_mosaic_type(::google::protobuf::uint32 value);

  // optional bool custom_bounce = 12;
  inline bool has_custom_bounce() const;
  inline void clear_custom_bounce();
  static const int kCustomBounceFieldNumber = 12;
  inline bool custom_bounce() const;
  inline void set_custom_bounce(bool value);

  // optional bool custom_magic_move_fade_unmatched_objects = 13;
  inline bool has_custom_magic_move_fade_unmatched_objects() const;
  inline void clear_custom_magic_move_fade_unmatched_objects();
  static const int kCustomMagicMoveFadeUnmatchedObjectsFieldNumber = 13;
  inline bool custom_magic_move_fade_unmatched_objects() const;
  inline void set_custom_magic_move_fade_unmatched_objects(bool value);

  // optional .KN.TransitionAttributesArchive.TransitionCustomAttributesTimingCurveType custom_timing_curve = 15;
  inline bool has_custom_timing_curve() const;
  inline void clear_custom_timing_curve();
  static const int kCustomTimingCurveFieldNumber = 15;
  inline ::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType custom_timing_curve() const;
  inline void set_custom_timing_curve(::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType value);

  // optional .KN.TransitionAttributesArchive.TransitionCustomAttributesTextDeliveryType custom_text_delivery_type = 16;
  inline bool has_custom_text_delivery_type() const;
  inline void clear_custom_text_delivery_type();
  static const int kCustomTextDeliveryTypeFieldNumber = 16;
  inline ::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType custom_text_delivery_type() const;
  inline void set_custom_text_delivery_type(::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType value);

  // optional string database_animationType = 1;
  inline bool has_database_animationtype() const;
  inline void clear_database_animationtype();
  static const int kDatabaseAnimationTypeFieldNumber = 1;
  inline const ::std::string& database_animationtype() const;
  inline void set_database_animationtype(const ::std::string& value);
  inline void set_database_animationtype(const char* value);
  inline void set_database_animationtype(const char* value, size_t size);
  inline ::std::string* mutable_database_animationtype();
  inline ::std::string* release_database_animationtype();
  inline void set_allocated_database_animationtype(::std::string* database_animationtype);

  // optional string database_effect = 2;
  inline bool has_database_effect() const;
  inline void clear_database_effect();
  static const int kDatabaseEffectFieldNumber = 2;
  inline const ::std::string& database_effect() const;
  inline void set_database_effect(const ::std::string& value);
  inline void set_database_effect(const char* value);
  inline void set_database_effect(const char* value, size_t size);
  inline ::std::string* mutable_database_effect();
  inline ::std::string* release_database_effect();
  inline void set_allocated_database_effect(::std::string* database_effect);

  // optional double database_duration = 3;
  inline bool has_database_duration() const;
  inline void clear_database_duration();
  static const int kDatabaseDurationFieldNumber = 3;
  inline double database_duration() const;
  inline void set_database_duration(double value);

  // optional uint32 database_direction = 4;
  inline bool has_database_direction() const;
  inline void clear_database_direction();
  static const int kDatabaseDirectionFieldNumber = 4;
  inline ::google::protobuf::uint32 database_direction() const;
  inline void set_database_direction(::google::protobuf::uint32 value);

  // optional float database_delay = 5;
  inline bool has_database_delay() const;
  inline void clear_database_delay();
  static const int kDatabaseDelayFieldNumber = 5;
  inline float database_delay() const;
  inline void set_database_delay(float value);

  // optional .TSP.Color database_color = 7;
  inline bool has_database_color() const;
  inline void clear_database_color();
  static const int kDatabaseColorFieldNumber = 7;
  inline const ::TSP::Color& database_color() const;
  inline ::TSP::Color* mutable_database_color();
  inline ::TSP::Color* release_database_color();
  inline void set_allocated_database_color(::TSP::Color* database_color);

  // @@protoc_insertion_point(class_scope:KN.TransitionAttributesArchive)
 private:
  inline void set_has_animationattributes();
  inline void clear_has_animationattributes();
  inline void set_has_isautomatic();
  inline void clear_has_isautomatic();
  inline void set_has_custom_twist();
  inline void clear_has_custom_twist();
  inline void set_has_custom_mosaic_size();
  inline void clear_has_custom_mosaic_size();
  inline void set_has_custom_mosaic_type();
  inline void clear_has_custom_mosaic_type();
  inline void set_has_custom_bounce();
  inline void clear_has_custom_bounce();
  inline void set_has_custom_magic_move_fade_unmatched_objects();
  inline void clear_has_custom_magic_move_fade_unmatched_objects();
  inline void set_has_custom_timing_curve();
  inline void clear_has_custom_timing_curve();
  inline void set_has_custom_text_delivery_type();
  inline void clear_has_custom_text_delivery_type();
  inline void set_has_database_animationtype();
  inline void clear_has_database_animationtype();
  inline void set_has_database_effect();
  inline void clear_has_database_effect();
  inline void set_has_database_duration();
  inline void clear_has_database_duration();
  inline void set_has_database_direction();
  inline void clear_has_database_direction();
  inline void set_has_database_delay();
  inline void clear_has_database_delay();
  inline void set_has_database_color();
  inline void clear_has_database_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::KN::AnimationAttributesArchive* animationattributes_;
  float custom_twist_;
  ::google::protobuf::uint32 custom_mosaic_size_;
  ::google::protobuf::uint32 custom_mosaic_type_;
  bool isautomatic_;
  bool custom_bounce_;
  bool custom_magic_move_fade_unmatched_objects_;
  int custom_timing_curve_;
  int custom_text_delivery_type_;
  ::std::string* database_animationtype_;
  ::std::string* database_effect_;
  double database_duration_;
  ::google::protobuf::uint32 database_direction_;
  float database_delay_;
  ::TSP::Color* database_color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static TransitionAttributesArchive* default_instance_;
};
// -------------------------------------------------------------------

class TransitionArchive : public ::google::protobuf::Message {
 public:
  TransitionArchive();
  virtual ~TransitionArchive();

  TransitionArchive(const TransitionArchive& from);

  inline TransitionArchive& operator=(const TransitionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitionArchive& default_instance();

  void Swap(TransitionArchive* other);

  // implements Message ----------------------------------------------

  TransitionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransitionArchive& from);
  void MergeFrom(const TransitionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KN.TransitionAttributesArchive attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::KN::TransitionAttributesArchive& attributes() const;
  inline ::KN::TransitionAttributesArchive* mutable_attributes();
  inline ::KN::TransitionAttributesArchive* release_attributes();
  inline void set_allocated_attributes(::KN::TransitionAttributesArchive* attributes);

  // @@protoc_insertion_point(class_scope:KN.TransitionArchive)
 private:
  inline void set_has_attributes();
  inline void clear_has_attributes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::KN::TransitionAttributesArchive* attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static TransitionArchive* default_instance_;
};
// -------------------------------------------------------------------

class BuildChunkArchive : public ::google::protobuf::Message {
 public:
  BuildChunkArchive();
  virtual ~BuildChunkArchive();

  BuildChunkArchive(const BuildChunkArchive& from);

  inline BuildChunkArchive& operator=(const BuildChunkArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildChunkArchive& default_instance();

  void Swap(BuildChunkArchive* other);

  // implements Message ----------------------------------------------

  BuildChunkArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildChunkArchive& from);
  void MergeFrom(const BuildChunkArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference build = 1;
  inline bool has_build() const;
  inline void clear_build();
  static const int kBuildFieldNumber = 1;
  inline const ::TSP::Reference& build() const;
  inline ::TSP::Reference* mutable_build();
  inline ::TSP::Reference* release_build();
  inline void set_allocated_build(::TSP::Reference* build);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional double delay = 3;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 3;
  inline double delay() const;
  inline void set_delay(double value);

  // optional double duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline double duration() const;
  inline void set_duration(double value);

  // optional bool automatic = 5;
  inline bool has_automatic() const;
  inline void clear_automatic();
  static const int kAutomaticFieldNumber = 5;
  inline bool automatic() const;
  inline void set_automatic(bool value);

  // optional bool referent = 6;
  inline bool has_referent() const;
  inline void clear_referent();
  static const int kReferentFieldNumber = 6;
  inline bool referent() const;
  inline void set_referent(bool value);

  // @@protoc_insertion_point(class_scope:KN.BuildChunkArchive)
 private:
  inline void set_has_build();
  inline void clear_has_build();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_automatic();
  inline void clear_has_automatic();
  inline void set_has_referent();
  inline void clear_has_referent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* build_;
  double delay_;
  double duration_;
  ::google::protobuf::uint32 index_;
  bool automatic_;
  bool referent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static BuildChunkArchive* default_instance_;
};
// -------------------------------------------------------------------

class BuildAttributesArchive : public ::google::protobuf::Message {
 public:
  BuildAttributesArchive();
  virtual ~BuildAttributesArchive();

  BuildAttributesArchive(const BuildAttributesArchive& from);

  inline BuildAttributesArchive& operator=(const BuildAttributesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildAttributesArchive& default_instance();

  void Swap(BuildAttributesArchive* other);

  // implements Message ----------------------------------------------

  BuildAttributesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildAttributesArchive& from);
  void MergeFrom(const BuildAttributesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BuildAttributesArchive_BuildAttributesAcceleration BuildAttributesAcceleration;
  static const BuildAttributesAcceleration kNone = BuildAttributesArchive_BuildAttributesAcceleration_kNone;
  static const BuildAttributesAcceleration kEaseIn = BuildAttributesArchive_BuildAttributesAcceleration_kEaseIn;
  static const BuildAttributesAcceleration kEaseOut = BuildAttributesArchive_BuildAttributesAcceleration_kEaseOut;
  static const BuildAttributesAcceleration kEaseBoth = BuildAttributesArchive_BuildAttributesAcceleration_kEaseBoth;
  static inline bool BuildAttributesAcceleration_IsValid(int value) {
    return BuildAttributesArchive_BuildAttributesAcceleration_IsValid(value);
  }
  static const BuildAttributesAcceleration BuildAttributesAcceleration_MIN =
    BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_MIN;
  static const BuildAttributesAcceleration BuildAttributesAcceleration_MAX =
    BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_MAX;
  static const int BuildAttributesAcceleration_ARRAYSIZE =
    BuildAttributesArchive_BuildAttributesAcceleration_BuildAttributesAcceleration_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildAttributesAcceleration_descriptor() {
    return BuildAttributesArchive_BuildAttributesAcceleration_descriptor();
  }
  static inline const ::std::string& BuildAttributesAcceleration_Name(BuildAttributesAcceleration value) {
    return BuildAttributesArchive_BuildAttributesAcceleration_Name(value);
  }
  static inline bool BuildAttributesAcceleration_Parse(const ::std::string& name,
      BuildAttributesAcceleration* value) {
    return BuildAttributesArchive_BuildAttributesAcceleration_Parse(name, value);
  }

  typedef BuildAttributesArchive_BuildAttributesRotationDirection BuildAttributesRotationDirection;
  static const BuildAttributesRotationDirection kClockwise = BuildAttributesArchive_BuildAttributesRotationDirection_kClockwise;
  static const BuildAttributesRotationDirection kCounterclockwise = BuildAttributesArchive_BuildAttributesRotationDirection_kCounterclockwise;
  static inline bool BuildAttributesRotationDirection_IsValid(int value) {
    return BuildAttributesArchive_BuildAttributesRotationDirection_IsValid(value);
  }
  static const BuildAttributesRotationDirection BuildAttributesRotationDirection_MIN =
    BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_MIN;
  static const BuildAttributesRotationDirection BuildAttributesRotationDirection_MAX =
    BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_MAX;
  static const int BuildAttributesRotationDirection_ARRAYSIZE =
    BuildAttributesArchive_BuildAttributesRotationDirection_BuildAttributesRotationDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildAttributesRotationDirection_descriptor() {
    return BuildAttributesArchive_BuildAttributesRotationDirection_descriptor();
  }
  static inline const ::std::string& BuildAttributesRotationDirection_Name(BuildAttributesRotationDirection value) {
    return BuildAttributesArchive_BuildAttributesRotationDirection_Name(value);
  }
  static inline bool BuildAttributesRotationDirection_Parse(const ::std::string& name,
      BuildAttributesRotationDirection* value) {
    return BuildAttributesArchive_BuildAttributesRotationDirection_Parse(name, value);
  }

  typedef BuildAttributesArchive_BuildAttributesCurveStyle BuildAttributesCurveStyle;
  static const BuildAttributesCurveStyle kStraight = BuildAttributesArchive_BuildAttributesCurveStyle_kStraight;
  static const BuildAttributesCurveStyle kCurved = BuildAttributesArchive_BuildAttributesCurveStyle_kCurved;
  static inline bool BuildAttributesCurveStyle_IsValid(int value) {
    return BuildAttributesArchive_BuildAttributesCurveStyle_IsValid(value);
  }
  static const BuildAttributesCurveStyle BuildAttributesCurveStyle_MIN =
    BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_MIN;
  static const BuildAttributesCurveStyle BuildAttributesCurveStyle_MAX =
    BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_MAX;
  static const int BuildAttributesCurveStyle_ARRAYSIZE =
    BuildAttributesArchive_BuildAttributesCurveStyle_BuildAttributesCurveStyle_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildAttributesCurveStyle_descriptor() {
    return BuildAttributesArchive_BuildAttributesCurveStyle_descriptor();
  }
  static inline const ::std::string& BuildAttributesCurveStyle_Name(BuildAttributesCurveStyle value) {
    return BuildAttributesArchive_BuildAttributesCurveStyle_Name(value);
  }
  static inline bool BuildAttributesCurveStyle_Parse(const ::std::string& name,
      BuildAttributesCurveStyle* value) {
    return BuildAttributesArchive_BuildAttributesCurveStyle_Parse(name, value);
  }

  typedef BuildAttributesArchive_BuildAttributesTextDelivery BuildAttributesTextDelivery;
  static const BuildAttributesTextDelivery kTextDeliveryUndefined = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryUndefined;
  static const BuildAttributesTextDelivery kTextDeliveryByObject = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByObject;
  static const BuildAttributesTextDelivery kTextDeliveryByWord = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByWord;
  static const BuildAttributesTextDelivery kTextDeliveryByCharacter = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByCharacter;
  static const BuildAttributesTextDelivery kTextDeliveryByLine = BuildAttributesArchive_BuildAttributesTextDelivery_kTextDeliveryByLine;
  static inline bool BuildAttributesTextDelivery_IsValid(int value) {
    return BuildAttributesArchive_BuildAttributesTextDelivery_IsValid(value);
  }
  static const BuildAttributesTextDelivery BuildAttributesTextDelivery_MIN =
    BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_MIN;
  static const BuildAttributesTextDelivery BuildAttributesTextDelivery_MAX =
    BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_MAX;
  static const int BuildAttributesTextDelivery_ARRAYSIZE =
    BuildAttributesArchive_BuildAttributesTextDelivery_BuildAttributesTextDelivery_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildAttributesTextDelivery_descriptor() {
    return BuildAttributesArchive_BuildAttributesTextDelivery_descriptor();
  }
  static inline const ::std::string& BuildAttributesTextDelivery_Name(BuildAttributesTextDelivery value) {
    return BuildAttributesArchive_BuildAttributesTextDelivery_Name(value);
  }
  static inline bool BuildAttributesTextDelivery_Parse(const ::std::string& name,
      BuildAttributesTextDelivery* value) {
    return BuildAttributesArchive_BuildAttributesTextDelivery_Parse(name, value);
  }

  typedef BuildAttributesArchive_BuildAttributesDeliveryOption BuildAttributesDeliveryOption;
  static const BuildAttributesDeliveryOption kDeliveryOptionUndefined = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionUndefined;
  static const BuildAttributesDeliveryOption kDeliveryOptionForward = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionForward;
  static const BuildAttributesDeliveryOption kDeliveryOptionBackward = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionBackward;
  static const BuildAttributesDeliveryOption kDeliveryOptionFromCenter = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionFromCenter;
  static const BuildAttributesDeliveryOption kDeliveryOptionFromEdges = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionFromEdges;
  static const BuildAttributesDeliveryOption kDeliveryOptionRandom = BuildAttributesArchive_BuildAttributesDeliveryOption_kDeliveryOptionRandom;
  static inline bool BuildAttributesDeliveryOption_IsValid(int value) {
    return BuildAttributesArchive_BuildAttributesDeliveryOption_IsValid(value);
  }
  static const BuildAttributesDeliveryOption BuildAttributesDeliveryOption_MIN =
    BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_MIN;
  static const BuildAttributesDeliveryOption BuildAttributesDeliveryOption_MAX =
    BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_MAX;
  static const int BuildAttributesDeliveryOption_ARRAYSIZE =
    BuildAttributesArchive_BuildAttributesDeliveryOption_BuildAttributesDeliveryOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildAttributesDeliveryOption_descriptor() {
    return BuildAttributesArchive_BuildAttributesDeliveryOption_descriptor();
  }
  static inline const ::std::string& BuildAttributesDeliveryOption_Name(BuildAttributesDeliveryOption value) {
    return BuildAttributesArchive_BuildAttributesDeliveryOption_Name(value);
  }
  static inline bool BuildAttributesDeliveryOption_Parse(const ::std::string& name,
      BuildAttributesDeliveryOption* value) {
    return BuildAttributesArchive_BuildAttributesDeliveryOption_Parse(name, value);
  }

  typedef BuildAttributesArchive_ActionBuildAttributesJiggleIntensity ActionBuildAttributesJiggleIntensity;
  static const ActionBuildAttributesJiggleIntensity kJiggleIntensitySmall = BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensitySmall;
  static const ActionBuildAttributesJiggleIntensity kJiggleIntensityMedium = BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensityMedium;
  static const ActionBuildAttributesJiggleIntensity kJiggleIntensityLarge = BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_kJiggleIntensityLarge;
  static inline bool ActionBuildAttributesJiggleIntensity_IsValid(int value) {
    return BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_IsValid(value);
  }
  static const ActionBuildAttributesJiggleIntensity ActionBuildAttributesJiggleIntensity_MIN =
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_MIN;
  static const ActionBuildAttributesJiggleIntensity ActionBuildAttributesJiggleIntensity_MAX =
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_MAX;
  static const int ActionBuildAttributesJiggleIntensity_ARRAYSIZE =
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_ActionBuildAttributesJiggleIntensity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionBuildAttributesJiggleIntensity_descriptor() {
    return BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_descriptor();
  }
  static inline const ::std::string& ActionBuildAttributesJiggleIntensity_Name(ActionBuildAttributesJiggleIntensity value) {
    return BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_Name(value);
  }
  static inline bool ActionBuildAttributesJiggleIntensity_Parse(const ::std::string& name,
      ActionBuildAttributesJiggleIntensity* value) {
    return BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .KN.AnimationAttributesArchive animationAttributes = 18;
  inline bool has_animationattributes() const;
  inline void clear_animationattributes();
  static const int kAnimationAttributesFieldNumber = 18;
  inline const ::KN::AnimationAttributesArchive& animationattributes() const;
  inline ::KN::AnimationAttributesArchive* mutable_animationattributes();
  inline ::KN::AnimationAttributesArchive* release_animationattributes();
  inline void set_allocated_animationattributes(::KN::AnimationAttributesArchive* animationattributes);

  // optional uint32 eventTrigger = 4;
  inline bool has_eventtrigger() const;
  inline void clear_eventtrigger();
  static const int kEventTriggerFieldNumber = 4;
  inline ::google::protobuf::uint32 eventtrigger() const;
  inline void set_eventtrigger(::google::protobuf::uint32 value);

  // optional double delayAutomaticAfter = 6;
  inline bool has_delayautomaticafter() const;
  inline void clear_delayautomaticafter();
  static const int kDelayAutomaticAfterFieldNumber = 6;
  inline double delayautomaticafter() const;
  inline void set_delayautomaticafter(double value);

  // optional double delayAutomaticWith = 7;
  inline bool has_delayautomaticwith() const;
  inline void clear_delayautomaticwith();
  static const int kDelayAutomaticWithFieldNumber = 7;
  inline double delayautomaticwith() const;
  inline void set_delayautomaticwith(double value);

  // optional .KN.BuildAttributesArchive.BuildAttributesCurveStyle curveStyle = 14;
  inline bool has_curvestyle() const;
  inline void clear_curvestyle();
  static const int kCurveStyleFieldNumber = 14;
  inline ::KN::BuildAttributesArchive_BuildAttributesCurveStyle curvestyle() const;
  inline void set_curvestyle(::KN::BuildAttributesArchive_BuildAttributesCurveStyle value);

  // optional double ChartRotation3D = 17;
  inline bool has_chartrotation3d() const;
  inline void clear_chartrotation3d();
  static const int kChartRotation3DFieldNumber = 17;
  inline double chartrotation3d() const;
  inline void set_chartrotation3d(double value);

  // optional uint32 startOffset = 27;
  inline bool has_startoffset() const;
  inline void clear_startoffset();
  static const int kStartOffsetFieldNumber = 27;
  inline ::google::protobuf::uint32 startoffset() const;
  inline void set_startoffset(::google::protobuf::uint32 value);

  // optional uint32 endOffset = 28;
  inline bool has_endoffset() const;
  inline void clear_endoffset();
  static const int kEndOffsetFieldNumber = 28;
  inline ::google::protobuf::uint32 endoffset() const;
  inline void set_endoffset(::google::protobuf::uint32 value);

  // optional double action_rotationAngle = 9;
  inline bool has_action_rotationangle() const;
  inline void clear_action_rotationangle();
  static const int kActionRotationAngleFieldNumber = 9;
  inline double action_rotationangle() const;
  inline void set_action_rotationangle(double value);

  // optional .KN.BuildAttributesArchive.BuildAttributesRotationDirection action_rotationDirection = 10;
  inline bool has_action_rotationdirection() const;
  inline void clear_action_rotationdirection();
  static const int kActionRotationDirectionFieldNumber = 10;
  inline ::KN::BuildAttributesArchive_BuildAttributesRotationDirection action_rotationdirection() const;
  inline void set_action_rotationdirection(::KN::BuildAttributesArchive_BuildAttributesRotationDirection value);

  // optional double action_scaleSize = 11;
  inline bool has_action_scalesize() const;
  inline void clear_action_scalesize();
  static const int kActionScaleSizeFieldNumber = 11;
  inline double action_scalesize() const;
  inline void set_action_scalesize(double value);

  // optional double action_colorAlpha = 12;
  inline bool has_action_coloralpha() const;
  inline void clear_action_coloralpha();
  static const int kActionColorAlphaFieldNumber = 12;
  inline double action_coloralpha() const;
  inline void set_action_coloralpha(double value);

  // optional .KN.BuildAttributesArchive.BuildAttributesAcceleration action_acceleration = 13;
  inline bool has_action_acceleration() const;
  inline void clear_action_acceleration();
  static const int kActionAccelerationFieldNumber = 13;
  inline ::KN::BuildAttributesArchive_BuildAttributesAcceleration action_acceleration() const;
  inline void set_action_acceleration(::KN::BuildAttributesArchive_BuildAttributesAcceleration value);

  // optional .TSD.PathSourceArchive action_motionPathSource = 22;
  inline bool has_action_motionpathsource() const;
  inline void clear_action_motionpathsource();
  static const int kActionMotionPathSourceFieldNumber = 22;
  inline const ::TSD::PathSourceArchive& action_motionpathsource() const;
  inline ::TSD::PathSourceArchive* mutable_action_motionpathsource();
  inline ::TSD::PathSourceArchive* release_action_motionpathsource();
  inline void set_allocated_action_motionpathsource(::TSD::PathSourceArchive* action_motionpathsource);

  // optional bool custom_bounce = 19;
  inline bool has_custom_bounce() const;
  inline void clear_custom_bounce();
  static const int kCustomBounceFieldNumber = 19;
  inline bool custom_bounce() const;
  inline void set_custom_bounce(bool value);

  // optional .KN.BuildAttributesArchive.BuildAttributesTextDelivery custom_textDelivery = 20;
  inline bool has_custom_textdelivery() const;
  inline void clear_custom_textdelivery();
  static const int kCustomTextDeliveryFieldNumber = 20;
  inline ::KN::BuildAttributesArchive_BuildAttributesTextDelivery custom_textdelivery() const;
  inline void set_custom_textdelivery(::KN::BuildAttributesArchive_BuildAttributesTextDelivery value);

  // optional .KN.BuildAttributesArchive.BuildAttributesDeliveryOption custom_deliveryOption = 21;
  inline bool has_custom_deliveryoption() const;
  inline void clear_custom_deliveryoption();
  static const int kCustomDeliveryOptionFieldNumber = 21;
  inline ::KN::BuildAttributesArchive_BuildAttributesDeliveryOption custom_deliveryoption() const;
  inline void set_custom_deliveryoption(::KN::BuildAttributesArchive_BuildAttributesDeliveryOption value);

  // optional bool custom_action_decay = 23;
  inline bool has_custom_action_decay() const;
  inline void clear_custom_action_decay();
  static const int kCustomActionDecayFieldNumber = 23;
  inline bool custom_action_decay() const;
  inline void set_custom_action_decay(bool value);

  // optional uint32 custom_action_repeatCount = 24;
  inline bool has_custom_action_repeatcount() const;
  inline void clear_custom_action_repeatcount();
  static const int kCustomActionRepeatCountFieldNumber = 24;
  inline ::google::protobuf::uint32 custom_action_repeatcount() const;
  inline void set_custom_action_repeatcount(::google::protobuf::uint32 value);

  // optional double custom_action_scale = 25;
  inline bool has_custom_action_scale() const;
  inline void clear_custom_action_scale();
  static const int kCustomActionScaleFieldNumber = 25;
  inline double custom_action_scale() const;
  inline void set_custom_action_scale(double value);

  // optional .KN.BuildAttributesArchive.ActionBuildAttributesJiggleIntensity custom_action_jiggleIntensity = 26;
  inline bool has_custom_action_jiggleintensity() const;
  inline void clear_custom_action_jiggleintensity();
  static const int kCustomActionJiggleIntensityFieldNumber = 26;
  inline ::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity custom_action_jiggleintensity() const;
  inline void set_custom_action_jiggleintensity(::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity value);

  // optional string database_animationType = 1;
  inline bool has_database_animationtype() const;
  inline void clear_database_animationtype();
  static const int kDatabaseAnimationTypeFieldNumber = 1;
  inline const ::std::string& database_animationtype() const;
  inline void set_database_animationtype(const ::std::string& value);
  inline void set_database_animationtype(const char* value);
  inline void set_database_animationtype(const char* value, size_t size);
  inline ::std::string* mutable_database_animationtype();
  inline ::std::string* release_database_animationtype();
  inline void set_allocated_database_animationtype(::std::string* database_animationtype);

  // optional string database_effect = 2;
  inline bool has_database_effect() const;
  inline void clear_database_effect();
  static const int kDatabaseEffectFieldNumber = 2;
  inline const ::std::string& database_effect() const;
  inline void set_database_effect(const ::std::string& value);
  inline void set_database_effect(const char* value);
  inline void set_database_effect(const char* value, size_t size);
  inline ::std::string* mutable_database_effect();
  inline ::std::string* release_database_effect();
  inline void set_allocated_database_effect(::std::string* database_effect);

  // optional uint32 database_direction = 3;
  inline bool has_database_direction() const;
  inline void clear_database_direction();
  static const int kDatabaseDirectionFieldNumber = 3;
  inline ::google::protobuf::uint32 database_direction() const;
  inline void set_database_direction(::google::protobuf::uint32 value);

  // optional double database_delay = 5;
  inline bool has_database_delay() const;
  inline void clear_database_delay();
  static const int kDatabaseDelayFieldNumber = 5;
  inline double database_delay() const;
  inline void set_database_delay(double value);

  // optional double database_duration = 8;
  inline bool has_database_duration() const;
  inline void clear_database_duration();
  static const int kDatabaseDurationFieldNumber = 8;
  inline double database_duration() const;
  inline void set_database_duration(double value);

  // optional .TSP.Color database_color = 16;
  inline bool has_database_color() const;
  inline void clear_database_color();
  static const int kDatabaseColorFieldNumber = 16;
  inline const ::TSP::Color& database_color() const;
  inline ::TSP::Color* mutable_database_color();
  inline ::TSP::Color* release_database_color();
  inline void set_allocated_database_color(::TSP::Color* database_color);

  // optional string motionPathString = 15 [deprecated = true];
  inline bool has_motionpathstring() const PROTOBUF_DEPRECATED;
  inline void clear_motionpathstring() PROTOBUF_DEPRECATED;
  static const int kMotionPathStringFieldNumber = 15;
  inline const ::std::string& motionpathstring() const PROTOBUF_DEPRECATED;
  inline void set_motionpathstring(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_motionpathstring(const char* value) PROTOBUF_DEPRECATED;
  inline void set_motionpathstring(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_motionpathstring() PROTOBUF_DEPRECATED;
  inline ::std::string* release_motionpathstring() PROTOBUF_DEPRECATED;
  inline void set_allocated_motionpathstring(::std::string* motionpathstring) PROTOBUF_DEPRECATED;

  // @@protoc_insertion_point(class_scope:KN.BuildAttributesArchive)
 private:
  inline void set_has_animationattributes();
  inline void clear_has_animationattributes();
  inline void set_has_eventtrigger();
  inline void clear_has_eventtrigger();
  inline void set_has_delayautomaticafter();
  inline void clear_has_delayautomaticafter();
  inline void set_has_delayautomaticwith();
  inline void clear_has_delayautomaticwith();
  inline void set_has_curvestyle();
  inline void clear_has_curvestyle();
  inline void set_has_chartrotation3d();
  inline void clear_has_chartrotation3d();
  inline void set_has_startoffset();
  inline void clear_has_startoffset();
  inline void set_has_endoffset();
  inline void clear_has_endoffset();
  inline void set_has_action_rotationangle();
  inline void clear_has_action_rotationangle();
  inline void set_has_action_rotationdirection();
  inline void clear_has_action_rotationdirection();
  inline void set_has_action_scalesize();
  inline void clear_has_action_scalesize();
  inline void set_has_action_coloralpha();
  inline void clear_has_action_coloralpha();
  inline void set_has_action_acceleration();
  inline void clear_has_action_acceleration();
  inline void set_has_action_motionpathsource();
  inline void clear_has_action_motionpathsource();
  inline void set_has_custom_bounce();
  inline void clear_has_custom_bounce();
  inline void set_has_custom_textdelivery();
  inline void clear_has_custom_textdelivery();
  inline void set_has_custom_deliveryoption();
  inline void clear_has_custom_deliveryoption();
  inline void set_has_custom_action_decay();
  inline void clear_has_custom_action_decay();
  inline void set_has_custom_action_repeatcount();
  inline void clear_has_custom_action_repeatcount();
  inline void set_has_custom_action_scale();
  inline void clear_has_custom_action_scale();
  inline void set_has_custom_action_jiggleintensity();
  inline void clear_has_custom_action_jiggleintensity();
  inline void set_has_database_animationtype();
  inline void clear_has_database_animationtype();
  inline void set_has_database_effect();
  inline void clear_has_database_effect();
  inline void set_has_database_direction();
  inline void clear_has_database_direction();
  inline void set_has_database_delay();
  inline void clear_has_database_delay();
  inline void set_has_database_duration();
  inline void clear_has_database_duration();
  inline void set_has_database_color();
  inline void clear_has_database_color();
  inline void set_has_motionpathstring();
  inline void clear_has_motionpathstring();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::KN::AnimationAttributesArchive* animationattributes_;
  double delayautomaticafter_;
  ::google::protobuf::uint32 eventtrigger_;
  int curvestyle_;
  double delayautomaticwith_;
  double chartrotation3d_;
  ::google::protobuf::uint32 startoffset_;
  ::google::protobuf::uint32 endoffset_;
  double action_rotationangle_;
  double action_scalesize_;
  int action_rotationdirection_;
  int action_acceleration_;
  double action_coloralpha_;
  ::TSD::PathSourceArchive* action_motionpathsource_;
  int custom_textdelivery_;
  bool custom_bounce_;
  bool custom_action_decay_;
  int custom_deliveryoption_;
  ::google::protobuf::uint32 custom_action_repeatcount_;
  double custom_action_scale_;
  ::std::string* database_animationtype_;
  int custom_action_jiggleintensity_;
  ::google::protobuf::uint32 database_direction_;
  ::std::string* database_effect_;
  double database_delay_;
  double database_duration_;
  ::TSP::Color* database_color_;
  ::std::string* motionpathstring_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static BuildAttributesArchive* default_instance_;
};
// -------------------------------------------------------------------

class BuildArchive : public ::google::protobuf::Message {
 public:
  BuildArchive();
  virtual ~BuildArchive();

  BuildArchive(const BuildArchive& from);

  inline BuildArchive& operator=(const BuildArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildArchive& default_instance();

  void Swap(BuildArchive* other);

  // implements Message ----------------------------------------------

  BuildArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildArchive& from);
  void MergeFrom(const BuildArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // required string delivery = 2;
  inline bool has_delivery() const;
  inline void clear_delivery();
  static const int kDeliveryFieldNumber = 2;
  inline const ::std::string& delivery() const;
  inline void set_delivery(const ::std::string& value);
  inline void set_delivery(const char* value);
  inline void set_delivery(const char* value, size_t size);
  inline ::std::string* mutable_delivery();
  inline ::std::string* release_delivery();
  inline void set_allocated_delivery(::std::string* delivery);

  // required double duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline double duration() const;
  inline void set_duration(double value);

  // required .KN.BuildAttributesArchive attributes = 4;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::KN::BuildAttributesArchive& attributes() const;
  inline ::KN::BuildAttributesArchive* mutable_attributes();
  inline ::KN::BuildAttributesArchive* release_attributes();
  inline void set_allocated_attributes(::KN::BuildAttributesArchive* attributes);

  // @@protoc_insertion_point(class_scope:KN.BuildArchive)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_delivery();
  inline void clear_has_delivery();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_attributes();
  inline void clear_has_attributes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::std::string* delivery_;
  double duration_;
  ::KN::BuildAttributesArchive* attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static BuildArchive* default_instance_;
};
// -------------------------------------------------------------------

class PlaceholderArchive : public ::google::protobuf::Message {
 public:
  PlaceholderArchive();
  virtual ~PlaceholderArchive();

  PlaceholderArchive(const PlaceholderArchive& from);

  inline PlaceholderArchive& operator=(const PlaceholderArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaceholderArchive& default_instance();

  void Swap(PlaceholderArchive* other);

  // implements Message ----------------------------------------------

  PlaceholderArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaceholderArchive& from);
  void MergeFrom(const PlaceholderArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlaceholderArchive_Kind Kind;
  static const Kind kKindPlaceholder = PlaceholderArchive_Kind_kKindPlaceholder;
  static const Kind kKindSlideNumberPlaceholder = PlaceholderArchive_Kind_kKindSlideNumberPlaceholder;
  static const Kind kKindTitlePlaceholder = PlaceholderArchive_Kind_kKindTitlePlaceholder;
  static const Kind kKindBodyPlaceholder = PlaceholderArchive_Kind_kKindBodyPlaceholder;
  static const Kind kKindObjectPlaceholder = PlaceholderArchive_Kind_kKindObjectPlaceholder;
  static inline bool Kind_IsValid(int value) {
    return PlaceholderArchive_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    PlaceholderArchive_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    PlaceholderArchive_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    PlaceholderArchive_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return PlaceholderArchive_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return PlaceholderArchive_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return PlaceholderArchive_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSWP.ShapeInfoArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::ShapeInfoArchive& super() const;
  inline ::TSWP::ShapeInfoArchive* mutable_super();
  inline ::TSWP::ShapeInfoArchive* release_super();
  inline void set_allocated_super(::TSWP::ShapeInfoArchive* super);

  // optional .KN.PlaceholderArchive.Kind kind = 2 [default = kKindPlaceholder];
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 2;
  inline ::KN::PlaceholderArchive_Kind kind() const;
  inline void set_kind(::KN::PlaceholderArchive_Kind value);

  // @@protoc_insertion_point(class_scope:KN.PlaceholderArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ShapeInfoArchive* super_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static PlaceholderArchive* default_instance_;
};
// -------------------------------------------------------------------

class NoteArchive : public ::google::protobuf::Message {
 public:
  NoteArchive();
  virtual ~NoteArchive();

  NoteArchive(const NoteArchive& from);

  inline NoteArchive& operator=(const NoteArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoteArchive& default_instance();

  void Swap(NoteArchive* other);

  // implements Message ----------------------------------------------

  NoteArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoteArchive& from);
  void MergeFrom(const NoteArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference containedStorage = 1;
  inline bool has_containedstorage() const;
  inline void clear_containedstorage();
  static const int kContainedStorageFieldNumber = 1;
  inline const ::TSP::Reference& containedstorage() const;
  inline ::TSP::Reference* mutable_containedstorage();
  inline ::TSP::Reference* release_containedstorage();
  inline void set_allocated_containedstorage(::TSP::Reference* containedstorage);

  // @@protoc_insertion_point(class_scope:KN.NoteArchive)
 private:
  inline void set_has_containedstorage();
  inline void clear_has_containedstorage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* containedstorage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static NoteArchive* default_instance_;
};
// -------------------------------------------------------------------

class ClassicStylesheetRecordArchive : public ::google::protobuf::Message {
 public:
  ClassicStylesheetRecordArchive();
  virtual ~ClassicStylesheetRecordArchive();

  ClassicStylesheetRecordArchive(const ClassicStylesheetRecordArchive& from);

  inline ClassicStylesheetRecordArchive& operator=(const ClassicStylesheetRecordArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassicStylesheetRecordArchive& default_instance();

  void Swap(ClassicStylesheetRecordArchive* other);

  // implements Message ----------------------------------------------

  ClassicStylesheetRecordArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClassicStylesheetRecordArchive& from);
  void MergeFrom(const ClassicStylesheetRecordArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSS.StylesheetArchive.IdentifiedStyleEntry identifier_to_style_map = 1;
  inline int identifier_to_style_map_size() const;
  inline void clear_identifier_to_style_map();
  static const int kIdentifierToStyleMapFieldNumber = 1;
  inline const ::TSS::StylesheetArchive_IdentifiedStyleEntry& identifier_to_style_map(int index) const;
  inline ::TSS::StylesheetArchive_IdentifiedStyleEntry* mutable_identifier_to_style_map(int index);
  inline ::TSS::StylesheetArchive_IdentifiedStyleEntry* add_identifier_to_style_map();
  inline const ::google::protobuf::RepeatedPtrField< ::TSS::StylesheetArchive_IdentifiedStyleEntry >&
      identifier_to_style_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSS::StylesheetArchive_IdentifiedStyleEntry >*
      mutable_identifier_to_style_map();

  // optional .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // @@protoc_insertion_point(class_scope:KN.ClassicStylesheetRecordArchive)
 private:
  inline void set_has_theme();
  inline void clear_has_theme();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSS::StylesheetArchive_IdentifiedStyleEntry > identifier_to_style_map_;
  ::TSP::Reference* theme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static ClassicStylesheetRecordArchive* default_instance_;
};
// -------------------------------------------------------------------

class ClassicThemeRecordArchive : public ::google::protobuf::Message {
 public:
  ClassicThemeRecordArchive();
  virtual ~ClassicThemeRecordArchive();

  ClassicThemeRecordArchive(const ClassicThemeRecordArchive& from);

  inline ClassicThemeRecordArchive& operator=(const ClassicThemeRecordArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassicThemeRecordArchive& default_instance();

  void Swap(ClassicThemeRecordArchive* other);

  // implements Message ----------------------------------------------

  ClassicThemeRecordArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClassicThemeRecordArchive& from);
  void MergeFrom(const ClassicThemeRecordArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional .TSP.Reference stylesheetRecord = 2;
  inline bool has_stylesheetrecord() const;
  inline void clear_stylesheetrecord();
  static const int kStylesheetRecordFieldNumber = 2;
  inline const ::TSP::Reference& stylesheetrecord() const;
  inline ::TSP::Reference* mutable_stylesheetrecord();
  inline ::TSP::Reference* release_stylesheetrecord();
  inline void set_allocated_stylesheetrecord(::TSP::Reference* stylesheetrecord);

  // repeated .TSP.Reference masters = 3;
  inline int masters_size() const;
  inline void clear_masters();
  static const int kMastersFieldNumber = 3;
  inline const ::TSP::Reference& masters(int index) const;
  inline ::TSP::Reference* mutable_masters(int index);
  inline ::TSP::Reference* add_masters();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      masters() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_masters();

  // @@protoc_insertion_point(class_scope:KN.ClassicThemeRecordArchive)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_stylesheetrecord();
  inline void clear_has_stylesheetrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::TSP::Reference* stylesheetrecord_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > masters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static ClassicThemeRecordArchive* default_instance_;
};
// -------------------------------------------------------------------

class SlideArchive_SageTagMapEntry : public ::google::protobuf::Message {
 public:
  SlideArchive_SageTagMapEntry();
  virtual ~SlideArchive_SageTagMapEntry();

  SlideArchive_SageTagMapEntry(const SlideArchive_SageTagMapEntry& from);

  inline SlideArchive_SageTagMapEntry& operator=(const SlideArchive_SageTagMapEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideArchive_SageTagMapEntry& default_instance();

  void Swap(SlideArchive_SageTagMapEntry* other);

  // implements Message ----------------------------------------------

  SlideArchive_SageTagMapEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideArchive_SageTagMapEntry& from);
  void MergeFrom(const SlideArchive_SageTagMapEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // required .TSP.Reference info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::TSP::Reference& info() const;
  inline ::TSP::Reference* mutable_info();
  inline ::TSP::Reference* release_info();
  inline void set_allocated_info(::TSP::Reference* info);

  // @@protoc_insertion_point(class_scope:KN.SlideArchive.SageTagMapEntry)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tag_;
  ::TSP::Reference* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideArchive_SageTagMapEntry* default_instance_;
};
// -------------------------------------------------------------------

class SlideArchive : public ::google::protobuf::Message {
 public:
  SlideArchive();
  virtual ~SlideArchive();

  SlideArchive(const SlideArchive& from);

  inline SlideArchive& operator=(const SlideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideArchive& default_instance();

  void Swap(SlideArchive* other);

  // implements Message ----------------------------------------------

  SlideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideArchive& from);
  void MergeFrom(const SlideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlideArchive_SageTagMapEntry SageTagMapEntry;

  // accessors -------------------------------------------------------

  // required .TSP.Reference style = 1;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 1;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // repeated .TSP.Reference builds = 2;
  inline int builds_size() const;
  inline void clear_builds();
  static const int kBuildsFieldNumber = 2;
  inline const ::TSP::Reference& builds(int index) const;
  inline ::TSP::Reference* mutable_builds(int index);
  inline ::TSP::Reference* add_builds();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      builds() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_builds();

  // repeated .KN.BuildChunkArchive buildChunks = 3;
  inline int buildchunks_size() const;
  inline void clear_buildchunks();
  static const int kBuildChunksFieldNumber = 3;
  inline const ::KN::BuildChunkArchive& buildchunks(int index) const;
  inline ::KN::BuildChunkArchive* mutable_buildchunks(int index);
  inline ::KN::BuildChunkArchive* add_buildchunks();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >&
      buildchunks() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >*
      mutable_buildchunks();

  // required .KN.TransitionArchive transition = 4;
  inline bool has_transition() const;
  inline void clear_transition();
  static const int kTransitionFieldNumber = 4;
  inline const ::KN::TransitionArchive& transition() const;
  inline ::KN::TransitionArchive* mutable_transition();
  inline ::KN::TransitionArchive* release_transition();
  inline void set_allocated_transition(::KN::TransitionArchive* transition);

  // optional .TSP.Reference titlePlaceholder = 5;
  inline bool has_titleplaceholder() const;
  inline void clear_titleplaceholder();
  static const int kTitlePlaceholderFieldNumber = 5;
  inline const ::TSP::Reference& titleplaceholder() const;
  inline ::TSP::Reference* mutable_titleplaceholder();
  inline ::TSP::Reference* release_titleplaceholder();
  inline void set_allocated_titleplaceholder(::TSP::Reference* titleplaceholder);

  // optional .TSP.Reference bodyPlaceholder = 6;
  inline bool has_bodyplaceholder() const;
  inline void clear_bodyplaceholder();
  static const int kBodyPlaceholderFieldNumber = 6;
  inline const ::TSP::Reference& bodyplaceholder() const;
  inline ::TSP::Reference* mutable_bodyplaceholder();
  inline ::TSP::Reference* release_bodyplaceholder();
  inline void set_allocated_bodyplaceholder(::TSP::Reference* bodyplaceholder);

  // optional .TSP.Reference objectPlaceholder = 30;
  inline bool has_objectplaceholder() const;
  inline void clear_objectplaceholder();
  static const int kObjectPlaceholderFieldNumber = 30;
  inline const ::TSP::Reference& objectplaceholder() const;
  inline ::TSP::Reference* mutable_objectplaceholder();
  inline ::TSP::Reference* release_objectplaceholder();
  inline void set_allocated_objectplaceholder(::TSP::Reference* objectplaceholder);

  // optional .TSP.Reference slideNumberPlaceholder = 20;
  inline bool has_slidenumberplaceholder() const;
  inline void clear_slidenumberplaceholder();
  static const int kSlideNumberPlaceholderFieldNumber = 20;
  inline const ::TSP::Reference& slidenumberplaceholder() const;
  inline ::TSP::Reference* mutable_slidenumberplaceholder();
  inline ::TSP::Reference* release_slidenumberplaceholder();
  inline void set_allocated_slidenumberplaceholder(::TSP::Reference* slidenumberplaceholder);

  // repeated .TSP.Reference drawables = 7;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 7;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // repeated .KN.SlideArchive.SageTagMapEntry sage_tag_to_info_map = 28;
  inline int sage_tag_to_info_map_size() const;
  inline void clear_sage_tag_to_info_map();
  static const int kSageTagToInfoMapFieldNumber = 28;
  inline const ::KN::SlideArchive_SageTagMapEntry& sage_tag_to_info_map(int index) const;
  inline ::KN::SlideArchive_SageTagMapEntry* mutable_sage_tag_to_info_map(int index);
  inline ::KN::SlideArchive_SageTagMapEntry* add_sage_tag_to_info_map();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::SlideArchive_SageTagMapEntry >&
      sage_tag_to_info_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::SlideArchive_SageTagMapEntry >*
      mutable_sage_tag_to_info_map();

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .TSD.GeometryArchive titlePlaceholderGeometry = 11;
  inline bool has_titleplaceholdergeometry() const;
  inline void clear_titleplaceholdergeometry();
  static const int kTitlePlaceholderGeometryFieldNumber = 11;
  inline const ::TSD::GeometryArchive& titleplaceholdergeometry() const;
  inline ::TSD::GeometryArchive* mutable_titleplaceholdergeometry();
  inline ::TSD::GeometryArchive* release_titleplaceholdergeometry();
  inline void set_allocated_titleplaceholdergeometry(::TSD::GeometryArchive* titleplaceholdergeometry);

  // optional uint32 titlePlaceholderShapeStyleIndex = 12;
  inline bool has_titleplaceholdershapestyleindex() const;
  inline void clear_titleplaceholdershapestyleindex();
  static const int kTitlePlaceholderShapeStyleIndexFieldNumber = 12;
  inline ::google::protobuf::uint32 titleplaceholdershapestyleindex() const;
  inline void set_titleplaceholdershapestyleindex(::google::protobuf::uint32 value);

  // optional uint32 titlePlaceholderTextStyleIndex = 13;
  inline bool has_titleplaceholdertextstyleindex() const;
  inline void clear_titleplaceholdertextstyleindex();
  static const int kTitlePlaceholderTextStyleIndexFieldNumber = 13;
  inline ::google::protobuf::uint32 titleplaceholdertextstyleindex() const;
  inline void set_titleplaceholdertextstyleindex(::google::protobuf::uint32 value);

  // optional .TSWP.ShapeStylePropertiesArchive titleLayoutProperties = 24;
  inline bool has_titlelayoutproperties() const;
  inline void clear_titlelayoutproperties();
  static const int kTitleLayoutPropertiesFieldNumber = 24;
  inline const ::TSWP::ShapeStylePropertiesArchive& titlelayoutproperties() const;
  inline ::TSWP::ShapeStylePropertiesArchive* mutable_titlelayoutproperties();
  inline ::TSWP::ShapeStylePropertiesArchive* release_titlelayoutproperties();
  inline void set_allocated_titlelayoutproperties(::TSWP::ShapeStylePropertiesArchive* titlelayoutproperties);

  // optional .TSD.GeometryArchive bodyPlaceholderGeometry = 14;
  inline bool has_bodyplaceholdergeometry() const;
  inline void clear_bodyplaceholdergeometry();
  static const int kBodyPlaceholderGeometryFieldNumber = 14;
  inline const ::TSD::GeometryArchive& bodyplaceholdergeometry() const;
  inline ::TSD::GeometryArchive* mutable_bodyplaceholdergeometry();
  inline ::TSD::GeometryArchive* release_bodyplaceholdergeometry();
  inline void set_allocated_bodyplaceholdergeometry(::TSD::GeometryArchive* bodyplaceholdergeometry);

  // optional uint32 bodyPlaceholderShapeStyleIndex = 15;
  inline bool has_bodyplaceholdershapestyleindex() const;
  inline void clear_bodyplaceholdershapestyleindex();
  static const int kBodyPlaceholderShapeStyleIndexFieldNumber = 15;
  inline ::google::protobuf::uint32 bodyplaceholdershapestyleindex() const;
  inline void set_bodyplaceholdershapestyleindex(::google::protobuf::uint32 value);

  // optional uint32 bodyPlaceholderTextStyleIndex = 16;
  inline bool has_bodyplaceholdertextstyleindex() const;
  inline void clear_bodyplaceholdertextstyleindex();
  static const int kBodyPlaceholderTextStyleIndexFieldNumber = 16;
  inline ::google::protobuf::uint32 bodyplaceholdertextstyleindex() const;
  inline void set_bodyplaceholdertextstyleindex(::google::protobuf::uint32 value);

  // optional .TSWP.ShapeStylePropertiesArchive bodyLayoutProperties = 25;
  inline bool has_bodylayoutproperties() const;
  inline void clear_bodylayoutproperties();
  static const int kBodyLayoutPropertiesFieldNumber = 25;
  inline const ::TSWP::ShapeStylePropertiesArchive& bodylayoutproperties() const;
  inline ::TSWP::ShapeStylePropertiesArchive* mutable_bodylayoutproperties();
  inline ::TSWP::ShapeStylePropertiesArchive* release_bodylayoutproperties();
  inline void set_allocated_bodylayoutproperties(::TSWP::ShapeStylePropertiesArchive* bodylayoutproperties);

  // optional .TSD.GeometryArchive slideNumberPlaceholderGeometry = 21;
  inline bool has_slidenumberplaceholdergeometry() const;
  inline void clear_slidenumberplaceholdergeometry();
  static const int kSlideNumberPlaceholderGeometryFieldNumber = 21;
  inline const ::TSD::GeometryArchive& slidenumberplaceholdergeometry() const;
  inline ::TSD::GeometryArchive* mutable_slidenumberplaceholdergeometry();
  inline ::TSD::GeometryArchive* release_slidenumberplaceholdergeometry();
  inline void set_allocated_slidenumberplaceholdergeometry(::TSD::GeometryArchive* slidenumberplaceholdergeometry);

  // optional uint32 slideNumberPlaceholderShapeStyleIndex = 22;
  inline bool has_slidenumberplaceholdershapestyleindex() const;
  inline void clear_slidenumberplaceholdershapestyleindex();
  static const int kSlideNumberPlaceholderShapeStyleIndexFieldNumber = 22;
  inline ::google::protobuf::uint32 slidenumberplaceholdershapestyleindex() const;
  inline void set_slidenumberplaceholdershapestyleindex(::google::protobuf::uint32 value);

  // optional uint32 slideNumberPlaceholderTextStyleIndex = 23;
  inline bool has_slidenumberplaceholdertextstyleindex() const;
  inline void clear_slidenumberplaceholdertextstyleindex();
  static const int kSlideNumberPlaceholderTextStyleIndexFieldNumber = 23;
  inline ::google::protobuf::uint32 slidenumberplaceholdertextstyleindex() const;
  inline void set_slidenumberplaceholdertextstyleindex(::google::protobuf::uint32 value);

  // optional .TSWP.ShapeStylePropertiesArchive slideNumberLayoutProperties = 26;
  inline bool has_slidenumberlayoutproperties() const;
  inline void clear_slidenumberlayoutproperties();
  static const int kSlideNumberLayoutPropertiesFieldNumber = 26;
  inline const ::TSWP::ShapeStylePropertiesArchive& slidenumberlayoutproperties() const;
  inline ::TSWP::ShapeStylePropertiesArchive* mutable_slidenumberlayoutproperties();
  inline ::TSWP::ShapeStylePropertiesArchive* release_slidenumberlayoutproperties();
  inline void set_allocated_slidenumberlayoutproperties(::TSWP::ShapeStylePropertiesArchive* slidenumberlayoutproperties);

  // optional .TSP.Reference classicStylesheetRecord = 29;
  inline bool has_classicstylesheetrecord() const;
  inline void clear_classicstylesheetrecord();
  static const int kClassicStylesheetRecordFieldNumber = 29;
  inline const ::TSP::Reference& classicstylesheetrecord() const;
  inline ::TSP::Reference* mutable_classicstylesheetrecord();
  inline ::TSP::Reference* release_classicstylesheetrecord();
  inline void set_allocated_classicstylesheetrecord(::TSP::Reference* classicstylesheetrecord);

  // repeated .TSP.Reference bodyParagraphStyles = 31;
  inline int bodyparagraphstyles_size() const;
  inline void clear_bodyparagraphstyles();
  static const int kBodyParagraphStylesFieldNumber = 31;
  inline const ::TSP::Reference& bodyparagraphstyles(int index) const;
  inline ::TSP::Reference* mutable_bodyparagraphstyles(int index);
  inline ::TSP::Reference* add_bodyparagraphstyles();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      bodyparagraphstyles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_bodyparagraphstyles();

  // repeated .TSP.Reference bodyListStyles = 35;
  inline int bodyliststyles_size() const;
  inline void clear_bodyliststyles();
  static const int kBodyListStylesFieldNumber = 35;
  inline const ::TSP::Reference& bodyliststyles(int index) const;
  inline ::TSP::Reference* mutable_bodyliststyles(int index);
  inline ::TSP::Reference* add_bodyliststyles();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      bodyliststyles() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_bodyliststyles();

  // optional string thumbnailTextForTitlePlaceholder = 37;
  inline bool has_thumbnailtextfortitleplaceholder() const;
  inline void clear_thumbnailtextfortitleplaceholder();
  static const int kThumbnailTextForTitlePlaceholderFieldNumber = 37;
  inline const ::std::string& thumbnailtextfortitleplaceholder() const;
  inline void set_thumbnailtextfortitleplaceholder(const ::std::string& value);
  inline void set_thumbnailtextfortitleplaceholder(const char* value);
  inline void set_thumbnailtextfortitleplaceholder(const char* value, size_t size);
  inline ::std::string* mutable_thumbnailtextfortitleplaceholder();
  inline ::std::string* release_thumbnailtextfortitleplaceholder();
  inline void set_allocated_thumbnailtextfortitleplaceholder(::std::string* thumbnailtextfortitleplaceholder);

  // optional string thumbnailTextForBodyPlaceholder = 38;
  inline bool has_thumbnailtextforbodyplaceholder() const;
  inline void clear_thumbnailtextforbodyplaceholder();
  static const int kThumbnailTextForBodyPlaceholderFieldNumber = 38;
  inline const ::std::string& thumbnailtextforbodyplaceholder() const;
  inline void set_thumbnailtextforbodyplaceholder(const ::std::string& value);
  inline void set_thumbnailtextforbodyplaceholder(const char* value);
  inline void set_thumbnailtextforbodyplaceholder(const char* value, size_t size);
  inline ::std::string* mutable_thumbnailtextforbodyplaceholder();
  inline ::std::string* release_thumbnailtextforbodyplaceholder();
  inline void set_allocated_thumbnailtextforbodyplaceholder(::std::string* thumbnailtextforbodyplaceholder);

  // optional .TSP.Reference master = 17;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 17;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // repeated .TSD.GuideArchive staticGuides = 18;
  inline int staticguides_size() const;
  inline void clear_staticguides();
  static const int kStaticGuidesFieldNumber = 18;
  inline const ::TSD::GuideArchive& staticguides(int index) const;
  inline ::TSD::GuideArchive* mutable_staticguides(int index);
  inline ::TSD::GuideArchive* add_staticguides();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::GuideArchive >&
      staticguides() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::GuideArchive >*
      mutable_staticguides();

  // optional .TSP.Reference userDefinedGuideStorage = 36;
  inline bool has_userdefinedguidestorage() const;
  inline void clear_userdefinedguidestorage();
  static const int kUserDefinedGuideStorageFieldNumber = 36;
  inline const ::TSP::Reference& userdefinedguidestorage() const;
  inline ::TSP::Reference* mutable_userdefinedguidestorage();
  inline ::TSP::Reference* release_userdefinedguidestorage();
  inline void set_allocated_userdefinedguidestorage(::TSP::Reference* userdefinedguidestorage);

  // required bool inDocument = 19;
  inline bool has_indocument() const;
  inline void clear_indocument();
  static const int kInDocumentFieldNumber = 19;
  inline bool indocument() const;
  inline void set_indocument(bool value);

  // optional .TSP.Reference note = 27;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 27;
  inline const ::TSP::Reference& note() const;
  inline ::TSP::Reference* mutable_note();
  inline ::TSP::Reference* release_note();
  inline void set_allocated_note(::TSP::Reference* note);

  // optional .TSP.Reference info_using_object_placeholder_geometry = 39;
  inline bool has_info_using_object_placeholder_geometry() const;
  inline void clear_info_using_object_placeholder_geometry();
  static const int kInfoUsingObjectPlaceholderGeometryFieldNumber = 39;
  inline const ::TSP::Reference& info_using_object_placeholder_geometry() const;
  inline ::TSP::Reference* mutable_info_using_object_placeholder_geometry();
  inline ::TSP::Reference* release_info_using_object_placeholder_geometry();
  inline void set_allocated_info_using_object_placeholder_geometry(::TSP::Reference* info_using_object_placeholder_geometry);

  // optional bool info_using_object_placeholder_geometry_matches_object_placeholder_geometry = 40;
  inline bool has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry() const;
  inline void clear_info_using_object_placeholder_geometry_matches_object_placeholder_geometry();
  static const int kInfoUsingObjectPlaceholderGeometryMatchesObjectPlaceholderGeometryFieldNumber = 40;
  inline bool info_using_object_placeholder_geometry_matches_object_placeholder_geometry() const;
  inline void set_info_using_object_placeholder_geometry_matches_object_placeholder_geometry(bool value);

  // optional bool deprecated_objectPlaceholderVisibleForExport = 34;
  inline bool has_deprecated_objectplaceholdervisibleforexport() const;
  inline void clear_deprecated_objectplaceholdervisibleforexport();
  static const int kDeprecatedObjectPlaceholderVisibleForExportFieldNumber = 34;
  inline bool deprecated_objectplaceholdervisibleforexport() const;
  inline void set_deprecated_objectplaceholdervisibleforexport(bool value);

  // @@protoc_insertion_point(class_scope:KN.SlideArchive)
 private:
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_transition();
  inline void clear_has_transition();
  inline void set_has_titleplaceholder();
  inline void clear_has_titleplaceholder();
  inline void set_has_bodyplaceholder();
  inline void clear_has_bodyplaceholder();
  inline void set_has_objectplaceholder();
  inline void clear_has_objectplaceholder();
  inline void set_has_slidenumberplaceholder();
  inline void clear_has_slidenumberplaceholder();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_titleplaceholdergeometry();
  inline void clear_has_titleplaceholdergeometry();
  inline void set_has_titleplaceholdershapestyleindex();
  inline void clear_has_titleplaceholdershapestyleindex();
  inline void set_has_titleplaceholdertextstyleindex();
  inline void clear_has_titleplaceholdertextstyleindex();
  inline void set_has_titlelayoutproperties();
  inline void clear_has_titlelayoutproperties();
  inline void set_has_bodyplaceholdergeometry();
  inline void clear_has_bodyplaceholdergeometry();
  inline void set_has_bodyplaceholdershapestyleindex();
  inline void clear_has_bodyplaceholdershapestyleindex();
  inline void set_has_bodyplaceholdertextstyleindex();
  inline void clear_has_bodyplaceholdertextstyleindex();
  inline void set_has_bodylayoutproperties();
  inline void clear_has_bodylayoutproperties();
  inline void set_has_slidenumberplaceholdergeometry();
  inline void clear_has_slidenumberplaceholdergeometry();
  inline void set_has_slidenumberplaceholdershapestyleindex();
  inline void clear_has_slidenumberplaceholdershapestyleindex();
  inline void set_has_slidenumberplaceholdertextstyleindex();
  inline void clear_has_slidenumberplaceholdertextstyleindex();
  inline void set_has_slidenumberlayoutproperties();
  inline void clear_has_slidenumberlayoutproperties();
  inline void set_has_classicstylesheetrecord();
  inline void clear_has_classicstylesheetrecord();
  inline void set_has_thumbnailtextfortitleplaceholder();
  inline void clear_has_thumbnailtextfortitleplaceholder();
  inline void set_has_thumbnailtextforbodyplaceholder();
  inline void clear_has_thumbnailtextforbodyplaceholder();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_userdefinedguidestorage();
  inline void clear_has_userdefinedguidestorage();
  inline void set_has_indocument();
  inline void clear_has_indocument();
  inline void set_has_note();
  inline void clear_has_note();
  inline void set_has_info_using_object_placeholder_geometry();
  inline void clear_has_info_using_object_placeholder_geometry();
  inline void set_has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry();
  inline void clear_has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry();
  inline void set_has_deprecated_objectplaceholdervisibleforexport();
  inline void clear_has_deprecated_objectplaceholdervisibleforexport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* style_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > builds_;
  ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive > buildchunks_;
  ::KN::TransitionArchive* transition_;
  ::TSP::Reference* titleplaceholder_;
  ::TSP::Reference* bodyplaceholder_;
  ::TSP::Reference* objectplaceholder_;
  ::TSP::Reference* slidenumberplaceholder_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  ::google::protobuf::RepeatedPtrField< ::KN::SlideArchive_SageTagMapEntry > sage_tag_to_info_map_;
  ::std::string* name_;
  ::TSD::GeometryArchive* titleplaceholdergeometry_;
  ::google::protobuf::uint32 titleplaceholdershapestyleindex_;
  ::google::protobuf::uint32 titleplaceholdertextstyleindex_;
  ::TSWP::ShapeStylePropertiesArchive* titlelayoutproperties_;
  ::TSD::GeometryArchive* bodyplaceholdergeometry_;
  ::google::protobuf::uint32 bodyplaceholdershapestyleindex_;
  ::google::protobuf::uint32 bodyplaceholdertextstyleindex_;
  ::TSWP::ShapeStylePropertiesArchive* bodylayoutproperties_;
  ::TSD::GeometryArchive* slidenumberplaceholdergeometry_;
  ::google::protobuf::uint32 slidenumberplaceholdershapestyleindex_;
  ::google::protobuf::uint32 slidenumberplaceholdertextstyleindex_;
  ::TSWP::ShapeStylePropertiesArchive* slidenumberlayoutproperties_;
  ::TSP::Reference* classicstylesheetrecord_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > bodyparagraphstyles_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > bodyliststyles_;
  ::std::string* thumbnailtextfortitleplaceholder_;
  ::std::string* thumbnailtextforbodyplaceholder_;
  ::TSP::Reference* master_;
  ::google::protobuf::RepeatedPtrField< ::TSD::GuideArchive > staticguides_;
  ::TSP::Reference* userdefinedguidestorage_;
  ::TSP::Reference* note_;
  ::TSP::Reference* info_using_object_placeholder_geometry_;
  bool indocument_;
  bool info_using_object_placeholder_geometry_matches_object_placeholder_geometry_;
  bool deprecated_objectplaceholdervisibleforexport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideArchive* default_instance_;
};
// -------------------------------------------------------------------

class SlideNodeArchive : public ::google::protobuf::Message {
 public:
  SlideNodeArchive();
  virtual ~SlideNodeArchive();

  SlideNodeArchive(const SlideNodeArchive& from);

  inline SlideNodeArchive& operator=(const SlideNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideNodeArchive& default_instance();

  void Swap(SlideNodeArchive* other);

  // implements Message ----------------------------------------------

  SlideNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideNodeArchive& from);
  void MergeFrom(const SlideNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference children = 1;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 1;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // optional .TSP.Reference slide = 2;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 2;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // repeated .TSP.DataReference thumbnails = 16;
  inline int thumbnails_size() const;
  inline void clear_thumbnails();
  static const int kThumbnailsFieldNumber = 16;
  inline const ::TSP::DataReference& thumbnails(int index) const;
  inline ::TSP::DataReference* mutable_thumbnails(int index);
  inline ::TSP::DataReference* add_thumbnails();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >&
      thumbnails() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >*
      mutable_thumbnails();

  // repeated .TSP.Size thumbnailSizes = 10;
  inline int thumbnailsizes_size() const;
  inline void clear_thumbnailsizes();
  static const int kThumbnailSizesFieldNumber = 10;
  inline const ::TSP::Size& thumbnailsizes(int index) const;
  inline ::TSP::Size* mutable_thumbnailsizes(int index);
  inline ::TSP::Size* add_thumbnailsizes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Size >&
      thumbnailsizes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Size >*
      mutable_thumbnailsizes();

  // optional bool thumbnailsAreDirty = 14;
  inline bool has_thumbnailsaredirty() const;
  inline void clear_thumbnailsaredirty();
  static const int kThumbnailsAreDirtyFieldNumber = 14;
  inline bool thumbnailsaredirty() const;
  inline void set_thumbnailsaredirty(bool value);

  // required bool isHidden = 4;
  inline bool has_ishidden() const;
  inline void clear_ishidden();
  static const int kIsHiddenFieldNumber = 4;
  inline bool ishidden() const;
  inline void set_ishidden(bool value);

  // required bool isCollapsed = 5 [deprecated = true];
  inline bool has_iscollapsed() const PROTOBUF_DEPRECATED;
  inline void clear_iscollapsed() PROTOBUF_DEPRECATED;
  static const int kIsCollapsedFieldNumber = 5;
  inline bool iscollapsed() const PROTOBUF_DEPRECATED;
  inline void set_iscollapsed(bool value) PROTOBUF_DEPRECATED;

  // optional bool isCollapsedInOutlineView = 17;
  inline bool has_iscollapsedinoutlineview() const;
  inline void clear_iscollapsedinoutlineview();
  static const int kIsCollapsedInOutlineViewFieldNumber = 17;
  inline bool iscollapsedinoutlineview() const;
  inline void set_iscollapsedinoutlineview(bool value);

  // optional bool hasBodyInOutlineView = 19;
  inline bool has_hasbodyinoutlineview() const;
  inline void clear_hasbodyinoutlineview();
  static const int kHasBodyInOutlineViewFieldNumber = 19;
  inline bool hasbodyinoutlineview() const;
  inline void set_hasbodyinoutlineview(bool value);

  // required bool hasBuilds = 6;
  inline bool has_hasbuilds() const;
  inline void clear_hasbuilds();
  static const int kHasBuildsFieldNumber = 6;
  inline bool hasbuilds() const;
  inline void set_hasbuilds(bool value);

  // required bool hasTransition = 7;
  inline bool has_hastransition() const;
  inline void clear_hastransition();
  static const int kHasTransitionFieldNumber = 7;
  inline bool hastransition() const;
  inline void set_hastransition(bool value);

  // optional bool hasNote = 8;
  inline bool has_hasnote() const;
  inline void clear_hasnote();
  static const int kHasNoteFieldNumber = 8;
  inline bool hasnote() const;
  inline void set_hasnote(bool value);

  // optional bool isSlideNumberVisible = 18 [default = false];
  inline bool has_isslidenumbervisible() const;
  inline void clear_isslidenumbervisible();
  static const int kIsSlideNumberVisibleFieldNumber = 18;
  inline bool isslidenumbervisible() const;
  inline void set_isslidenumbervisible(bool value);

  // optional string uniqueIdentifier = 11;
  inline bool has_uniqueidentifier() const;
  inline void clear_uniqueidentifier();
  static const int kUniqueIdentifierFieldNumber = 11;
  inline const ::std::string& uniqueidentifier() const;
  inline void set_uniqueidentifier(const ::std::string& value);
  inline void set_uniqueidentifier(const char* value);
  inline void set_uniqueidentifier(const char* value, size_t size);
  inline ::std::string* mutable_uniqueidentifier();
  inline ::std::string* release_uniqueidentifier();
  inline void set_allocated_uniqueidentifier(::std::string* uniqueidentifier);

  // optional string copyFromSlideIdentifier = 12;
  inline bool has_copyfromslideidentifier() const;
  inline void clear_copyfromslideidentifier();
  static const int kCopyFromSlideIdentifierFieldNumber = 12;
  inline const ::std::string& copyfromslideidentifier() const;
  inline void set_copyfromslideidentifier(const ::std::string& value);
  inline void set_copyfromslideidentifier(const char* value);
  inline void set_copyfromslideidentifier(const char* value, size_t size);
  inline ::std::string* mutable_copyfromslideidentifier();
  inline ::std::string* release_copyfromslideidentifier();
  inline void set_allocated_copyfromslideidentifier(::std::string* copyfromslideidentifier);

  // optional uint32 slideSpecificHyperlinkCount = 13;
  inline bool has_slidespecifichyperlinkcount() const;
  inline void clear_slidespecifichyperlinkcount();
  static const int kSlideSpecificHyperlinkCountFieldNumber = 13;
  inline ::google::protobuf::uint32 slidespecifichyperlinkcount() const;
  inline void set_slidespecifichyperlinkcount(::google::protobuf::uint32 value);

  // optional uint32 eventCount = 15;
  inline bool has_eventcount() const;
  inline void clear_eventcount();
  static const int kEventCountFieldNumber = 15;
  inline ::google::protobuf::uint32 eventcount() const;
  inline void set_eventcount(::google::protobuf::uint32 value);

  // optional .TSP.Reference database_thumbnail = 3;
  inline bool has_database_thumbnail() const;
  inline void clear_database_thumbnail();
  static const int kDatabaseThumbnailFieldNumber = 3;
  inline const ::TSP::Reference& database_thumbnail() const;
  inline ::TSP::Reference* mutable_database_thumbnail();
  inline ::TSP::Reference* release_database_thumbnail();
  inline void set_allocated_database_thumbnail(::TSP::Reference* database_thumbnail);

  // repeated .TSP.Reference database_thumbnails = 9;
  inline int database_thumbnails_size() const;
  inline void clear_database_thumbnails();
  static const int kDatabaseThumbnailsFieldNumber = 9;
  inline const ::TSP::Reference& database_thumbnails(int index) const;
  inline ::TSP::Reference* mutable_database_thumbnails(int index);
  inline ::TSP::Reference* add_database_thumbnails();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      database_thumbnails() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_database_thumbnails();

  // @@protoc_insertion_point(class_scope:KN.SlideNodeArchive)
 private:
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_thumbnailsaredirty();
  inline void clear_has_thumbnailsaredirty();
  inline void set_has_ishidden();
  inline void clear_has_ishidden();
  inline void set_has_iscollapsed();
  inline void clear_has_iscollapsed();
  inline void set_has_iscollapsedinoutlineview();
  inline void clear_has_iscollapsedinoutlineview();
  inline void set_has_hasbodyinoutlineview();
  inline void clear_has_hasbodyinoutlineview();
  inline void set_has_hasbuilds();
  inline void clear_has_hasbuilds();
  inline void set_has_hastransition();
  inline void clear_has_hastransition();
  inline void set_has_hasnote();
  inline void clear_has_hasnote();
  inline void set_has_isslidenumbervisible();
  inline void clear_has_isslidenumbervisible();
  inline void set_has_uniqueidentifier();
  inline void clear_has_uniqueidentifier();
  inline void set_has_copyfromslideidentifier();
  inline void clear_has_copyfromslideidentifier();
  inline void set_has_slidespecifichyperlinkcount();
  inline void clear_has_slidespecifichyperlinkcount();
  inline void set_has_eventcount();
  inline void clear_has_eventcount();
  inline void set_has_database_thumbnail();
  inline void clear_has_database_thumbnail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;
  ::TSP::Reference* slide_;
  ::google::protobuf::RepeatedPtrField< ::TSP::DataReference > thumbnails_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Size > thumbnailsizes_;
  bool thumbnailsaredirty_;
  bool ishidden_;
  bool iscollapsed_;
  bool iscollapsedinoutlineview_;
  bool hasbodyinoutlineview_;
  bool hasbuilds_;
  bool hastransition_;
  bool hasnote_;
  ::std::string* uniqueidentifier_;
  bool isslidenumbervisible_;
  ::google::protobuf::uint32 slidespecifichyperlinkcount_;
  ::std::string* copyfromslideidentifier_;
  ::TSP::Reference* database_thumbnail_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > database_thumbnails_;
  ::google::protobuf::uint32 eventcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class DesktopUILayoutArchive : public ::google::protobuf::Message {
 public:
  DesktopUILayoutArchive();
  virtual ~DesktopUILayoutArchive();

  DesktopUILayoutArchive(const DesktopUILayoutArchive& from);

  inline DesktopUILayoutArchive& operator=(const DesktopUILayoutArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DesktopUILayoutArchive& default_instance();

  void Swap(DesktopUILayoutArchive* other);

  // implements Message ----------------------------------------------

  DesktopUILayoutArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DesktopUILayoutArchive& from);
  void MergeFrom(const DesktopUILayoutArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DesktopUILayoutArchive_SidebarViewMode SidebarViewMode;
  static const SidebarViewMode kSidebarViewModeNavigator = DesktopUILayoutArchive_SidebarViewMode_kSidebarViewModeNavigator;
  static const SidebarViewMode kSidebarViewModeOutline = DesktopUILayoutArchive_SidebarViewMode_kSidebarViewModeOutline;
  static inline bool SidebarViewMode_IsValid(int value) {
    return DesktopUILayoutArchive_SidebarViewMode_IsValid(value);
  }
  static const SidebarViewMode SidebarViewMode_MIN =
    DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_MIN;
  static const SidebarViewMode SidebarViewMode_MAX =
    DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_MAX;
  static const int SidebarViewMode_ARRAYSIZE =
    DesktopUILayoutArchive_SidebarViewMode_SidebarViewMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SidebarViewMode_descriptor() {
    return DesktopUILayoutArchive_SidebarViewMode_descriptor();
  }
  static inline const ::std::string& SidebarViewMode_Name(SidebarViewMode value) {
    return DesktopUILayoutArchive_SidebarViewMode_Name(value);
  }
  static inline bool SidebarViewMode_Parse(const ::std::string& name,
      SidebarViewMode* value) {
    return DesktopUILayoutArchive_SidebarViewMode_Parse(name, value);
  }

  typedef DesktopUILayoutArchive_InspectorPaneViewMode InspectorPaneViewMode;
  static const InspectorPaneViewMode kInspectorPaneViewModeFormat = DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeFormat;
  static const InspectorPaneViewMode kInspectorPaneViewModeAnimate = DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeAnimate;
  static const InspectorPaneViewMode kInspectorPaneViewModeSetup = DesktopUILayoutArchive_InspectorPaneViewMode_kInspectorPaneViewModeSetup;
  static inline bool InspectorPaneViewMode_IsValid(int value) {
    return DesktopUILayoutArchive_InspectorPaneViewMode_IsValid(value);
  }
  static const InspectorPaneViewMode InspectorPaneViewMode_MIN =
    DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_MIN;
  static const InspectorPaneViewMode InspectorPaneViewMode_MAX =
    DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_MAX;
  static const int InspectorPaneViewMode_ARRAYSIZE =
    DesktopUILayoutArchive_InspectorPaneViewMode_InspectorPaneViewMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InspectorPaneViewMode_descriptor() {
    return DesktopUILayoutArchive_InspectorPaneViewMode_descriptor();
  }
  static inline const ::std::string& InspectorPaneViewMode_Name(InspectorPaneViewMode value) {
    return DesktopUILayoutArchive_InspectorPaneViewMode_Name(value);
  }
  static inline bool InspectorPaneViewMode_Parse(const ::std::string& name,
      InspectorPaneViewMode* value) {
    return DesktopUILayoutArchive_InspectorPaneViewMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool sidebar_visible = 1;
  inline bool has_sidebar_visible() const;
  inline void clear_sidebar_visible();
  static const int kSidebarVisibleFieldNumber = 1;
  inline bool sidebar_visible() const;
  inline void set_sidebar_visible(bool value);

  // optional .KN.DesktopUILayoutArchive.SidebarViewMode sidebar_view_mode = 2;
  inline bool has_sidebar_view_mode() const;
  inline void clear_sidebar_view_mode();
  static const int kSidebarViewModeFieldNumber = 2;
  inline ::KN::DesktopUILayoutArchive_SidebarViewMode sidebar_view_mode() const;
  inline void set_sidebar_view_mode(::KN::DesktopUILayoutArchive_SidebarViewMode value);

  // optional bool notes_visible = 3;
  inline bool has_notes_visible() const;
  inline void clear_notes_visible();
  static const int kNotesVisibleFieldNumber = 3;
  inline bool notes_visible() const;
  inline void set_notes_visible(bool value);

  // optional bool light_table_visible = 5;
  inline bool has_light_table_visible() const;
  inline void clear_light_table_visible();
  static const int kLightTableVisibleFieldNumber = 5;
  inline bool light_table_visible() const;
  inline void set_light_table_visible(bool value);

  // optional bool inspector_pane_visible = 6 [default = true];
  inline bool has_inspector_pane_visible() const;
  inline void clear_inspector_pane_visible();
  static const int kInspectorPaneVisibleFieldNumber = 6;
  inline bool inspector_pane_visible() const;
  inline void set_inspector_pane_visible(bool value);

  // optional .KN.DesktopUILayoutArchive.InspectorPaneViewMode inspector_pane_view_mode = 7 [default = kInspectorPaneViewModeFormat];
  inline bool has_inspector_pane_view_mode() const;
  inline void clear_inspector_pane_view_mode();
  static const int kInspectorPaneViewModeFieldNumber = 7;
  inline ::KN::DesktopUILayoutArchive_InspectorPaneViewMode inspector_pane_view_mode() const;
  inline void set_inspector_pane_view_mode(::KN::DesktopUILayoutArchive_InspectorPaneViewMode value);

  // @@protoc_insertion_point(class_scope:KN.DesktopUILayoutArchive)
 private:
  inline void set_has_sidebar_visible();
  inline void clear_has_sidebar_visible();
  inline void set_has_sidebar_view_mode();
  inline void clear_has_sidebar_view_mode();
  inline void set_has_notes_visible();
  inline void clear_has_notes_visible();
  inline void set_has_light_table_visible();
  inline void clear_has_light_table_visible();
  inline void set_has_inspector_pane_visible();
  inline void clear_has_inspector_pane_visible();
  inline void set_has_inspector_pane_view_mode();
  inline void clear_has_inspector_pane_view_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int sidebar_view_mode_;
  bool sidebar_visible_;
  bool notes_visible_;
  bool light_table_visible_;
  bool inspector_pane_visible_;
  int inspector_pane_view_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static DesktopUILayoutArchive* default_instance_;
};
// -------------------------------------------------------------------

class UIStateArchive : public ::google::protobuf::Message {
 public:
  UIStateArchive();
  virtual ~UIStateArchive();

  UIStateArchive(const UIStateArchive& from);

  inline UIStateArchive& operator=(const UIStateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIStateArchive& default_instance();

  void Swap(UIStateArchive* other);

  // implements Message ----------------------------------------------

  UIStateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIStateArchive& from);
  void MergeFrom(const UIStateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference slideNodeToEdit = 1;
  inline bool has_slidenodetoedit() const;
  inline void clear_slidenodetoedit();
  static const int kSlideNodeToEditFieldNumber = 1;
  inline const ::TSP::Reference& slidenodetoedit() const;
  inline ::TSP::Reference* mutable_slidenodetoedit();
  inline ::TSP::Reference* release_slidenodetoedit();
  inline void set_allocated_slidenodetoedit(::TSP::Reference* slidenodetoedit);

  // optional .TSP.Reference deprecated_masterSlideNodeToApply = 2;
  inline bool has_deprecated_masterslidenodetoapply() const;
  inline void clear_deprecated_masterslidenodetoapply();
  static const int kDeprecatedMasterSlideNodeToApplyFieldNumber = 2;
  inline const ::TSP::Reference& deprecated_masterslidenodetoapply() const;
  inline ::TSP::Reference* mutable_deprecated_masterslidenodetoapply();
  inline ::TSP::Reference* release_deprecated_masterslidenodetoapply();
  inline void set_allocated_deprecated_masterslidenodetoapply(::TSP::Reference* deprecated_masterslidenodetoapply);

  // optional .TSP.Size deprecated_slideThumbnailSize = 3;
  inline bool has_deprecated_slidethumbnailsize() const;
  inline void clear_deprecated_slidethumbnailsize();
  static const int kDeprecatedSlideThumbnailSizeFieldNumber = 3;
  inline const ::TSP::Size& deprecated_slidethumbnailsize() const;
  inline ::TSP::Size* mutable_deprecated_slidethumbnailsize();
  inline ::TSP::Size* release_deprecated_slidethumbnailsize();
  inline void set_allocated_deprecated_slidethumbnailsize(::TSP::Size* deprecated_slidethumbnailsize);

  // optional float canvasViewScale = 4;
  inline bool has_canvasviewscale() const;
  inline void clear_canvasviewscale();
  static const int kCanvasViewScaleFieldNumber = 4;
  inline float canvasviewscale() const;
  inline void set_canvasviewscale(float value);

  // optional .TSP.Point canvasOffset = 5;
  inline bool has_canvasoffset() const;
  inline void clear_canvasoffset();
  static const int kCanvasOffsetFieldNumber = 5;
  inline const ::TSP::Point& canvasoffset() const;
  inline ::TSP::Point* mutable_canvasoffset();
  inline ::TSP::Point* release_canvasoffset();
  inline void set_allocated_canvasoffset(::TSP::Point* canvasoffset);

  // repeated .TSP.Reference selectedSlideNodes = 6;
  inline int selectedslidenodes_size() const;
  inline void clear_selectedslidenodes();
  static const int kSelectedSlideNodesFieldNumber = 6;
  inline const ::TSP::Reference& selectedslidenodes(int index) const;
  inline ::TSP::Reference* mutable_selectedslidenodes(int index);
  inline ::TSP::Reference* add_selectedslidenodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      selectedslidenodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_selectedslidenodes();

  // optional float iPhoneCanvasViewScale = 7;
  inline bool has_iphonecanvasviewscale() const;
  inline void clear_iphonecanvasviewscale();
  static const int kIPhoneCanvasViewScaleFieldNumber = 7;
  inline float iphonecanvasviewscale() const;
  inline void set_iphonecanvasviewscale(float value);

  // optional .TSP.Point iPhoneCanvasOffset = 8;
  inline bool has_iphonecanvasoffset() const;
  inline void clear_iphonecanvasoffset();
  static const int kIPhoneCanvasOffsetFieldNumber = 8;
  inline const ::TSP::Point& iphonecanvasoffset() const;
  inline ::TSP::Point* mutable_iphonecanvasoffset();
  inline ::TSP::Point* release_iphonecanvasoffset();
  inline void set_allocated_iphonecanvasoffset(::TSP::Point* iphonecanvasoffset);

  // optional float iPhone568CanvasViewScale = 9;
  inline bool has_iphone568canvasviewscale() const;
  inline void clear_iphone568canvasviewscale();
  static const int kIPhone568CanvasViewScaleFieldNumber = 9;
  inline float iphone568canvasviewscale() const;
  inline void set_iphone568canvasviewscale(float value);

  // optional .TSP.Point iPhone568CanvasOffset = 10;
  inline bool has_iphone568canvasoffset() const;
  inline void clear_iphone568canvasoffset();
  static const int kIPhone568CanvasOffsetFieldNumber = 10;
  inline const ::TSP::Point& iphone568canvasoffset() const;
  inline ::TSP::Point* mutable_iphone568canvasoffset();
  inline ::TSP::Point* release_iphone568canvasoffset();
  inline void set_allocated_iphone568canvasoffset(::TSP::Point* iphone568canvasoffset);

  // optional .TSP.Reference desktop_ui_layout = 11;
  inline bool has_desktop_ui_layout() const;
  inline void clear_desktop_ui_layout();
  static const int kDesktopUiLayoutFieldNumber = 11;
  inline const ::TSP::Reference& desktop_ui_layout() const;
  inline ::TSP::Reference* mutable_desktop_ui_layout();
  inline ::TSP::Reference* release_desktop_ui_layout();
  inline void set_allocated_desktop_ui_layout(::TSP::Reference* desktop_ui_layout);

  // optional bool desktop_slide_view_content_fits_window = 12;
  inline bool has_desktop_slide_view_content_fits_window() const;
  inline void clear_desktop_slide_view_content_fits_window();
  static const int kDesktopSlideViewContentFitsWindowFieldNumber = 12;
  inline bool desktop_slide_view_content_fits_window() const;
  inline void set_desktop_slide_view_content_fits_window(bool value);

  // optional float desktop_canvas_view_scale = 13;
  inline bool has_desktop_canvas_view_scale() const;
  inline void clear_desktop_canvas_view_scale();
  static const int kDesktopCanvasViewScaleFieldNumber = 13;
  inline float desktop_canvas_view_scale() const;
  inline void set_desktop_canvas_view_scale(float value);

  // optional .TSP.Point desktop_canvas_offset = 21;
  inline bool has_desktop_canvas_offset() const;
  inline void clear_desktop_canvas_offset();
  static const int kDesktopCanvasOffsetFieldNumber = 21;
  inline const ::TSP::Point& desktop_canvas_offset() const;
  inline ::TSP::Point* mutable_desktop_canvas_offset();
  inline ::TSP::Point* release_desktop_canvas_offset();
  inline void set_allocated_desktop_canvas_offset(::TSP::Point* desktop_canvas_offset);

  // optional float light_table_zoom_scale = 14;
  inline bool has_light_table_zoom_scale() const;
  inline void clear_light_table_zoom_scale();
  static const int kLightTableZoomScaleFieldNumber = 14;
  inline float light_table_zoom_scale() const;
  inline void set_light_table_zoom_scale(float value);

  // repeated .TSCH.ChartUIState chart_ui_state = 15;
  inline int chart_ui_state_size() const;
  inline void clear_chart_ui_state();
  static const int kChartUiStateFieldNumber = 15;
  inline const ::TSCH::ChartUIState& chart_ui_state(int index) const;
  inline ::TSCH::ChartUIState* mutable_chart_ui_state(int index);
  inline ::TSCH::ChartUIState* add_chart_ui_state();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCH::ChartUIState >&
      chart_ui_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCH::ChartUIState >*
      mutable_chart_ui_state();

  // optional bool show_slide_guides = 16;
  inline bool has_show_slide_guides() const;
  inline void clear_show_slide_guides();
  static const int kShowSlideGuidesFieldNumber = 16;
  inline bool show_slide_guides() const;
  inline void set_show_slide_guides(bool value);

  // optional bool show_master_guides = 17;
  inline bool has_show_master_guides() const;
  inline void clear_show_master_guides();
  static const int kShowMasterGuidesFieldNumber = 17;
  inline bool show_master_guides() const;
  inline void set_show_master_guides(bool value);

  // optional bool shows_comments = 18;
  inline bool has_shows_comments() const;
  inline void clear_shows_comments();
  static const int kShowsCommentsFieldNumber = 18;
  inline bool shows_comments() const;
  inline void set_shows_comments(bool value);

  // repeated .TSP.Reference collapsed_slide_nodes = 19;
  inline int collapsed_slide_nodes_size() const;
  inline void clear_collapsed_slide_nodes();
  static const int kCollapsedSlideNodesFieldNumber = 19;
  inline const ::TSP::Reference& collapsed_slide_nodes(int index) const;
  inline ::TSP::Reference* mutable_collapsed_slide_nodes(int index);
  inline ::TSP::Reference* add_collapsed_slide_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      collapsed_slide_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_collapsed_slide_nodes();

  // optional bool shows_ruler = 20;
  inline bool has_shows_ruler() const;
  inline void clear_shows_ruler();
  static const int kShowsRulerFieldNumber = 20;
  inline bool shows_ruler() const;
  inline void set_shows_ruler(bool value);

  // optional float desktop_navigator_view_width = 22;
  inline bool has_desktop_navigator_view_width() const;
  inline void clear_desktop_navigator_view_width();
  static const int kDesktopNavigatorViewWidthFieldNumber = 22;
  inline float desktop_navigator_view_width() const;
  inline void set_desktop_navigator_view_width(float value);

  // optional float desktop_outline_view_width = 23;
  inline bool has_desktop_outline_view_width() const;
  inline void clear_desktop_outline_view_width();
  static const int kDesktopOutlineViewWidthFieldNumber = 23;
  inline float desktop_outline_view_width() const;
  inline void set_desktop_outline_view_width(float value);

  // optional .TSP.Size desktop_main_content_size = 24;
  inline bool has_desktop_main_content_size() const;
  inline void clear_desktop_main_content_size();
  static const int kDesktopMainContentSizeFieldNumber = 24;
  inline const ::TSP::Size& desktop_main_content_size() const;
  inline ::TSP::Size* mutable_desktop_main_content_size();
  inline ::TSP::Size* release_desktop_main_content_size();
  inline void set_allocated_desktop_main_content_size(::TSP::Size* desktop_main_content_size);

  // @@protoc_insertion_point(class_scope:KN.UIStateArchive)
 private:
  inline void set_has_slidenodetoedit();
  inline void clear_has_slidenodetoedit();
  inline void set_has_deprecated_masterslidenodetoapply();
  inline void clear_has_deprecated_masterslidenodetoapply();
  inline void set_has_deprecated_slidethumbnailsize();
  inline void clear_has_deprecated_slidethumbnailsize();
  inline void set_has_canvasviewscale();
  inline void clear_has_canvasviewscale();
  inline void set_has_canvasoffset();
  inline void clear_has_canvasoffset();
  inline void set_has_iphonecanvasviewscale();
  inline void clear_has_iphonecanvasviewscale();
  inline void set_has_iphonecanvasoffset();
  inline void clear_has_iphonecanvasoffset();
  inline void set_has_iphone568canvasviewscale();
  inline void clear_has_iphone568canvasviewscale();
  inline void set_has_iphone568canvasoffset();
  inline void clear_has_iphone568canvasoffset();
  inline void set_has_desktop_ui_layout();
  inline void clear_has_desktop_ui_layout();
  inline void set_has_desktop_slide_view_content_fits_window();
  inline void clear_has_desktop_slide_view_content_fits_window();
  inline void set_has_desktop_canvas_view_scale();
  inline void clear_has_desktop_canvas_view_scale();
  inline void set_has_desktop_canvas_offset();
  inline void clear_has_desktop_canvas_offset();
  inline void set_has_light_table_zoom_scale();
  inline void clear_has_light_table_zoom_scale();
  inline void set_has_show_slide_guides();
  inline void clear_has_show_slide_guides();
  inline void set_has_show_master_guides();
  inline void clear_has_show_master_guides();
  inline void set_has_shows_comments();
  inline void clear_has_shows_comments();
  inline void set_has_shows_ruler();
  inline void clear_has_shows_ruler();
  inline void set_has_desktop_navigator_view_width();
  inline void clear_has_desktop_navigator_view_width();
  inline void set_has_desktop_outline_view_width();
  inline void clear_has_desktop_outline_view_width();
  inline void set_has_desktop_main_content_size();
  inline void clear_has_desktop_main_content_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* slidenodetoedit_;
  ::TSP::Reference* deprecated_masterslidenodetoapply_;
  ::TSP::Size* deprecated_slidethumbnailsize_;
  ::TSP::Point* canvasoffset_;
  float canvasviewscale_;
  float iphonecanvasviewscale_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > selectedslidenodes_;
  ::TSP::Point* iphonecanvasoffset_;
  ::TSP::Point* iphone568canvasoffset_;
  ::TSP::Reference* desktop_ui_layout_;
  float iphone568canvasviewscale_;
  float desktop_canvas_view_scale_;
  ::TSP::Point* desktop_canvas_offset_;
  ::google::protobuf::RepeatedPtrField< ::TSCH::ChartUIState > chart_ui_state_;
  float light_table_zoom_scale_;
  bool desktop_slide_view_content_fits_window_;
  bool show_slide_guides_;
  bool show_master_guides_;
  bool shows_comments_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > collapsed_slide_nodes_;
  bool shows_ruler_;
  float desktop_navigator_view_width_;
  ::TSP::Size* desktop_main_content_size_;
  float desktop_outline_view_width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static UIStateArchive* default_instance_;
};
// -------------------------------------------------------------------

class CanvasSelectionArchive : public ::google::protobuf::Message {
 public:
  CanvasSelectionArchive();
  virtual ~CanvasSelectionArchive();

  CanvasSelectionArchive(const CanvasSelectionArchive& from);

  inline CanvasSelectionArchive& operator=(const CanvasSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CanvasSelectionArchive& default_instance();

  void Swap(CanvasSelectionArchive* other);

  // implements Message ----------------------------------------------

  CanvasSelectionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CanvasSelectionArchive& from);
  void MergeFrom(const CanvasSelectionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::TSP::Reference& infos(int index) const;
  inline ::TSP::Reference* mutable_infos(int index);
  inline ::TSP::Reference* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();

  // repeated .TSP.IndexSet action_ghost_indexes = 3;
  inline int action_ghost_indexes_size() const;
  inline void clear_action_ghost_indexes();
  static const int kActionGhostIndexesFieldNumber = 3;
  inline const ::TSP::IndexSet& action_ghost_indexes(int index) const;
  inline ::TSP::IndexSet* mutable_action_ghost_indexes(int index);
  inline ::TSP::IndexSet* add_action_ghost_indexes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::IndexSet >&
      action_ghost_indexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::IndexSet >*
      mutable_action_ghost_indexes();

  // repeated uint32 database_action_ghost_indexes = 2 [deprecated = true];
  inline int database_action_ghost_indexes_size() const PROTOBUF_DEPRECATED;
  inline void clear_database_action_ghost_indexes() PROTOBUF_DEPRECATED;
  static const int kDatabaseActionGhostIndexesFieldNumber = 2;
  inline ::google::protobuf::uint32 database_action_ghost_indexes(int index) const PROTOBUF_DEPRECATED;
  inline void set_database_action_ghost_indexes(int index, ::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  inline void add_database_action_ghost_indexes(::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      database_action_ghost_indexes() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_database_action_ghost_indexes() PROTOBUF_DEPRECATED;

  // @@protoc_insertion_point(class_scope:KN.CanvasSelectionArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > infos_;
  ::google::protobuf::RepeatedPtrField< ::TSP::IndexSet > action_ghost_indexes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > database_action_ghost_indexes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static CanvasSelectionArchive* default_instance_;
};
// -------------------------------------------------------------------

class ThemeArchive : public ::google::protobuf::Message {
 public:
  ThemeArchive();
  virtual ~ThemeArchive();

  ThemeArchive(const ThemeArchive& from);

  inline ThemeArchive& operator=(const ThemeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThemeArchive& default_instance();

  void Swap(ThemeArchive* other);

  // implements Message ----------------------------------------------

  ThemeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThemeArchive& from);
  void MergeFrom(const ThemeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.ThemeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::ThemeArchive& super() const;
  inline ::TSS::ThemeArchive* mutable_super();
  inline ::TSS::ThemeArchive* release_super();
  inline void set_allocated_super(::TSS::ThemeArchive* super);

  // repeated .TSP.Reference masters = 2;
  inline int masters_size() const;
  inline void clear_masters();
  static const int kMastersFieldNumber = 2;
  inline const ::TSP::Reference& masters(int index) const;
  inline ::TSP::Reference* mutable_masters(int index);
  inline ::TSP::Reference* add_masters();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      masters() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_masters();

  // optional string uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // repeated .TSP.Reference classicThemeRecords = 4;
  inline int classicthemerecords_size() const;
  inline void clear_classicthemerecords();
  static const int kClassicThemeRecordsFieldNumber = 4;
  inline const ::TSP::Reference& classicthemerecords(int index) const;
  inline ::TSP::Reference* mutable_classicthemerecords(int index);
  inline ::TSP::Reference* add_classicthemerecords();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      classicthemerecords() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_classicthemerecords();

  // optional .TSP.Reference defaultMasterSlideNode = 5;
  inline bool has_defaultmasterslidenode() const;
  inline void clear_defaultmasterslidenode();
  static const int kDefaultMasterSlideNodeFieldNumber = 5;
  inline const ::TSP::Reference& defaultmasterslidenode() const;
  inline ::TSP::Reference* mutable_defaultmasterslidenode();
  inline ::TSP::Reference* release_defaultmasterslidenode();
  inline void set_allocated_defaultmasterslidenode(::TSP::Reference* defaultmasterslidenode);

  // @@protoc_insertion_point(class_scope:KN.ThemeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_defaultmasterslidenode();
  inline void clear_has_defaultmasterslidenode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::ThemeArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > masters_;
  ::std::string* uuid_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > classicthemerecords_;
  ::TSP::Reference* defaultmasterslidenode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static ThemeArchive* default_instance_;
};
// -------------------------------------------------------------------

class SlideTreeArchive : public ::google::protobuf::Message {
 public:
  SlideTreeArchive();
  virtual ~SlideTreeArchive();

  SlideTreeArchive(const SlideTreeArchive& from);

  inline SlideTreeArchive& operator=(const SlideTreeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideTreeArchive& default_instance();

  void Swap(SlideTreeArchive* other);

  // implements Message ----------------------------------------------

  SlideTreeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideTreeArchive& from);
  void MergeFrom(const SlideTreeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference rootSlideNode = 1;
  inline bool has_rootslidenode() const;
  inline void clear_rootslidenode();
  static const int kRootSlideNodeFieldNumber = 1;
  inline const ::TSP::Reference& rootslidenode() const;
  inline ::TSP::Reference* mutable_rootslidenode();
  inline ::TSP::Reference* release_rootslidenode();
  inline void set_allocated_rootslidenode(::TSP::Reference* rootslidenode);

  // @@protoc_insertion_point(class_scope:KN.SlideTreeArchive)
 private:
  inline void set_has_rootslidenode();
  inline void clear_has_rootslidenode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* rootslidenode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideTreeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShowArchive : public ::google::protobuf::Message {
 public:
  ShowArchive();
  virtual ~ShowArchive();

  ShowArchive(const ShowArchive& from);

  inline ShowArchive& operator=(const ShowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShowArchive& default_instance();

  void Swap(ShowArchive* other);

  // implements Message ----------------------------------------------

  ShowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShowArchive& from);
  void MergeFrom(const ShowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ShowArchive_KNShowMode KNShowMode;
  static const KNShowMode kKNShowModeNormal = ShowArchive_KNShowMode_kKNShowModeNormal;
  static const KNShowMode kKNShowModeAutoPlay = ShowArchive_KNShowMode_kKNShowModeAutoPlay;
  static const KNShowMode kKNShowModeHyperlinksOnly = ShowArchive_KNShowMode_kKNShowModeHyperlinksOnly;
  static inline bool KNShowMode_IsValid(int value) {
    return ShowArchive_KNShowMode_IsValid(value);
  }
  static const KNShowMode KNShowMode_MIN =
    ShowArchive_KNShowMode_KNShowMode_MIN;
  static const KNShowMode KNShowMode_MAX =
    ShowArchive_KNShowMode_KNShowMode_MAX;
  static const int KNShowMode_ARRAYSIZE =
    ShowArchive_KNShowMode_KNShowMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KNShowMode_descriptor() {
    return ShowArchive_KNShowMode_descriptor();
  }
  static inline const ::std::string& KNShowMode_Name(KNShowMode value) {
    return ShowArchive_KNShowMode_Name(value);
  }
  static inline bool KNShowMode_Parse(const ::std::string& name,
      KNShowMode* value) {
    return ShowArchive_KNShowMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Reference uiState = 1;
  inline bool has_uistate() const;
  inline void clear_uistate();
  static const int kUiStateFieldNumber = 1;
  inline const ::TSP::Reference& uistate() const;
  inline ::TSP::Reference* mutable_uistate();
  inline ::TSP::Reference* release_uistate();
  inline void set_allocated_uistate(::TSP::Reference* uistate);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .KN.SlideTreeArchive slideTree = 3;
  inline bool has_slidetree() const;
  inline void clear_slidetree();
  static const int kSlideTreeFieldNumber = 3;
  inline const ::KN::SlideTreeArchive& slidetree() const;
  inline ::KN::SlideTreeArchive* mutable_slidetree();
  inline ::KN::SlideTreeArchive* release_slidetree();
  inline void set_allocated_slidetree(::KN::SlideTreeArchive* slidetree);

  // required .TSP.Size size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline const ::TSP::Size& size() const;
  inline ::TSP::Size* mutable_size();
  inline ::TSP::Size* release_size();
  inline void set_allocated_size(::TSP::Size* size);

  // required .TSP.Reference stylesheet = 5;
  inline bool has_stylesheet() const;
  inline void clear_stylesheet();
  static const int kStylesheetFieldNumber = 5;
  inline const ::TSP::Reference& stylesheet() const;
  inline ::TSP::Reference* mutable_stylesheet();
  inline ::TSP::Reference* release_stylesheet();
  inline void set_allocated_stylesheet(::TSP::Reference* stylesheet);

  // optional bool slideNumbersVisible = 6;
  inline bool has_slidenumbersvisible() const;
  inline void clear_slidenumbersvisible();
  static const int kSlideNumbersVisibleFieldNumber = 6;
  inline bool slidenumbersvisible() const;
  inline void set_slidenumbersvisible(bool value);

  // optional .TSP.Reference recording = 7;
  inline bool has_recording() const;
  inline void clear_recording();
  static const int kRecordingFieldNumber = 7;
  inline const ::TSP::Reference& recording() const;
  inline ::TSP::Reference* mutable_recording();
  inline ::TSP::Reference* release_recording();
  inline void set_allocated_recording(::TSP::Reference* recording);

  // optional bool loop_presentation = 8;
  inline bool has_loop_presentation() const;
  inline void clear_loop_presentation();
  static const int kLoopPresentationFieldNumber = 8;
  inline bool loop_presentation() const;
  inline void set_loop_presentation(bool value);

  // optional .KN.ShowArchive.KNShowMode mode = 9 [default = kKNShowModeNormal];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 9;
  inline ::KN::ShowArchive_KNShowMode mode() const;
  inline void set_mode(::KN::ShowArchive_KNShowMode value);

  // optional double autoplay_transition_delay = 10 [default = 5];
  inline bool has_autoplay_transition_delay() const;
  inline void clear_autoplay_transition_delay();
  static const int kAutoplayTransitionDelayFieldNumber = 10;
  inline double autoplay_transition_delay() const;
  inline void set_autoplay_transition_delay(double value);

  // optional double autoplay_build_delay = 11 [default = 2];
  inline bool has_autoplay_build_delay() const;
  inline void clear_autoplay_build_delay();
  static const int kAutoplayBuildDelayFieldNumber = 11;
  inline double autoplay_build_delay() const;
  inline void set_autoplay_build_delay(double value);

  // optional bool idle_timer_active = 15;
  inline bool has_idle_timer_active() const;
  inline void clear_idle_timer_active();
  static const int kIdleTimerActiveFieldNumber = 15;
  inline bool idle_timer_active() const;
  inline void set_idle_timer_active(bool value);

  // optional double idle_timer_delay = 16 [default = 900];
  inline bool has_idle_timer_delay() const;
  inline void clear_idle_timer_delay();
  static const int kIdleTimerDelayFieldNumber = 16;
  inline double idle_timer_delay() const;
  inline void set_idle_timer_delay(double value);

  // optional .TSP.Reference soundtrack = 17;
  inline bool has_soundtrack() const;
  inline void clear_soundtrack();
  static const int kSoundtrackFieldNumber = 17;
  inline const ::TSP::Reference& soundtrack() const;
  inline ::TSP::Reference* mutable_soundtrack();
  inline ::TSP::Reference* release_soundtrack();
  inline void set_allocated_soundtrack(::TSP::Reference* soundtrack);

  // optional bool automatically_plays_upon_open = 18;
  inline bool has_automatically_plays_upon_open() const;
  inline void clear_automatically_plays_upon_open();
  static const int kAutomaticallyPlaysUponOpenFieldNumber = 18;
  inline bool automatically_plays_upon_open() const;
  inline void set_automatically_plays_upon_open(bool value);

  // @@protoc_insertion_point(class_scope:KN.ShowArchive)
 private:
  inline void set_has_uistate();
  inline void clear_has_uistate();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_slidetree();
  inline void clear_has_slidetree();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_stylesheet();
  inline void clear_has_stylesheet();
  inline void set_has_slidenumbersvisible();
  inline void clear_has_slidenumbersvisible();
  inline void set_has_recording();
  inline void clear_has_recording();
  inline void set_has_loop_presentation();
  inline void clear_has_loop_presentation();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_autoplay_transition_delay();
  inline void clear_has_autoplay_transition_delay();
  inline void set_has_autoplay_build_delay();
  inline void clear_has_autoplay_build_delay();
  inline void set_has_idle_timer_active();
  inline void clear_has_idle_timer_active();
  inline void set_has_idle_timer_delay();
  inline void clear_has_idle_timer_delay();
  inline void set_has_soundtrack();
  inline void clear_has_soundtrack();
  inline void set_has_automatically_plays_upon_open();
  inline void clear_has_automatically_plays_upon_open();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* uistate_;
  ::TSP::Reference* theme_;
  ::KN::SlideTreeArchive* slidetree_;
  ::TSP::Size* size_;
  ::TSP::Reference* stylesheet_;
  ::TSP::Reference* recording_;
  double autoplay_transition_delay_;
  int mode_;
  bool slidenumbersvisible_;
  bool loop_presentation_;
  bool idle_timer_active_;
  bool automatically_plays_upon_open_;
  double autoplay_build_delay_;
  double idle_timer_delay_;
  ::TSP::Reference* soundtrack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static ShowArchive* default_instance_;
};
// -------------------------------------------------------------------

class DocumentArchive : public ::google::protobuf::Message {
 public:
  DocumentArchive();
  virtual ~DocumentArchive();

  DocumentArchive(const DocumentArchive& from);

  inline DocumentArchive& operator=(const DocumentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentArchive& default_instance();

  void Swap(DocumentArchive* other);

  // implements Message ----------------------------------------------

  DocumentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentArchive& from);
  void MergeFrom(const DocumentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSA.DocumentArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSA::DocumentArchive& super() const;
  inline ::TSA::DocumentArchive* mutable_super();
  inline ::TSA::DocumentArchive* release_super();
  inline void set_allocated_super(::TSA::DocumentArchive* super);

  // required .TSP.Reference show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline const ::TSP::Reference& show() const;
  inline ::TSP::Reference* mutable_show();
  inline ::TSP::Reference* release_show();
  inline void set_allocated_show(::TSP::Reference* show);

  // optional .TSP.Reference tables_custom_format_list = 4;
  inline bool has_tables_custom_format_list() const;
  inline void clear_tables_custom_format_list();
  static const int kTablesCustomFormatListFieldNumber = 4;
  inline const ::TSP::Reference& tables_custom_format_list() const;
  inline ::TSP::Reference* mutable_tables_custom_format_list();
  inline ::TSP::Reference* release_tables_custom_format_list();
  inline void set_allocated_tables_custom_format_list(::TSP::Reference* tables_custom_format_list);

  // @@protoc_insertion_point(class_scope:KN.DocumentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_tables_custom_format_list();
  inline void clear_has_tables_custom_format_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSA::DocumentArchive* super_;
  ::TSP::Reference* show_;
  ::TSP::Reference* tables_custom_format_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static DocumentArchive* default_instance_;
};
// -------------------------------------------------------------------

class SlideStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  SlideStylePropertiesArchive();
  virtual ~SlideStylePropertiesArchive();

  SlideStylePropertiesArchive(const SlideStylePropertiesArchive& from);

  inline SlideStylePropertiesArchive& operator=(const SlideStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideStylePropertiesArchive& default_instance();

  void Swap(SlideStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  SlideStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideStylePropertiesArchive& from);
  void MergeFrom(const SlideStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSD.FillArchive fill = 1;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 1;
  inline const ::TSD::FillArchive& fill() const;
  inline ::TSD::FillArchive* mutable_fill();
  inline ::TSD::FillArchive* release_fill();
  inline void set_allocated_fill(::TSD::FillArchive* fill);

  // optional .KN.TransitionAttributesArchive transition = 2;
  inline bool has_transition() const;
  inline void clear_transition();
  static const int kTransitionFieldNumber = 2;
  inline const ::KN::TransitionAttributesArchive& transition() const;
  inline ::KN::TransitionAttributesArchive* mutable_transition();
  inline ::KN::TransitionAttributesArchive* release_transition();
  inline void set_allocated_transition(::KN::TransitionAttributesArchive* transition);

  // optional bool transition_null = 3;
  inline bool has_transition_null() const;
  inline void clear_transition_null();
  static const int kTransitionNullFieldNumber = 3;
  inline bool transition_null() const;
  inline void set_transition_null(bool value);

  // optional bool titlePlaceholderVisibility = 4;
  inline bool has_titleplaceholdervisibility() const;
  inline void clear_titleplaceholdervisibility();
  static const int kTitlePlaceholderVisibilityFieldNumber = 4;
  inline bool titleplaceholdervisibility() const;
  inline void set_titleplaceholdervisibility(bool value);

  // optional bool bodyPlaceholderVisibility = 5;
  inline bool has_bodyplaceholdervisibility() const;
  inline void clear_bodyplaceholdervisibility();
  static const int kBodyPlaceholderVisibilityFieldNumber = 5;
  inline bool bodyplaceholdervisibility() const;
  inline void set_bodyplaceholdervisibility(bool value);

  // optional bool objectPlaceholderVisibility = 7;
  inline bool has_objectplaceholdervisibility() const;
  inline void clear_objectplaceholdervisibility();
  static const int kObjectPlaceholderVisibilityFieldNumber = 7;
  inline bool objectplaceholdervisibility() const;
  inline void set_objectplaceholdervisibility(bool value);

  // optional bool slideNumberPlaceholderVisibility = 6;
  inline bool has_slidenumberplaceholdervisibility() const;
  inline void clear_slidenumberplaceholdervisibility();
  static const int kSlideNumberPlaceholderVisibilityFieldNumber = 6;
  inline bool slidenumberplaceholdervisibility() const;
  inline void set_slidenumberplaceholdervisibility(bool value);

  // @@protoc_insertion_point(class_scope:KN.SlideStylePropertiesArchive)
 private:
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_transition();
  inline void clear_has_transition();
  inline void set_has_transition_null();
  inline void clear_has_transition_null();
  inline void set_has_titleplaceholdervisibility();
  inline void clear_has_titleplaceholdervisibility();
  inline void set_has_bodyplaceholdervisibility();
  inline void clear_has_bodyplaceholdervisibility();
  inline void set_has_objectplaceholdervisibility();
  inline void clear_has_objectplaceholdervisibility();
  inline void set_has_slidenumberplaceholdervisibility();
  inline void clear_has_slidenumberplaceholdervisibility();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::FillArchive* fill_;
  ::KN::TransitionAttributesArchive* transition_;
  bool transition_null_;
  bool titleplaceholdervisibility_;
  bool bodyplaceholdervisibility_;
  bool objectplaceholdervisibility_;
  bool slidenumberplaceholdervisibility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class SlideStyleArchive : public ::google::protobuf::Message {
 public:
  SlideStyleArchive();
  virtual ~SlideStyleArchive();

  SlideStyleArchive(const SlideStyleArchive& from);

  inline SlideStyleArchive& operator=(const SlideStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideStyleArchive& default_instance();

  void Swap(SlideStyleArchive* other);

  // implements Message ----------------------------------------------

  SlideStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideStyleArchive& from);
  void MergeFrom(const SlideStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .KN.SlideStylePropertiesArchive slide_properties = 11;
  inline bool has_slide_properties() const;
  inline void clear_slide_properties();
  static const int kSlidePropertiesFieldNumber = 11;
  inline const ::KN::SlideStylePropertiesArchive& slide_properties() const;
  inline ::KN::SlideStylePropertiesArchive* mutable_slide_properties();
  inline ::KN::SlideStylePropertiesArchive* release_slide_properties();
  inline void set_allocated_slide_properties(::KN::SlideStylePropertiesArchive* slide_properties);

  // @@protoc_insertion_point(class_scope:KN.SlideStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_slide_properties();
  inline void clear_has_slide_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::KN::SlideStylePropertiesArchive* slide_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class PasteboardNativeStorageArchive : public ::google::protobuf::Message {
 public:
  PasteboardNativeStorageArchive();
  virtual ~PasteboardNativeStorageArchive();

  PasteboardNativeStorageArchive(const PasteboardNativeStorageArchive& from);

  inline PasteboardNativeStorageArchive& operator=(const PasteboardNativeStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PasteboardNativeStorageArchive& default_instance();

  void Swap(PasteboardNativeStorageArchive* other);

  // implements Message ----------------------------------------------

  PasteboardNativeStorageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PasteboardNativeStorageArchive& from);
  void MergeFrom(const PasteboardNativeStorageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference drawables = 1;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 1;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // repeated .TSP.Reference builds = 2;
  inline int builds_size() const;
  inline void clear_builds();
  static const int kBuildsFieldNumber = 2;
  inline const ::TSP::Reference& builds(int index) const;
  inline ::TSP::Reference* mutable_builds(int index);
  inline ::TSP::Reference* add_builds();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      builds() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_builds();

  // repeated .KN.BuildChunkArchive buildChunks = 3;
  inline int buildchunks_size() const;
  inline void clear_buildchunks();
  static const int kBuildChunksFieldNumber = 3;
  inline const ::KN::BuildChunkArchive& buildchunks(int index) const;
  inline ::KN::BuildChunkArchive* mutable_buildchunks(int index);
  inline ::KN::BuildChunkArchive* add_buildchunks();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >&
      buildchunks() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >*
      mutable_buildchunks();

  // repeated .TSP.Reference slideNodes = 4;
  inline int slidenodes_size() const;
  inline void clear_slidenodes();
  static const int kSlideNodesFieldNumber = 4;
  inline const ::TSP::Reference& slidenodes(int index) const;
  inline ::TSP::Reference* mutable_slidenodes(int index);
  inline ::TSP::Reference* add_slidenodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      slidenodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_slidenodes();

  // optional .TSP.Size originalShowSize = 5;
  inline bool has_originalshowsize() const;
  inline void clear_originalshowsize();
  static const int kOriginalShowSizeFieldNumber = 5;
  inline const ::TSP::Size& originalshowsize() const;
  inline ::TSP::Size* mutable_originalshowsize();
  inline ::TSP::Size* release_originalshowsize();
  inline void set_allocated_originalshowsize(::TSP::Size* originalshowsize);

  // repeated .TSP.Range titleRanges = 6;
  inline int titleranges_size() const;
  inline void clear_titleranges();
  static const int kTitleRangesFieldNumber = 6;
  inline const ::TSP::Range& titleranges(int index) const;
  inline ::TSP::Range* mutable_titleranges(int index);
  inline ::TSP::Range* add_titleranges();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Range >&
      titleranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Range >*
      mutable_titleranges();

  // @@protoc_insertion_point(class_scope:KN.PasteboardNativeStorageArchive)
 private:
  inline void set_has_originalshowsize();
  inline void clear_has_originalshowsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > builds_;
  ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive > buildchunks_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > slidenodes_;
  ::TSP::Size* originalshowsize_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Range > titleranges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static PasteboardNativeStorageArchive* default_instance_;
};
// -------------------------------------------------------------------

class MasterChangeBlobArchive : public ::google::protobuf::Message {
 public:
  MasterChangeBlobArchive();
  virtual ~MasterChangeBlobArchive();

  MasterChangeBlobArchive(const MasterChangeBlobArchive& from);

  inline MasterChangeBlobArchive& operator=(const MasterChangeBlobArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterChangeBlobArchive& default_instance();

  void Swap(MasterChangeBlobArchive* other);

  // implements Message ----------------------------------------------

  MasterChangeBlobArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterChangeBlobArchive& from);
  void MergeFrom(const MasterChangeBlobArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference slide = 1;
  inline bool has_slide() const;
  inline void clear_slide();
  static const int kSlideFieldNumber = 1;
  inline const ::TSP::Reference& slide() const;
  inline ::TSP::Reference* mutable_slide();
  inline ::TSP::Reference* release_slide();
  inline void set_allocated_slide(::TSP::Reference* slide);

  // optional .TSP.Reference master = 2;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 2;
  inline const ::TSP::Reference& master() const;
  inline ::TSP::Reference* mutable_master();
  inline ::TSP::Reference* release_master();
  inline void set_allocated_master(::TSP::Reference* master);

  // optional .TSP.Reference slide_style = 3;
  inline bool has_slide_style() const;
  inline void clear_slide_style();
  static const int kSlideStyleFieldNumber = 3;
  inline const ::TSP::Reference& slide_style() const;
  inline ::TSP::Reference* mutable_slide_style();
  inline ::TSP::Reference* release_slide_style();
  inline void set_allocated_slide_style(::TSP::Reference* slide_style);

  // optional .TSP.Reference title_placeholder = 4;
  inline bool has_title_placeholder() const;
  inline void clear_title_placeholder();
  static const int kTitlePlaceholderFieldNumber = 4;
  inline const ::TSP::Reference& title_placeholder() const;
  inline ::TSP::Reference* mutable_title_placeholder();
  inline ::TSP::Reference* release_title_placeholder();
  inline void set_allocated_title_placeholder(::TSP::Reference* title_placeholder);

  // optional .TSP.Reference body_placeholder = 5;
  inline bool has_body_placeholder() const;
  inline void clear_body_placeholder();
  static const int kBodyPlaceholderFieldNumber = 5;
  inline const ::TSP::Reference& body_placeholder() const;
  inline ::TSP::Reference* mutable_body_placeholder();
  inline ::TSP::Reference* release_body_placeholder();
  inline void set_allocated_body_placeholder(::TSP::Reference* body_placeholder);

  // optional .TSP.Reference object_placeholder = 7;
  inline bool has_object_placeholder() const;
  inline void clear_object_placeholder();
  static const int kObjectPlaceholderFieldNumber = 7;
  inline const ::TSP::Reference& object_placeholder() const;
  inline ::TSP::Reference* mutable_object_placeholder();
  inline ::TSP::Reference* release_object_placeholder();
  inline void set_allocated_object_placeholder(::TSP::Reference* object_placeholder);

  // repeated .TSP.Reference drawables = 6;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 6;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // @@protoc_insertion_point(class_scope:KN.MasterChangeBlobArchive)
 private:
  inline void set_has_slide();
  inline void clear_has_slide();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_slide_style();
  inline void clear_has_slide_style();
  inline void set_has_title_placeholder();
  inline void clear_has_title_placeholder();
  inline void set_has_body_placeholder();
  inline void clear_has_body_placeholder();
  inline void set_has_object_placeholder();
  inline void clear_has_object_placeholder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* slide_;
  ::TSP::Reference* master_;
  ::TSP::Reference* slide_style_;
  ::TSP::Reference* title_placeholder_;
  ::TSP::Reference* body_placeholder_;
  ::TSP::Reference* object_placeholder_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static MasterChangeBlobArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingArchive : public ::google::protobuf::Message {
 public:
  RecordingArchive();
  virtual ~RecordingArchive();

  RecordingArchive(const RecordingArchive& from);

  inline RecordingArchive& operator=(const RecordingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingArchive& default_instance();

  void Swap(RecordingArchive* other);

  // implements Message ----------------------------------------------

  RecordingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingArchive& from);
  void MergeFrom(const RecordingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RecordingArchive_RecordingSyncState RecordingSyncState;
  static const RecordingSyncState kRecordingSyncStateInSyncWithShow = RecordingArchive_RecordingSyncState_kRecordingSyncStateInSyncWithShow;
  static const RecordingSyncState kRecordingSyncStateOutOfSyncWithShow = RecordingArchive_RecordingSyncState_kRecordingSyncStateOutOfSyncWithShow;
  static inline bool RecordingSyncState_IsValid(int value) {
    return RecordingArchive_RecordingSyncState_IsValid(value);
  }
  static const RecordingSyncState RecordingSyncState_MIN =
    RecordingArchive_RecordingSyncState_RecordingSyncState_MIN;
  static const RecordingSyncState RecordingSyncState_MAX =
    RecordingArchive_RecordingSyncState_RecordingSyncState_MAX;
  static const int RecordingSyncState_ARRAYSIZE =
    RecordingArchive_RecordingSyncState_RecordingSyncState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordingSyncState_descriptor() {
    return RecordingArchive_RecordingSyncState_descriptor();
  }
  static inline const ::std::string& RecordingSyncState_Name(RecordingSyncState value) {
    return RecordingArchive_RecordingSyncState_Name(value);
  }
  static inline bool RecordingSyncState_Parse(const ::std::string& name,
      RecordingSyncState* value) {
    return RecordingArchive_RecordingSyncState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference event_tracks = 1;
  inline int event_tracks_size() const;
  inline void clear_event_tracks();
  static const int kEventTracksFieldNumber = 1;
  inline const ::TSP::Reference& event_tracks(int index) const;
  inline ::TSP::Reference* mutable_event_tracks(int index);
  inline ::TSP::Reference* add_event_tracks();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      event_tracks() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_event_tracks();

  // optional .TSP.Reference movie_track = 2;
  inline bool has_movie_track() const;
  inline void clear_movie_track();
  static const int kMovieTrackFieldNumber = 2;
  inline const ::TSP::Reference& movie_track() const;
  inline ::TSP::Reference* mutable_movie_track();
  inline ::TSP::Reference* release_movie_track();
  inline void set_allocated_movie_track(::TSP::Reference* movie_track);

  // optional double duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline double duration() const;
  inline void set_duration(double value);

  // optional .KN.RecordingArchive.RecordingSyncState sync_state = 4 [default = kRecordingSyncStateInSyncWithShow];
  inline bool has_sync_state() const;
  inline void clear_sync_state();
  static const int kSyncStateFieldNumber = 4;
  inline ::KN::RecordingArchive_RecordingSyncState sync_state() const;
  inline void set_sync_state(::KN::RecordingArchive_RecordingSyncState value);

  // optional .TSP.Date modification_date = 5;
  inline bool has_modification_date() const;
  inline void clear_modification_date();
  static const int kModificationDateFieldNumber = 5;
  inline const ::TSP::Date& modification_date() const;
  inline ::TSP::Date* mutable_modification_date();
  inline ::TSP::Date* release_modification_date();
  inline void set_allocated_modification_date(::TSP::Date* modification_date);

  // @@protoc_insertion_point(class_scope:KN.RecordingArchive)
 private:
  inline void set_has_movie_track();
  inline void clear_has_movie_track();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_sync_state();
  inline void clear_has_sync_state();
  inline void set_has_modification_date();
  inline void clear_has_modification_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > event_tracks_;
  ::TSP::Reference* movie_track_;
  double duration_;
  ::TSP::Date* modification_date_;
  int sync_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingEventTrackArchive : public ::google::protobuf::Message {
 public:
  RecordingEventTrackArchive();
  virtual ~RecordingEventTrackArchive();

  RecordingEventTrackArchive(const RecordingEventTrackArchive& from);

  inline RecordingEventTrackArchive& operator=(const RecordingEventTrackArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingEventTrackArchive& default_instance();

  void Swap(RecordingEventTrackArchive* other);

  // implements Message ----------------------------------------------

  RecordingEventTrackArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingEventTrackArchive& from);
  void MergeFrom(const RecordingEventTrackArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated .KN.RecordingEventArchive events = 2;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 2;
  inline const ::KN::RecordingEventArchive& events(int index) const;
  inline ::KN::RecordingEventArchive* mutable_events(int index);
  inline ::KN::RecordingEventArchive* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::RecordingEventArchive >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::RecordingEventArchive >*
      mutable_events();

  // @@protoc_insertion_point(class_scope:KN.RecordingEventTrackArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::KN::RecordingEventArchive > events_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingEventTrackArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingEventArchive : public ::google::protobuf::Message {
 public:
  RecordingEventArchive();
  virtual ~RecordingEventArchive();

  RecordingEventArchive(const RecordingEventArchive& from);

  inline RecordingEventArchive& operator=(const RecordingEventArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingEventArchive& default_instance();

  void Swap(RecordingEventArchive* other);

  // implements Message ----------------------------------------------

  RecordingEventArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingEventArchive& from);
  void MergeFrom(const RecordingEventArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_time = 1 [default = -1];
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  inline double start_time() const;
  inline void set_start_time(double value);

  // optional .KN.RecordingNavigationEventArchive navigation_event_archive = 1000;
  inline bool has_navigation_event_archive() const;
  inline void clear_navigation_event_archive();
  static const int kNavigationEventArchiveFieldNumber = 1000;
  inline const ::KN::RecordingNavigationEventArchive& navigation_event_archive() const;
  inline ::KN::RecordingNavigationEventArchive* mutable_navigation_event_archive();
  inline ::KN::RecordingNavigationEventArchive* release_navigation_event_archive();
  inline void set_allocated_navigation_event_archive(::KN::RecordingNavigationEventArchive* navigation_event_archive);

  // optional .KN.RecordingLaserEventArchive laser_event_archive = 1001;
  inline bool has_laser_event_archive() const;
  inline void clear_laser_event_archive();
  static const int kLaserEventArchiveFieldNumber = 1001;
  inline const ::KN::RecordingLaserEventArchive& laser_event_archive() const;
  inline ::KN::RecordingLaserEventArchive* mutable_laser_event_archive();
  inline ::KN::RecordingLaserEventArchive* release_laser_event_archive();
  inline void set_allocated_laser_event_archive(::KN::RecordingLaserEventArchive* laser_event_archive);

  // optional .KN.RecordingPauseEventArchive pause_event_archive = 1002;
  inline bool has_pause_event_archive() const;
  inline void clear_pause_event_archive();
  static const int kPauseEventArchiveFieldNumber = 1002;
  inline const ::KN::RecordingPauseEventArchive& pause_event_archive() const;
  inline ::KN::RecordingPauseEventArchive* mutable_pause_event_archive();
  inline ::KN::RecordingPauseEventArchive* release_pause_event_archive();
  inline void set_allocated_pause_event_archive(::KN::RecordingPauseEventArchive* pause_event_archive);

  // optional .KN.RecordingMovieEventArchive movie_event_archive = 1003;
  inline bool has_movie_event_archive() const;
  inline void clear_movie_event_archive();
  static const int kMovieEventArchiveFieldNumber = 1003;
  inline const ::KN::RecordingMovieEventArchive& movie_event_archive() const;
  inline ::KN::RecordingMovieEventArchive* mutable_movie_event_archive();
  inline ::KN::RecordingMovieEventArchive* release_movie_event_archive();
  inline void set_allocated_movie_event_archive(::KN::RecordingMovieEventArchive* movie_event_archive);

  // @@protoc_insertion_point(class_scope:KN.RecordingEventArchive)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_navigation_event_archive();
  inline void clear_has_navigation_event_archive();
  inline void set_has_laser_event_archive();
  inline void clear_has_laser_event_archive();
  inline void set_has_pause_event_archive();
  inline void clear_has_pause_event_archive();
  inline void set_has_movie_event_archive();
  inline void clear_has_movie_event_archive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double start_time_;
  ::KN::RecordingNavigationEventArchive* navigation_event_archive_;
  ::KN::RecordingLaserEventArchive* laser_event_archive_;
  ::KN::RecordingPauseEventArchive* pause_event_archive_;
  ::KN::RecordingMovieEventArchive* movie_event_archive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingEventArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingNavigationEventArchive : public ::google::protobuf::Message {
 public:
  RecordingNavigationEventArchive();
  virtual ~RecordingNavigationEventArchive();

  RecordingNavigationEventArchive(const RecordingNavigationEventArchive& from);

  inline RecordingNavigationEventArchive& operator=(const RecordingNavigationEventArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingNavigationEventArchive& default_instance();

  void Swap(RecordingNavigationEventArchive* other);

  // implements Message ----------------------------------------------

  RecordingNavigationEventArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingNavigationEventArchive& from);
  void MergeFrom(const RecordingNavigationEventArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase RecordingNavigationEventAnimationPhase;
  static const RecordingNavigationEventAnimationPhase kRecordingNavigationEventAnimationNone = RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationNone;
  static const RecordingNavigationEventAnimationPhase kRecordingNavigationEventAnimationStart = RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationStart;
  static const RecordingNavigationEventAnimationPhase kRecordingNavigationEventAnimationEnd = RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_kRecordingNavigationEventAnimationEnd;
  static inline bool RecordingNavigationEventAnimationPhase_IsValid(int value) {
    return RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_IsValid(value);
  }
  static const RecordingNavigationEventAnimationPhase RecordingNavigationEventAnimationPhase_MIN =
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_MIN;
  static const RecordingNavigationEventAnimationPhase RecordingNavigationEventAnimationPhase_MAX =
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_MAX;
  static const int RecordingNavigationEventAnimationPhase_ARRAYSIZE =
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_RecordingNavigationEventAnimationPhase_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordingNavigationEventAnimationPhase_descriptor() {
    return RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_descriptor();
  }
  static inline const ::std::string& RecordingNavigationEventAnimationPhase_Name(RecordingNavigationEventAnimationPhase value) {
    return RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_Name(value);
  }
  static inline bool RecordingNavigationEventAnimationPhase_Parse(const ::std::string& name,
      RecordingNavigationEventAnimationPhase* value) {
    return RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Reference target_slide_node_reference = 1;
  inline bool has_target_slide_node_reference() const;
  inline void clear_target_slide_node_reference();
  static const int kTargetSlideNodeReferenceFieldNumber = 1;
  inline const ::TSP::Reference& target_slide_node_reference() const;
  inline ::TSP::Reference* mutable_target_slide_node_reference();
  inline ::TSP::Reference* release_target_slide_node_reference();
  inline void set_allocated_target_slide_node_reference(::TSP::Reference* target_slide_node_reference);

  // optional uint32 target_event_index = 2;
  inline bool has_target_event_index() const;
  inline void clear_target_event_index();
  static const int kTargetEventIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 target_event_index() const;
  inline void set_target_event_index(::google::protobuf::uint32 value);

  // optional .KN.RecordingNavigationEventArchive.RecordingNavigationEventAnimationPhase animation_phase = 3 [default = kRecordingNavigationEventAnimationNone];
  inline bool has_animation_phase() const;
  inline void clear_animation_phase();
  static const int kAnimationPhaseFieldNumber = 3;
  inline ::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase animation_phase() const;
  inline void set_animation_phase(::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase value);

  // @@protoc_insertion_point(class_scope:KN.RecordingNavigationEventArchive)
 private:
  inline void set_has_target_slide_node_reference();
  inline void clear_has_target_slide_node_reference();
  inline void set_has_target_event_index();
  inline void clear_has_target_event_index();
  inline void set_has_animation_phase();
  inline void clear_has_animation_phase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* target_slide_node_reference_;
  ::google::protobuf::uint32 target_event_index_;
  int animation_phase_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingNavigationEventArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingLaserEventArchive : public ::google::protobuf::Message {
 public:
  RecordingLaserEventArchive();
  virtual ~RecordingLaserEventArchive();

  RecordingLaserEventArchive(const RecordingLaserEventArchive& from);

  inline RecordingLaserEventArchive& operator=(const RecordingLaserEventArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingLaserEventArchive& default_instance();

  void Swap(RecordingLaserEventArchive* other);

  // implements Message ----------------------------------------------

  RecordingLaserEventArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingLaserEventArchive& from);
  void MergeFrom(const RecordingLaserEventArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Point unscaled_location = 1;
  inline bool has_unscaled_location() const;
  inline void clear_unscaled_location();
  static const int kUnscaledLocationFieldNumber = 1;
  inline const ::TSP::Point& unscaled_location() const;
  inline ::TSP::Point* mutable_unscaled_location();
  inline ::TSP::Point* release_unscaled_location();
  inline void set_allocated_unscaled_location(::TSP::Point* unscaled_location);

  // @@protoc_insertion_point(class_scope:KN.RecordingLaserEventArchive)
 private:
  inline void set_has_unscaled_location();
  inline void clear_has_unscaled_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Point* unscaled_location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingLaserEventArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingPauseEventArchive : public ::google::protobuf::Message {
 public:
  RecordingPauseEventArchive();
  virtual ~RecordingPauseEventArchive();

  RecordingPauseEventArchive(const RecordingPauseEventArchive& from);

  inline RecordingPauseEventArchive& operator=(const RecordingPauseEventArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingPauseEventArchive& default_instance();

  void Swap(RecordingPauseEventArchive* other);

  // implements Message ----------------------------------------------

  RecordingPauseEventArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingPauseEventArchive& from);
  void MergeFrom(const RecordingPauseEventArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RecordingPauseEventArchive_RecordingPauseEventType RecordingPauseEventType;
  static const RecordingPauseEventType kRecordingPauseEventTypeResume = RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeResume;
  static const RecordingPauseEventType kRecordingPauseEventTypePause = RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypePause;
  static const RecordingPauseEventType kRecordingPauseEventTypeConcealWithBlack = RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeConcealWithBlack;
  static const RecordingPauseEventType kRecordingPauseEventTypeConcealWithWhite = RecordingPauseEventArchive_RecordingPauseEventType_kRecordingPauseEventTypeConcealWithWhite;
  static inline bool RecordingPauseEventType_IsValid(int value) {
    return RecordingPauseEventArchive_RecordingPauseEventType_IsValid(value);
  }
  static const RecordingPauseEventType RecordingPauseEventType_MIN =
    RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_MIN;
  static const RecordingPauseEventType RecordingPauseEventType_MAX =
    RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_MAX;
  static const int RecordingPauseEventType_ARRAYSIZE =
    RecordingPauseEventArchive_RecordingPauseEventType_RecordingPauseEventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordingPauseEventType_descriptor() {
    return RecordingPauseEventArchive_RecordingPauseEventType_descriptor();
  }
  static inline const ::std::string& RecordingPauseEventType_Name(RecordingPauseEventType value) {
    return RecordingPauseEventArchive_RecordingPauseEventType_Name(value);
  }
  static inline bool RecordingPauseEventType_Parse(const ::std::string& name,
      RecordingPauseEventType* value) {
    return RecordingPauseEventArchive_RecordingPauseEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .KN.RecordingPauseEventArchive.RecordingPauseEventType pause_event_type = 1 [default = kRecordingPauseEventTypeResume];
  inline bool has_pause_event_type() const;
  inline void clear_pause_event_type();
  static const int kPauseEventTypeFieldNumber = 1;
  inline ::KN::RecordingPauseEventArchive_RecordingPauseEventType pause_event_type() const;
  inline void set_pause_event_type(::KN::RecordingPauseEventArchive_RecordingPauseEventType value);

  // @@protoc_insertion_point(class_scope:KN.RecordingPauseEventArchive)
 private:
  inline void set_has_pause_event_type();
  inline void clear_has_pause_event_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int pause_event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingPauseEventArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingMovieEventArchive : public ::google::protobuf::Message {
 public:
  RecordingMovieEventArchive();
  virtual ~RecordingMovieEventArchive();

  RecordingMovieEventArchive(const RecordingMovieEventArchive& from);

  inline RecordingMovieEventArchive& operator=(const RecordingMovieEventArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingMovieEventArchive& default_instance();

  void Swap(RecordingMovieEventArchive* other);

  // implements Message ----------------------------------------------

  RecordingMovieEventArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingMovieEventArchive& from);
  void MergeFrom(const RecordingMovieEventArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RecordingMovieEventArchive_RecordingMovieEventType RecordingMovieEventType;
  static const RecordingMovieEventType kRecordingMovieEventNone = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventNone;
  static const RecordingMovieEventType kRecordingMovieEventSeek = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventSeek;
  static const RecordingMovieEventType kRecordingMovieEventSetRate = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventSetRate;
  static const RecordingMovieEventType kRecordingMovieEventStartPlayback = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventStartPlayback;
  static const RecordingMovieEventType kRecordingMovieEventStopPlayback = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventStopPlayback;
  static const RecordingMovieEventType kRecordingMovieEventBeginScrubbing = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventBeginScrubbing;
  static const RecordingMovieEventType kRecordingMovieEventEndScrubbing = RecordingMovieEventArchive_RecordingMovieEventType_kRecordingMovieEventEndScrubbing;
  static inline bool RecordingMovieEventType_IsValid(int value) {
    return RecordingMovieEventArchive_RecordingMovieEventType_IsValid(value);
  }
  static const RecordingMovieEventType RecordingMovieEventType_MIN =
    RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_MIN;
  static const RecordingMovieEventType RecordingMovieEventType_MAX =
    RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_MAX;
  static const int RecordingMovieEventType_ARRAYSIZE =
    RecordingMovieEventArchive_RecordingMovieEventType_RecordingMovieEventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordingMovieEventType_descriptor() {
    return RecordingMovieEventArchive_RecordingMovieEventType_descriptor();
  }
  static inline const ::std::string& RecordingMovieEventType_Name(RecordingMovieEventType value) {
    return RecordingMovieEventArchive_RecordingMovieEventType_Name(value);
  }
  static inline bool RecordingMovieEventType_Parse(const ::std::string& name,
      RecordingMovieEventType* value) {
    return RecordingMovieEventArchive_RecordingMovieEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Reference movie_info_reference = 1;
  inline bool has_movie_info_reference() const;
  inline void clear_movie_info_reference();
  static const int kMovieInfoReferenceFieldNumber = 1;
  inline const ::TSP::Reference& movie_info_reference() const;
  inline ::TSP::Reference* mutable_movie_info_reference();
  inline ::TSP::Reference* release_movie_info_reference();
  inline void set_allocated_movie_info_reference(::TSP::Reference* movie_info_reference);

  // optional .KN.RecordingMovieEventArchive.RecordingMovieEventType movie_event_type = 2 [default = kRecordingMovieEventSeek];
  inline bool has_movie_event_type() const;
  inline void clear_movie_event_type();
  static const int kMovieEventTypeFieldNumber = 2;
  inline ::KN::RecordingMovieEventArchive_RecordingMovieEventType movie_event_type() const;
  inline void set_movie_event_type(::KN::RecordingMovieEventArchive_RecordingMovieEventType value);

  // optional double movie_event_value = 3;
  inline bool has_movie_event_value() const;
  inline void clear_movie_event_value();
  static const int kMovieEventValueFieldNumber = 3;
  inline double movie_event_value() const;
  inline void set_movie_event_value(double value);

  // @@protoc_insertion_point(class_scope:KN.RecordingMovieEventArchive)
 private:
  inline void set_has_movie_info_reference();
  inline void clear_has_movie_info_reference();
  inline void set_has_movie_event_type();
  inline void clear_has_movie_event_type();
  inline void set_has_movie_event_value();
  inline void clear_has_movie_event_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* movie_info_reference_;
  double movie_event_value_;
  int movie_event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingMovieEventArchive* default_instance_;
};
// -------------------------------------------------------------------

class RecordingMovieTrackArchive : public ::google::protobuf::Message {
 public:
  RecordingMovieTrackArchive();
  virtual ~RecordingMovieTrackArchive();

  RecordingMovieTrackArchive(const RecordingMovieTrackArchive& from);

  inline RecordingMovieTrackArchive& operator=(const RecordingMovieTrackArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingMovieTrackArchive& default_instance();

  void Swap(RecordingMovieTrackArchive* other);

  // implements Message ----------------------------------------------

  RecordingMovieTrackArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingMovieTrackArchive& from);
  void MergeFrom(const RecordingMovieTrackArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KN.MovieSegmentArchive movie_segments = 1;
  inline int movie_segments_size() const;
  inline void clear_movie_segments();
  static const int kMovieSegmentsFieldNumber = 1;
  inline const ::KN::MovieSegmentArchive& movie_segments(int index) const;
  inline ::KN::MovieSegmentArchive* mutable_movie_segments(int index);
  inline ::KN::MovieSegmentArchive* add_movie_segments();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::MovieSegmentArchive >&
      movie_segments() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::MovieSegmentArchive >*
      mutable_movie_segments();

  // @@protoc_insertion_point(class_scope:KN.RecordingMovieTrackArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::KN::MovieSegmentArchive > movie_segments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static RecordingMovieTrackArchive* default_instance_;
};
// -------------------------------------------------------------------

class MovieSegmentArchive : public ::google::protobuf::Message {
 public:
  MovieSegmentArchive();
  virtual ~MovieSegmentArchive();

  MovieSegmentArchive(const MovieSegmentArchive& from);

  inline MovieSegmentArchive& operator=(const MovieSegmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieSegmentArchive& default_instance();

  void Swap(MovieSegmentArchive* other);

  // implements Message ----------------------------------------------

  MovieSegmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MovieSegmentArchive& from);
  void MergeFrom(const MovieSegmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.DataReference movie_data = 3;
  inline bool has_movie_data() const;
  inline void clear_movie_data();
  static const int kMovieDataFieldNumber = 3;
  inline const ::TSP::DataReference& movie_data() const;
  inline ::TSP::DataReference* mutable_movie_data();
  inline ::TSP::DataReference* release_movie_data();
  inline void set_allocated_movie_data(::TSP::DataReference* movie_data);

  // optional double start_time = 2 [default = -1];
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline double start_time() const;
  inline void set_start_time(double value);

  // optional .TSP.Reference database_movie_data = 1;
  inline bool has_database_movie_data() const;
  inline void clear_database_movie_data();
  static const int kDatabaseMovieDataFieldNumber = 1;
  inline const ::TSP::Reference& database_movie_data() const;
  inline ::TSP::Reference* mutable_database_movie_data();
  inline ::TSP::Reference* release_database_movie_data();
  inline void set_allocated_database_movie_data(::TSP::Reference* database_movie_data);

  // @@protoc_insertion_point(class_scope:KN.MovieSegmentArchive)
 private:
  inline void set_has_movie_data();
  inline void clear_has_movie_data();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_database_movie_data();
  inline void clear_has_database_movie_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::DataReference* movie_data_;
  double start_time_;
  ::TSP::Reference* database_movie_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static MovieSegmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class Soundtrack : public ::google::protobuf::Message {
 public:
  Soundtrack();
  virtual ~Soundtrack();

  Soundtrack(const Soundtrack& from);

  inline Soundtrack& operator=(const Soundtrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Soundtrack& default_instance();

  void Swap(Soundtrack* other);

  // implements Message ----------------------------------------------

  Soundtrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soundtrack& from);
  void MergeFrom(const Soundtrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Soundtrack_SoundtrackMode SoundtrackMode;
  static const SoundtrackMode kKNSoundtrackModePlayOnce = Soundtrack_SoundtrackMode_kKNSoundtrackModePlayOnce;
  static const SoundtrackMode kKNSoundtrackModeLoop = Soundtrack_SoundtrackMode_kKNSoundtrackModeLoop;
  static const SoundtrackMode kKNSoundtrackModeDoNotPlay = Soundtrack_SoundtrackMode_kKNSoundtrackModeDoNotPlay;
  static inline bool SoundtrackMode_IsValid(int value) {
    return Soundtrack_SoundtrackMode_IsValid(value);
  }
  static const SoundtrackMode SoundtrackMode_MIN =
    Soundtrack_SoundtrackMode_SoundtrackMode_MIN;
  static const SoundtrackMode SoundtrackMode_MAX =
    Soundtrack_SoundtrackMode_SoundtrackMode_MAX;
  static const int SoundtrackMode_ARRAYSIZE =
    Soundtrack_SoundtrackMode_SoundtrackMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SoundtrackMode_descriptor() {
    return Soundtrack_SoundtrackMode_descriptor();
  }
  static inline const ::std::string& SoundtrackMode_Name(SoundtrackMode value) {
    return Soundtrack_SoundtrackMode_Name(value);
  }
  static inline bool SoundtrackMode_Parse(const ::std::string& name,
      SoundtrackMode* value) {
    return Soundtrack_SoundtrackMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double volume = 1;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 1;
  inline double volume() const;
  inline void set_volume(double value);

  // optional .KN.Soundtrack.SoundtrackMode mode = 2 [default = kKNSoundtrackModePlayOnce];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::KN::Soundtrack_SoundtrackMode mode() const;
  inline void set_mode(::KN::Soundtrack_SoundtrackMode value);

  // repeated .TSP.DataReference movie_media = 3;
  inline int movie_media_size() const;
  inline void clear_movie_media();
  static const int kMovieMediaFieldNumber = 3;
  inline const ::TSP::DataReference& movie_media(int index) const;
  inline ::TSP::DataReference* mutable_movie_media(int index);
  inline ::TSP::DataReference* add_movie_media();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >&
      movie_media() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >*
      mutable_movie_media();

  // @@protoc_insertion_point(class_scope:KN.Soundtrack)
 private:
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double volume_;
  ::google::protobuf::RepeatedPtrField< ::TSP::DataReference > movie_media_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static Soundtrack* default_instance_;
};
// -------------------------------------------------------------------

class SlideNumberAttachmentArchive : public ::google::protobuf::Message {
 public:
  SlideNumberAttachmentArchive();
  virtual ~SlideNumberAttachmentArchive();

  SlideNumberAttachmentArchive(const SlideNumberAttachmentArchive& from);

  inline SlideNumberAttachmentArchive& operator=(const SlideNumberAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideNumberAttachmentArchive& default_instance();

  void Swap(SlideNumberAttachmentArchive* other);

  // implements Message ----------------------------------------------

  SlideNumberAttachmentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideNumberAttachmentArchive& from);
  void MergeFrom(const SlideNumberAttachmentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.TextualAttachmentArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextualAttachmentArchive& super() const;
  inline ::TSWP::TextualAttachmentArchive* mutable_super();
  inline ::TSWP::TextualAttachmentArchive* release_super();
  inline void set_allocated_super(::TSWP::TextualAttachmentArchive* super);

  // @@protoc_insertion_point(class_scope:KN.SlideNumberAttachmentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextualAttachmentArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideNumberAttachmentArchive* default_instance_;
};
// -------------------------------------------------------------------

class SlideCollectionSelectionArchive_OutlineSelection : public ::google::protobuf::Message {
 public:
  SlideCollectionSelectionArchive_OutlineSelection();
  virtual ~SlideCollectionSelectionArchive_OutlineSelection();

  SlideCollectionSelectionArchive_OutlineSelection(const SlideCollectionSelectionArchive_OutlineSelection& from);

  inline SlideCollectionSelectionArchive_OutlineSelection& operator=(const SlideCollectionSelectionArchive_OutlineSelection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideCollectionSelectionArchive_OutlineSelection& default_instance();

  void Swap(SlideCollectionSelectionArchive_OutlineSelection* other);

  // implements Message ----------------------------------------------

  SlideCollectionSelectionArchive_OutlineSelection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideCollectionSelectionArchive_OutlineSelection& from);
  void MergeFrom(const SlideCollectionSelectionArchive_OutlineSelection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference slide_node = 1;
  inline bool has_slide_node() const;
  inline void clear_slide_node();
  static const int kSlideNodeFieldNumber = 1;
  inline const ::TSP::Reference& slide_node() const;
  inline ::TSP::Reference* mutable_slide_node();
  inline ::TSP::Reference* release_slide_node();
  inline void set_allocated_slide_node(::TSP::Reference* slide_node);

  // required .TSP.IndexSet selected_paragraph_indexes = 2;
  inline bool has_selected_paragraph_indexes() const;
  inline void clear_selected_paragraph_indexes();
  static const int kSelectedParagraphIndexesFieldNumber = 2;
  inline const ::TSP::IndexSet& selected_paragraph_indexes() const;
  inline ::TSP::IndexSet* mutable_selected_paragraph_indexes();
  inline ::TSP::IndexSet* release_selected_paragraph_indexes();
  inline void set_allocated_selected_paragraph_indexes(::TSP::IndexSet* selected_paragraph_indexes);

  // @@protoc_insertion_point(class_scope:KN.SlideCollectionSelectionArchive.OutlineSelection)
 private:
  inline void set_has_slide_node();
  inline void clear_has_slide_node();
  inline void set_has_selected_paragraph_indexes();
  inline void clear_has_selected_paragraph_indexes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* slide_node_;
  ::TSP::IndexSet* selected_paragraph_indexes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideCollectionSelectionArchive_OutlineSelection* default_instance_;
};
// -------------------------------------------------------------------

class SlideCollectionSelectionArchive : public ::google::protobuf::Message {
 public:
  SlideCollectionSelectionArchive();
  virtual ~SlideCollectionSelectionArchive();

  SlideCollectionSelectionArchive(const SlideCollectionSelectionArchive& from);

  inline SlideCollectionSelectionArchive& operator=(const SlideCollectionSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideCollectionSelectionArchive& default_instance();

  void Swap(SlideCollectionSelectionArchive* other);

  // implements Message ----------------------------------------------

  SlideCollectionSelectionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlideCollectionSelectionArchive& from);
  void MergeFrom(const SlideCollectionSelectionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlideCollectionSelectionArchive_OutlineSelection OutlineSelection;

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference slide_nodes = 1;
  inline int slide_nodes_size() const;
  inline void clear_slide_nodes();
  static const int kSlideNodesFieldNumber = 1;
  inline const ::TSP::Reference& slide_nodes(int index) const;
  inline ::TSP::Reference* mutable_slide_nodes(int index);
  inline ::TSP::Reference* add_slide_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      slide_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_slide_nodes();

  // optional .TSP.Reference slide_node_to_edit = 2;
  inline bool has_slide_node_to_edit() const;
  inline void clear_slide_node_to_edit();
  static const int kSlideNodeToEditFieldNumber = 2;
  inline const ::TSP::Reference& slide_node_to_edit() const;
  inline ::TSP::Reference* mutable_slide_node_to_edit();
  inline ::TSP::Reference* release_slide_node_to_edit();
  inline void set_allocated_slide_node_to_edit(::TSP::Reference* slide_node_to_edit);

  // repeated .KN.SlideCollectionSelectionArchive.OutlineSelection selected_paragraph_indexes_for_slide_nodes = 3;
  inline int selected_paragraph_indexes_for_slide_nodes_size() const;
  inline void clear_selected_paragraph_indexes_for_slide_nodes();
  static const int kSelectedParagraphIndexesForSlideNodesFieldNumber = 3;
  inline const ::KN::SlideCollectionSelectionArchive_OutlineSelection& selected_paragraph_indexes_for_slide_nodes(int index) const;
  inline ::KN::SlideCollectionSelectionArchive_OutlineSelection* mutable_selected_paragraph_indexes_for_slide_nodes(int index);
  inline ::KN::SlideCollectionSelectionArchive_OutlineSelection* add_selected_paragraph_indexes_for_slide_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::KN::SlideCollectionSelectionArchive_OutlineSelection >&
      selected_paragraph_indexes_for_slide_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::KN::SlideCollectionSelectionArchive_OutlineSelection >*
      mutable_selected_paragraph_indexes_for_slide_nodes();

  // optional .TSP.Range range_in_selected_paragraph = 4;
  inline bool has_range_in_selected_paragraph() const;
  inline void clear_range_in_selected_paragraph();
  static const int kRangeInSelectedParagraphFieldNumber = 4;
  inline const ::TSP::Range& range_in_selected_paragraph() const;
  inline ::TSP::Range* mutable_range_in_selected_paragraph();
  inline ::TSP::Range* release_range_in_selected_paragraph();
  inline void set_allocated_range_in_selected_paragraph(::TSP::Range* range_in_selected_paragraph);

  // @@protoc_insertion_point(class_scope:KN.SlideCollectionSelectionArchive)
 private:
  inline void set_has_slide_node_to_edit();
  inline void clear_has_slide_node_to_edit();
  inline void set_has_range_in_selected_paragraph();
  inline void clear_has_range_in_selected_paragraph();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > slide_nodes_;
  ::TSP::Reference* slide_node_to_edit_;
  ::google::protobuf::RepeatedPtrField< ::KN::SlideCollectionSelectionArchive_OutlineSelection > selected_paragraph_indexes_for_slide_nodes_;
  ::TSP::Range* range_in_selected_paragraph_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KNArchives_2eproto();
  friend void protobuf_AssignDesc_KNArchives_2eproto();
  friend void protobuf_ShutdownFile_KNArchives_2eproto();

  void InitAsDefaultInstance();
  static SlideCollectionSelectionArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// AnimationAttributesArchive

// optional string animationType = 1;
inline bool AnimationAttributesArchive::has_animationtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimationAttributesArchive::set_has_animationtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimationAttributesArchive::clear_has_animationtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimationAttributesArchive::clear_animationtype() {
  if (animationtype_ != &::google::protobuf::internal::kEmptyString) {
    animationtype_->clear();
  }
  clear_has_animationtype();
}
inline const ::std::string& AnimationAttributesArchive::animationtype() const {
  return *animationtype_;
}
inline void AnimationAttributesArchive::set_animationtype(const ::std::string& value) {
  set_has_animationtype();
  if (animationtype_ == &::google::protobuf::internal::kEmptyString) {
    animationtype_ = new ::std::string;
  }
  animationtype_->assign(value);
}
inline void AnimationAttributesArchive::set_animationtype(const char* value) {
  set_has_animationtype();
  if (animationtype_ == &::google::protobuf::internal::kEmptyString) {
    animationtype_ = new ::std::string;
  }
  animationtype_->assign(value);
}
inline void AnimationAttributesArchive::set_animationtype(const char* value, size_t size) {
  set_has_animationtype();
  if (animationtype_ == &::google::protobuf::internal::kEmptyString) {
    animationtype_ = new ::std::string;
  }
  animationtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimationAttributesArchive::mutable_animationtype() {
  set_has_animationtype();
  if (animationtype_ == &::google::protobuf::internal::kEmptyString) {
    animationtype_ = new ::std::string;
  }
  return animationtype_;
}
inline ::std::string* AnimationAttributesArchive::release_animationtype() {
  clear_has_animationtype();
  if (animationtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = animationtype_;
    animationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AnimationAttributesArchive::set_allocated_animationtype(::std::string* animationtype) {
  if (animationtype_ != &::google::protobuf::internal::kEmptyString) {
    delete animationtype_;
  }
  if (animationtype) {
    set_has_animationtype();
    animationtype_ = animationtype;
  } else {
    clear_has_animationtype();
    animationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string effect = 2;
inline bool AnimationAttributesArchive::has_effect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimationAttributesArchive::set_has_effect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimationAttributesArchive::clear_has_effect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimationAttributesArchive::clear_effect() {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    effect_->clear();
  }
  clear_has_effect();
}
inline const ::std::string& AnimationAttributesArchive::effect() const {
  return *effect_;
}
inline void AnimationAttributesArchive::set_effect(const ::std::string& value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void AnimationAttributesArchive::set_effect(const char* value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void AnimationAttributesArchive::set_effect(const char* value, size_t size) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimationAttributesArchive::mutable_effect() {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  return effect_;
}
inline ::std::string* AnimationAttributesArchive::release_effect() {
  clear_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effect_;
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AnimationAttributesArchive::set_allocated_effect(::std::string* effect) {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    delete effect_;
  }
  if (effect) {
    set_has_effect();
    effect_ = effect;
  } else {
    clear_has_effect();
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double duration = 3;
inline bool AnimationAttributesArchive::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimationAttributesArchive::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimationAttributesArchive::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimationAttributesArchive::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double AnimationAttributesArchive::duration() const {
  return duration_;
}
inline void AnimationAttributesArchive::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 direction = 4;
inline bool AnimationAttributesArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimationAttributesArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimationAttributesArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimationAttributesArchive::clear_direction() {
  direction_ = 0u;
  clear_has_direction();
}
inline ::google::protobuf::uint32 AnimationAttributesArchive::direction() const {
  return direction_;
}
inline void AnimationAttributesArchive::set_direction(::google::protobuf::uint32 value) {
  set_has_direction();
  direction_ = value;
}

// optional double delay = 5;
inline bool AnimationAttributesArchive::has_delay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnimationAttributesArchive::set_has_delay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnimationAttributesArchive::clear_has_delay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnimationAttributesArchive::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline double AnimationAttributesArchive::delay() const {
  return delay_;
}
inline void AnimationAttributesArchive::set_delay(double value) {
  set_has_delay();
  delay_ = value;
}

// optional bool isAutomatic = 6;
inline bool AnimationAttributesArchive::has_isautomatic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnimationAttributesArchive::set_has_isautomatic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnimationAttributesArchive::clear_has_isautomatic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnimationAttributesArchive::clear_isautomatic() {
  isautomatic_ = false;
  clear_has_isautomatic();
}
inline bool AnimationAttributesArchive::isautomatic() const {
  return isautomatic_;
}
inline void AnimationAttributesArchive::set_isautomatic(bool value) {
  set_has_isautomatic();
  isautomatic_ = value;
}

// optional .TSP.Color color = 7;
inline bool AnimationAttributesArchive::has_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnimationAttributesArchive::set_has_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnimationAttributesArchive::clear_has_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnimationAttributesArchive::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& AnimationAttributesArchive::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* AnimationAttributesArchive::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* AnimationAttributesArchive::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void AnimationAttributesArchive::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// -------------------------------------------------------------------

// TransitionAttributesArchive

// optional .KN.AnimationAttributesArchive animationAttributes = 8;
inline bool TransitionAttributesArchive::has_animationattributes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitionAttributesArchive::set_has_animationattributes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitionAttributesArchive::clear_has_animationattributes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitionAttributesArchive::clear_animationattributes() {
  if (animationattributes_ != NULL) animationattributes_->::KN::AnimationAttributesArchive::Clear();
  clear_has_animationattributes();
}
inline const ::KN::AnimationAttributesArchive& TransitionAttributesArchive::animationattributes() const {
  return animationattributes_ != NULL ? *animationattributes_ : *default_instance_->animationattributes_;
}
inline ::KN::AnimationAttributesArchive* TransitionAttributesArchive::mutable_animationattributes() {
  set_has_animationattributes();
  if (animationattributes_ == NULL) animationattributes_ = new ::KN::AnimationAttributesArchive;
  return animationattributes_;
}
inline ::KN::AnimationAttributesArchive* TransitionAttributesArchive::release_animationattributes() {
  clear_has_animationattributes();
  ::KN::AnimationAttributesArchive* temp = animationattributes_;
  animationattributes_ = NULL;
  return temp;
}
inline void TransitionAttributesArchive::set_allocated_animationattributes(::KN::AnimationAttributesArchive* animationattributes) {
  delete animationattributes_;
  animationattributes_ = animationattributes;
  if (animationattributes) {
    set_has_animationattributes();
  } else {
    clear_has_animationattributes();
  }
}

// optional bool isAutomatic = 6;
inline bool TransitionAttributesArchive::has_isautomatic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitionAttributesArchive::set_has_isautomatic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitionAttributesArchive::clear_has_isautomatic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitionAttributesArchive::clear_isautomatic() {
  isautomatic_ = false;
  clear_has_isautomatic();
}
inline bool TransitionAttributesArchive::isautomatic() const {
  return isautomatic_;
}
inline void TransitionAttributesArchive::set_isautomatic(bool value) {
  set_has_isautomatic();
  isautomatic_ = value;
}

// optional float custom_twist = 9;
inline bool TransitionAttributesArchive::has_custom_twist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_twist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitionAttributesArchive::clear_has_custom_twist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitionAttributesArchive::clear_custom_twist() {
  custom_twist_ = 0;
  clear_has_custom_twist();
}
inline float TransitionAttributesArchive::custom_twist() const {
  return custom_twist_;
}
inline void TransitionAttributesArchive::set_custom_twist(float value) {
  set_has_custom_twist();
  custom_twist_ = value;
}

// optional uint32 custom_mosaic_size = 10;
inline bool TransitionAttributesArchive::has_custom_mosaic_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_mosaic_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransitionAttributesArchive::clear_has_custom_mosaic_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransitionAttributesArchive::clear_custom_mosaic_size() {
  custom_mosaic_size_ = 0u;
  clear_has_custom_mosaic_size();
}
inline ::google::protobuf::uint32 TransitionAttributesArchive::custom_mosaic_size() const {
  return custom_mosaic_size_;
}
inline void TransitionAttributesArchive::set_custom_mosaic_size(::google::protobuf::uint32 value) {
  set_has_custom_mosaic_size();
  custom_mosaic_size_ = value;
}

// optional uint32 custom_mosaic_type = 11;
inline bool TransitionAttributesArchive::has_custom_mosaic_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_mosaic_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransitionAttributesArchive::clear_has_custom_mosaic_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransitionAttributesArchive::clear_custom_mosaic_type() {
  custom_mosaic_type_ = 0u;
  clear_has_custom_mosaic_type();
}
inline ::google::protobuf::uint32 TransitionAttributesArchive::custom_mosaic_type() const {
  return custom_mosaic_type_;
}
inline void TransitionAttributesArchive::set_custom_mosaic_type(::google::protobuf::uint32 value) {
  set_has_custom_mosaic_type();
  custom_mosaic_type_ = value;
}

// optional bool custom_bounce = 12;
inline bool TransitionAttributesArchive::has_custom_bounce() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_bounce() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransitionAttributesArchive::clear_has_custom_bounce() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransitionAttributesArchive::clear_custom_bounce() {
  custom_bounce_ = false;
  clear_has_custom_bounce();
}
inline bool TransitionAttributesArchive::custom_bounce() const {
  return custom_bounce_;
}
inline void TransitionAttributesArchive::set_custom_bounce(bool value) {
  set_has_custom_bounce();
  custom_bounce_ = value;
}

// optional bool custom_magic_move_fade_unmatched_objects = 13;
inline bool TransitionAttributesArchive::has_custom_magic_move_fade_unmatched_objects() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_magic_move_fade_unmatched_objects() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransitionAttributesArchive::clear_has_custom_magic_move_fade_unmatched_objects() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransitionAttributesArchive::clear_custom_magic_move_fade_unmatched_objects() {
  custom_magic_move_fade_unmatched_objects_ = false;
  clear_has_custom_magic_move_fade_unmatched_objects();
}
inline bool TransitionAttributesArchive::custom_magic_move_fade_unmatched_objects() const {
  return custom_magic_move_fade_unmatched_objects_;
}
inline void TransitionAttributesArchive::set_custom_magic_move_fade_unmatched_objects(bool value) {
  set_has_custom_magic_move_fade_unmatched_objects();
  custom_magic_move_fade_unmatched_objects_ = value;
}

// optional .KN.TransitionAttributesArchive.TransitionCustomAttributesTimingCurveType custom_timing_curve = 15;
inline bool TransitionAttributesArchive::has_custom_timing_curve() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_timing_curve() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransitionAttributesArchive::clear_has_custom_timing_curve() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransitionAttributesArchive::clear_custom_timing_curve() {
  custom_timing_curve_ = 1;
  clear_has_custom_timing_curve();
}
inline ::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType TransitionAttributesArchive::custom_timing_curve() const {
  return static_cast< ::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType >(custom_timing_curve_);
}
inline void TransitionAttributesArchive::set_custom_timing_curve(::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType value) {
  assert(::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_IsValid(value));
  set_has_custom_timing_curve();
  custom_timing_curve_ = value;
}

// optional .KN.TransitionAttributesArchive.TransitionCustomAttributesTextDeliveryType custom_text_delivery_type = 16;
inline bool TransitionAttributesArchive::has_custom_text_delivery_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransitionAttributesArchive::set_has_custom_text_delivery_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransitionAttributesArchive::clear_has_custom_text_delivery_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransitionAttributesArchive::clear_custom_text_delivery_type() {
  custom_text_delivery_type_ = 1;
  clear_has_custom_text_delivery_type();
}
inline ::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType TransitionAttributesArchive::custom_text_delivery_type() const {
  return static_cast< ::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType >(custom_text_delivery_type_);
}
inline void TransitionAttributesArchive::set_custom_text_delivery_type(::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType value) {
  assert(::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_IsValid(value));
  set_has_custom_text_delivery_type();
  custom_text_delivery_type_ = value;
}

// optional string database_animationType = 1;
inline bool TransitionAttributesArchive::has_database_animationtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TransitionAttributesArchive::set_has_database_animationtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TransitionAttributesArchive::clear_has_database_animationtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TransitionAttributesArchive::clear_database_animationtype() {
  if (database_animationtype_ != &::google::protobuf::internal::kEmptyString) {
    database_animationtype_->clear();
  }
  clear_has_database_animationtype();
}
inline const ::std::string& TransitionAttributesArchive::database_animationtype() const {
  return *database_animationtype_;
}
inline void TransitionAttributesArchive::set_database_animationtype(const ::std::string& value) {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  database_animationtype_->assign(value);
}
inline void TransitionAttributesArchive::set_database_animationtype(const char* value) {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  database_animationtype_->assign(value);
}
inline void TransitionAttributesArchive::set_database_animationtype(const char* value, size_t size) {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  database_animationtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitionAttributesArchive::mutable_database_animationtype() {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  return database_animationtype_;
}
inline ::std::string* TransitionAttributesArchive::release_database_animationtype() {
  clear_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = database_animationtype_;
    database_animationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitionAttributesArchive::set_allocated_database_animationtype(::std::string* database_animationtype) {
  if (database_animationtype_ != &::google::protobuf::internal::kEmptyString) {
    delete database_animationtype_;
  }
  if (database_animationtype) {
    set_has_database_animationtype();
    database_animationtype_ = database_animationtype;
  } else {
    clear_has_database_animationtype();
    database_animationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string database_effect = 2;
inline bool TransitionAttributesArchive::has_database_effect() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TransitionAttributesArchive::set_has_database_effect() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TransitionAttributesArchive::clear_has_database_effect() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TransitionAttributesArchive::clear_database_effect() {
  if (database_effect_ != &::google::protobuf::internal::kEmptyString) {
    database_effect_->clear();
  }
  clear_has_database_effect();
}
inline const ::std::string& TransitionAttributesArchive::database_effect() const {
  return *database_effect_;
}
inline void TransitionAttributesArchive::set_database_effect(const ::std::string& value) {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  database_effect_->assign(value);
}
inline void TransitionAttributesArchive::set_database_effect(const char* value) {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  database_effect_->assign(value);
}
inline void TransitionAttributesArchive::set_database_effect(const char* value, size_t size) {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  database_effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitionAttributesArchive::mutable_database_effect() {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  return database_effect_;
}
inline ::std::string* TransitionAttributesArchive::release_database_effect() {
  clear_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = database_effect_;
    database_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitionAttributesArchive::set_allocated_database_effect(::std::string* database_effect) {
  if (database_effect_ != &::google::protobuf::internal::kEmptyString) {
    delete database_effect_;
  }
  if (database_effect) {
    set_has_database_effect();
    database_effect_ = database_effect;
  } else {
    clear_has_database_effect();
    database_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double database_duration = 3;
inline bool TransitionAttributesArchive::has_database_duration() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TransitionAttributesArchive::set_has_database_duration() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TransitionAttributesArchive::clear_has_database_duration() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TransitionAttributesArchive::clear_database_duration() {
  database_duration_ = 0;
  clear_has_database_duration();
}
inline double TransitionAttributesArchive::database_duration() const {
  return database_duration_;
}
inline void TransitionAttributesArchive::set_database_duration(double value) {
  set_has_database_duration();
  database_duration_ = value;
}

// optional uint32 database_direction = 4;
inline bool TransitionAttributesArchive::has_database_direction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TransitionAttributesArchive::set_has_database_direction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TransitionAttributesArchive::clear_has_database_direction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TransitionAttributesArchive::clear_database_direction() {
  database_direction_ = 0u;
  clear_has_database_direction();
}
inline ::google::protobuf::uint32 TransitionAttributesArchive::database_direction() const {
  return database_direction_;
}
inline void TransitionAttributesArchive::set_database_direction(::google::protobuf::uint32 value) {
  set_has_database_direction();
  database_direction_ = value;
}

// optional float database_delay = 5;
inline bool TransitionAttributesArchive::has_database_delay() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TransitionAttributesArchive::set_has_database_delay() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TransitionAttributesArchive::clear_has_database_delay() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TransitionAttributesArchive::clear_database_delay() {
  database_delay_ = 0;
  clear_has_database_delay();
}
inline float TransitionAttributesArchive::database_delay() const {
  return database_delay_;
}
inline void TransitionAttributesArchive::set_database_delay(float value) {
  set_has_database_delay();
  database_delay_ = value;
}

// optional .TSP.Color database_color = 7;
inline bool TransitionAttributesArchive::has_database_color() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TransitionAttributesArchive::set_has_database_color() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TransitionAttributesArchive::clear_has_database_color() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TransitionAttributesArchive::clear_database_color() {
  if (database_color_ != NULL) database_color_->::TSP::Color::Clear();
  clear_has_database_color();
}
inline const ::TSP::Color& TransitionAttributesArchive::database_color() const {
  return database_color_ != NULL ? *database_color_ : *default_instance_->database_color_;
}
inline ::TSP::Color* TransitionAttributesArchive::mutable_database_color() {
  set_has_database_color();
  if (database_color_ == NULL) database_color_ = new ::TSP::Color;
  return database_color_;
}
inline ::TSP::Color* TransitionAttributesArchive::release_database_color() {
  clear_has_database_color();
  ::TSP::Color* temp = database_color_;
  database_color_ = NULL;
  return temp;
}
inline void TransitionAttributesArchive::set_allocated_database_color(::TSP::Color* database_color) {
  delete database_color_;
  database_color_ = database_color;
  if (database_color) {
    set_has_database_color();
  } else {
    clear_has_database_color();
  }
}

// -------------------------------------------------------------------

// TransitionArchive

// required .KN.TransitionAttributesArchive attributes = 2;
inline bool TransitionArchive::has_attributes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitionArchive::set_has_attributes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitionArchive::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitionArchive::clear_attributes() {
  if (attributes_ != NULL) attributes_->::KN::TransitionAttributesArchive::Clear();
  clear_has_attributes();
}
inline const ::KN::TransitionAttributesArchive& TransitionArchive::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::KN::TransitionAttributesArchive* TransitionArchive::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::KN::TransitionAttributesArchive;
  return attributes_;
}
inline ::KN::TransitionAttributesArchive* TransitionArchive::release_attributes() {
  clear_has_attributes();
  ::KN::TransitionAttributesArchive* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline void TransitionArchive::set_allocated_attributes(::KN::TransitionAttributesArchive* attributes) {
  delete attributes_;
  attributes_ = attributes;
  if (attributes) {
    set_has_attributes();
  } else {
    clear_has_attributes();
  }
}

// -------------------------------------------------------------------

// BuildChunkArchive

// required .TSP.Reference build = 1;
inline bool BuildChunkArchive::has_build() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildChunkArchive::set_has_build() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildChunkArchive::clear_has_build() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildChunkArchive::clear_build() {
  if (build_ != NULL) build_->::TSP::Reference::Clear();
  clear_has_build();
}
inline const ::TSP::Reference& BuildChunkArchive::build() const {
  return build_ != NULL ? *build_ : *default_instance_->build_;
}
inline ::TSP::Reference* BuildChunkArchive::mutable_build() {
  set_has_build();
  if (build_ == NULL) build_ = new ::TSP::Reference;
  return build_;
}
inline ::TSP::Reference* BuildChunkArchive::release_build() {
  clear_has_build();
  ::TSP::Reference* temp = build_;
  build_ = NULL;
  return temp;
}
inline void BuildChunkArchive::set_allocated_build(::TSP::Reference* build) {
  delete build_;
  build_ = build;
  if (build) {
    set_has_build();
  } else {
    clear_has_build();
  }
}

// required uint32 index = 2;
inline bool BuildChunkArchive::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildChunkArchive::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildChunkArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildChunkArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BuildChunkArchive::index() const {
  return index_;
}
inline void BuildChunkArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional double delay = 3;
inline bool BuildChunkArchive::has_delay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildChunkArchive::set_has_delay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildChunkArchive::clear_has_delay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildChunkArchive::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline double BuildChunkArchive::delay() const {
  return delay_;
}
inline void BuildChunkArchive::set_delay(double value) {
  set_has_delay();
  delay_ = value;
}

// optional double duration = 4;
inline bool BuildChunkArchive::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildChunkArchive::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildChunkArchive::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildChunkArchive::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double BuildChunkArchive::duration() const {
  return duration_;
}
inline void BuildChunkArchive::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional bool automatic = 5;
inline bool BuildChunkArchive::has_automatic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuildChunkArchive::set_has_automatic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuildChunkArchive::clear_has_automatic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuildChunkArchive::clear_automatic() {
  automatic_ = false;
  clear_has_automatic();
}
inline bool BuildChunkArchive::automatic() const {
  return automatic_;
}
inline void BuildChunkArchive::set_automatic(bool value) {
  set_has_automatic();
  automatic_ = value;
}

// optional bool referent = 6;
inline bool BuildChunkArchive::has_referent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuildChunkArchive::set_has_referent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuildChunkArchive::clear_has_referent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuildChunkArchive::clear_referent() {
  referent_ = false;
  clear_has_referent();
}
inline bool BuildChunkArchive::referent() const {
  return referent_;
}
inline void BuildChunkArchive::set_referent(bool value) {
  set_has_referent();
  referent_ = value;
}

// -------------------------------------------------------------------

// BuildAttributesArchive

// optional .KN.AnimationAttributesArchive animationAttributes = 18;
inline bool BuildAttributesArchive::has_animationattributes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildAttributesArchive::set_has_animationattributes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildAttributesArchive::clear_has_animationattributes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildAttributesArchive::clear_animationattributes() {
  if (animationattributes_ != NULL) animationattributes_->::KN::AnimationAttributesArchive::Clear();
  clear_has_animationattributes();
}
inline const ::KN::AnimationAttributesArchive& BuildAttributesArchive::animationattributes() const {
  return animationattributes_ != NULL ? *animationattributes_ : *default_instance_->animationattributes_;
}
inline ::KN::AnimationAttributesArchive* BuildAttributesArchive::mutable_animationattributes() {
  set_has_animationattributes();
  if (animationattributes_ == NULL) animationattributes_ = new ::KN::AnimationAttributesArchive;
  return animationattributes_;
}
inline ::KN::AnimationAttributesArchive* BuildAttributesArchive::release_animationattributes() {
  clear_has_animationattributes();
  ::KN::AnimationAttributesArchive* temp = animationattributes_;
  animationattributes_ = NULL;
  return temp;
}
inline void BuildAttributesArchive::set_allocated_animationattributes(::KN::AnimationAttributesArchive* animationattributes) {
  delete animationattributes_;
  animationattributes_ = animationattributes;
  if (animationattributes) {
    set_has_animationattributes();
  } else {
    clear_has_animationattributes();
  }
}

// optional uint32 eventTrigger = 4;
inline bool BuildAttributesArchive::has_eventtrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildAttributesArchive::set_has_eventtrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildAttributesArchive::clear_has_eventtrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildAttributesArchive::clear_eventtrigger() {
  eventtrigger_ = 0u;
  clear_has_eventtrigger();
}
inline ::google::protobuf::uint32 BuildAttributesArchive::eventtrigger() const {
  return eventtrigger_;
}
inline void BuildAttributesArchive::set_eventtrigger(::google::protobuf::uint32 value) {
  set_has_eventtrigger();
  eventtrigger_ = value;
}

// optional double delayAutomaticAfter = 6;
inline bool BuildAttributesArchive::has_delayautomaticafter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildAttributesArchive::set_has_delayautomaticafter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildAttributesArchive::clear_has_delayautomaticafter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildAttributesArchive::clear_delayautomaticafter() {
  delayautomaticafter_ = 0;
  clear_has_delayautomaticafter();
}
inline double BuildAttributesArchive::delayautomaticafter() const {
  return delayautomaticafter_;
}
inline void BuildAttributesArchive::set_delayautomaticafter(double value) {
  set_has_delayautomaticafter();
  delayautomaticafter_ = value;
}

// optional double delayAutomaticWith = 7;
inline bool BuildAttributesArchive::has_delayautomaticwith() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildAttributesArchive::set_has_delayautomaticwith() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildAttributesArchive::clear_has_delayautomaticwith() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildAttributesArchive::clear_delayautomaticwith() {
  delayautomaticwith_ = 0;
  clear_has_delayautomaticwith();
}
inline double BuildAttributesArchive::delayautomaticwith() const {
  return delayautomaticwith_;
}
inline void BuildAttributesArchive::set_delayautomaticwith(double value) {
  set_has_delayautomaticwith();
  delayautomaticwith_ = value;
}

// optional .KN.BuildAttributesArchive.BuildAttributesCurveStyle curveStyle = 14;
inline bool BuildAttributesArchive::has_curvestyle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuildAttributesArchive::set_has_curvestyle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuildAttributesArchive::clear_has_curvestyle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuildAttributesArchive::clear_curvestyle() {
  curvestyle_ = 0;
  clear_has_curvestyle();
}
inline ::KN::BuildAttributesArchive_BuildAttributesCurveStyle BuildAttributesArchive::curvestyle() const {
  return static_cast< ::KN::BuildAttributesArchive_BuildAttributesCurveStyle >(curvestyle_);
}
inline void BuildAttributesArchive::set_curvestyle(::KN::BuildAttributesArchive_BuildAttributesCurveStyle value) {
  assert(::KN::BuildAttributesArchive_BuildAttributesCurveStyle_IsValid(value));
  set_has_curvestyle();
  curvestyle_ = value;
}

// optional double ChartRotation3D = 17;
inline bool BuildAttributesArchive::has_chartrotation3d() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuildAttributesArchive::set_has_chartrotation3d() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuildAttributesArchive::clear_has_chartrotation3d() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuildAttributesArchive::clear_chartrotation3d() {
  chartrotation3d_ = 0;
  clear_has_chartrotation3d();
}
inline double BuildAttributesArchive::chartrotation3d() const {
  return chartrotation3d_;
}
inline void BuildAttributesArchive::set_chartrotation3d(double value) {
  set_has_chartrotation3d();
  chartrotation3d_ = value;
}

// optional uint32 startOffset = 27;
inline bool BuildAttributesArchive::has_startoffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuildAttributesArchive::set_has_startoffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuildAttributesArchive::clear_has_startoffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuildAttributesArchive::clear_startoffset() {
  startoffset_ = 0u;
  clear_has_startoffset();
}
inline ::google::protobuf::uint32 BuildAttributesArchive::startoffset() const {
  return startoffset_;
}
inline void BuildAttributesArchive::set_startoffset(::google::protobuf::uint32 value) {
  set_has_startoffset();
  startoffset_ = value;
}

// optional uint32 endOffset = 28;
inline bool BuildAttributesArchive::has_endoffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuildAttributesArchive::set_has_endoffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuildAttributesArchive::clear_has_endoffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuildAttributesArchive::clear_endoffset() {
  endoffset_ = 0u;
  clear_has_endoffset();
}
inline ::google::protobuf::uint32 BuildAttributesArchive::endoffset() const {
  return endoffset_;
}
inline void BuildAttributesArchive::set_endoffset(::google::protobuf::uint32 value) {
  set_has_endoffset();
  endoffset_ = value;
}

// optional double action_rotationAngle = 9;
inline bool BuildAttributesArchive::has_action_rotationangle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BuildAttributesArchive::set_has_action_rotationangle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BuildAttributesArchive::clear_has_action_rotationangle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BuildAttributesArchive::clear_action_rotationangle() {
  action_rotationangle_ = 0;
  clear_has_action_rotationangle();
}
inline double BuildAttributesArchive::action_rotationangle() const {
  return action_rotationangle_;
}
inline void BuildAttributesArchive::set_action_rotationangle(double value) {
  set_has_action_rotationangle();
  action_rotationangle_ = value;
}

// optional .KN.BuildAttributesArchive.BuildAttributesRotationDirection action_rotationDirection = 10;
inline bool BuildAttributesArchive::has_action_rotationdirection() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BuildAttributesArchive::set_has_action_rotationdirection() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BuildAttributesArchive::clear_has_action_rotationdirection() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BuildAttributesArchive::clear_action_rotationdirection() {
  action_rotationdirection_ = 31;
  clear_has_action_rotationdirection();
}
inline ::KN::BuildAttributesArchive_BuildAttributesRotationDirection BuildAttributesArchive::action_rotationdirection() const {
  return static_cast< ::KN::BuildAttributesArchive_BuildAttributesRotationDirection >(action_rotationdirection_);
}
inline void BuildAttributesArchive::set_action_rotationdirection(::KN::BuildAttributesArchive_BuildAttributesRotationDirection value) {
  assert(::KN::BuildAttributesArchive_BuildAttributesRotationDirection_IsValid(value));
  set_has_action_rotationdirection();
  action_rotationdirection_ = value;
}

// optional double action_scaleSize = 11;
inline bool BuildAttributesArchive::has_action_scalesize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BuildAttributesArchive::set_has_action_scalesize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BuildAttributesArchive::clear_has_action_scalesize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BuildAttributesArchive::clear_action_scalesize() {
  action_scalesize_ = 0;
  clear_has_action_scalesize();
}
inline double BuildAttributesArchive::action_scalesize() const {
  return action_scalesize_;
}
inline void BuildAttributesArchive::set_action_scalesize(double value) {
  set_has_action_scalesize();
  action_scalesize_ = value;
}

// optional double action_colorAlpha = 12;
inline bool BuildAttributesArchive::has_action_coloralpha() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BuildAttributesArchive::set_has_action_coloralpha() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BuildAttributesArchive::clear_has_action_coloralpha() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BuildAttributesArchive::clear_action_coloralpha() {
  action_coloralpha_ = 0;
  clear_has_action_coloralpha();
}
inline double BuildAttributesArchive::action_coloralpha() const {
  return action_coloralpha_;
}
inline void BuildAttributesArchive::set_action_coloralpha(double value) {
  set_has_action_coloralpha();
  action_coloralpha_ = value;
}

// optional .KN.BuildAttributesArchive.BuildAttributesAcceleration action_acceleration = 13;
inline bool BuildAttributesArchive::has_action_acceleration() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BuildAttributesArchive::set_has_action_acceleration() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BuildAttributesArchive::clear_has_action_acceleration() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BuildAttributesArchive::clear_action_acceleration() {
  action_acceleration_ = 0;
  clear_has_action_acceleration();
}
inline ::KN::BuildAttributesArchive_BuildAttributesAcceleration BuildAttributesArchive::action_acceleration() const {
  return static_cast< ::KN::BuildAttributesArchive_BuildAttributesAcceleration >(action_acceleration_);
}
inline void BuildAttributesArchive::set_action_acceleration(::KN::BuildAttributesArchive_BuildAttributesAcceleration value) {
  assert(::KN::BuildAttributesArchive_BuildAttributesAcceleration_IsValid(value));
  set_has_action_acceleration();
  action_acceleration_ = value;
}

// optional .TSD.PathSourceArchive action_motionPathSource = 22;
inline bool BuildAttributesArchive::has_action_motionpathsource() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BuildAttributesArchive::set_has_action_motionpathsource() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BuildAttributesArchive::clear_has_action_motionpathsource() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BuildAttributesArchive::clear_action_motionpathsource() {
  if (action_motionpathsource_ != NULL) action_motionpathsource_->::TSD::PathSourceArchive::Clear();
  clear_has_action_motionpathsource();
}
inline const ::TSD::PathSourceArchive& BuildAttributesArchive::action_motionpathsource() const {
  return action_motionpathsource_ != NULL ? *action_motionpathsource_ : *default_instance_->action_motionpathsource_;
}
inline ::TSD::PathSourceArchive* BuildAttributesArchive::mutable_action_motionpathsource() {
  set_has_action_motionpathsource();
  if (action_motionpathsource_ == NULL) action_motionpathsource_ = new ::TSD::PathSourceArchive;
  return action_motionpathsource_;
}
inline ::TSD::PathSourceArchive* BuildAttributesArchive::release_action_motionpathsource() {
  clear_has_action_motionpathsource();
  ::TSD::PathSourceArchive* temp = action_motionpathsource_;
  action_motionpathsource_ = NULL;
  return temp;
}
inline void BuildAttributesArchive::set_allocated_action_motionpathsource(::TSD::PathSourceArchive* action_motionpathsource) {
  delete action_motionpathsource_;
  action_motionpathsource_ = action_motionpathsource;
  if (action_motionpathsource) {
    set_has_action_motionpathsource();
  } else {
    clear_has_action_motionpathsource();
  }
}

// optional bool custom_bounce = 19;
inline bool BuildAttributesArchive::has_custom_bounce() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_bounce() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BuildAttributesArchive::clear_has_custom_bounce() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BuildAttributesArchive::clear_custom_bounce() {
  custom_bounce_ = false;
  clear_has_custom_bounce();
}
inline bool BuildAttributesArchive::custom_bounce() const {
  return custom_bounce_;
}
inline void BuildAttributesArchive::set_custom_bounce(bool value) {
  set_has_custom_bounce();
  custom_bounce_ = value;
}

// optional .KN.BuildAttributesArchive.BuildAttributesTextDelivery custom_textDelivery = 20;
inline bool BuildAttributesArchive::has_custom_textdelivery() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_textdelivery() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BuildAttributesArchive::clear_has_custom_textdelivery() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BuildAttributesArchive::clear_custom_textdelivery() {
  custom_textdelivery_ = 0;
  clear_has_custom_textdelivery();
}
inline ::KN::BuildAttributesArchive_BuildAttributesTextDelivery BuildAttributesArchive::custom_textdelivery() const {
  return static_cast< ::KN::BuildAttributesArchive_BuildAttributesTextDelivery >(custom_textdelivery_);
}
inline void BuildAttributesArchive::set_custom_textdelivery(::KN::BuildAttributesArchive_BuildAttributesTextDelivery value) {
  assert(::KN::BuildAttributesArchive_BuildAttributesTextDelivery_IsValid(value));
  set_has_custom_textdelivery();
  custom_textdelivery_ = value;
}

// optional .KN.BuildAttributesArchive.BuildAttributesDeliveryOption custom_deliveryOption = 21;
inline bool BuildAttributesArchive::has_custom_deliveryoption() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_deliveryoption() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BuildAttributesArchive::clear_has_custom_deliveryoption() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BuildAttributesArchive::clear_custom_deliveryoption() {
  custom_deliveryoption_ = 0;
  clear_has_custom_deliveryoption();
}
inline ::KN::BuildAttributesArchive_BuildAttributesDeliveryOption BuildAttributesArchive::custom_deliveryoption() const {
  return static_cast< ::KN::BuildAttributesArchive_BuildAttributesDeliveryOption >(custom_deliveryoption_);
}
inline void BuildAttributesArchive::set_custom_deliveryoption(::KN::BuildAttributesArchive_BuildAttributesDeliveryOption value) {
  assert(::KN::BuildAttributesArchive_BuildAttributesDeliveryOption_IsValid(value));
  set_has_custom_deliveryoption();
  custom_deliveryoption_ = value;
}

// optional bool custom_action_decay = 23;
inline bool BuildAttributesArchive::has_custom_action_decay() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_action_decay() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BuildAttributesArchive::clear_has_custom_action_decay() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BuildAttributesArchive::clear_custom_action_decay() {
  custom_action_decay_ = false;
  clear_has_custom_action_decay();
}
inline bool BuildAttributesArchive::custom_action_decay() const {
  return custom_action_decay_;
}
inline void BuildAttributesArchive::set_custom_action_decay(bool value) {
  set_has_custom_action_decay();
  custom_action_decay_ = value;
}

// optional uint32 custom_action_repeatCount = 24;
inline bool BuildAttributesArchive::has_custom_action_repeatcount() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_action_repeatcount() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BuildAttributesArchive::clear_has_custom_action_repeatcount() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BuildAttributesArchive::clear_custom_action_repeatcount() {
  custom_action_repeatcount_ = 0u;
  clear_has_custom_action_repeatcount();
}
inline ::google::protobuf::uint32 BuildAttributesArchive::custom_action_repeatcount() const {
  return custom_action_repeatcount_;
}
inline void BuildAttributesArchive::set_custom_action_repeatcount(::google::protobuf::uint32 value) {
  set_has_custom_action_repeatcount();
  custom_action_repeatcount_ = value;
}

// optional double custom_action_scale = 25;
inline bool BuildAttributesArchive::has_custom_action_scale() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_action_scale() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BuildAttributesArchive::clear_has_custom_action_scale() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BuildAttributesArchive::clear_custom_action_scale() {
  custom_action_scale_ = 0;
  clear_has_custom_action_scale();
}
inline double BuildAttributesArchive::custom_action_scale() const {
  return custom_action_scale_;
}
inline void BuildAttributesArchive::set_custom_action_scale(double value) {
  set_has_custom_action_scale();
  custom_action_scale_ = value;
}

// optional .KN.BuildAttributesArchive.ActionBuildAttributesJiggleIntensity custom_action_jiggleIntensity = 26;
inline bool BuildAttributesArchive::has_custom_action_jiggleintensity() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BuildAttributesArchive::set_has_custom_action_jiggleintensity() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BuildAttributesArchive::clear_has_custom_action_jiggleintensity() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BuildAttributesArchive::clear_custom_action_jiggleintensity() {
  custom_action_jiggleintensity_ = 0;
  clear_has_custom_action_jiggleintensity();
}
inline ::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity BuildAttributesArchive::custom_action_jiggleintensity() const {
  return static_cast< ::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity >(custom_action_jiggleintensity_);
}
inline void BuildAttributesArchive::set_custom_action_jiggleintensity(::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity value) {
  assert(::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_IsValid(value));
  set_has_custom_action_jiggleintensity();
  custom_action_jiggleintensity_ = value;
}

// optional string database_animationType = 1;
inline bool BuildAttributesArchive::has_database_animationtype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BuildAttributesArchive::set_has_database_animationtype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BuildAttributesArchive::clear_has_database_animationtype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BuildAttributesArchive::clear_database_animationtype() {
  if (database_animationtype_ != &::google::protobuf::internal::kEmptyString) {
    database_animationtype_->clear();
  }
  clear_has_database_animationtype();
}
inline const ::std::string& BuildAttributesArchive::database_animationtype() const {
  return *database_animationtype_;
}
inline void BuildAttributesArchive::set_database_animationtype(const ::std::string& value) {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  database_animationtype_->assign(value);
}
inline void BuildAttributesArchive::set_database_animationtype(const char* value) {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  database_animationtype_->assign(value);
}
inline void BuildAttributesArchive::set_database_animationtype(const char* value, size_t size) {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  database_animationtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildAttributesArchive::mutable_database_animationtype() {
  set_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    database_animationtype_ = new ::std::string;
  }
  return database_animationtype_;
}
inline ::std::string* BuildAttributesArchive::release_database_animationtype() {
  clear_has_database_animationtype();
  if (database_animationtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = database_animationtype_;
    database_animationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildAttributesArchive::set_allocated_database_animationtype(::std::string* database_animationtype) {
  if (database_animationtype_ != &::google::protobuf::internal::kEmptyString) {
    delete database_animationtype_;
  }
  if (database_animationtype) {
    set_has_database_animationtype();
    database_animationtype_ = database_animationtype;
  } else {
    clear_has_database_animationtype();
    database_animationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string database_effect = 2;
inline bool BuildAttributesArchive::has_database_effect() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BuildAttributesArchive::set_has_database_effect() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BuildAttributesArchive::clear_has_database_effect() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BuildAttributesArchive::clear_database_effect() {
  if (database_effect_ != &::google::protobuf::internal::kEmptyString) {
    database_effect_->clear();
  }
  clear_has_database_effect();
}
inline const ::std::string& BuildAttributesArchive::database_effect() const {
  return *database_effect_;
}
inline void BuildAttributesArchive::set_database_effect(const ::std::string& value) {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  database_effect_->assign(value);
}
inline void BuildAttributesArchive::set_database_effect(const char* value) {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  database_effect_->assign(value);
}
inline void BuildAttributesArchive::set_database_effect(const char* value, size_t size) {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  database_effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildAttributesArchive::mutable_database_effect() {
  set_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    database_effect_ = new ::std::string;
  }
  return database_effect_;
}
inline ::std::string* BuildAttributesArchive::release_database_effect() {
  clear_has_database_effect();
  if (database_effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = database_effect_;
    database_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildAttributesArchive::set_allocated_database_effect(::std::string* database_effect) {
  if (database_effect_ != &::google::protobuf::internal::kEmptyString) {
    delete database_effect_;
  }
  if (database_effect) {
    set_has_database_effect();
    database_effect_ = database_effect;
  } else {
    clear_has_database_effect();
    database_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 database_direction = 3;
inline bool BuildAttributesArchive::has_database_direction() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BuildAttributesArchive::set_has_database_direction() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BuildAttributesArchive::clear_has_database_direction() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BuildAttributesArchive::clear_database_direction() {
  database_direction_ = 0u;
  clear_has_database_direction();
}
inline ::google::protobuf::uint32 BuildAttributesArchive::database_direction() const {
  return database_direction_;
}
inline void BuildAttributesArchive::set_database_direction(::google::protobuf::uint32 value) {
  set_has_database_direction();
  database_direction_ = value;
}

// optional double database_delay = 5;
inline bool BuildAttributesArchive::has_database_delay() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BuildAttributesArchive::set_has_database_delay() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BuildAttributesArchive::clear_has_database_delay() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BuildAttributesArchive::clear_database_delay() {
  database_delay_ = 0;
  clear_has_database_delay();
}
inline double BuildAttributesArchive::database_delay() const {
  return database_delay_;
}
inline void BuildAttributesArchive::set_database_delay(double value) {
  set_has_database_delay();
  database_delay_ = value;
}

// optional double database_duration = 8;
inline bool BuildAttributesArchive::has_database_duration() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BuildAttributesArchive::set_has_database_duration() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BuildAttributesArchive::clear_has_database_duration() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BuildAttributesArchive::clear_database_duration() {
  database_duration_ = 0;
  clear_has_database_duration();
}
inline double BuildAttributesArchive::database_duration() const {
  return database_duration_;
}
inline void BuildAttributesArchive::set_database_duration(double value) {
  set_has_database_duration();
  database_duration_ = value;
}

// optional .TSP.Color database_color = 16;
inline bool BuildAttributesArchive::has_database_color() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BuildAttributesArchive::set_has_database_color() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BuildAttributesArchive::clear_has_database_color() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BuildAttributesArchive::clear_database_color() {
  if (database_color_ != NULL) database_color_->::TSP::Color::Clear();
  clear_has_database_color();
}
inline const ::TSP::Color& BuildAttributesArchive::database_color() const {
  return database_color_ != NULL ? *database_color_ : *default_instance_->database_color_;
}
inline ::TSP::Color* BuildAttributesArchive::mutable_database_color() {
  set_has_database_color();
  if (database_color_ == NULL) database_color_ = new ::TSP::Color;
  return database_color_;
}
inline ::TSP::Color* BuildAttributesArchive::release_database_color() {
  clear_has_database_color();
  ::TSP::Color* temp = database_color_;
  database_color_ = NULL;
  return temp;
}
inline void BuildAttributesArchive::set_allocated_database_color(::TSP::Color* database_color) {
  delete database_color_;
  database_color_ = database_color;
  if (database_color) {
    set_has_database_color();
  } else {
    clear_has_database_color();
  }
}

// optional string motionPathString = 15 [deprecated = true];
inline bool BuildAttributesArchive::has_motionpathstring() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BuildAttributesArchive::set_has_motionpathstring() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BuildAttributesArchive::clear_has_motionpathstring() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BuildAttributesArchive::clear_motionpathstring() {
  if (motionpathstring_ != &::google::protobuf::internal::kEmptyString) {
    motionpathstring_->clear();
  }
  clear_has_motionpathstring();
}
inline const ::std::string& BuildAttributesArchive::motionpathstring() const {
  return *motionpathstring_;
}
inline void BuildAttributesArchive::set_motionpathstring(const ::std::string& value) {
  set_has_motionpathstring();
  if (motionpathstring_ == &::google::protobuf::internal::kEmptyString) {
    motionpathstring_ = new ::std::string;
  }
  motionpathstring_->assign(value);
}
inline void BuildAttributesArchive::set_motionpathstring(const char* value) {
  set_has_motionpathstring();
  if (motionpathstring_ == &::google::protobuf::internal::kEmptyString) {
    motionpathstring_ = new ::std::string;
  }
  motionpathstring_->assign(value);
}
inline void BuildAttributesArchive::set_motionpathstring(const char* value, size_t size) {
  set_has_motionpathstring();
  if (motionpathstring_ == &::google::protobuf::internal::kEmptyString) {
    motionpathstring_ = new ::std::string;
  }
  motionpathstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildAttributesArchive::mutable_motionpathstring() {
  set_has_motionpathstring();
  if (motionpathstring_ == &::google::protobuf::internal::kEmptyString) {
    motionpathstring_ = new ::std::string;
  }
  return motionpathstring_;
}
inline ::std::string* BuildAttributesArchive::release_motionpathstring() {
  clear_has_motionpathstring();
  if (motionpathstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = motionpathstring_;
    motionpathstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildAttributesArchive::set_allocated_motionpathstring(::std::string* motionpathstring) {
  if (motionpathstring_ != &::google::protobuf::internal::kEmptyString) {
    delete motionpathstring_;
  }
  if (motionpathstring) {
    set_has_motionpathstring();
    motionpathstring_ = motionpathstring;
  } else {
    clear_has_motionpathstring();
    motionpathstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuildArchive

// required .TSP.Reference drawable = 1;
inline bool BuildArchive::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildArchive::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildArchive::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildArchive::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& BuildArchive::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* BuildArchive::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* BuildArchive::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void BuildArchive::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// required string delivery = 2;
inline bool BuildArchive::has_delivery() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildArchive::set_has_delivery() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildArchive::clear_has_delivery() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildArchive::clear_delivery() {
  if (delivery_ != &::google::protobuf::internal::kEmptyString) {
    delivery_->clear();
  }
  clear_has_delivery();
}
inline const ::std::string& BuildArchive::delivery() const {
  return *delivery_;
}
inline void BuildArchive::set_delivery(const ::std::string& value) {
  set_has_delivery();
  if (delivery_ == &::google::protobuf::internal::kEmptyString) {
    delivery_ = new ::std::string;
  }
  delivery_->assign(value);
}
inline void BuildArchive::set_delivery(const char* value) {
  set_has_delivery();
  if (delivery_ == &::google::protobuf::internal::kEmptyString) {
    delivery_ = new ::std::string;
  }
  delivery_->assign(value);
}
inline void BuildArchive::set_delivery(const char* value, size_t size) {
  set_has_delivery();
  if (delivery_ == &::google::protobuf::internal::kEmptyString) {
    delivery_ = new ::std::string;
  }
  delivery_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildArchive::mutable_delivery() {
  set_has_delivery();
  if (delivery_ == &::google::protobuf::internal::kEmptyString) {
    delivery_ = new ::std::string;
  }
  return delivery_;
}
inline ::std::string* BuildArchive::release_delivery() {
  clear_has_delivery();
  if (delivery_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = delivery_;
    delivery_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildArchive::set_allocated_delivery(::std::string* delivery) {
  if (delivery_ != &::google::protobuf::internal::kEmptyString) {
    delete delivery_;
  }
  if (delivery) {
    set_has_delivery();
    delivery_ = delivery;
  } else {
    clear_has_delivery();
    delivery_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double duration = 3;
inline bool BuildArchive::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildArchive::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildArchive::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildArchive::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double BuildArchive::duration() const {
  return duration_;
}
inline void BuildArchive::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// required .KN.BuildAttributesArchive attributes = 4;
inline bool BuildArchive::has_attributes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildArchive::set_has_attributes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildArchive::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildArchive::clear_attributes() {
  if (attributes_ != NULL) attributes_->::KN::BuildAttributesArchive::Clear();
  clear_has_attributes();
}
inline const ::KN::BuildAttributesArchive& BuildArchive::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::KN::BuildAttributesArchive* BuildArchive::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::KN::BuildAttributesArchive;
  return attributes_;
}
inline ::KN::BuildAttributesArchive* BuildArchive::release_attributes() {
  clear_has_attributes();
  ::KN::BuildAttributesArchive* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline void BuildArchive::set_allocated_attributes(::KN::BuildAttributesArchive* attributes) {
  delete attributes_;
  attributes_ = attributes;
  if (attributes) {
    set_has_attributes();
  } else {
    clear_has_attributes();
  }
}

// -------------------------------------------------------------------

// PlaceholderArchive

// required .TSWP.ShapeInfoArchive super = 1;
inline bool PlaceholderArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaceholderArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaceholderArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaceholderArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::ShapeInfoArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::ShapeInfoArchive& PlaceholderArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::ShapeInfoArchive* PlaceholderArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::ShapeInfoArchive;
  return super_;
}
inline ::TSWP::ShapeInfoArchive* PlaceholderArchive::release_super() {
  clear_has_super();
  ::TSWP::ShapeInfoArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PlaceholderArchive::set_allocated_super(::TSWP::ShapeInfoArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .KN.PlaceholderArchive.Kind kind = 2 [default = kKindPlaceholder];
inline bool PlaceholderArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlaceholderArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlaceholderArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlaceholderArchive::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::KN::PlaceholderArchive_Kind PlaceholderArchive::kind() const {
  return static_cast< ::KN::PlaceholderArchive_Kind >(kind_);
}
inline void PlaceholderArchive::set_kind(::KN::PlaceholderArchive_Kind value) {
  assert(::KN::PlaceholderArchive_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// NoteArchive

// required .TSP.Reference containedStorage = 1;
inline bool NoteArchive::has_containedstorage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NoteArchive::set_has_containedstorage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NoteArchive::clear_has_containedstorage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NoteArchive::clear_containedstorage() {
  if (containedstorage_ != NULL) containedstorage_->::TSP::Reference::Clear();
  clear_has_containedstorage();
}
inline const ::TSP::Reference& NoteArchive::containedstorage() const {
  return containedstorage_ != NULL ? *containedstorage_ : *default_instance_->containedstorage_;
}
inline ::TSP::Reference* NoteArchive::mutable_containedstorage() {
  set_has_containedstorage();
  if (containedstorage_ == NULL) containedstorage_ = new ::TSP::Reference;
  return containedstorage_;
}
inline ::TSP::Reference* NoteArchive::release_containedstorage() {
  clear_has_containedstorage();
  ::TSP::Reference* temp = containedstorage_;
  containedstorage_ = NULL;
  return temp;
}
inline void NoteArchive::set_allocated_containedstorage(::TSP::Reference* containedstorage) {
  delete containedstorage_;
  containedstorage_ = containedstorage;
  if (containedstorage) {
    set_has_containedstorage();
  } else {
    clear_has_containedstorage();
  }
}

// -------------------------------------------------------------------

// ClassicStylesheetRecordArchive

// repeated .TSS.StylesheetArchive.IdentifiedStyleEntry identifier_to_style_map = 1;
inline int ClassicStylesheetRecordArchive::identifier_to_style_map_size() const {
  return identifier_to_style_map_.size();
}
inline void ClassicStylesheetRecordArchive::clear_identifier_to_style_map() {
  identifier_to_style_map_.Clear();
}
inline const ::TSS::StylesheetArchive_IdentifiedStyleEntry& ClassicStylesheetRecordArchive::identifier_to_style_map(int index) const {
  return identifier_to_style_map_.Get(index);
}
inline ::TSS::StylesheetArchive_IdentifiedStyleEntry* ClassicStylesheetRecordArchive::mutable_identifier_to_style_map(int index) {
  return identifier_to_style_map_.Mutable(index);
}
inline ::TSS::StylesheetArchive_IdentifiedStyleEntry* ClassicStylesheetRecordArchive::add_identifier_to_style_map() {
  return identifier_to_style_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSS::StylesheetArchive_IdentifiedStyleEntry >&
ClassicStylesheetRecordArchive::identifier_to_style_map() const {
  return identifier_to_style_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSS::StylesheetArchive_IdentifiedStyleEntry >*
ClassicStylesheetRecordArchive::mutable_identifier_to_style_map() {
  return &identifier_to_style_map_;
}

// optional .TSP.Reference theme = 2;
inline bool ClassicStylesheetRecordArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClassicStylesheetRecordArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClassicStylesheetRecordArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClassicStylesheetRecordArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& ClassicStylesheetRecordArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* ClassicStylesheetRecordArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* ClassicStylesheetRecordArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void ClassicStylesheetRecordArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// -------------------------------------------------------------------

// ClassicThemeRecordArchive

// optional string uuid = 1;
inline bool ClassicThemeRecordArchive::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClassicThemeRecordArchive::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClassicThemeRecordArchive::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClassicThemeRecordArchive::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& ClassicThemeRecordArchive::uuid() const {
  return *uuid_;
}
inline void ClassicThemeRecordArchive::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void ClassicThemeRecordArchive::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void ClassicThemeRecordArchive::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClassicThemeRecordArchive::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* ClassicThemeRecordArchive::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClassicThemeRecordArchive::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference stylesheetRecord = 2;
inline bool ClassicThemeRecordArchive::has_stylesheetrecord() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClassicThemeRecordArchive::set_has_stylesheetrecord() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClassicThemeRecordArchive::clear_has_stylesheetrecord() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClassicThemeRecordArchive::clear_stylesheetrecord() {
  if (stylesheetrecord_ != NULL) stylesheetrecord_->::TSP::Reference::Clear();
  clear_has_stylesheetrecord();
}
inline const ::TSP::Reference& ClassicThemeRecordArchive::stylesheetrecord() const {
  return stylesheetrecord_ != NULL ? *stylesheetrecord_ : *default_instance_->stylesheetrecord_;
}
inline ::TSP::Reference* ClassicThemeRecordArchive::mutable_stylesheetrecord() {
  set_has_stylesheetrecord();
  if (stylesheetrecord_ == NULL) stylesheetrecord_ = new ::TSP::Reference;
  return stylesheetrecord_;
}
inline ::TSP::Reference* ClassicThemeRecordArchive::release_stylesheetrecord() {
  clear_has_stylesheetrecord();
  ::TSP::Reference* temp = stylesheetrecord_;
  stylesheetrecord_ = NULL;
  return temp;
}
inline void ClassicThemeRecordArchive::set_allocated_stylesheetrecord(::TSP::Reference* stylesheetrecord) {
  delete stylesheetrecord_;
  stylesheetrecord_ = stylesheetrecord;
  if (stylesheetrecord) {
    set_has_stylesheetrecord();
  } else {
    clear_has_stylesheetrecord();
  }
}

// repeated .TSP.Reference masters = 3;
inline int ClassicThemeRecordArchive::masters_size() const {
  return masters_.size();
}
inline void ClassicThemeRecordArchive::clear_masters() {
  masters_.Clear();
}
inline const ::TSP::Reference& ClassicThemeRecordArchive::masters(int index) const {
  return masters_.Get(index);
}
inline ::TSP::Reference* ClassicThemeRecordArchive::mutable_masters(int index) {
  return masters_.Mutable(index);
}
inline ::TSP::Reference* ClassicThemeRecordArchive::add_masters() {
  return masters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ClassicThemeRecordArchive::masters() const {
  return masters_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ClassicThemeRecordArchive::mutable_masters() {
  return &masters_;
}

// -------------------------------------------------------------------

// SlideArchive_SageTagMapEntry

// required string tag = 1;
inline bool SlideArchive_SageTagMapEntry::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideArchive_SageTagMapEntry::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideArchive_SageTagMapEntry::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideArchive_SageTagMapEntry::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& SlideArchive_SageTagMapEntry::tag() const {
  return *tag_;
}
inline void SlideArchive_SageTagMapEntry::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void SlideArchive_SageTagMapEntry::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void SlideArchive_SageTagMapEntry::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlideArchive_SageTagMapEntry::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* SlideArchive_SageTagMapEntry::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlideArchive_SageTagMapEntry::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSP.Reference info = 2;
inline bool SlideArchive_SageTagMapEntry::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideArchive_SageTagMapEntry::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideArchive_SageTagMapEntry::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideArchive_SageTagMapEntry::clear_info() {
  if (info_ != NULL) info_->::TSP::Reference::Clear();
  clear_has_info();
}
inline const ::TSP::Reference& SlideArchive_SageTagMapEntry::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::TSP::Reference* SlideArchive_SageTagMapEntry::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::TSP::Reference;
  return info_;
}
inline ::TSP::Reference* SlideArchive_SageTagMapEntry::release_info() {
  clear_has_info();
  ::TSP::Reference* temp = info_;
  info_ = NULL;
  return temp;
}
inline void SlideArchive_SageTagMapEntry::set_allocated_info(::TSP::Reference* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// SlideArchive

// required .TSP.Reference style = 1;
inline bool SlideArchive::has_style() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideArchive::set_has_style() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& SlideArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* SlideArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* SlideArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// repeated .TSP.Reference builds = 2;
inline int SlideArchive::builds_size() const {
  return builds_.size();
}
inline void SlideArchive::clear_builds() {
  builds_.Clear();
}
inline const ::TSP::Reference& SlideArchive::builds(int index) const {
  return builds_.Get(index);
}
inline ::TSP::Reference* SlideArchive::mutable_builds(int index) {
  return builds_.Mutable(index);
}
inline ::TSP::Reference* SlideArchive::add_builds() {
  return builds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideArchive::builds() const {
  return builds_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideArchive::mutable_builds() {
  return &builds_;
}

// repeated .KN.BuildChunkArchive buildChunks = 3;
inline int SlideArchive::buildchunks_size() const {
  return buildchunks_.size();
}
inline void SlideArchive::clear_buildchunks() {
  buildchunks_.Clear();
}
inline const ::KN::BuildChunkArchive& SlideArchive::buildchunks(int index) const {
  return buildchunks_.Get(index);
}
inline ::KN::BuildChunkArchive* SlideArchive::mutable_buildchunks(int index) {
  return buildchunks_.Mutable(index);
}
inline ::KN::BuildChunkArchive* SlideArchive::add_buildchunks() {
  return buildchunks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >&
SlideArchive::buildchunks() const {
  return buildchunks_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >*
SlideArchive::mutable_buildchunks() {
  return &buildchunks_;
}

// required .KN.TransitionArchive transition = 4;
inline bool SlideArchive::has_transition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlideArchive::set_has_transition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlideArchive::clear_has_transition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlideArchive::clear_transition() {
  if (transition_ != NULL) transition_->::KN::TransitionArchive::Clear();
  clear_has_transition();
}
inline const ::KN::TransitionArchive& SlideArchive::transition() const {
  return transition_ != NULL ? *transition_ : *default_instance_->transition_;
}
inline ::KN::TransitionArchive* SlideArchive::mutable_transition() {
  set_has_transition();
  if (transition_ == NULL) transition_ = new ::KN::TransitionArchive;
  return transition_;
}
inline ::KN::TransitionArchive* SlideArchive::release_transition() {
  clear_has_transition();
  ::KN::TransitionArchive* temp = transition_;
  transition_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_transition(::KN::TransitionArchive* transition) {
  delete transition_;
  transition_ = transition;
  if (transition) {
    set_has_transition();
  } else {
    clear_has_transition();
  }
}

// optional .TSP.Reference titlePlaceholder = 5;
inline bool SlideArchive::has_titleplaceholder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlideArchive::set_has_titleplaceholder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlideArchive::clear_has_titleplaceholder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlideArchive::clear_titleplaceholder() {
  if (titleplaceholder_ != NULL) titleplaceholder_->::TSP::Reference::Clear();
  clear_has_titleplaceholder();
}
inline const ::TSP::Reference& SlideArchive::titleplaceholder() const {
  return titleplaceholder_ != NULL ? *titleplaceholder_ : *default_instance_->titleplaceholder_;
}
inline ::TSP::Reference* SlideArchive::mutable_titleplaceholder() {
  set_has_titleplaceholder();
  if (titleplaceholder_ == NULL) titleplaceholder_ = new ::TSP::Reference;
  return titleplaceholder_;
}
inline ::TSP::Reference* SlideArchive::release_titleplaceholder() {
  clear_has_titleplaceholder();
  ::TSP::Reference* temp = titleplaceholder_;
  titleplaceholder_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_titleplaceholder(::TSP::Reference* titleplaceholder) {
  delete titleplaceholder_;
  titleplaceholder_ = titleplaceholder;
  if (titleplaceholder) {
    set_has_titleplaceholder();
  } else {
    clear_has_titleplaceholder();
  }
}

// optional .TSP.Reference bodyPlaceholder = 6;
inline bool SlideArchive::has_bodyplaceholder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlideArchive::set_has_bodyplaceholder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlideArchive::clear_has_bodyplaceholder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlideArchive::clear_bodyplaceholder() {
  if (bodyplaceholder_ != NULL) bodyplaceholder_->::TSP::Reference::Clear();
  clear_has_bodyplaceholder();
}
inline const ::TSP::Reference& SlideArchive::bodyplaceholder() const {
  return bodyplaceholder_ != NULL ? *bodyplaceholder_ : *default_instance_->bodyplaceholder_;
}
inline ::TSP::Reference* SlideArchive::mutable_bodyplaceholder() {
  set_has_bodyplaceholder();
  if (bodyplaceholder_ == NULL) bodyplaceholder_ = new ::TSP::Reference;
  return bodyplaceholder_;
}
inline ::TSP::Reference* SlideArchive::release_bodyplaceholder() {
  clear_has_bodyplaceholder();
  ::TSP::Reference* temp = bodyplaceholder_;
  bodyplaceholder_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_bodyplaceholder(::TSP::Reference* bodyplaceholder) {
  delete bodyplaceholder_;
  bodyplaceholder_ = bodyplaceholder;
  if (bodyplaceholder) {
    set_has_bodyplaceholder();
  } else {
    clear_has_bodyplaceholder();
  }
}

// optional .TSP.Reference objectPlaceholder = 30;
inline bool SlideArchive::has_objectplaceholder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlideArchive::set_has_objectplaceholder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlideArchive::clear_has_objectplaceholder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlideArchive::clear_objectplaceholder() {
  if (objectplaceholder_ != NULL) objectplaceholder_->::TSP::Reference::Clear();
  clear_has_objectplaceholder();
}
inline const ::TSP::Reference& SlideArchive::objectplaceholder() const {
  return objectplaceholder_ != NULL ? *objectplaceholder_ : *default_instance_->objectplaceholder_;
}
inline ::TSP::Reference* SlideArchive::mutable_objectplaceholder() {
  set_has_objectplaceholder();
  if (objectplaceholder_ == NULL) objectplaceholder_ = new ::TSP::Reference;
  return objectplaceholder_;
}
inline ::TSP::Reference* SlideArchive::release_objectplaceholder() {
  clear_has_objectplaceholder();
  ::TSP::Reference* temp = objectplaceholder_;
  objectplaceholder_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_objectplaceholder(::TSP::Reference* objectplaceholder) {
  delete objectplaceholder_;
  objectplaceholder_ = objectplaceholder;
  if (objectplaceholder) {
    set_has_objectplaceholder();
  } else {
    clear_has_objectplaceholder();
  }
}

// optional .TSP.Reference slideNumberPlaceholder = 20;
inline bool SlideArchive::has_slidenumberplaceholder() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlideArchive::set_has_slidenumberplaceholder() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlideArchive::clear_has_slidenumberplaceholder() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlideArchive::clear_slidenumberplaceholder() {
  if (slidenumberplaceholder_ != NULL) slidenumberplaceholder_->::TSP::Reference::Clear();
  clear_has_slidenumberplaceholder();
}
inline const ::TSP::Reference& SlideArchive::slidenumberplaceholder() const {
  return slidenumberplaceholder_ != NULL ? *slidenumberplaceholder_ : *default_instance_->slidenumberplaceholder_;
}
inline ::TSP::Reference* SlideArchive::mutable_slidenumberplaceholder() {
  set_has_slidenumberplaceholder();
  if (slidenumberplaceholder_ == NULL) slidenumberplaceholder_ = new ::TSP::Reference;
  return slidenumberplaceholder_;
}
inline ::TSP::Reference* SlideArchive::release_slidenumberplaceholder() {
  clear_has_slidenumberplaceholder();
  ::TSP::Reference* temp = slidenumberplaceholder_;
  slidenumberplaceholder_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_slidenumberplaceholder(::TSP::Reference* slidenumberplaceholder) {
  delete slidenumberplaceholder_;
  slidenumberplaceholder_ = slidenumberplaceholder;
  if (slidenumberplaceholder) {
    set_has_slidenumberplaceholder();
  } else {
    clear_has_slidenumberplaceholder();
  }
}

// repeated .TSP.Reference drawables = 7;
inline int SlideArchive::drawables_size() const {
  return drawables_.size();
}
inline void SlideArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& SlideArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* SlideArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* SlideArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideArchive::mutable_drawables() {
  return &drawables_;
}

// repeated .KN.SlideArchive.SageTagMapEntry sage_tag_to_info_map = 28;
inline int SlideArchive::sage_tag_to_info_map_size() const {
  return sage_tag_to_info_map_.size();
}
inline void SlideArchive::clear_sage_tag_to_info_map() {
  sage_tag_to_info_map_.Clear();
}
inline const ::KN::SlideArchive_SageTagMapEntry& SlideArchive::sage_tag_to_info_map(int index) const {
  return sage_tag_to_info_map_.Get(index);
}
inline ::KN::SlideArchive_SageTagMapEntry* SlideArchive::mutable_sage_tag_to_info_map(int index) {
  return sage_tag_to_info_map_.Mutable(index);
}
inline ::KN::SlideArchive_SageTagMapEntry* SlideArchive::add_sage_tag_to_info_map() {
  return sage_tag_to_info_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::SlideArchive_SageTagMapEntry >&
SlideArchive::sage_tag_to_info_map() const {
  return sage_tag_to_info_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::SlideArchive_SageTagMapEntry >*
SlideArchive::mutable_sage_tag_to_info_map() {
  return &sage_tag_to_info_map_;
}

// optional string name = 10;
inline bool SlideArchive::has_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SlideArchive::set_has_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SlideArchive::clear_has_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SlideArchive::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SlideArchive::name() const {
  return *name_;
}
inline void SlideArchive::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SlideArchive::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SlideArchive::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlideArchive::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SlideArchive::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlideArchive::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSD.GeometryArchive titlePlaceholderGeometry = 11;
inline bool SlideArchive::has_titleplaceholdergeometry() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SlideArchive::set_has_titleplaceholdergeometry() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SlideArchive::clear_has_titleplaceholdergeometry() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SlideArchive::clear_titleplaceholdergeometry() {
  if (titleplaceholdergeometry_ != NULL) titleplaceholdergeometry_->::TSD::GeometryArchive::Clear();
  clear_has_titleplaceholdergeometry();
}
inline const ::TSD::GeometryArchive& SlideArchive::titleplaceholdergeometry() const {
  return titleplaceholdergeometry_ != NULL ? *titleplaceholdergeometry_ : *default_instance_->titleplaceholdergeometry_;
}
inline ::TSD::GeometryArchive* SlideArchive::mutable_titleplaceholdergeometry() {
  set_has_titleplaceholdergeometry();
  if (titleplaceholdergeometry_ == NULL) titleplaceholdergeometry_ = new ::TSD::GeometryArchive;
  return titleplaceholdergeometry_;
}
inline ::TSD::GeometryArchive* SlideArchive::release_titleplaceholdergeometry() {
  clear_has_titleplaceholdergeometry();
  ::TSD::GeometryArchive* temp = titleplaceholdergeometry_;
  titleplaceholdergeometry_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_titleplaceholdergeometry(::TSD::GeometryArchive* titleplaceholdergeometry) {
  delete titleplaceholdergeometry_;
  titleplaceholdergeometry_ = titleplaceholdergeometry;
  if (titleplaceholdergeometry) {
    set_has_titleplaceholdergeometry();
  } else {
    clear_has_titleplaceholdergeometry();
  }
}

// optional uint32 titlePlaceholderShapeStyleIndex = 12;
inline bool SlideArchive::has_titleplaceholdershapestyleindex() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SlideArchive::set_has_titleplaceholdershapestyleindex() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SlideArchive::clear_has_titleplaceholdershapestyleindex() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SlideArchive::clear_titleplaceholdershapestyleindex() {
  titleplaceholdershapestyleindex_ = 0u;
  clear_has_titleplaceholdershapestyleindex();
}
inline ::google::protobuf::uint32 SlideArchive::titleplaceholdershapestyleindex() const {
  return titleplaceholdershapestyleindex_;
}
inline void SlideArchive::set_titleplaceholdershapestyleindex(::google::protobuf::uint32 value) {
  set_has_titleplaceholdershapestyleindex();
  titleplaceholdershapestyleindex_ = value;
}

// optional uint32 titlePlaceholderTextStyleIndex = 13;
inline bool SlideArchive::has_titleplaceholdertextstyleindex() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SlideArchive::set_has_titleplaceholdertextstyleindex() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SlideArchive::clear_has_titleplaceholdertextstyleindex() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SlideArchive::clear_titleplaceholdertextstyleindex() {
  titleplaceholdertextstyleindex_ = 0u;
  clear_has_titleplaceholdertextstyleindex();
}
inline ::google::protobuf::uint32 SlideArchive::titleplaceholdertextstyleindex() const {
  return titleplaceholdertextstyleindex_;
}
inline void SlideArchive::set_titleplaceholdertextstyleindex(::google::protobuf::uint32 value) {
  set_has_titleplaceholdertextstyleindex();
  titleplaceholdertextstyleindex_ = value;
}

// optional .TSWP.ShapeStylePropertiesArchive titleLayoutProperties = 24;
inline bool SlideArchive::has_titlelayoutproperties() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SlideArchive::set_has_titlelayoutproperties() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SlideArchive::clear_has_titlelayoutproperties() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SlideArchive::clear_titlelayoutproperties() {
  if (titlelayoutproperties_ != NULL) titlelayoutproperties_->::TSWP::ShapeStylePropertiesArchive::Clear();
  clear_has_titlelayoutproperties();
}
inline const ::TSWP::ShapeStylePropertiesArchive& SlideArchive::titlelayoutproperties() const {
  return titlelayoutproperties_ != NULL ? *titlelayoutproperties_ : *default_instance_->titlelayoutproperties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* SlideArchive::mutable_titlelayoutproperties() {
  set_has_titlelayoutproperties();
  if (titlelayoutproperties_ == NULL) titlelayoutproperties_ = new ::TSWP::ShapeStylePropertiesArchive;
  return titlelayoutproperties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* SlideArchive::release_titlelayoutproperties() {
  clear_has_titlelayoutproperties();
  ::TSWP::ShapeStylePropertiesArchive* temp = titlelayoutproperties_;
  titlelayoutproperties_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_titlelayoutproperties(::TSWP::ShapeStylePropertiesArchive* titlelayoutproperties) {
  delete titlelayoutproperties_;
  titlelayoutproperties_ = titlelayoutproperties;
  if (titlelayoutproperties) {
    set_has_titlelayoutproperties();
  } else {
    clear_has_titlelayoutproperties();
  }
}

// optional .TSD.GeometryArchive bodyPlaceholderGeometry = 14;
inline bool SlideArchive::has_bodyplaceholdergeometry() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SlideArchive::set_has_bodyplaceholdergeometry() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SlideArchive::clear_has_bodyplaceholdergeometry() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SlideArchive::clear_bodyplaceholdergeometry() {
  if (bodyplaceholdergeometry_ != NULL) bodyplaceholdergeometry_->::TSD::GeometryArchive::Clear();
  clear_has_bodyplaceholdergeometry();
}
inline const ::TSD::GeometryArchive& SlideArchive::bodyplaceholdergeometry() const {
  return bodyplaceholdergeometry_ != NULL ? *bodyplaceholdergeometry_ : *default_instance_->bodyplaceholdergeometry_;
}
inline ::TSD::GeometryArchive* SlideArchive::mutable_bodyplaceholdergeometry() {
  set_has_bodyplaceholdergeometry();
  if (bodyplaceholdergeometry_ == NULL) bodyplaceholdergeometry_ = new ::TSD::GeometryArchive;
  return bodyplaceholdergeometry_;
}
inline ::TSD::GeometryArchive* SlideArchive::release_bodyplaceholdergeometry() {
  clear_has_bodyplaceholdergeometry();
  ::TSD::GeometryArchive* temp = bodyplaceholdergeometry_;
  bodyplaceholdergeometry_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_bodyplaceholdergeometry(::TSD::GeometryArchive* bodyplaceholdergeometry) {
  delete bodyplaceholdergeometry_;
  bodyplaceholdergeometry_ = bodyplaceholdergeometry;
  if (bodyplaceholdergeometry) {
    set_has_bodyplaceholdergeometry();
  } else {
    clear_has_bodyplaceholdergeometry();
  }
}

// optional uint32 bodyPlaceholderShapeStyleIndex = 15;
inline bool SlideArchive::has_bodyplaceholdershapestyleindex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SlideArchive::set_has_bodyplaceholdershapestyleindex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SlideArchive::clear_has_bodyplaceholdershapestyleindex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SlideArchive::clear_bodyplaceholdershapestyleindex() {
  bodyplaceholdershapestyleindex_ = 0u;
  clear_has_bodyplaceholdershapestyleindex();
}
inline ::google::protobuf::uint32 SlideArchive::bodyplaceholdershapestyleindex() const {
  return bodyplaceholdershapestyleindex_;
}
inline void SlideArchive::set_bodyplaceholdershapestyleindex(::google::protobuf::uint32 value) {
  set_has_bodyplaceholdershapestyleindex();
  bodyplaceholdershapestyleindex_ = value;
}

// optional uint32 bodyPlaceholderTextStyleIndex = 16;
inline bool SlideArchive::has_bodyplaceholdertextstyleindex() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SlideArchive::set_has_bodyplaceholdertextstyleindex() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SlideArchive::clear_has_bodyplaceholdertextstyleindex() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SlideArchive::clear_bodyplaceholdertextstyleindex() {
  bodyplaceholdertextstyleindex_ = 0u;
  clear_has_bodyplaceholdertextstyleindex();
}
inline ::google::protobuf::uint32 SlideArchive::bodyplaceholdertextstyleindex() const {
  return bodyplaceholdertextstyleindex_;
}
inline void SlideArchive::set_bodyplaceholdertextstyleindex(::google::protobuf::uint32 value) {
  set_has_bodyplaceholdertextstyleindex();
  bodyplaceholdertextstyleindex_ = value;
}

// optional .TSWP.ShapeStylePropertiesArchive bodyLayoutProperties = 25;
inline bool SlideArchive::has_bodylayoutproperties() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SlideArchive::set_has_bodylayoutproperties() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SlideArchive::clear_has_bodylayoutproperties() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SlideArchive::clear_bodylayoutproperties() {
  if (bodylayoutproperties_ != NULL) bodylayoutproperties_->::TSWP::ShapeStylePropertiesArchive::Clear();
  clear_has_bodylayoutproperties();
}
inline const ::TSWP::ShapeStylePropertiesArchive& SlideArchive::bodylayoutproperties() const {
  return bodylayoutproperties_ != NULL ? *bodylayoutproperties_ : *default_instance_->bodylayoutproperties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* SlideArchive::mutable_bodylayoutproperties() {
  set_has_bodylayoutproperties();
  if (bodylayoutproperties_ == NULL) bodylayoutproperties_ = new ::TSWP::ShapeStylePropertiesArchive;
  return bodylayoutproperties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* SlideArchive::release_bodylayoutproperties() {
  clear_has_bodylayoutproperties();
  ::TSWP::ShapeStylePropertiesArchive* temp = bodylayoutproperties_;
  bodylayoutproperties_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_bodylayoutproperties(::TSWP::ShapeStylePropertiesArchive* bodylayoutproperties) {
  delete bodylayoutproperties_;
  bodylayoutproperties_ = bodylayoutproperties;
  if (bodylayoutproperties) {
    set_has_bodylayoutproperties();
  } else {
    clear_has_bodylayoutproperties();
  }
}

// optional .TSD.GeometryArchive slideNumberPlaceholderGeometry = 21;
inline bool SlideArchive::has_slidenumberplaceholdergeometry() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SlideArchive::set_has_slidenumberplaceholdergeometry() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SlideArchive::clear_has_slidenumberplaceholdergeometry() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SlideArchive::clear_slidenumberplaceholdergeometry() {
  if (slidenumberplaceholdergeometry_ != NULL) slidenumberplaceholdergeometry_->::TSD::GeometryArchive::Clear();
  clear_has_slidenumberplaceholdergeometry();
}
inline const ::TSD::GeometryArchive& SlideArchive::slidenumberplaceholdergeometry() const {
  return slidenumberplaceholdergeometry_ != NULL ? *slidenumberplaceholdergeometry_ : *default_instance_->slidenumberplaceholdergeometry_;
}
inline ::TSD::GeometryArchive* SlideArchive::mutable_slidenumberplaceholdergeometry() {
  set_has_slidenumberplaceholdergeometry();
  if (slidenumberplaceholdergeometry_ == NULL) slidenumberplaceholdergeometry_ = new ::TSD::GeometryArchive;
  return slidenumberplaceholdergeometry_;
}
inline ::TSD::GeometryArchive* SlideArchive::release_slidenumberplaceholdergeometry() {
  clear_has_slidenumberplaceholdergeometry();
  ::TSD::GeometryArchive* temp = slidenumberplaceholdergeometry_;
  slidenumberplaceholdergeometry_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_slidenumberplaceholdergeometry(::TSD::GeometryArchive* slidenumberplaceholdergeometry) {
  delete slidenumberplaceholdergeometry_;
  slidenumberplaceholdergeometry_ = slidenumberplaceholdergeometry;
  if (slidenumberplaceholdergeometry) {
    set_has_slidenumberplaceholdergeometry();
  } else {
    clear_has_slidenumberplaceholdergeometry();
  }
}

// optional uint32 slideNumberPlaceholderShapeStyleIndex = 22;
inline bool SlideArchive::has_slidenumberplaceholdershapestyleindex() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SlideArchive::set_has_slidenumberplaceholdershapestyleindex() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SlideArchive::clear_has_slidenumberplaceholdershapestyleindex() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SlideArchive::clear_slidenumberplaceholdershapestyleindex() {
  slidenumberplaceholdershapestyleindex_ = 0u;
  clear_has_slidenumberplaceholdershapestyleindex();
}
inline ::google::protobuf::uint32 SlideArchive::slidenumberplaceholdershapestyleindex() const {
  return slidenumberplaceholdershapestyleindex_;
}
inline void SlideArchive::set_slidenumberplaceholdershapestyleindex(::google::protobuf::uint32 value) {
  set_has_slidenumberplaceholdershapestyleindex();
  slidenumberplaceholdershapestyleindex_ = value;
}

// optional uint32 slideNumberPlaceholderTextStyleIndex = 23;
inline bool SlideArchive::has_slidenumberplaceholdertextstyleindex() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SlideArchive::set_has_slidenumberplaceholdertextstyleindex() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SlideArchive::clear_has_slidenumberplaceholdertextstyleindex() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SlideArchive::clear_slidenumberplaceholdertextstyleindex() {
  slidenumberplaceholdertextstyleindex_ = 0u;
  clear_has_slidenumberplaceholdertextstyleindex();
}
inline ::google::protobuf::uint32 SlideArchive::slidenumberplaceholdertextstyleindex() const {
  return slidenumberplaceholdertextstyleindex_;
}
inline void SlideArchive::set_slidenumberplaceholdertextstyleindex(::google::protobuf::uint32 value) {
  set_has_slidenumberplaceholdertextstyleindex();
  slidenumberplaceholdertextstyleindex_ = value;
}

// optional .TSWP.ShapeStylePropertiesArchive slideNumberLayoutProperties = 26;
inline bool SlideArchive::has_slidenumberlayoutproperties() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SlideArchive::set_has_slidenumberlayoutproperties() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SlideArchive::clear_has_slidenumberlayoutproperties() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SlideArchive::clear_slidenumberlayoutproperties() {
  if (slidenumberlayoutproperties_ != NULL) slidenumberlayoutproperties_->::TSWP::ShapeStylePropertiesArchive::Clear();
  clear_has_slidenumberlayoutproperties();
}
inline const ::TSWP::ShapeStylePropertiesArchive& SlideArchive::slidenumberlayoutproperties() const {
  return slidenumberlayoutproperties_ != NULL ? *slidenumberlayoutproperties_ : *default_instance_->slidenumberlayoutproperties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* SlideArchive::mutable_slidenumberlayoutproperties() {
  set_has_slidenumberlayoutproperties();
  if (slidenumberlayoutproperties_ == NULL) slidenumberlayoutproperties_ = new ::TSWP::ShapeStylePropertiesArchive;
  return slidenumberlayoutproperties_;
}
inline ::TSWP::ShapeStylePropertiesArchive* SlideArchive::release_slidenumberlayoutproperties() {
  clear_has_slidenumberlayoutproperties();
  ::TSWP::ShapeStylePropertiesArchive* temp = slidenumberlayoutproperties_;
  slidenumberlayoutproperties_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_slidenumberlayoutproperties(::TSWP::ShapeStylePropertiesArchive* slidenumberlayoutproperties) {
  delete slidenumberlayoutproperties_;
  slidenumberlayoutproperties_ = slidenumberlayoutproperties;
  if (slidenumberlayoutproperties) {
    set_has_slidenumberlayoutproperties();
  } else {
    clear_has_slidenumberlayoutproperties();
  }
}

// optional .TSP.Reference classicStylesheetRecord = 29;
inline bool SlideArchive::has_classicstylesheetrecord() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SlideArchive::set_has_classicstylesheetrecord() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SlideArchive::clear_has_classicstylesheetrecord() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SlideArchive::clear_classicstylesheetrecord() {
  if (classicstylesheetrecord_ != NULL) classicstylesheetrecord_->::TSP::Reference::Clear();
  clear_has_classicstylesheetrecord();
}
inline const ::TSP::Reference& SlideArchive::classicstylesheetrecord() const {
  return classicstylesheetrecord_ != NULL ? *classicstylesheetrecord_ : *default_instance_->classicstylesheetrecord_;
}
inline ::TSP::Reference* SlideArchive::mutable_classicstylesheetrecord() {
  set_has_classicstylesheetrecord();
  if (classicstylesheetrecord_ == NULL) classicstylesheetrecord_ = new ::TSP::Reference;
  return classicstylesheetrecord_;
}
inline ::TSP::Reference* SlideArchive::release_classicstylesheetrecord() {
  clear_has_classicstylesheetrecord();
  ::TSP::Reference* temp = classicstylesheetrecord_;
  classicstylesheetrecord_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_classicstylesheetrecord(::TSP::Reference* classicstylesheetrecord) {
  delete classicstylesheetrecord_;
  classicstylesheetrecord_ = classicstylesheetrecord;
  if (classicstylesheetrecord) {
    set_has_classicstylesheetrecord();
  } else {
    clear_has_classicstylesheetrecord();
  }
}

// repeated .TSP.Reference bodyParagraphStyles = 31;
inline int SlideArchive::bodyparagraphstyles_size() const {
  return bodyparagraphstyles_.size();
}
inline void SlideArchive::clear_bodyparagraphstyles() {
  bodyparagraphstyles_.Clear();
}
inline const ::TSP::Reference& SlideArchive::bodyparagraphstyles(int index) const {
  return bodyparagraphstyles_.Get(index);
}
inline ::TSP::Reference* SlideArchive::mutable_bodyparagraphstyles(int index) {
  return bodyparagraphstyles_.Mutable(index);
}
inline ::TSP::Reference* SlideArchive::add_bodyparagraphstyles() {
  return bodyparagraphstyles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideArchive::bodyparagraphstyles() const {
  return bodyparagraphstyles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideArchive::mutable_bodyparagraphstyles() {
  return &bodyparagraphstyles_;
}

// repeated .TSP.Reference bodyListStyles = 35;
inline int SlideArchive::bodyliststyles_size() const {
  return bodyliststyles_.size();
}
inline void SlideArchive::clear_bodyliststyles() {
  bodyliststyles_.Clear();
}
inline const ::TSP::Reference& SlideArchive::bodyliststyles(int index) const {
  return bodyliststyles_.Get(index);
}
inline ::TSP::Reference* SlideArchive::mutable_bodyliststyles(int index) {
  return bodyliststyles_.Mutable(index);
}
inline ::TSP::Reference* SlideArchive::add_bodyliststyles() {
  return bodyliststyles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideArchive::bodyliststyles() const {
  return bodyliststyles_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideArchive::mutable_bodyliststyles() {
  return &bodyliststyles_;
}

// optional string thumbnailTextForTitlePlaceholder = 37;
inline bool SlideArchive::has_thumbnailtextfortitleplaceholder() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SlideArchive::set_has_thumbnailtextfortitleplaceholder() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SlideArchive::clear_has_thumbnailtextfortitleplaceholder() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SlideArchive::clear_thumbnailtextfortitleplaceholder() {
  if (thumbnailtextfortitleplaceholder_ != &::google::protobuf::internal::kEmptyString) {
    thumbnailtextfortitleplaceholder_->clear();
  }
  clear_has_thumbnailtextfortitleplaceholder();
}
inline const ::std::string& SlideArchive::thumbnailtextfortitleplaceholder() const {
  return *thumbnailtextfortitleplaceholder_;
}
inline void SlideArchive::set_thumbnailtextfortitleplaceholder(const ::std::string& value) {
  set_has_thumbnailtextfortitleplaceholder();
  if (thumbnailtextfortitleplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextfortitleplaceholder_ = new ::std::string;
  }
  thumbnailtextfortitleplaceholder_->assign(value);
}
inline void SlideArchive::set_thumbnailtextfortitleplaceholder(const char* value) {
  set_has_thumbnailtextfortitleplaceholder();
  if (thumbnailtextfortitleplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextfortitleplaceholder_ = new ::std::string;
  }
  thumbnailtextfortitleplaceholder_->assign(value);
}
inline void SlideArchive::set_thumbnailtextfortitleplaceholder(const char* value, size_t size) {
  set_has_thumbnailtextfortitleplaceholder();
  if (thumbnailtextfortitleplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextfortitleplaceholder_ = new ::std::string;
  }
  thumbnailtextfortitleplaceholder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlideArchive::mutable_thumbnailtextfortitleplaceholder() {
  set_has_thumbnailtextfortitleplaceholder();
  if (thumbnailtextfortitleplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextfortitleplaceholder_ = new ::std::string;
  }
  return thumbnailtextfortitleplaceholder_;
}
inline ::std::string* SlideArchive::release_thumbnailtextfortitleplaceholder() {
  clear_has_thumbnailtextfortitleplaceholder();
  if (thumbnailtextfortitleplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thumbnailtextfortitleplaceholder_;
    thumbnailtextfortitleplaceholder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlideArchive::set_allocated_thumbnailtextfortitleplaceholder(::std::string* thumbnailtextfortitleplaceholder) {
  if (thumbnailtextfortitleplaceholder_ != &::google::protobuf::internal::kEmptyString) {
    delete thumbnailtextfortitleplaceholder_;
  }
  if (thumbnailtextfortitleplaceholder) {
    set_has_thumbnailtextfortitleplaceholder();
    thumbnailtextfortitleplaceholder_ = thumbnailtextfortitleplaceholder;
  } else {
    clear_has_thumbnailtextfortitleplaceholder();
    thumbnailtextfortitleplaceholder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string thumbnailTextForBodyPlaceholder = 38;
inline bool SlideArchive::has_thumbnailtextforbodyplaceholder() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SlideArchive::set_has_thumbnailtextforbodyplaceholder() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SlideArchive::clear_has_thumbnailtextforbodyplaceholder() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SlideArchive::clear_thumbnailtextforbodyplaceholder() {
  if (thumbnailtextforbodyplaceholder_ != &::google::protobuf::internal::kEmptyString) {
    thumbnailtextforbodyplaceholder_->clear();
  }
  clear_has_thumbnailtextforbodyplaceholder();
}
inline const ::std::string& SlideArchive::thumbnailtextforbodyplaceholder() const {
  return *thumbnailtextforbodyplaceholder_;
}
inline void SlideArchive::set_thumbnailtextforbodyplaceholder(const ::std::string& value) {
  set_has_thumbnailtextforbodyplaceholder();
  if (thumbnailtextforbodyplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextforbodyplaceholder_ = new ::std::string;
  }
  thumbnailtextforbodyplaceholder_->assign(value);
}
inline void SlideArchive::set_thumbnailtextforbodyplaceholder(const char* value) {
  set_has_thumbnailtextforbodyplaceholder();
  if (thumbnailtextforbodyplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextforbodyplaceholder_ = new ::std::string;
  }
  thumbnailtextforbodyplaceholder_->assign(value);
}
inline void SlideArchive::set_thumbnailtextforbodyplaceholder(const char* value, size_t size) {
  set_has_thumbnailtextforbodyplaceholder();
  if (thumbnailtextforbodyplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextforbodyplaceholder_ = new ::std::string;
  }
  thumbnailtextforbodyplaceholder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlideArchive::mutable_thumbnailtextforbodyplaceholder() {
  set_has_thumbnailtextforbodyplaceholder();
  if (thumbnailtextforbodyplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailtextforbodyplaceholder_ = new ::std::string;
  }
  return thumbnailtextforbodyplaceholder_;
}
inline ::std::string* SlideArchive::release_thumbnailtextforbodyplaceholder() {
  clear_has_thumbnailtextforbodyplaceholder();
  if (thumbnailtextforbodyplaceholder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thumbnailtextforbodyplaceholder_;
    thumbnailtextforbodyplaceholder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlideArchive::set_allocated_thumbnailtextforbodyplaceholder(::std::string* thumbnailtextforbodyplaceholder) {
  if (thumbnailtextforbodyplaceholder_ != &::google::protobuf::internal::kEmptyString) {
    delete thumbnailtextforbodyplaceholder_;
  }
  if (thumbnailtextforbodyplaceholder) {
    set_has_thumbnailtextforbodyplaceholder();
    thumbnailtextforbodyplaceholder_ = thumbnailtextforbodyplaceholder;
  } else {
    clear_has_thumbnailtextforbodyplaceholder();
    thumbnailtextforbodyplaceholder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference master = 17;
inline bool SlideArchive::has_master() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SlideArchive::set_has_master() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SlideArchive::clear_has_master() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SlideArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& SlideArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* SlideArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* SlideArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// repeated .TSD.GuideArchive staticGuides = 18;
inline int SlideArchive::staticguides_size() const {
  return staticguides_.size();
}
inline void SlideArchive::clear_staticguides() {
  staticguides_.Clear();
}
inline const ::TSD::GuideArchive& SlideArchive::staticguides(int index) const {
  return staticguides_.Get(index);
}
inline ::TSD::GuideArchive* SlideArchive::mutable_staticguides(int index) {
  return staticguides_.Mutable(index);
}
inline ::TSD::GuideArchive* SlideArchive::add_staticguides() {
  return staticguides_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::GuideArchive >&
SlideArchive::staticguides() const {
  return staticguides_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::GuideArchive >*
SlideArchive::mutable_staticguides() {
  return &staticguides_;
}

// optional .TSP.Reference userDefinedGuideStorage = 36;
inline bool SlideArchive::has_userdefinedguidestorage() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SlideArchive::set_has_userdefinedguidestorage() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SlideArchive::clear_has_userdefinedguidestorage() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SlideArchive::clear_userdefinedguidestorage() {
  if (userdefinedguidestorage_ != NULL) userdefinedguidestorage_->::TSP::Reference::Clear();
  clear_has_userdefinedguidestorage();
}
inline const ::TSP::Reference& SlideArchive::userdefinedguidestorage() const {
  return userdefinedguidestorage_ != NULL ? *userdefinedguidestorage_ : *default_instance_->userdefinedguidestorage_;
}
inline ::TSP::Reference* SlideArchive::mutable_userdefinedguidestorage() {
  set_has_userdefinedguidestorage();
  if (userdefinedguidestorage_ == NULL) userdefinedguidestorage_ = new ::TSP::Reference;
  return userdefinedguidestorage_;
}
inline ::TSP::Reference* SlideArchive::release_userdefinedguidestorage() {
  clear_has_userdefinedguidestorage();
  ::TSP::Reference* temp = userdefinedguidestorage_;
  userdefinedguidestorage_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_userdefinedguidestorage(::TSP::Reference* userdefinedguidestorage) {
  delete userdefinedguidestorage_;
  userdefinedguidestorage_ = userdefinedguidestorage;
  if (userdefinedguidestorage) {
    set_has_userdefinedguidestorage();
  } else {
    clear_has_userdefinedguidestorage();
  }
}

// required bool inDocument = 19;
inline bool SlideArchive::has_indocument() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SlideArchive::set_has_indocument() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SlideArchive::clear_has_indocument() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SlideArchive::clear_indocument() {
  indocument_ = false;
  clear_has_indocument();
}
inline bool SlideArchive::indocument() const {
  return indocument_;
}
inline void SlideArchive::set_indocument(bool value) {
  set_has_indocument();
  indocument_ = value;
}

// optional .TSP.Reference note = 27;
inline bool SlideArchive::has_note() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void SlideArchive::set_has_note() {
  _has_bits_[1] |= 0x00000001u;
}
inline void SlideArchive::clear_has_note() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void SlideArchive::clear_note() {
  if (note_ != NULL) note_->::TSP::Reference::Clear();
  clear_has_note();
}
inline const ::TSP::Reference& SlideArchive::note() const {
  return note_ != NULL ? *note_ : *default_instance_->note_;
}
inline ::TSP::Reference* SlideArchive::mutable_note() {
  set_has_note();
  if (note_ == NULL) note_ = new ::TSP::Reference;
  return note_;
}
inline ::TSP::Reference* SlideArchive::release_note() {
  clear_has_note();
  ::TSP::Reference* temp = note_;
  note_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_note(::TSP::Reference* note) {
  delete note_;
  note_ = note;
  if (note) {
    set_has_note();
  } else {
    clear_has_note();
  }
}

// optional .TSP.Reference info_using_object_placeholder_geometry = 39;
inline bool SlideArchive::has_info_using_object_placeholder_geometry() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void SlideArchive::set_has_info_using_object_placeholder_geometry() {
  _has_bits_[1] |= 0x00000002u;
}
inline void SlideArchive::clear_has_info_using_object_placeholder_geometry() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void SlideArchive::clear_info_using_object_placeholder_geometry() {
  if (info_using_object_placeholder_geometry_ != NULL) info_using_object_placeholder_geometry_->::TSP::Reference::Clear();
  clear_has_info_using_object_placeholder_geometry();
}
inline const ::TSP::Reference& SlideArchive::info_using_object_placeholder_geometry() const {
  return info_using_object_placeholder_geometry_ != NULL ? *info_using_object_placeholder_geometry_ : *default_instance_->info_using_object_placeholder_geometry_;
}
inline ::TSP::Reference* SlideArchive::mutable_info_using_object_placeholder_geometry() {
  set_has_info_using_object_placeholder_geometry();
  if (info_using_object_placeholder_geometry_ == NULL) info_using_object_placeholder_geometry_ = new ::TSP::Reference;
  return info_using_object_placeholder_geometry_;
}
inline ::TSP::Reference* SlideArchive::release_info_using_object_placeholder_geometry() {
  clear_has_info_using_object_placeholder_geometry();
  ::TSP::Reference* temp = info_using_object_placeholder_geometry_;
  info_using_object_placeholder_geometry_ = NULL;
  return temp;
}
inline void SlideArchive::set_allocated_info_using_object_placeholder_geometry(::TSP::Reference* info_using_object_placeholder_geometry) {
  delete info_using_object_placeholder_geometry_;
  info_using_object_placeholder_geometry_ = info_using_object_placeholder_geometry;
  if (info_using_object_placeholder_geometry) {
    set_has_info_using_object_placeholder_geometry();
  } else {
    clear_has_info_using_object_placeholder_geometry();
  }
}

// optional bool info_using_object_placeholder_geometry_matches_object_placeholder_geometry = 40;
inline bool SlideArchive::has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void SlideArchive::set_has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry() {
  _has_bits_[1] |= 0x00000004u;
}
inline void SlideArchive::clear_has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void SlideArchive::clear_info_using_object_placeholder_geometry_matches_object_placeholder_geometry() {
  info_using_object_placeholder_geometry_matches_object_placeholder_geometry_ = false;
  clear_has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry();
}
inline bool SlideArchive::info_using_object_placeholder_geometry_matches_object_placeholder_geometry() const {
  return info_using_object_placeholder_geometry_matches_object_placeholder_geometry_;
}
inline void SlideArchive::set_info_using_object_placeholder_geometry_matches_object_placeholder_geometry(bool value) {
  set_has_info_using_object_placeholder_geometry_matches_object_placeholder_geometry();
  info_using_object_placeholder_geometry_matches_object_placeholder_geometry_ = value;
}

// optional bool deprecated_objectPlaceholderVisibleForExport = 34;
inline bool SlideArchive::has_deprecated_objectplaceholdervisibleforexport() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void SlideArchive::set_has_deprecated_objectplaceholdervisibleforexport() {
  _has_bits_[1] |= 0x00000008u;
}
inline void SlideArchive::clear_has_deprecated_objectplaceholdervisibleforexport() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void SlideArchive::clear_deprecated_objectplaceholdervisibleforexport() {
  deprecated_objectplaceholdervisibleforexport_ = false;
  clear_has_deprecated_objectplaceholdervisibleforexport();
}
inline bool SlideArchive::deprecated_objectplaceholdervisibleforexport() const {
  return deprecated_objectplaceholdervisibleforexport_;
}
inline void SlideArchive::set_deprecated_objectplaceholdervisibleforexport(bool value) {
  set_has_deprecated_objectplaceholdervisibleforexport();
  deprecated_objectplaceholdervisibleforexport_ = value;
}

// -------------------------------------------------------------------

// SlideNodeArchive

// repeated .TSP.Reference children = 1;
inline int SlideNodeArchive::children_size() const {
  return children_.size();
}
inline void SlideNodeArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& SlideNodeArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* SlideNodeArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* SlideNodeArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideNodeArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideNodeArchive::mutable_children() {
  return &children_;
}

// optional .TSP.Reference slide = 2;
inline bool SlideNodeArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideNodeArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideNodeArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideNodeArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& SlideNodeArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* SlideNodeArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* SlideNodeArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void SlideNodeArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// repeated .TSP.DataReference thumbnails = 16;
inline int SlideNodeArchive::thumbnails_size() const {
  return thumbnails_.size();
}
inline void SlideNodeArchive::clear_thumbnails() {
  thumbnails_.Clear();
}
inline const ::TSP::DataReference& SlideNodeArchive::thumbnails(int index) const {
  return thumbnails_.Get(index);
}
inline ::TSP::DataReference* SlideNodeArchive::mutable_thumbnails(int index) {
  return thumbnails_.Mutable(index);
}
inline ::TSP::DataReference* SlideNodeArchive::add_thumbnails() {
  return thumbnails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >&
SlideNodeArchive::thumbnails() const {
  return thumbnails_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >*
SlideNodeArchive::mutable_thumbnails() {
  return &thumbnails_;
}

// repeated .TSP.Size thumbnailSizes = 10;
inline int SlideNodeArchive::thumbnailsizes_size() const {
  return thumbnailsizes_.size();
}
inline void SlideNodeArchive::clear_thumbnailsizes() {
  thumbnailsizes_.Clear();
}
inline const ::TSP::Size& SlideNodeArchive::thumbnailsizes(int index) const {
  return thumbnailsizes_.Get(index);
}
inline ::TSP::Size* SlideNodeArchive::mutable_thumbnailsizes(int index) {
  return thumbnailsizes_.Mutable(index);
}
inline ::TSP::Size* SlideNodeArchive::add_thumbnailsizes() {
  return thumbnailsizes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Size >&
SlideNodeArchive::thumbnailsizes() const {
  return thumbnailsizes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Size >*
SlideNodeArchive::mutable_thumbnailsizes() {
  return &thumbnailsizes_;
}

// optional bool thumbnailsAreDirty = 14;
inline bool SlideNodeArchive::has_thumbnailsaredirty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlideNodeArchive::set_has_thumbnailsaredirty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlideNodeArchive::clear_has_thumbnailsaredirty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlideNodeArchive::clear_thumbnailsaredirty() {
  thumbnailsaredirty_ = false;
  clear_has_thumbnailsaredirty();
}
inline bool SlideNodeArchive::thumbnailsaredirty() const {
  return thumbnailsaredirty_;
}
inline void SlideNodeArchive::set_thumbnailsaredirty(bool value) {
  set_has_thumbnailsaredirty();
  thumbnailsaredirty_ = value;
}

// required bool isHidden = 4;
inline bool SlideNodeArchive::has_ishidden() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlideNodeArchive::set_has_ishidden() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlideNodeArchive::clear_has_ishidden() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlideNodeArchive::clear_ishidden() {
  ishidden_ = false;
  clear_has_ishidden();
}
inline bool SlideNodeArchive::ishidden() const {
  return ishidden_;
}
inline void SlideNodeArchive::set_ishidden(bool value) {
  set_has_ishidden();
  ishidden_ = value;
}

// required bool isCollapsed = 5 [deprecated = true];
inline bool SlideNodeArchive::has_iscollapsed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlideNodeArchive::set_has_iscollapsed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlideNodeArchive::clear_has_iscollapsed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlideNodeArchive::clear_iscollapsed() {
  iscollapsed_ = false;
  clear_has_iscollapsed();
}
inline bool SlideNodeArchive::iscollapsed() const {
  return iscollapsed_;
}
inline void SlideNodeArchive::set_iscollapsed(bool value) {
  set_has_iscollapsed();
  iscollapsed_ = value;
}

// optional bool isCollapsedInOutlineView = 17;
inline bool SlideNodeArchive::has_iscollapsedinoutlineview() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlideNodeArchive::set_has_iscollapsedinoutlineview() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlideNodeArchive::clear_has_iscollapsedinoutlineview() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlideNodeArchive::clear_iscollapsedinoutlineview() {
  iscollapsedinoutlineview_ = false;
  clear_has_iscollapsedinoutlineview();
}
inline bool SlideNodeArchive::iscollapsedinoutlineview() const {
  return iscollapsedinoutlineview_;
}
inline void SlideNodeArchive::set_iscollapsedinoutlineview(bool value) {
  set_has_iscollapsedinoutlineview();
  iscollapsedinoutlineview_ = value;
}

// optional bool hasBodyInOutlineView = 19;
inline bool SlideNodeArchive::has_hasbodyinoutlineview() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlideNodeArchive::set_has_hasbodyinoutlineview() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlideNodeArchive::clear_has_hasbodyinoutlineview() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlideNodeArchive::clear_hasbodyinoutlineview() {
  hasbodyinoutlineview_ = false;
  clear_has_hasbodyinoutlineview();
}
inline bool SlideNodeArchive::hasbodyinoutlineview() const {
  return hasbodyinoutlineview_;
}
inline void SlideNodeArchive::set_hasbodyinoutlineview(bool value) {
  set_has_hasbodyinoutlineview();
  hasbodyinoutlineview_ = value;
}

// required bool hasBuilds = 6;
inline bool SlideNodeArchive::has_hasbuilds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SlideNodeArchive::set_has_hasbuilds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SlideNodeArchive::clear_has_hasbuilds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SlideNodeArchive::clear_hasbuilds() {
  hasbuilds_ = false;
  clear_has_hasbuilds();
}
inline bool SlideNodeArchive::hasbuilds() const {
  return hasbuilds_;
}
inline void SlideNodeArchive::set_hasbuilds(bool value) {
  set_has_hasbuilds();
  hasbuilds_ = value;
}

// required bool hasTransition = 7;
inline bool SlideNodeArchive::has_hastransition() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SlideNodeArchive::set_has_hastransition() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SlideNodeArchive::clear_has_hastransition() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SlideNodeArchive::clear_hastransition() {
  hastransition_ = false;
  clear_has_hastransition();
}
inline bool SlideNodeArchive::hastransition() const {
  return hastransition_;
}
inline void SlideNodeArchive::set_hastransition(bool value) {
  set_has_hastransition();
  hastransition_ = value;
}

// optional bool hasNote = 8;
inline bool SlideNodeArchive::has_hasnote() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SlideNodeArchive::set_has_hasnote() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SlideNodeArchive::clear_has_hasnote() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SlideNodeArchive::clear_hasnote() {
  hasnote_ = false;
  clear_has_hasnote();
}
inline bool SlideNodeArchive::hasnote() const {
  return hasnote_;
}
inline void SlideNodeArchive::set_hasnote(bool value) {
  set_has_hasnote();
  hasnote_ = value;
}

// optional bool isSlideNumberVisible = 18 [default = false];
inline bool SlideNodeArchive::has_isslidenumbervisible() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SlideNodeArchive::set_has_isslidenumbervisible() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SlideNodeArchive::clear_has_isslidenumbervisible() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SlideNodeArchive::clear_isslidenumbervisible() {
  isslidenumbervisible_ = false;
  clear_has_isslidenumbervisible();
}
inline bool SlideNodeArchive::isslidenumbervisible() const {
  return isslidenumbervisible_;
}
inline void SlideNodeArchive::set_isslidenumbervisible(bool value) {
  set_has_isslidenumbervisible();
  isslidenumbervisible_ = value;
}

// optional string uniqueIdentifier = 11;
inline bool SlideNodeArchive::has_uniqueidentifier() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SlideNodeArchive::set_has_uniqueidentifier() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SlideNodeArchive::clear_has_uniqueidentifier() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SlideNodeArchive::clear_uniqueidentifier() {
  if (uniqueidentifier_ != &::google::protobuf::internal::kEmptyString) {
    uniqueidentifier_->clear();
  }
  clear_has_uniqueidentifier();
}
inline const ::std::string& SlideNodeArchive::uniqueidentifier() const {
  return *uniqueidentifier_;
}
inline void SlideNodeArchive::set_uniqueidentifier(const ::std::string& value) {
  set_has_uniqueidentifier();
  if (uniqueidentifier_ == &::google::protobuf::internal::kEmptyString) {
    uniqueidentifier_ = new ::std::string;
  }
  uniqueidentifier_->assign(value);
}
inline void SlideNodeArchive::set_uniqueidentifier(const char* value) {
  set_has_uniqueidentifier();
  if (uniqueidentifier_ == &::google::protobuf::internal::kEmptyString) {
    uniqueidentifier_ = new ::std::string;
  }
  uniqueidentifier_->assign(value);
}
inline void SlideNodeArchive::set_uniqueidentifier(const char* value, size_t size) {
  set_has_uniqueidentifier();
  if (uniqueidentifier_ == &::google::protobuf::internal::kEmptyString) {
    uniqueidentifier_ = new ::std::string;
  }
  uniqueidentifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlideNodeArchive::mutable_uniqueidentifier() {
  set_has_uniqueidentifier();
  if (uniqueidentifier_ == &::google::protobuf::internal::kEmptyString) {
    uniqueidentifier_ = new ::std::string;
  }
  return uniqueidentifier_;
}
inline ::std::string* SlideNodeArchive::release_uniqueidentifier() {
  clear_has_uniqueidentifier();
  if (uniqueidentifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueidentifier_;
    uniqueidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlideNodeArchive::set_allocated_uniqueidentifier(::std::string* uniqueidentifier) {
  if (uniqueidentifier_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueidentifier_;
  }
  if (uniqueidentifier) {
    set_has_uniqueidentifier();
    uniqueidentifier_ = uniqueidentifier;
  } else {
    clear_has_uniqueidentifier();
    uniqueidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string copyFromSlideIdentifier = 12;
inline bool SlideNodeArchive::has_copyfromslideidentifier() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SlideNodeArchive::set_has_copyfromslideidentifier() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SlideNodeArchive::clear_has_copyfromslideidentifier() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SlideNodeArchive::clear_copyfromslideidentifier() {
  if (copyfromslideidentifier_ != &::google::protobuf::internal::kEmptyString) {
    copyfromslideidentifier_->clear();
  }
  clear_has_copyfromslideidentifier();
}
inline const ::std::string& SlideNodeArchive::copyfromslideidentifier() const {
  return *copyfromslideidentifier_;
}
inline void SlideNodeArchive::set_copyfromslideidentifier(const ::std::string& value) {
  set_has_copyfromslideidentifier();
  if (copyfromslideidentifier_ == &::google::protobuf::internal::kEmptyString) {
    copyfromslideidentifier_ = new ::std::string;
  }
  copyfromslideidentifier_->assign(value);
}
inline void SlideNodeArchive::set_copyfromslideidentifier(const char* value) {
  set_has_copyfromslideidentifier();
  if (copyfromslideidentifier_ == &::google::protobuf::internal::kEmptyString) {
    copyfromslideidentifier_ = new ::std::string;
  }
  copyfromslideidentifier_->assign(value);
}
inline void SlideNodeArchive::set_copyfromslideidentifier(const char* value, size_t size) {
  set_has_copyfromslideidentifier();
  if (copyfromslideidentifier_ == &::google::protobuf::internal::kEmptyString) {
    copyfromslideidentifier_ = new ::std::string;
  }
  copyfromslideidentifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlideNodeArchive::mutable_copyfromslideidentifier() {
  set_has_copyfromslideidentifier();
  if (copyfromslideidentifier_ == &::google::protobuf::internal::kEmptyString) {
    copyfromslideidentifier_ = new ::std::string;
  }
  return copyfromslideidentifier_;
}
inline ::std::string* SlideNodeArchive::release_copyfromslideidentifier() {
  clear_has_copyfromslideidentifier();
  if (copyfromslideidentifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = copyfromslideidentifier_;
    copyfromslideidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlideNodeArchive::set_allocated_copyfromslideidentifier(::std::string* copyfromslideidentifier) {
  if (copyfromslideidentifier_ != &::google::protobuf::internal::kEmptyString) {
    delete copyfromslideidentifier_;
  }
  if (copyfromslideidentifier) {
    set_has_copyfromslideidentifier();
    copyfromslideidentifier_ = copyfromslideidentifier;
  } else {
    clear_has_copyfromslideidentifier();
    copyfromslideidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 slideSpecificHyperlinkCount = 13;
inline bool SlideNodeArchive::has_slidespecifichyperlinkcount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SlideNodeArchive::set_has_slidespecifichyperlinkcount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SlideNodeArchive::clear_has_slidespecifichyperlinkcount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SlideNodeArchive::clear_slidespecifichyperlinkcount() {
  slidespecifichyperlinkcount_ = 0u;
  clear_has_slidespecifichyperlinkcount();
}
inline ::google::protobuf::uint32 SlideNodeArchive::slidespecifichyperlinkcount() const {
  return slidespecifichyperlinkcount_;
}
inline void SlideNodeArchive::set_slidespecifichyperlinkcount(::google::protobuf::uint32 value) {
  set_has_slidespecifichyperlinkcount();
  slidespecifichyperlinkcount_ = value;
}

// optional uint32 eventCount = 15;
inline bool SlideNodeArchive::has_eventcount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SlideNodeArchive::set_has_eventcount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SlideNodeArchive::clear_has_eventcount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SlideNodeArchive::clear_eventcount() {
  eventcount_ = 0u;
  clear_has_eventcount();
}
inline ::google::protobuf::uint32 SlideNodeArchive::eventcount() const {
  return eventcount_;
}
inline void SlideNodeArchive::set_eventcount(::google::protobuf::uint32 value) {
  set_has_eventcount();
  eventcount_ = value;
}

// optional .TSP.Reference database_thumbnail = 3;
inline bool SlideNodeArchive::has_database_thumbnail() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SlideNodeArchive::set_has_database_thumbnail() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SlideNodeArchive::clear_has_database_thumbnail() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SlideNodeArchive::clear_database_thumbnail() {
  if (database_thumbnail_ != NULL) database_thumbnail_->::TSP::Reference::Clear();
  clear_has_database_thumbnail();
}
inline const ::TSP::Reference& SlideNodeArchive::database_thumbnail() const {
  return database_thumbnail_ != NULL ? *database_thumbnail_ : *default_instance_->database_thumbnail_;
}
inline ::TSP::Reference* SlideNodeArchive::mutable_database_thumbnail() {
  set_has_database_thumbnail();
  if (database_thumbnail_ == NULL) database_thumbnail_ = new ::TSP::Reference;
  return database_thumbnail_;
}
inline ::TSP::Reference* SlideNodeArchive::release_database_thumbnail() {
  clear_has_database_thumbnail();
  ::TSP::Reference* temp = database_thumbnail_;
  database_thumbnail_ = NULL;
  return temp;
}
inline void SlideNodeArchive::set_allocated_database_thumbnail(::TSP::Reference* database_thumbnail) {
  delete database_thumbnail_;
  database_thumbnail_ = database_thumbnail;
  if (database_thumbnail) {
    set_has_database_thumbnail();
  } else {
    clear_has_database_thumbnail();
  }
}

// repeated .TSP.Reference database_thumbnails = 9;
inline int SlideNodeArchive::database_thumbnails_size() const {
  return database_thumbnails_.size();
}
inline void SlideNodeArchive::clear_database_thumbnails() {
  database_thumbnails_.Clear();
}
inline const ::TSP::Reference& SlideNodeArchive::database_thumbnails(int index) const {
  return database_thumbnails_.Get(index);
}
inline ::TSP::Reference* SlideNodeArchive::mutable_database_thumbnails(int index) {
  return database_thumbnails_.Mutable(index);
}
inline ::TSP::Reference* SlideNodeArchive::add_database_thumbnails() {
  return database_thumbnails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideNodeArchive::database_thumbnails() const {
  return database_thumbnails_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideNodeArchive::mutable_database_thumbnails() {
  return &database_thumbnails_;
}

// -------------------------------------------------------------------

// DesktopUILayoutArchive

// optional bool sidebar_visible = 1;
inline bool DesktopUILayoutArchive::has_sidebar_visible() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DesktopUILayoutArchive::set_has_sidebar_visible() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DesktopUILayoutArchive::clear_has_sidebar_visible() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DesktopUILayoutArchive::clear_sidebar_visible() {
  sidebar_visible_ = false;
  clear_has_sidebar_visible();
}
inline bool DesktopUILayoutArchive::sidebar_visible() const {
  return sidebar_visible_;
}
inline void DesktopUILayoutArchive::set_sidebar_visible(bool value) {
  set_has_sidebar_visible();
  sidebar_visible_ = value;
}

// optional .KN.DesktopUILayoutArchive.SidebarViewMode sidebar_view_mode = 2;
inline bool DesktopUILayoutArchive::has_sidebar_view_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DesktopUILayoutArchive::set_has_sidebar_view_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DesktopUILayoutArchive::clear_has_sidebar_view_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DesktopUILayoutArchive::clear_sidebar_view_mode() {
  sidebar_view_mode_ = 0;
  clear_has_sidebar_view_mode();
}
inline ::KN::DesktopUILayoutArchive_SidebarViewMode DesktopUILayoutArchive::sidebar_view_mode() const {
  return static_cast< ::KN::DesktopUILayoutArchive_SidebarViewMode >(sidebar_view_mode_);
}
inline void DesktopUILayoutArchive::set_sidebar_view_mode(::KN::DesktopUILayoutArchive_SidebarViewMode value) {
  assert(::KN::DesktopUILayoutArchive_SidebarViewMode_IsValid(value));
  set_has_sidebar_view_mode();
  sidebar_view_mode_ = value;
}

// optional bool notes_visible = 3;
inline bool DesktopUILayoutArchive::has_notes_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DesktopUILayoutArchive::set_has_notes_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DesktopUILayoutArchive::clear_has_notes_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DesktopUILayoutArchive::clear_notes_visible() {
  notes_visible_ = false;
  clear_has_notes_visible();
}
inline bool DesktopUILayoutArchive::notes_visible() const {
  return notes_visible_;
}
inline void DesktopUILayoutArchive::set_notes_visible(bool value) {
  set_has_notes_visible();
  notes_visible_ = value;
}

// optional bool light_table_visible = 5;
inline bool DesktopUILayoutArchive::has_light_table_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DesktopUILayoutArchive::set_has_light_table_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DesktopUILayoutArchive::clear_has_light_table_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DesktopUILayoutArchive::clear_light_table_visible() {
  light_table_visible_ = false;
  clear_has_light_table_visible();
}
inline bool DesktopUILayoutArchive::light_table_visible() const {
  return light_table_visible_;
}
inline void DesktopUILayoutArchive::set_light_table_visible(bool value) {
  set_has_light_table_visible();
  light_table_visible_ = value;
}

// optional bool inspector_pane_visible = 6 [default = true];
inline bool DesktopUILayoutArchive::has_inspector_pane_visible() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DesktopUILayoutArchive::set_has_inspector_pane_visible() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DesktopUILayoutArchive::clear_has_inspector_pane_visible() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DesktopUILayoutArchive::clear_inspector_pane_visible() {
  inspector_pane_visible_ = true;
  clear_has_inspector_pane_visible();
}
inline bool DesktopUILayoutArchive::inspector_pane_visible() const {
  return inspector_pane_visible_;
}
inline void DesktopUILayoutArchive::set_inspector_pane_visible(bool value) {
  set_has_inspector_pane_visible();
  inspector_pane_visible_ = value;
}

// optional .KN.DesktopUILayoutArchive.InspectorPaneViewMode inspector_pane_view_mode = 7 [default = kInspectorPaneViewModeFormat];
inline bool DesktopUILayoutArchive::has_inspector_pane_view_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DesktopUILayoutArchive::set_has_inspector_pane_view_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DesktopUILayoutArchive::clear_has_inspector_pane_view_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DesktopUILayoutArchive::clear_inspector_pane_view_mode() {
  inspector_pane_view_mode_ = 0;
  clear_has_inspector_pane_view_mode();
}
inline ::KN::DesktopUILayoutArchive_InspectorPaneViewMode DesktopUILayoutArchive::inspector_pane_view_mode() const {
  return static_cast< ::KN::DesktopUILayoutArchive_InspectorPaneViewMode >(inspector_pane_view_mode_);
}
inline void DesktopUILayoutArchive::set_inspector_pane_view_mode(::KN::DesktopUILayoutArchive_InspectorPaneViewMode value) {
  assert(::KN::DesktopUILayoutArchive_InspectorPaneViewMode_IsValid(value));
  set_has_inspector_pane_view_mode();
  inspector_pane_view_mode_ = value;
}

// -------------------------------------------------------------------

// UIStateArchive

// optional .TSP.Reference slideNodeToEdit = 1;
inline bool UIStateArchive::has_slidenodetoedit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIStateArchive::set_has_slidenodetoedit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIStateArchive::clear_has_slidenodetoedit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIStateArchive::clear_slidenodetoedit() {
  if (slidenodetoedit_ != NULL) slidenodetoedit_->::TSP::Reference::Clear();
  clear_has_slidenodetoedit();
}
inline const ::TSP::Reference& UIStateArchive::slidenodetoedit() const {
  return slidenodetoedit_ != NULL ? *slidenodetoedit_ : *default_instance_->slidenodetoedit_;
}
inline ::TSP::Reference* UIStateArchive::mutable_slidenodetoedit() {
  set_has_slidenodetoedit();
  if (slidenodetoedit_ == NULL) slidenodetoedit_ = new ::TSP::Reference;
  return slidenodetoedit_;
}
inline ::TSP::Reference* UIStateArchive::release_slidenodetoedit() {
  clear_has_slidenodetoedit();
  ::TSP::Reference* temp = slidenodetoedit_;
  slidenodetoedit_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_slidenodetoedit(::TSP::Reference* slidenodetoedit) {
  delete slidenodetoedit_;
  slidenodetoedit_ = slidenodetoedit;
  if (slidenodetoedit) {
    set_has_slidenodetoedit();
  } else {
    clear_has_slidenodetoedit();
  }
}

// optional .TSP.Reference deprecated_masterSlideNodeToApply = 2;
inline bool UIStateArchive::has_deprecated_masterslidenodetoapply() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIStateArchive::set_has_deprecated_masterslidenodetoapply() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIStateArchive::clear_has_deprecated_masterslidenodetoapply() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIStateArchive::clear_deprecated_masterslidenodetoapply() {
  if (deprecated_masterslidenodetoapply_ != NULL) deprecated_masterslidenodetoapply_->::TSP::Reference::Clear();
  clear_has_deprecated_masterslidenodetoapply();
}
inline const ::TSP::Reference& UIStateArchive::deprecated_masterslidenodetoapply() const {
  return deprecated_masterslidenodetoapply_ != NULL ? *deprecated_masterslidenodetoapply_ : *default_instance_->deprecated_masterslidenodetoapply_;
}
inline ::TSP::Reference* UIStateArchive::mutable_deprecated_masterslidenodetoapply() {
  set_has_deprecated_masterslidenodetoapply();
  if (deprecated_masterslidenodetoapply_ == NULL) deprecated_masterslidenodetoapply_ = new ::TSP::Reference;
  return deprecated_masterslidenodetoapply_;
}
inline ::TSP::Reference* UIStateArchive::release_deprecated_masterslidenodetoapply() {
  clear_has_deprecated_masterslidenodetoapply();
  ::TSP::Reference* temp = deprecated_masterslidenodetoapply_;
  deprecated_masterslidenodetoapply_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_deprecated_masterslidenodetoapply(::TSP::Reference* deprecated_masterslidenodetoapply) {
  delete deprecated_masterslidenodetoapply_;
  deprecated_masterslidenodetoapply_ = deprecated_masterslidenodetoapply;
  if (deprecated_masterslidenodetoapply) {
    set_has_deprecated_masterslidenodetoapply();
  } else {
    clear_has_deprecated_masterslidenodetoapply();
  }
}

// optional .TSP.Size deprecated_slideThumbnailSize = 3;
inline bool UIStateArchive::has_deprecated_slidethumbnailsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIStateArchive::set_has_deprecated_slidethumbnailsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIStateArchive::clear_has_deprecated_slidethumbnailsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIStateArchive::clear_deprecated_slidethumbnailsize() {
  if (deprecated_slidethumbnailsize_ != NULL) deprecated_slidethumbnailsize_->::TSP::Size::Clear();
  clear_has_deprecated_slidethumbnailsize();
}
inline const ::TSP::Size& UIStateArchive::deprecated_slidethumbnailsize() const {
  return deprecated_slidethumbnailsize_ != NULL ? *deprecated_slidethumbnailsize_ : *default_instance_->deprecated_slidethumbnailsize_;
}
inline ::TSP::Size* UIStateArchive::mutable_deprecated_slidethumbnailsize() {
  set_has_deprecated_slidethumbnailsize();
  if (deprecated_slidethumbnailsize_ == NULL) deprecated_slidethumbnailsize_ = new ::TSP::Size;
  return deprecated_slidethumbnailsize_;
}
inline ::TSP::Size* UIStateArchive::release_deprecated_slidethumbnailsize() {
  clear_has_deprecated_slidethumbnailsize();
  ::TSP::Size* temp = deprecated_slidethumbnailsize_;
  deprecated_slidethumbnailsize_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_deprecated_slidethumbnailsize(::TSP::Size* deprecated_slidethumbnailsize) {
  delete deprecated_slidethumbnailsize_;
  deprecated_slidethumbnailsize_ = deprecated_slidethumbnailsize;
  if (deprecated_slidethumbnailsize) {
    set_has_deprecated_slidethumbnailsize();
  } else {
    clear_has_deprecated_slidethumbnailsize();
  }
}

// optional float canvasViewScale = 4;
inline bool UIStateArchive::has_canvasviewscale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIStateArchive::set_has_canvasviewscale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIStateArchive::clear_has_canvasviewscale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIStateArchive::clear_canvasviewscale() {
  canvasviewscale_ = 0;
  clear_has_canvasviewscale();
}
inline float UIStateArchive::canvasviewscale() const {
  return canvasviewscale_;
}
inline void UIStateArchive::set_canvasviewscale(float value) {
  set_has_canvasviewscale();
  canvasviewscale_ = value;
}

// optional .TSP.Point canvasOffset = 5;
inline bool UIStateArchive::has_canvasoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UIStateArchive::set_has_canvasoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UIStateArchive::clear_has_canvasoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UIStateArchive::clear_canvasoffset() {
  if (canvasoffset_ != NULL) canvasoffset_->::TSP::Point::Clear();
  clear_has_canvasoffset();
}
inline const ::TSP::Point& UIStateArchive::canvasoffset() const {
  return canvasoffset_ != NULL ? *canvasoffset_ : *default_instance_->canvasoffset_;
}
inline ::TSP::Point* UIStateArchive::mutable_canvasoffset() {
  set_has_canvasoffset();
  if (canvasoffset_ == NULL) canvasoffset_ = new ::TSP::Point;
  return canvasoffset_;
}
inline ::TSP::Point* UIStateArchive::release_canvasoffset() {
  clear_has_canvasoffset();
  ::TSP::Point* temp = canvasoffset_;
  canvasoffset_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_canvasoffset(::TSP::Point* canvasoffset) {
  delete canvasoffset_;
  canvasoffset_ = canvasoffset;
  if (canvasoffset) {
    set_has_canvasoffset();
  } else {
    clear_has_canvasoffset();
  }
}

// repeated .TSP.Reference selectedSlideNodes = 6;
inline int UIStateArchive::selectedslidenodes_size() const {
  return selectedslidenodes_.size();
}
inline void UIStateArchive::clear_selectedslidenodes() {
  selectedslidenodes_.Clear();
}
inline const ::TSP::Reference& UIStateArchive::selectedslidenodes(int index) const {
  return selectedslidenodes_.Get(index);
}
inline ::TSP::Reference* UIStateArchive::mutable_selectedslidenodes(int index) {
  return selectedslidenodes_.Mutable(index);
}
inline ::TSP::Reference* UIStateArchive::add_selectedslidenodes() {
  return selectedslidenodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UIStateArchive::selectedslidenodes() const {
  return selectedslidenodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UIStateArchive::mutable_selectedslidenodes() {
  return &selectedslidenodes_;
}

// optional float iPhoneCanvasViewScale = 7;
inline bool UIStateArchive::has_iphonecanvasviewscale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UIStateArchive::set_has_iphonecanvasviewscale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UIStateArchive::clear_has_iphonecanvasviewscale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UIStateArchive::clear_iphonecanvasviewscale() {
  iphonecanvasviewscale_ = 0;
  clear_has_iphonecanvasviewscale();
}
inline float UIStateArchive::iphonecanvasviewscale() const {
  return iphonecanvasviewscale_;
}
inline void UIStateArchive::set_iphonecanvasviewscale(float value) {
  set_has_iphonecanvasviewscale();
  iphonecanvasviewscale_ = value;
}

// optional .TSP.Point iPhoneCanvasOffset = 8;
inline bool UIStateArchive::has_iphonecanvasoffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UIStateArchive::set_has_iphonecanvasoffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UIStateArchive::clear_has_iphonecanvasoffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UIStateArchive::clear_iphonecanvasoffset() {
  if (iphonecanvasoffset_ != NULL) iphonecanvasoffset_->::TSP::Point::Clear();
  clear_has_iphonecanvasoffset();
}
inline const ::TSP::Point& UIStateArchive::iphonecanvasoffset() const {
  return iphonecanvasoffset_ != NULL ? *iphonecanvasoffset_ : *default_instance_->iphonecanvasoffset_;
}
inline ::TSP::Point* UIStateArchive::mutable_iphonecanvasoffset() {
  set_has_iphonecanvasoffset();
  if (iphonecanvasoffset_ == NULL) iphonecanvasoffset_ = new ::TSP::Point;
  return iphonecanvasoffset_;
}
inline ::TSP::Point* UIStateArchive::release_iphonecanvasoffset() {
  clear_has_iphonecanvasoffset();
  ::TSP::Point* temp = iphonecanvasoffset_;
  iphonecanvasoffset_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_iphonecanvasoffset(::TSP::Point* iphonecanvasoffset) {
  delete iphonecanvasoffset_;
  iphonecanvasoffset_ = iphonecanvasoffset;
  if (iphonecanvasoffset) {
    set_has_iphonecanvasoffset();
  } else {
    clear_has_iphonecanvasoffset();
  }
}

// optional float iPhone568CanvasViewScale = 9;
inline bool UIStateArchive::has_iphone568canvasviewscale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UIStateArchive::set_has_iphone568canvasviewscale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UIStateArchive::clear_has_iphone568canvasviewscale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UIStateArchive::clear_iphone568canvasviewscale() {
  iphone568canvasviewscale_ = 0;
  clear_has_iphone568canvasviewscale();
}
inline float UIStateArchive::iphone568canvasviewscale() const {
  return iphone568canvasviewscale_;
}
inline void UIStateArchive::set_iphone568canvasviewscale(float value) {
  set_has_iphone568canvasviewscale();
  iphone568canvasviewscale_ = value;
}

// optional .TSP.Point iPhone568CanvasOffset = 10;
inline bool UIStateArchive::has_iphone568canvasoffset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UIStateArchive::set_has_iphone568canvasoffset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UIStateArchive::clear_has_iphone568canvasoffset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UIStateArchive::clear_iphone568canvasoffset() {
  if (iphone568canvasoffset_ != NULL) iphone568canvasoffset_->::TSP::Point::Clear();
  clear_has_iphone568canvasoffset();
}
inline const ::TSP::Point& UIStateArchive::iphone568canvasoffset() const {
  return iphone568canvasoffset_ != NULL ? *iphone568canvasoffset_ : *default_instance_->iphone568canvasoffset_;
}
inline ::TSP::Point* UIStateArchive::mutable_iphone568canvasoffset() {
  set_has_iphone568canvasoffset();
  if (iphone568canvasoffset_ == NULL) iphone568canvasoffset_ = new ::TSP::Point;
  return iphone568canvasoffset_;
}
inline ::TSP::Point* UIStateArchive::release_iphone568canvasoffset() {
  clear_has_iphone568canvasoffset();
  ::TSP::Point* temp = iphone568canvasoffset_;
  iphone568canvasoffset_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_iphone568canvasoffset(::TSP::Point* iphone568canvasoffset) {
  delete iphone568canvasoffset_;
  iphone568canvasoffset_ = iphone568canvasoffset;
  if (iphone568canvasoffset) {
    set_has_iphone568canvasoffset();
  } else {
    clear_has_iphone568canvasoffset();
  }
}

// optional .TSP.Reference desktop_ui_layout = 11;
inline bool UIStateArchive::has_desktop_ui_layout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UIStateArchive::set_has_desktop_ui_layout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UIStateArchive::clear_has_desktop_ui_layout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UIStateArchive::clear_desktop_ui_layout() {
  if (desktop_ui_layout_ != NULL) desktop_ui_layout_->::TSP::Reference::Clear();
  clear_has_desktop_ui_layout();
}
inline const ::TSP::Reference& UIStateArchive::desktop_ui_layout() const {
  return desktop_ui_layout_ != NULL ? *desktop_ui_layout_ : *default_instance_->desktop_ui_layout_;
}
inline ::TSP::Reference* UIStateArchive::mutable_desktop_ui_layout() {
  set_has_desktop_ui_layout();
  if (desktop_ui_layout_ == NULL) desktop_ui_layout_ = new ::TSP::Reference;
  return desktop_ui_layout_;
}
inline ::TSP::Reference* UIStateArchive::release_desktop_ui_layout() {
  clear_has_desktop_ui_layout();
  ::TSP::Reference* temp = desktop_ui_layout_;
  desktop_ui_layout_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_desktop_ui_layout(::TSP::Reference* desktop_ui_layout) {
  delete desktop_ui_layout_;
  desktop_ui_layout_ = desktop_ui_layout;
  if (desktop_ui_layout) {
    set_has_desktop_ui_layout();
  } else {
    clear_has_desktop_ui_layout();
  }
}

// optional bool desktop_slide_view_content_fits_window = 12;
inline bool UIStateArchive::has_desktop_slide_view_content_fits_window() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UIStateArchive::set_has_desktop_slide_view_content_fits_window() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UIStateArchive::clear_has_desktop_slide_view_content_fits_window() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UIStateArchive::clear_desktop_slide_view_content_fits_window() {
  desktop_slide_view_content_fits_window_ = false;
  clear_has_desktop_slide_view_content_fits_window();
}
inline bool UIStateArchive::desktop_slide_view_content_fits_window() const {
  return desktop_slide_view_content_fits_window_;
}
inline void UIStateArchive::set_desktop_slide_view_content_fits_window(bool value) {
  set_has_desktop_slide_view_content_fits_window();
  desktop_slide_view_content_fits_window_ = value;
}

// optional float desktop_canvas_view_scale = 13;
inline bool UIStateArchive::has_desktop_canvas_view_scale() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UIStateArchive::set_has_desktop_canvas_view_scale() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UIStateArchive::clear_has_desktop_canvas_view_scale() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UIStateArchive::clear_desktop_canvas_view_scale() {
  desktop_canvas_view_scale_ = 0;
  clear_has_desktop_canvas_view_scale();
}
inline float UIStateArchive::desktop_canvas_view_scale() const {
  return desktop_canvas_view_scale_;
}
inline void UIStateArchive::set_desktop_canvas_view_scale(float value) {
  set_has_desktop_canvas_view_scale();
  desktop_canvas_view_scale_ = value;
}

// optional .TSP.Point desktop_canvas_offset = 21;
inline bool UIStateArchive::has_desktop_canvas_offset() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UIStateArchive::set_has_desktop_canvas_offset() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UIStateArchive::clear_has_desktop_canvas_offset() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UIStateArchive::clear_desktop_canvas_offset() {
  if (desktop_canvas_offset_ != NULL) desktop_canvas_offset_->::TSP::Point::Clear();
  clear_has_desktop_canvas_offset();
}
inline const ::TSP::Point& UIStateArchive::desktop_canvas_offset() const {
  return desktop_canvas_offset_ != NULL ? *desktop_canvas_offset_ : *default_instance_->desktop_canvas_offset_;
}
inline ::TSP::Point* UIStateArchive::mutable_desktop_canvas_offset() {
  set_has_desktop_canvas_offset();
  if (desktop_canvas_offset_ == NULL) desktop_canvas_offset_ = new ::TSP::Point;
  return desktop_canvas_offset_;
}
inline ::TSP::Point* UIStateArchive::release_desktop_canvas_offset() {
  clear_has_desktop_canvas_offset();
  ::TSP::Point* temp = desktop_canvas_offset_;
  desktop_canvas_offset_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_desktop_canvas_offset(::TSP::Point* desktop_canvas_offset) {
  delete desktop_canvas_offset_;
  desktop_canvas_offset_ = desktop_canvas_offset;
  if (desktop_canvas_offset) {
    set_has_desktop_canvas_offset();
  } else {
    clear_has_desktop_canvas_offset();
  }
}

// optional float light_table_zoom_scale = 14;
inline bool UIStateArchive::has_light_table_zoom_scale() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UIStateArchive::set_has_light_table_zoom_scale() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UIStateArchive::clear_has_light_table_zoom_scale() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UIStateArchive::clear_light_table_zoom_scale() {
  light_table_zoom_scale_ = 0;
  clear_has_light_table_zoom_scale();
}
inline float UIStateArchive::light_table_zoom_scale() const {
  return light_table_zoom_scale_;
}
inline void UIStateArchive::set_light_table_zoom_scale(float value) {
  set_has_light_table_zoom_scale();
  light_table_zoom_scale_ = value;
}

// repeated .TSCH.ChartUIState chart_ui_state = 15;
inline int UIStateArchive::chart_ui_state_size() const {
  return chart_ui_state_.size();
}
inline void UIStateArchive::clear_chart_ui_state() {
  chart_ui_state_.Clear();
}
inline const ::TSCH::ChartUIState& UIStateArchive::chart_ui_state(int index) const {
  return chart_ui_state_.Get(index);
}
inline ::TSCH::ChartUIState* UIStateArchive::mutable_chart_ui_state(int index) {
  return chart_ui_state_.Mutable(index);
}
inline ::TSCH::ChartUIState* UIStateArchive::add_chart_ui_state() {
  return chart_ui_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCH::ChartUIState >&
UIStateArchive::chart_ui_state() const {
  return chart_ui_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCH::ChartUIState >*
UIStateArchive::mutable_chart_ui_state() {
  return &chart_ui_state_;
}

// optional bool show_slide_guides = 16;
inline bool UIStateArchive::has_show_slide_guides() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UIStateArchive::set_has_show_slide_guides() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UIStateArchive::clear_has_show_slide_guides() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UIStateArchive::clear_show_slide_guides() {
  show_slide_guides_ = false;
  clear_has_show_slide_guides();
}
inline bool UIStateArchive::show_slide_guides() const {
  return show_slide_guides_;
}
inline void UIStateArchive::set_show_slide_guides(bool value) {
  set_has_show_slide_guides();
  show_slide_guides_ = value;
}

// optional bool show_master_guides = 17;
inline bool UIStateArchive::has_show_master_guides() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UIStateArchive::set_has_show_master_guides() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UIStateArchive::clear_has_show_master_guides() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UIStateArchive::clear_show_master_guides() {
  show_master_guides_ = false;
  clear_has_show_master_guides();
}
inline bool UIStateArchive::show_master_guides() const {
  return show_master_guides_;
}
inline void UIStateArchive::set_show_master_guides(bool value) {
  set_has_show_master_guides();
  show_master_guides_ = value;
}

// optional bool shows_comments = 18;
inline bool UIStateArchive::has_shows_comments() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UIStateArchive::set_has_shows_comments() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UIStateArchive::clear_has_shows_comments() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UIStateArchive::clear_shows_comments() {
  shows_comments_ = false;
  clear_has_shows_comments();
}
inline bool UIStateArchive::shows_comments() const {
  return shows_comments_;
}
inline void UIStateArchive::set_shows_comments(bool value) {
  set_has_shows_comments();
  shows_comments_ = value;
}

// repeated .TSP.Reference collapsed_slide_nodes = 19;
inline int UIStateArchive::collapsed_slide_nodes_size() const {
  return collapsed_slide_nodes_.size();
}
inline void UIStateArchive::clear_collapsed_slide_nodes() {
  collapsed_slide_nodes_.Clear();
}
inline const ::TSP::Reference& UIStateArchive::collapsed_slide_nodes(int index) const {
  return collapsed_slide_nodes_.Get(index);
}
inline ::TSP::Reference* UIStateArchive::mutable_collapsed_slide_nodes(int index) {
  return collapsed_slide_nodes_.Mutable(index);
}
inline ::TSP::Reference* UIStateArchive::add_collapsed_slide_nodes() {
  return collapsed_slide_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
UIStateArchive::collapsed_slide_nodes() const {
  return collapsed_slide_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
UIStateArchive::mutable_collapsed_slide_nodes() {
  return &collapsed_slide_nodes_;
}

// optional bool shows_ruler = 20;
inline bool UIStateArchive::has_shows_ruler() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void UIStateArchive::set_has_shows_ruler() {
  _has_bits_[0] |= 0x00100000u;
}
inline void UIStateArchive::clear_has_shows_ruler() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void UIStateArchive::clear_shows_ruler() {
  shows_ruler_ = false;
  clear_has_shows_ruler();
}
inline bool UIStateArchive::shows_ruler() const {
  return shows_ruler_;
}
inline void UIStateArchive::set_shows_ruler(bool value) {
  set_has_shows_ruler();
  shows_ruler_ = value;
}

// optional float desktop_navigator_view_width = 22;
inline bool UIStateArchive::has_desktop_navigator_view_width() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void UIStateArchive::set_has_desktop_navigator_view_width() {
  _has_bits_[0] |= 0x00200000u;
}
inline void UIStateArchive::clear_has_desktop_navigator_view_width() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void UIStateArchive::clear_desktop_navigator_view_width() {
  desktop_navigator_view_width_ = 0;
  clear_has_desktop_navigator_view_width();
}
inline float UIStateArchive::desktop_navigator_view_width() const {
  return desktop_navigator_view_width_;
}
inline void UIStateArchive::set_desktop_navigator_view_width(float value) {
  set_has_desktop_navigator_view_width();
  desktop_navigator_view_width_ = value;
}

// optional float desktop_outline_view_width = 23;
inline bool UIStateArchive::has_desktop_outline_view_width() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void UIStateArchive::set_has_desktop_outline_view_width() {
  _has_bits_[0] |= 0x00400000u;
}
inline void UIStateArchive::clear_has_desktop_outline_view_width() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void UIStateArchive::clear_desktop_outline_view_width() {
  desktop_outline_view_width_ = 0;
  clear_has_desktop_outline_view_width();
}
inline float UIStateArchive::desktop_outline_view_width() const {
  return desktop_outline_view_width_;
}
inline void UIStateArchive::set_desktop_outline_view_width(float value) {
  set_has_desktop_outline_view_width();
  desktop_outline_view_width_ = value;
}

// optional .TSP.Size desktop_main_content_size = 24;
inline bool UIStateArchive::has_desktop_main_content_size() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void UIStateArchive::set_has_desktop_main_content_size() {
  _has_bits_[0] |= 0x00800000u;
}
inline void UIStateArchive::clear_has_desktop_main_content_size() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void UIStateArchive::clear_desktop_main_content_size() {
  if (desktop_main_content_size_ != NULL) desktop_main_content_size_->::TSP::Size::Clear();
  clear_has_desktop_main_content_size();
}
inline const ::TSP::Size& UIStateArchive::desktop_main_content_size() const {
  return desktop_main_content_size_ != NULL ? *desktop_main_content_size_ : *default_instance_->desktop_main_content_size_;
}
inline ::TSP::Size* UIStateArchive::mutable_desktop_main_content_size() {
  set_has_desktop_main_content_size();
  if (desktop_main_content_size_ == NULL) desktop_main_content_size_ = new ::TSP::Size;
  return desktop_main_content_size_;
}
inline ::TSP::Size* UIStateArchive::release_desktop_main_content_size() {
  clear_has_desktop_main_content_size();
  ::TSP::Size* temp = desktop_main_content_size_;
  desktop_main_content_size_ = NULL;
  return temp;
}
inline void UIStateArchive::set_allocated_desktop_main_content_size(::TSP::Size* desktop_main_content_size) {
  delete desktop_main_content_size_;
  desktop_main_content_size_ = desktop_main_content_size;
  if (desktop_main_content_size) {
    set_has_desktop_main_content_size();
  } else {
    clear_has_desktop_main_content_size();
  }
}

// -------------------------------------------------------------------

// CanvasSelectionArchive

// repeated .TSP.Reference infos = 1;
inline int CanvasSelectionArchive::infos_size() const {
  return infos_.size();
}
inline void CanvasSelectionArchive::clear_infos() {
  infos_.Clear();
}
inline const ::TSP::Reference& CanvasSelectionArchive::infos(int index) const {
  return infos_.Get(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CanvasSelectionArchive::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CanvasSelectionArchive::mutable_infos() {
  return &infos_;
}

// repeated .TSP.IndexSet action_ghost_indexes = 3;
inline int CanvasSelectionArchive::action_ghost_indexes_size() const {
  return action_ghost_indexes_.size();
}
inline void CanvasSelectionArchive::clear_action_ghost_indexes() {
  action_ghost_indexes_.Clear();
}
inline const ::TSP::IndexSet& CanvasSelectionArchive::action_ghost_indexes(int index) const {
  return action_ghost_indexes_.Get(index);
}
inline ::TSP::IndexSet* CanvasSelectionArchive::mutable_action_ghost_indexes(int index) {
  return action_ghost_indexes_.Mutable(index);
}
inline ::TSP::IndexSet* CanvasSelectionArchive::add_action_ghost_indexes() {
  return action_ghost_indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::IndexSet >&
CanvasSelectionArchive::action_ghost_indexes() const {
  return action_ghost_indexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::IndexSet >*
CanvasSelectionArchive::mutable_action_ghost_indexes() {
  return &action_ghost_indexes_;
}

// repeated uint32 database_action_ghost_indexes = 2 [deprecated = true];
inline int CanvasSelectionArchive::database_action_ghost_indexes_size() const {
  return database_action_ghost_indexes_.size();
}
inline void CanvasSelectionArchive::clear_database_action_ghost_indexes() {
  database_action_ghost_indexes_.Clear();
}
inline ::google::protobuf::uint32 CanvasSelectionArchive::database_action_ghost_indexes(int index) const {
  return database_action_ghost_indexes_.Get(index);
}
inline void CanvasSelectionArchive::set_database_action_ghost_indexes(int index, ::google::protobuf::uint32 value) {
  database_action_ghost_indexes_.Set(index, value);
}
inline void CanvasSelectionArchive::add_database_action_ghost_indexes(::google::protobuf::uint32 value) {
  database_action_ghost_indexes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CanvasSelectionArchive::database_action_ghost_indexes() const {
  return database_action_ghost_indexes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CanvasSelectionArchive::mutable_database_action_ghost_indexes() {
  return &database_action_ghost_indexes_;
}

// -------------------------------------------------------------------

// ThemeArchive

// required .TSS.ThemeArchive super = 1;
inline bool ThemeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThemeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThemeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThemeArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::ThemeArchive::Clear();
  clear_has_super();
}
inline const ::TSS::ThemeArchive& ThemeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::ThemeArchive* ThemeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::ThemeArchive;
  return super_;
}
inline ::TSS::ThemeArchive* ThemeArchive::release_super() {
  clear_has_super();
  ::TSS::ThemeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ThemeArchive::set_allocated_super(::TSS::ThemeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference masters = 2;
inline int ThemeArchive::masters_size() const {
  return masters_.size();
}
inline void ThemeArchive::clear_masters() {
  masters_.Clear();
}
inline const ::TSP::Reference& ThemeArchive::masters(int index) const {
  return masters_.Get(index);
}
inline ::TSP::Reference* ThemeArchive::mutable_masters(int index) {
  return masters_.Mutable(index);
}
inline ::TSP::Reference* ThemeArchive::add_masters() {
  return masters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemeArchive::masters() const {
  return masters_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemeArchive::mutable_masters() {
  return &masters_;
}

// optional string uuid = 3;
inline bool ThemeArchive::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThemeArchive::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThemeArchive::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThemeArchive::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& ThemeArchive::uuid() const {
  return *uuid_;
}
inline void ThemeArchive::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void ThemeArchive::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void ThemeArchive::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThemeArchive::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* ThemeArchive::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ThemeArchive::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TSP.Reference classicThemeRecords = 4;
inline int ThemeArchive::classicthemerecords_size() const {
  return classicthemerecords_.size();
}
inline void ThemeArchive::clear_classicthemerecords() {
  classicthemerecords_.Clear();
}
inline const ::TSP::Reference& ThemeArchive::classicthemerecords(int index) const {
  return classicthemerecords_.Get(index);
}
inline ::TSP::Reference* ThemeArchive::mutable_classicthemerecords(int index) {
  return classicthemerecords_.Mutable(index);
}
inline ::TSP::Reference* ThemeArchive::add_classicthemerecords() {
  return classicthemerecords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemeArchive::classicthemerecords() const {
  return classicthemerecords_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemeArchive::mutable_classicthemerecords() {
  return &classicthemerecords_;
}

// optional .TSP.Reference defaultMasterSlideNode = 5;
inline bool ThemeArchive::has_defaultmasterslidenode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThemeArchive::set_has_defaultmasterslidenode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThemeArchive::clear_has_defaultmasterslidenode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThemeArchive::clear_defaultmasterslidenode() {
  if (defaultmasterslidenode_ != NULL) defaultmasterslidenode_->::TSP::Reference::Clear();
  clear_has_defaultmasterslidenode();
}
inline const ::TSP::Reference& ThemeArchive::defaultmasterslidenode() const {
  return defaultmasterslidenode_ != NULL ? *defaultmasterslidenode_ : *default_instance_->defaultmasterslidenode_;
}
inline ::TSP::Reference* ThemeArchive::mutable_defaultmasterslidenode() {
  set_has_defaultmasterslidenode();
  if (defaultmasterslidenode_ == NULL) defaultmasterslidenode_ = new ::TSP::Reference;
  return defaultmasterslidenode_;
}
inline ::TSP::Reference* ThemeArchive::release_defaultmasterslidenode() {
  clear_has_defaultmasterslidenode();
  ::TSP::Reference* temp = defaultmasterslidenode_;
  defaultmasterslidenode_ = NULL;
  return temp;
}
inline void ThemeArchive::set_allocated_defaultmasterslidenode(::TSP::Reference* defaultmasterslidenode) {
  delete defaultmasterslidenode_;
  defaultmasterslidenode_ = defaultmasterslidenode;
  if (defaultmasterslidenode) {
    set_has_defaultmasterslidenode();
  } else {
    clear_has_defaultmasterslidenode();
  }
}

// -------------------------------------------------------------------

// SlideTreeArchive

// optional .TSP.Reference rootSlideNode = 1;
inline bool SlideTreeArchive::has_rootslidenode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideTreeArchive::set_has_rootslidenode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideTreeArchive::clear_has_rootslidenode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideTreeArchive::clear_rootslidenode() {
  if (rootslidenode_ != NULL) rootslidenode_->::TSP::Reference::Clear();
  clear_has_rootslidenode();
}
inline const ::TSP::Reference& SlideTreeArchive::rootslidenode() const {
  return rootslidenode_ != NULL ? *rootslidenode_ : *default_instance_->rootslidenode_;
}
inline ::TSP::Reference* SlideTreeArchive::mutable_rootslidenode() {
  set_has_rootslidenode();
  if (rootslidenode_ == NULL) rootslidenode_ = new ::TSP::Reference;
  return rootslidenode_;
}
inline ::TSP::Reference* SlideTreeArchive::release_rootslidenode() {
  clear_has_rootslidenode();
  ::TSP::Reference* temp = rootslidenode_;
  rootslidenode_ = NULL;
  return temp;
}
inline void SlideTreeArchive::set_allocated_rootslidenode(::TSP::Reference* rootslidenode) {
  delete rootslidenode_;
  rootslidenode_ = rootslidenode;
  if (rootslidenode) {
    set_has_rootslidenode();
  } else {
    clear_has_rootslidenode();
  }
}

// -------------------------------------------------------------------

// ShowArchive

// optional .TSP.Reference uiState = 1;
inline bool ShowArchive::has_uistate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShowArchive::set_has_uistate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShowArchive::clear_has_uistate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShowArchive::clear_uistate() {
  if (uistate_ != NULL) uistate_->::TSP::Reference::Clear();
  clear_has_uistate();
}
inline const ::TSP::Reference& ShowArchive::uistate() const {
  return uistate_ != NULL ? *uistate_ : *default_instance_->uistate_;
}
inline ::TSP::Reference* ShowArchive::mutable_uistate() {
  set_has_uistate();
  if (uistate_ == NULL) uistate_ = new ::TSP::Reference;
  return uistate_;
}
inline ::TSP::Reference* ShowArchive::release_uistate() {
  clear_has_uistate();
  ::TSP::Reference* temp = uistate_;
  uistate_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_uistate(::TSP::Reference* uistate) {
  delete uistate_;
  uistate_ = uistate;
  if (uistate) {
    set_has_uistate();
  } else {
    clear_has_uistate();
  }
}

// required .TSP.Reference theme = 2;
inline bool ShowArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShowArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShowArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShowArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& ShowArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* ShowArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* ShowArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .KN.SlideTreeArchive slideTree = 3;
inline bool ShowArchive::has_slidetree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShowArchive::set_has_slidetree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShowArchive::clear_has_slidetree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShowArchive::clear_slidetree() {
  if (slidetree_ != NULL) slidetree_->::KN::SlideTreeArchive::Clear();
  clear_has_slidetree();
}
inline const ::KN::SlideTreeArchive& ShowArchive::slidetree() const {
  return slidetree_ != NULL ? *slidetree_ : *default_instance_->slidetree_;
}
inline ::KN::SlideTreeArchive* ShowArchive::mutable_slidetree() {
  set_has_slidetree();
  if (slidetree_ == NULL) slidetree_ = new ::KN::SlideTreeArchive;
  return slidetree_;
}
inline ::KN::SlideTreeArchive* ShowArchive::release_slidetree() {
  clear_has_slidetree();
  ::KN::SlideTreeArchive* temp = slidetree_;
  slidetree_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_slidetree(::KN::SlideTreeArchive* slidetree) {
  delete slidetree_;
  slidetree_ = slidetree;
  if (slidetree) {
    set_has_slidetree();
  } else {
    clear_has_slidetree();
  }
}

// required .TSP.Size size = 4;
inline bool ShowArchive::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShowArchive::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShowArchive::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShowArchive::clear_size() {
  if (size_ != NULL) size_->::TSP::Size::Clear();
  clear_has_size();
}
inline const ::TSP::Size& ShowArchive::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::TSP::Size* ShowArchive::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::TSP::Size;
  return size_;
}
inline ::TSP::Size* ShowArchive::release_size() {
  clear_has_size();
  ::TSP::Size* temp = size_;
  size_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_size(::TSP::Size* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .TSP.Reference stylesheet = 5;
inline bool ShowArchive::has_stylesheet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShowArchive::set_has_stylesheet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShowArchive::clear_has_stylesheet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShowArchive::clear_stylesheet() {
  if (stylesheet_ != NULL) stylesheet_->::TSP::Reference::Clear();
  clear_has_stylesheet();
}
inline const ::TSP::Reference& ShowArchive::stylesheet() const {
  return stylesheet_ != NULL ? *stylesheet_ : *default_instance_->stylesheet_;
}
inline ::TSP::Reference* ShowArchive::mutable_stylesheet() {
  set_has_stylesheet();
  if (stylesheet_ == NULL) stylesheet_ = new ::TSP::Reference;
  return stylesheet_;
}
inline ::TSP::Reference* ShowArchive::release_stylesheet() {
  clear_has_stylesheet();
  ::TSP::Reference* temp = stylesheet_;
  stylesheet_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_stylesheet(::TSP::Reference* stylesheet) {
  delete stylesheet_;
  stylesheet_ = stylesheet;
  if (stylesheet) {
    set_has_stylesheet();
  } else {
    clear_has_stylesheet();
  }
}

// optional bool slideNumbersVisible = 6;
inline bool ShowArchive::has_slidenumbersvisible() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShowArchive::set_has_slidenumbersvisible() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShowArchive::clear_has_slidenumbersvisible() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShowArchive::clear_slidenumbersvisible() {
  slidenumbersvisible_ = false;
  clear_has_slidenumbersvisible();
}
inline bool ShowArchive::slidenumbersvisible() const {
  return slidenumbersvisible_;
}
inline void ShowArchive::set_slidenumbersvisible(bool value) {
  set_has_slidenumbersvisible();
  slidenumbersvisible_ = value;
}

// optional .TSP.Reference recording = 7;
inline bool ShowArchive::has_recording() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShowArchive::set_has_recording() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShowArchive::clear_has_recording() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShowArchive::clear_recording() {
  if (recording_ != NULL) recording_->::TSP::Reference::Clear();
  clear_has_recording();
}
inline const ::TSP::Reference& ShowArchive::recording() const {
  return recording_ != NULL ? *recording_ : *default_instance_->recording_;
}
inline ::TSP::Reference* ShowArchive::mutable_recording() {
  set_has_recording();
  if (recording_ == NULL) recording_ = new ::TSP::Reference;
  return recording_;
}
inline ::TSP::Reference* ShowArchive::release_recording() {
  clear_has_recording();
  ::TSP::Reference* temp = recording_;
  recording_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_recording(::TSP::Reference* recording) {
  delete recording_;
  recording_ = recording;
  if (recording) {
    set_has_recording();
  } else {
    clear_has_recording();
  }
}

// optional bool loop_presentation = 8;
inline bool ShowArchive::has_loop_presentation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShowArchive::set_has_loop_presentation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShowArchive::clear_has_loop_presentation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShowArchive::clear_loop_presentation() {
  loop_presentation_ = false;
  clear_has_loop_presentation();
}
inline bool ShowArchive::loop_presentation() const {
  return loop_presentation_;
}
inline void ShowArchive::set_loop_presentation(bool value) {
  set_has_loop_presentation();
  loop_presentation_ = value;
}

// optional .KN.ShowArchive.KNShowMode mode = 9 [default = kKNShowModeNormal];
inline bool ShowArchive::has_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ShowArchive::set_has_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ShowArchive::clear_has_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ShowArchive::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::KN::ShowArchive_KNShowMode ShowArchive::mode() const {
  return static_cast< ::KN::ShowArchive_KNShowMode >(mode_);
}
inline void ShowArchive::set_mode(::KN::ShowArchive_KNShowMode value) {
  assert(::KN::ShowArchive_KNShowMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional double autoplay_transition_delay = 10 [default = 5];
inline bool ShowArchive::has_autoplay_transition_delay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ShowArchive::set_has_autoplay_transition_delay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ShowArchive::clear_has_autoplay_transition_delay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ShowArchive::clear_autoplay_transition_delay() {
  autoplay_transition_delay_ = 5;
  clear_has_autoplay_transition_delay();
}
inline double ShowArchive::autoplay_transition_delay() const {
  return autoplay_transition_delay_;
}
inline void ShowArchive::set_autoplay_transition_delay(double value) {
  set_has_autoplay_transition_delay();
  autoplay_transition_delay_ = value;
}

// optional double autoplay_build_delay = 11 [default = 2];
inline bool ShowArchive::has_autoplay_build_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ShowArchive::set_has_autoplay_build_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ShowArchive::clear_has_autoplay_build_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ShowArchive::clear_autoplay_build_delay() {
  autoplay_build_delay_ = 2;
  clear_has_autoplay_build_delay();
}
inline double ShowArchive::autoplay_build_delay() const {
  return autoplay_build_delay_;
}
inline void ShowArchive::set_autoplay_build_delay(double value) {
  set_has_autoplay_build_delay();
  autoplay_build_delay_ = value;
}

// optional bool idle_timer_active = 15;
inline bool ShowArchive::has_idle_timer_active() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ShowArchive::set_has_idle_timer_active() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ShowArchive::clear_has_idle_timer_active() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ShowArchive::clear_idle_timer_active() {
  idle_timer_active_ = false;
  clear_has_idle_timer_active();
}
inline bool ShowArchive::idle_timer_active() const {
  return idle_timer_active_;
}
inline void ShowArchive::set_idle_timer_active(bool value) {
  set_has_idle_timer_active();
  idle_timer_active_ = value;
}

// optional double idle_timer_delay = 16 [default = 900];
inline bool ShowArchive::has_idle_timer_delay() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ShowArchive::set_has_idle_timer_delay() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ShowArchive::clear_has_idle_timer_delay() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ShowArchive::clear_idle_timer_delay() {
  idle_timer_delay_ = 900;
  clear_has_idle_timer_delay();
}
inline double ShowArchive::idle_timer_delay() const {
  return idle_timer_delay_;
}
inline void ShowArchive::set_idle_timer_delay(double value) {
  set_has_idle_timer_delay();
  idle_timer_delay_ = value;
}

// optional .TSP.Reference soundtrack = 17;
inline bool ShowArchive::has_soundtrack() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ShowArchive::set_has_soundtrack() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ShowArchive::clear_has_soundtrack() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ShowArchive::clear_soundtrack() {
  if (soundtrack_ != NULL) soundtrack_->::TSP::Reference::Clear();
  clear_has_soundtrack();
}
inline const ::TSP::Reference& ShowArchive::soundtrack() const {
  return soundtrack_ != NULL ? *soundtrack_ : *default_instance_->soundtrack_;
}
inline ::TSP::Reference* ShowArchive::mutable_soundtrack() {
  set_has_soundtrack();
  if (soundtrack_ == NULL) soundtrack_ = new ::TSP::Reference;
  return soundtrack_;
}
inline ::TSP::Reference* ShowArchive::release_soundtrack() {
  clear_has_soundtrack();
  ::TSP::Reference* temp = soundtrack_;
  soundtrack_ = NULL;
  return temp;
}
inline void ShowArchive::set_allocated_soundtrack(::TSP::Reference* soundtrack) {
  delete soundtrack_;
  soundtrack_ = soundtrack;
  if (soundtrack) {
    set_has_soundtrack();
  } else {
    clear_has_soundtrack();
  }
}

// optional bool automatically_plays_upon_open = 18;
inline bool ShowArchive::has_automatically_plays_upon_open() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ShowArchive::set_has_automatically_plays_upon_open() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ShowArchive::clear_has_automatically_plays_upon_open() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ShowArchive::clear_automatically_plays_upon_open() {
  automatically_plays_upon_open_ = false;
  clear_has_automatically_plays_upon_open();
}
inline bool ShowArchive::automatically_plays_upon_open() const {
  return automatically_plays_upon_open_;
}
inline void ShowArchive::set_automatically_plays_upon_open(bool value) {
  set_has_automatically_plays_upon_open();
  automatically_plays_upon_open_ = value;
}

// -------------------------------------------------------------------

// DocumentArchive

// required .TSA.DocumentArchive super = 3;
inline bool DocumentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentArchive::clear_super() {
  if (super_ != NULL) super_->::TSA::DocumentArchive::Clear();
  clear_has_super();
}
inline const ::TSA::DocumentArchive& DocumentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSA::DocumentArchive* DocumentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSA::DocumentArchive;
  return super_;
}
inline ::TSA::DocumentArchive* DocumentArchive::release_super() {
  clear_has_super();
  ::TSA::DocumentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DocumentArchive::set_allocated_super(::TSA::DocumentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference show = 2;
inline bool DocumentArchive::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentArchive::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentArchive::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentArchive::clear_show() {
  if (show_ != NULL) show_->::TSP::Reference::Clear();
  clear_has_show();
}
inline const ::TSP::Reference& DocumentArchive::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::TSP::Reference* DocumentArchive::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::TSP::Reference;
  return show_;
}
inline ::TSP::Reference* DocumentArchive::release_show() {
  clear_has_show();
  ::TSP::Reference* temp = show_;
  show_ = NULL;
  return temp;
}
inline void DocumentArchive::set_allocated_show(::TSP::Reference* show) {
  delete show_;
  show_ = show;
  if (show) {
    set_has_show();
  } else {
    clear_has_show();
  }
}

// optional .TSP.Reference tables_custom_format_list = 4;
inline bool DocumentArchive::has_tables_custom_format_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentArchive::set_has_tables_custom_format_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentArchive::clear_has_tables_custom_format_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentArchive::clear_tables_custom_format_list() {
  if (tables_custom_format_list_ != NULL) tables_custom_format_list_->::TSP::Reference::Clear();
  clear_has_tables_custom_format_list();
}
inline const ::TSP::Reference& DocumentArchive::tables_custom_format_list() const {
  return tables_custom_format_list_ != NULL ? *tables_custom_format_list_ : *default_instance_->tables_custom_format_list_;
}
inline ::TSP::Reference* DocumentArchive::mutable_tables_custom_format_list() {
  set_has_tables_custom_format_list();
  if (tables_custom_format_list_ == NULL) tables_custom_format_list_ = new ::TSP::Reference;
  return tables_custom_format_list_;
}
inline ::TSP::Reference* DocumentArchive::release_tables_custom_format_list() {
  clear_has_tables_custom_format_list();
  ::TSP::Reference* temp = tables_custom_format_list_;
  tables_custom_format_list_ = NULL;
  return temp;
}
inline void DocumentArchive::set_allocated_tables_custom_format_list(::TSP::Reference* tables_custom_format_list) {
  delete tables_custom_format_list_;
  tables_custom_format_list_ = tables_custom_format_list;
  if (tables_custom_format_list) {
    set_has_tables_custom_format_list();
  } else {
    clear_has_tables_custom_format_list();
  }
}

// -------------------------------------------------------------------

// SlideStylePropertiesArchive

// optional .TSD.FillArchive fill = 1;
inline bool SlideStylePropertiesArchive::has_fill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_fill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideStylePropertiesArchive::clear_has_fill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideStylePropertiesArchive::clear_fill() {
  if (fill_ != NULL) fill_->::TSD::FillArchive::Clear();
  clear_has_fill();
}
inline const ::TSD::FillArchive& SlideStylePropertiesArchive::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSD::FillArchive* SlideStylePropertiesArchive::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSD::FillArchive;
  return fill_;
}
inline ::TSD::FillArchive* SlideStylePropertiesArchive::release_fill() {
  clear_has_fill();
  ::TSD::FillArchive* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void SlideStylePropertiesArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// optional .KN.TransitionAttributesArchive transition = 2;
inline bool SlideStylePropertiesArchive::has_transition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_transition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideStylePropertiesArchive::clear_has_transition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideStylePropertiesArchive::clear_transition() {
  if (transition_ != NULL) transition_->::KN::TransitionAttributesArchive::Clear();
  clear_has_transition();
}
inline const ::KN::TransitionAttributesArchive& SlideStylePropertiesArchive::transition() const {
  return transition_ != NULL ? *transition_ : *default_instance_->transition_;
}
inline ::KN::TransitionAttributesArchive* SlideStylePropertiesArchive::mutable_transition() {
  set_has_transition();
  if (transition_ == NULL) transition_ = new ::KN::TransitionAttributesArchive;
  return transition_;
}
inline ::KN::TransitionAttributesArchive* SlideStylePropertiesArchive::release_transition() {
  clear_has_transition();
  ::KN::TransitionAttributesArchive* temp = transition_;
  transition_ = NULL;
  return temp;
}
inline void SlideStylePropertiesArchive::set_allocated_transition(::KN::TransitionAttributesArchive* transition) {
  delete transition_;
  transition_ = transition;
  if (transition) {
    set_has_transition();
  } else {
    clear_has_transition();
  }
}

// optional bool transition_null = 3;
inline bool SlideStylePropertiesArchive::has_transition_null() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_transition_null() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlideStylePropertiesArchive::clear_has_transition_null() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlideStylePropertiesArchive::clear_transition_null() {
  transition_null_ = false;
  clear_has_transition_null();
}
inline bool SlideStylePropertiesArchive::transition_null() const {
  return transition_null_;
}
inline void SlideStylePropertiesArchive::set_transition_null(bool value) {
  set_has_transition_null();
  transition_null_ = value;
}

// optional bool titlePlaceholderVisibility = 4;
inline bool SlideStylePropertiesArchive::has_titleplaceholdervisibility() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_titleplaceholdervisibility() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlideStylePropertiesArchive::clear_has_titleplaceholdervisibility() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlideStylePropertiesArchive::clear_titleplaceholdervisibility() {
  titleplaceholdervisibility_ = false;
  clear_has_titleplaceholdervisibility();
}
inline bool SlideStylePropertiesArchive::titleplaceholdervisibility() const {
  return titleplaceholdervisibility_;
}
inline void SlideStylePropertiesArchive::set_titleplaceholdervisibility(bool value) {
  set_has_titleplaceholdervisibility();
  titleplaceholdervisibility_ = value;
}

// optional bool bodyPlaceholderVisibility = 5;
inline bool SlideStylePropertiesArchive::has_bodyplaceholdervisibility() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_bodyplaceholdervisibility() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlideStylePropertiesArchive::clear_has_bodyplaceholdervisibility() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlideStylePropertiesArchive::clear_bodyplaceholdervisibility() {
  bodyplaceholdervisibility_ = false;
  clear_has_bodyplaceholdervisibility();
}
inline bool SlideStylePropertiesArchive::bodyplaceholdervisibility() const {
  return bodyplaceholdervisibility_;
}
inline void SlideStylePropertiesArchive::set_bodyplaceholdervisibility(bool value) {
  set_has_bodyplaceholdervisibility();
  bodyplaceholdervisibility_ = value;
}

// optional bool objectPlaceholderVisibility = 7;
inline bool SlideStylePropertiesArchive::has_objectplaceholdervisibility() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_objectplaceholdervisibility() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlideStylePropertiesArchive::clear_has_objectplaceholdervisibility() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlideStylePropertiesArchive::clear_objectplaceholdervisibility() {
  objectplaceholdervisibility_ = false;
  clear_has_objectplaceholdervisibility();
}
inline bool SlideStylePropertiesArchive::objectplaceholdervisibility() const {
  return objectplaceholdervisibility_;
}
inline void SlideStylePropertiesArchive::set_objectplaceholdervisibility(bool value) {
  set_has_objectplaceholdervisibility();
  objectplaceholdervisibility_ = value;
}

// optional bool slideNumberPlaceholderVisibility = 6;
inline bool SlideStylePropertiesArchive::has_slidenumberplaceholdervisibility() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlideStylePropertiesArchive::set_has_slidenumberplaceholdervisibility() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlideStylePropertiesArchive::clear_has_slidenumberplaceholdervisibility() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlideStylePropertiesArchive::clear_slidenumberplaceholdervisibility() {
  slidenumberplaceholdervisibility_ = false;
  clear_has_slidenumberplaceholdervisibility();
}
inline bool SlideStylePropertiesArchive::slidenumberplaceholdervisibility() const {
  return slidenumberplaceholdervisibility_;
}
inline void SlideStylePropertiesArchive::set_slidenumberplaceholdervisibility(bool value) {
  set_has_slidenumberplaceholdervisibility();
  slidenumberplaceholdervisibility_ = value;
}

// -------------------------------------------------------------------

// SlideStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool SlideStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& SlideStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* SlideStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* SlideStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void SlideStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool SlideStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 SlideStyleArchive::override_count() const {
  return override_count_;
}
inline void SlideStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .KN.SlideStylePropertiesArchive slide_properties = 11;
inline bool SlideStyleArchive::has_slide_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlideStyleArchive::set_has_slide_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlideStyleArchive::clear_has_slide_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlideStyleArchive::clear_slide_properties() {
  if (slide_properties_ != NULL) slide_properties_->::KN::SlideStylePropertiesArchive::Clear();
  clear_has_slide_properties();
}
inline const ::KN::SlideStylePropertiesArchive& SlideStyleArchive::slide_properties() const {
  return slide_properties_ != NULL ? *slide_properties_ : *default_instance_->slide_properties_;
}
inline ::KN::SlideStylePropertiesArchive* SlideStyleArchive::mutable_slide_properties() {
  set_has_slide_properties();
  if (slide_properties_ == NULL) slide_properties_ = new ::KN::SlideStylePropertiesArchive;
  return slide_properties_;
}
inline ::KN::SlideStylePropertiesArchive* SlideStyleArchive::release_slide_properties() {
  clear_has_slide_properties();
  ::KN::SlideStylePropertiesArchive* temp = slide_properties_;
  slide_properties_ = NULL;
  return temp;
}
inline void SlideStyleArchive::set_allocated_slide_properties(::KN::SlideStylePropertiesArchive* slide_properties) {
  delete slide_properties_;
  slide_properties_ = slide_properties;
  if (slide_properties) {
    set_has_slide_properties();
  } else {
    clear_has_slide_properties();
  }
}

// -------------------------------------------------------------------

// PasteboardNativeStorageArchive

// repeated .TSP.Reference drawables = 1;
inline int PasteboardNativeStorageArchive::drawables_size() const {
  return drawables_.size();
}
inline void PasteboardNativeStorageArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& PasteboardNativeStorageArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* PasteboardNativeStorageArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* PasteboardNativeStorageArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
PasteboardNativeStorageArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
PasteboardNativeStorageArchive::mutable_drawables() {
  return &drawables_;
}

// repeated .TSP.Reference builds = 2;
inline int PasteboardNativeStorageArchive::builds_size() const {
  return builds_.size();
}
inline void PasteboardNativeStorageArchive::clear_builds() {
  builds_.Clear();
}
inline const ::TSP::Reference& PasteboardNativeStorageArchive::builds(int index) const {
  return builds_.Get(index);
}
inline ::TSP::Reference* PasteboardNativeStorageArchive::mutable_builds(int index) {
  return builds_.Mutable(index);
}
inline ::TSP::Reference* PasteboardNativeStorageArchive::add_builds() {
  return builds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
PasteboardNativeStorageArchive::builds() const {
  return builds_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
PasteboardNativeStorageArchive::mutable_builds() {
  return &builds_;
}

// repeated .KN.BuildChunkArchive buildChunks = 3;
inline int PasteboardNativeStorageArchive::buildchunks_size() const {
  return buildchunks_.size();
}
inline void PasteboardNativeStorageArchive::clear_buildchunks() {
  buildchunks_.Clear();
}
inline const ::KN::BuildChunkArchive& PasteboardNativeStorageArchive::buildchunks(int index) const {
  return buildchunks_.Get(index);
}
inline ::KN::BuildChunkArchive* PasteboardNativeStorageArchive::mutable_buildchunks(int index) {
  return buildchunks_.Mutable(index);
}
inline ::KN::BuildChunkArchive* PasteboardNativeStorageArchive::add_buildchunks() {
  return buildchunks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >&
PasteboardNativeStorageArchive::buildchunks() const {
  return buildchunks_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::BuildChunkArchive >*
PasteboardNativeStorageArchive::mutable_buildchunks() {
  return &buildchunks_;
}

// repeated .TSP.Reference slideNodes = 4;
inline int PasteboardNativeStorageArchive::slidenodes_size() const {
  return slidenodes_.size();
}
inline void PasteboardNativeStorageArchive::clear_slidenodes() {
  slidenodes_.Clear();
}
inline const ::TSP::Reference& PasteboardNativeStorageArchive::slidenodes(int index) const {
  return slidenodes_.Get(index);
}
inline ::TSP::Reference* PasteboardNativeStorageArchive::mutable_slidenodes(int index) {
  return slidenodes_.Mutable(index);
}
inline ::TSP::Reference* PasteboardNativeStorageArchive::add_slidenodes() {
  return slidenodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
PasteboardNativeStorageArchive::slidenodes() const {
  return slidenodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
PasteboardNativeStorageArchive::mutable_slidenodes() {
  return &slidenodes_;
}

// optional .TSP.Size originalShowSize = 5;
inline bool PasteboardNativeStorageArchive::has_originalshowsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PasteboardNativeStorageArchive::set_has_originalshowsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PasteboardNativeStorageArchive::clear_has_originalshowsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PasteboardNativeStorageArchive::clear_originalshowsize() {
  if (originalshowsize_ != NULL) originalshowsize_->::TSP::Size::Clear();
  clear_has_originalshowsize();
}
inline const ::TSP::Size& PasteboardNativeStorageArchive::originalshowsize() const {
  return originalshowsize_ != NULL ? *originalshowsize_ : *default_instance_->originalshowsize_;
}
inline ::TSP::Size* PasteboardNativeStorageArchive::mutable_originalshowsize() {
  set_has_originalshowsize();
  if (originalshowsize_ == NULL) originalshowsize_ = new ::TSP::Size;
  return originalshowsize_;
}
inline ::TSP::Size* PasteboardNativeStorageArchive::release_originalshowsize() {
  clear_has_originalshowsize();
  ::TSP::Size* temp = originalshowsize_;
  originalshowsize_ = NULL;
  return temp;
}
inline void PasteboardNativeStorageArchive::set_allocated_originalshowsize(::TSP::Size* originalshowsize) {
  delete originalshowsize_;
  originalshowsize_ = originalshowsize;
  if (originalshowsize) {
    set_has_originalshowsize();
  } else {
    clear_has_originalshowsize();
  }
}

// repeated .TSP.Range titleRanges = 6;
inline int PasteboardNativeStorageArchive::titleranges_size() const {
  return titleranges_.size();
}
inline void PasteboardNativeStorageArchive::clear_titleranges() {
  titleranges_.Clear();
}
inline const ::TSP::Range& PasteboardNativeStorageArchive::titleranges(int index) const {
  return titleranges_.Get(index);
}
inline ::TSP::Range* PasteboardNativeStorageArchive::mutable_titleranges(int index) {
  return titleranges_.Mutable(index);
}
inline ::TSP::Range* PasteboardNativeStorageArchive::add_titleranges() {
  return titleranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Range >&
PasteboardNativeStorageArchive::titleranges() const {
  return titleranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Range >*
PasteboardNativeStorageArchive::mutable_titleranges() {
  return &titleranges_;
}

// -------------------------------------------------------------------

// MasterChangeBlobArchive

// optional .TSP.Reference slide = 1;
inline bool MasterChangeBlobArchive::has_slide() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterChangeBlobArchive::set_has_slide() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterChangeBlobArchive::clear_has_slide() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterChangeBlobArchive::clear_slide() {
  if (slide_ != NULL) slide_->::TSP::Reference::Clear();
  clear_has_slide();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::slide() const {
  return slide_ != NULL ? *slide_ : *default_instance_->slide_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_slide() {
  set_has_slide();
  if (slide_ == NULL) slide_ = new ::TSP::Reference;
  return slide_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::release_slide() {
  clear_has_slide();
  ::TSP::Reference* temp = slide_;
  slide_ = NULL;
  return temp;
}
inline void MasterChangeBlobArchive::set_allocated_slide(::TSP::Reference* slide) {
  delete slide_;
  slide_ = slide;
  if (slide) {
    set_has_slide();
  } else {
    clear_has_slide();
  }
}

// optional .TSP.Reference master = 2;
inline bool MasterChangeBlobArchive::has_master() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterChangeBlobArchive::set_has_master() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterChangeBlobArchive::clear_has_master() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterChangeBlobArchive::clear_master() {
  if (master_ != NULL) master_->::TSP::Reference::Clear();
  clear_has_master();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::TSP::Reference;
  return master_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::release_master() {
  clear_has_master();
  ::TSP::Reference* temp = master_;
  master_ = NULL;
  return temp;
}
inline void MasterChangeBlobArchive::set_allocated_master(::TSP::Reference* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// optional .TSP.Reference slide_style = 3;
inline bool MasterChangeBlobArchive::has_slide_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterChangeBlobArchive::set_has_slide_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterChangeBlobArchive::clear_has_slide_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterChangeBlobArchive::clear_slide_style() {
  if (slide_style_ != NULL) slide_style_->::TSP::Reference::Clear();
  clear_has_slide_style();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::slide_style() const {
  return slide_style_ != NULL ? *slide_style_ : *default_instance_->slide_style_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_slide_style() {
  set_has_slide_style();
  if (slide_style_ == NULL) slide_style_ = new ::TSP::Reference;
  return slide_style_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::release_slide_style() {
  clear_has_slide_style();
  ::TSP::Reference* temp = slide_style_;
  slide_style_ = NULL;
  return temp;
}
inline void MasterChangeBlobArchive::set_allocated_slide_style(::TSP::Reference* slide_style) {
  delete slide_style_;
  slide_style_ = slide_style;
  if (slide_style) {
    set_has_slide_style();
  } else {
    clear_has_slide_style();
  }
}

// optional .TSP.Reference title_placeholder = 4;
inline bool MasterChangeBlobArchive::has_title_placeholder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterChangeBlobArchive::set_has_title_placeholder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterChangeBlobArchive::clear_has_title_placeholder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterChangeBlobArchive::clear_title_placeholder() {
  if (title_placeholder_ != NULL) title_placeholder_->::TSP::Reference::Clear();
  clear_has_title_placeholder();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::title_placeholder() const {
  return title_placeholder_ != NULL ? *title_placeholder_ : *default_instance_->title_placeholder_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_title_placeholder() {
  set_has_title_placeholder();
  if (title_placeholder_ == NULL) title_placeholder_ = new ::TSP::Reference;
  return title_placeholder_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::release_title_placeholder() {
  clear_has_title_placeholder();
  ::TSP::Reference* temp = title_placeholder_;
  title_placeholder_ = NULL;
  return temp;
}
inline void MasterChangeBlobArchive::set_allocated_title_placeholder(::TSP::Reference* title_placeholder) {
  delete title_placeholder_;
  title_placeholder_ = title_placeholder;
  if (title_placeholder) {
    set_has_title_placeholder();
  } else {
    clear_has_title_placeholder();
  }
}

// optional .TSP.Reference body_placeholder = 5;
inline bool MasterChangeBlobArchive::has_body_placeholder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterChangeBlobArchive::set_has_body_placeholder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterChangeBlobArchive::clear_has_body_placeholder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterChangeBlobArchive::clear_body_placeholder() {
  if (body_placeholder_ != NULL) body_placeholder_->::TSP::Reference::Clear();
  clear_has_body_placeholder();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::body_placeholder() const {
  return body_placeholder_ != NULL ? *body_placeholder_ : *default_instance_->body_placeholder_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_body_placeholder() {
  set_has_body_placeholder();
  if (body_placeholder_ == NULL) body_placeholder_ = new ::TSP::Reference;
  return body_placeholder_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::release_body_placeholder() {
  clear_has_body_placeholder();
  ::TSP::Reference* temp = body_placeholder_;
  body_placeholder_ = NULL;
  return temp;
}
inline void MasterChangeBlobArchive::set_allocated_body_placeholder(::TSP::Reference* body_placeholder) {
  delete body_placeholder_;
  body_placeholder_ = body_placeholder;
  if (body_placeholder) {
    set_has_body_placeholder();
  } else {
    clear_has_body_placeholder();
  }
}

// optional .TSP.Reference object_placeholder = 7;
inline bool MasterChangeBlobArchive::has_object_placeholder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MasterChangeBlobArchive::set_has_object_placeholder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MasterChangeBlobArchive::clear_has_object_placeholder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MasterChangeBlobArchive::clear_object_placeholder() {
  if (object_placeholder_ != NULL) object_placeholder_->::TSP::Reference::Clear();
  clear_has_object_placeholder();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::object_placeholder() const {
  return object_placeholder_ != NULL ? *object_placeholder_ : *default_instance_->object_placeholder_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_object_placeholder() {
  set_has_object_placeholder();
  if (object_placeholder_ == NULL) object_placeholder_ = new ::TSP::Reference;
  return object_placeholder_;
}
inline ::TSP::Reference* MasterChangeBlobArchive::release_object_placeholder() {
  clear_has_object_placeholder();
  ::TSP::Reference* temp = object_placeholder_;
  object_placeholder_ = NULL;
  return temp;
}
inline void MasterChangeBlobArchive::set_allocated_object_placeholder(::TSP::Reference* object_placeholder) {
  delete object_placeholder_;
  object_placeholder_ = object_placeholder;
  if (object_placeholder) {
    set_has_object_placeholder();
  } else {
    clear_has_object_placeholder();
  }
}

// repeated .TSP.Reference drawables = 6;
inline int MasterChangeBlobArchive::drawables_size() const {
  return drawables_.size();
}
inline void MasterChangeBlobArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& MasterChangeBlobArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* MasterChangeBlobArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* MasterChangeBlobArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
MasterChangeBlobArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
MasterChangeBlobArchive::mutable_drawables() {
  return &drawables_;
}

// -------------------------------------------------------------------

// RecordingArchive

// repeated .TSP.Reference event_tracks = 1;
inline int RecordingArchive::event_tracks_size() const {
  return event_tracks_.size();
}
inline void RecordingArchive::clear_event_tracks() {
  event_tracks_.Clear();
}
inline const ::TSP::Reference& RecordingArchive::event_tracks(int index) const {
  return event_tracks_.Get(index);
}
inline ::TSP::Reference* RecordingArchive::mutable_event_tracks(int index) {
  return event_tracks_.Mutable(index);
}
inline ::TSP::Reference* RecordingArchive::add_event_tracks() {
  return event_tracks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
RecordingArchive::event_tracks() const {
  return event_tracks_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
RecordingArchive::mutable_event_tracks() {
  return &event_tracks_;
}

// optional .TSP.Reference movie_track = 2;
inline bool RecordingArchive::has_movie_track() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordingArchive::set_has_movie_track() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordingArchive::clear_has_movie_track() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordingArchive::clear_movie_track() {
  if (movie_track_ != NULL) movie_track_->::TSP::Reference::Clear();
  clear_has_movie_track();
}
inline const ::TSP::Reference& RecordingArchive::movie_track() const {
  return movie_track_ != NULL ? *movie_track_ : *default_instance_->movie_track_;
}
inline ::TSP::Reference* RecordingArchive::mutable_movie_track() {
  set_has_movie_track();
  if (movie_track_ == NULL) movie_track_ = new ::TSP::Reference;
  return movie_track_;
}
inline ::TSP::Reference* RecordingArchive::release_movie_track() {
  clear_has_movie_track();
  ::TSP::Reference* temp = movie_track_;
  movie_track_ = NULL;
  return temp;
}
inline void RecordingArchive::set_allocated_movie_track(::TSP::Reference* movie_track) {
  delete movie_track_;
  movie_track_ = movie_track;
  if (movie_track) {
    set_has_movie_track();
  } else {
    clear_has_movie_track();
  }
}

// optional double duration = 3;
inline bool RecordingArchive::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordingArchive::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordingArchive::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordingArchive::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double RecordingArchive::duration() const {
  return duration_;
}
inline void RecordingArchive::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional .KN.RecordingArchive.RecordingSyncState sync_state = 4 [default = kRecordingSyncStateInSyncWithShow];
inline bool RecordingArchive::has_sync_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordingArchive::set_has_sync_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordingArchive::clear_has_sync_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordingArchive::clear_sync_state() {
  sync_state_ = 0;
  clear_has_sync_state();
}
inline ::KN::RecordingArchive_RecordingSyncState RecordingArchive::sync_state() const {
  return static_cast< ::KN::RecordingArchive_RecordingSyncState >(sync_state_);
}
inline void RecordingArchive::set_sync_state(::KN::RecordingArchive_RecordingSyncState value) {
  assert(::KN::RecordingArchive_RecordingSyncState_IsValid(value));
  set_has_sync_state();
  sync_state_ = value;
}

// optional .TSP.Date modification_date = 5;
inline bool RecordingArchive::has_modification_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordingArchive::set_has_modification_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecordingArchive::clear_has_modification_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecordingArchive::clear_modification_date() {
  if (modification_date_ != NULL) modification_date_->::TSP::Date::Clear();
  clear_has_modification_date();
}
inline const ::TSP::Date& RecordingArchive::modification_date() const {
  return modification_date_ != NULL ? *modification_date_ : *default_instance_->modification_date_;
}
inline ::TSP::Date* RecordingArchive::mutable_modification_date() {
  set_has_modification_date();
  if (modification_date_ == NULL) modification_date_ = new ::TSP::Date;
  return modification_date_;
}
inline ::TSP::Date* RecordingArchive::release_modification_date() {
  clear_has_modification_date();
  ::TSP::Date* temp = modification_date_;
  modification_date_ = NULL;
  return temp;
}
inline void RecordingArchive::set_allocated_modification_date(::TSP::Date* modification_date) {
  delete modification_date_;
  modification_date_ = modification_date;
  if (modification_date) {
    set_has_modification_date();
  } else {
    clear_has_modification_date();
  }
}

// -------------------------------------------------------------------

// RecordingEventTrackArchive

// optional string type = 1;
inline bool RecordingEventTrackArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingEventTrackArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingEventTrackArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingEventTrackArchive::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RecordingEventTrackArchive::type() const {
  return *type_;
}
inline void RecordingEventTrackArchive::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void RecordingEventTrackArchive::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void RecordingEventTrackArchive::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordingEventTrackArchive::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* RecordingEventTrackArchive::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecordingEventTrackArchive::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .KN.RecordingEventArchive events = 2;
inline int RecordingEventTrackArchive::events_size() const {
  return events_.size();
}
inline void RecordingEventTrackArchive::clear_events() {
  events_.Clear();
}
inline const ::KN::RecordingEventArchive& RecordingEventTrackArchive::events(int index) const {
  return events_.Get(index);
}
inline ::KN::RecordingEventArchive* RecordingEventTrackArchive::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::KN::RecordingEventArchive* RecordingEventTrackArchive::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::RecordingEventArchive >&
RecordingEventTrackArchive::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::RecordingEventArchive >*
RecordingEventTrackArchive::mutable_events() {
  return &events_;
}

// -------------------------------------------------------------------

// RecordingEventArchive

// optional double start_time = 1 [default = -1];
inline bool RecordingEventArchive::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingEventArchive::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingEventArchive::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingEventArchive::clear_start_time() {
  start_time_ = -1;
  clear_has_start_time();
}
inline double RecordingEventArchive::start_time() const {
  return start_time_;
}
inline void RecordingEventArchive::set_start_time(double value) {
  set_has_start_time();
  start_time_ = value;
}

// optional .KN.RecordingNavigationEventArchive navigation_event_archive = 1000;
inline bool RecordingEventArchive::has_navigation_event_archive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordingEventArchive::set_has_navigation_event_archive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordingEventArchive::clear_has_navigation_event_archive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordingEventArchive::clear_navigation_event_archive() {
  if (navigation_event_archive_ != NULL) navigation_event_archive_->::KN::RecordingNavigationEventArchive::Clear();
  clear_has_navigation_event_archive();
}
inline const ::KN::RecordingNavigationEventArchive& RecordingEventArchive::navigation_event_archive() const {
  return navigation_event_archive_ != NULL ? *navigation_event_archive_ : *default_instance_->navigation_event_archive_;
}
inline ::KN::RecordingNavigationEventArchive* RecordingEventArchive::mutable_navigation_event_archive() {
  set_has_navigation_event_archive();
  if (navigation_event_archive_ == NULL) navigation_event_archive_ = new ::KN::RecordingNavigationEventArchive;
  return navigation_event_archive_;
}
inline ::KN::RecordingNavigationEventArchive* RecordingEventArchive::release_navigation_event_archive() {
  clear_has_navigation_event_archive();
  ::KN::RecordingNavigationEventArchive* temp = navigation_event_archive_;
  navigation_event_archive_ = NULL;
  return temp;
}
inline void RecordingEventArchive::set_allocated_navigation_event_archive(::KN::RecordingNavigationEventArchive* navigation_event_archive) {
  delete navigation_event_archive_;
  navigation_event_archive_ = navigation_event_archive;
  if (navigation_event_archive) {
    set_has_navigation_event_archive();
  } else {
    clear_has_navigation_event_archive();
  }
}

// optional .KN.RecordingLaserEventArchive laser_event_archive = 1001;
inline bool RecordingEventArchive::has_laser_event_archive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordingEventArchive::set_has_laser_event_archive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordingEventArchive::clear_has_laser_event_archive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordingEventArchive::clear_laser_event_archive() {
  if (laser_event_archive_ != NULL) laser_event_archive_->::KN::RecordingLaserEventArchive::Clear();
  clear_has_laser_event_archive();
}
inline const ::KN::RecordingLaserEventArchive& RecordingEventArchive::laser_event_archive() const {
  return laser_event_archive_ != NULL ? *laser_event_archive_ : *default_instance_->laser_event_archive_;
}
inline ::KN::RecordingLaserEventArchive* RecordingEventArchive::mutable_laser_event_archive() {
  set_has_laser_event_archive();
  if (laser_event_archive_ == NULL) laser_event_archive_ = new ::KN::RecordingLaserEventArchive;
  return laser_event_archive_;
}
inline ::KN::RecordingLaserEventArchive* RecordingEventArchive::release_laser_event_archive() {
  clear_has_laser_event_archive();
  ::KN::RecordingLaserEventArchive* temp = laser_event_archive_;
  laser_event_archive_ = NULL;
  return temp;
}
inline void RecordingEventArchive::set_allocated_laser_event_archive(::KN::RecordingLaserEventArchive* laser_event_archive) {
  delete laser_event_archive_;
  laser_event_archive_ = laser_event_archive;
  if (laser_event_archive) {
    set_has_laser_event_archive();
  } else {
    clear_has_laser_event_archive();
  }
}

// optional .KN.RecordingPauseEventArchive pause_event_archive = 1002;
inline bool RecordingEventArchive::has_pause_event_archive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordingEventArchive::set_has_pause_event_archive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordingEventArchive::clear_has_pause_event_archive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordingEventArchive::clear_pause_event_archive() {
  if (pause_event_archive_ != NULL) pause_event_archive_->::KN::RecordingPauseEventArchive::Clear();
  clear_has_pause_event_archive();
}
inline const ::KN::RecordingPauseEventArchive& RecordingEventArchive::pause_event_archive() const {
  return pause_event_archive_ != NULL ? *pause_event_archive_ : *default_instance_->pause_event_archive_;
}
inline ::KN::RecordingPauseEventArchive* RecordingEventArchive::mutable_pause_event_archive() {
  set_has_pause_event_archive();
  if (pause_event_archive_ == NULL) pause_event_archive_ = new ::KN::RecordingPauseEventArchive;
  return pause_event_archive_;
}
inline ::KN::RecordingPauseEventArchive* RecordingEventArchive::release_pause_event_archive() {
  clear_has_pause_event_archive();
  ::KN::RecordingPauseEventArchive* temp = pause_event_archive_;
  pause_event_archive_ = NULL;
  return temp;
}
inline void RecordingEventArchive::set_allocated_pause_event_archive(::KN::RecordingPauseEventArchive* pause_event_archive) {
  delete pause_event_archive_;
  pause_event_archive_ = pause_event_archive;
  if (pause_event_archive) {
    set_has_pause_event_archive();
  } else {
    clear_has_pause_event_archive();
  }
}

// optional .KN.RecordingMovieEventArchive movie_event_archive = 1003;
inline bool RecordingEventArchive::has_movie_event_archive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordingEventArchive::set_has_movie_event_archive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecordingEventArchive::clear_has_movie_event_archive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecordingEventArchive::clear_movie_event_archive() {
  if (movie_event_archive_ != NULL) movie_event_archive_->::KN::RecordingMovieEventArchive::Clear();
  clear_has_movie_event_archive();
}
inline const ::KN::RecordingMovieEventArchive& RecordingEventArchive::movie_event_archive() const {
  return movie_event_archive_ != NULL ? *movie_event_archive_ : *default_instance_->movie_event_archive_;
}
inline ::KN::RecordingMovieEventArchive* RecordingEventArchive::mutable_movie_event_archive() {
  set_has_movie_event_archive();
  if (movie_event_archive_ == NULL) movie_event_archive_ = new ::KN::RecordingMovieEventArchive;
  return movie_event_archive_;
}
inline ::KN::RecordingMovieEventArchive* RecordingEventArchive::release_movie_event_archive() {
  clear_has_movie_event_archive();
  ::KN::RecordingMovieEventArchive* temp = movie_event_archive_;
  movie_event_archive_ = NULL;
  return temp;
}
inline void RecordingEventArchive::set_allocated_movie_event_archive(::KN::RecordingMovieEventArchive* movie_event_archive) {
  delete movie_event_archive_;
  movie_event_archive_ = movie_event_archive;
  if (movie_event_archive) {
    set_has_movie_event_archive();
  } else {
    clear_has_movie_event_archive();
  }
}

// -------------------------------------------------------------------

// RecordingNavigationEventArchive

// optional .TSP.Reference target_slide_node_reference = 1;
inline bool RecordingNavigationEventArchive::has_target_slide_node_reference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingNavigationEventArchive::set_has_target_slide_node_reference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingNavigationEventArchive::clear_has_target_slide_node_reference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingNavigationEventArchive::clear_target_slide_node_reference() {
  if (target_slide_node_reference_ != NULL) target_slide_node_reference_->::TSP::Reference::Clear();
  clear_has_target_slide_node_reference();
}
inline const ::TSP::Reference& RecordingNavigationEventArchive::target_slide_node_reference() const {
  return target_slide_node_reference_ != NULL ? *target_slide_node_reference_ : *default_instance_->target_slide_node_reference_;
}
inline ::TSP::Reference* RecordingNavigationEventArchive::mutable_target_slide_node_reference() {
  set_has_target_slide_node_reference();
  if (target_slide_node_reference_ == NULL) target_slide_node_reference_ = new ::TSP::Reference;
  return target_slide_node_reference_;
}
inline ::TSP::Reference* RecordingNavigationEventArchive::release_target_slide_node_reference() {
  clear_has_target_slide_node_reference();
  ::TSP::Reference* temp = target_slide_node_reference_;
  target_slide_node_reference_ = NULL;
  return temp;
}
inline void RecordingNavigationEventArchive::set_allocated_target_slide_node_reference(::TSP::Reference* target_slide_node_reference) {
  delete target_slide_node_reference_;
  target_slide_node_reference_ = target_slide_node_reference;
  if (target_slide_node_reference) {
    set_has_target_slide_node_reference();
  } else {
    clear_has_target_slide_node_reference();
  }
}

// optional uint32 target_event_index = 2;
inline bool RecordingNavigationEventArchive::has_target_event_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordingNavigationEventArchive::set_has_target_event_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordingNavigationEventArchive::clear_has_target_event_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordingNavigationEventArchive::clear_target_event_index() {
  target_event_index_ = 0u;
  clear_has_target_event_index();
}
inline ::google::protobuf::uint32 RecordingNavigationEventArchive::target_event_index() const {
  return target_event_index_;
}
inline void RecordingNavigationEventArchive::set_target_event_index(::google::protobuf::uint32 value) {
  set_has_target_event_index();
  target_event_index_ = value;
}

// optional .KN.RecordingNavigationEventArchive.RecordingNavigationEventAnimationPhase animation_phase = 3 [default = kRecordingNavigationEventAnimationNone];
inline bool RecordingNavigationEventArchive::has_animation_phase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordingNavigationEventArchive::set_has_animation_phase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordingNavigationEventArchive::clear_has_animation_phase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordingNavigationEventArchive::clear_animation_phase() {
  animation_phase_ = 0;
  clear_has_animation_phase();
}
inline ::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase RecordingNavigationEventArchive::animation_phase() const {
  return static_cast< ::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase >(animation_phase_);
}
inline void RecordingNavigationEventArchive::set_animation_phase(::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase value) {
  assert(::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_IsValid(value));
  set_has_animation_phase();
  animation_phase_ = value;
}

// -------------------------------------------------------------------

// RecordingLaserEventArchive

// optional .TSP.Point unscaled_location = 1;
inline bool RecordingLaserEventArchive::has_unscaled_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingLaserEventArchive::set_has_unscaled_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingLaserEventArchive::clear_has_unscaled_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingLaserEventArchive::clear_unscaled_location() {
  if (unscaled_location_ != NULL) unscaled_location_->::TSP::Point::Clear();
  clear_has_unscaled_location();
}
inline const ::TSP::Point& RecordingLaserEventArchive::unscaled_location() const {
  return unscaled_location_ != NULL ? *unscaled_location_ : *default_instance_->unscaled_location_;
}
inline ::TSP::Point* RecordingLaserEventArchive::mutable_unscaled_location() {
  set_has_unscaled_location();
  if (unscaled_location_ == NULL) unscaled_location_ = new ::TSP::Point;
  return unscaled_location_;
}
inline ::TSP::Point* RecordingLaserEventArchive::release_unscaled_location() {
  clear_has_unscaled_location();
  ::TSP::Point* temp = unscaled_location_;
  unscaled_location_ = NULL;
  return temp;
}
inline void RecordingLaserEventArchive::set_allocated_unscaled_location(::TSP::Point* unscaled_location) {
  delete unscaled_location_;
  unscaled_location_ = unscaled_location;
  if (unscaled_location) {
    set_has_unscaled_location();
  } else {
    clear_has_unscaled_location();
  }
}

// -------------------------------------------------------------------

// RecordingPauseEventArchive

// optional .KN.RecordingPauseEventArchive.RecordingPauseEventType pause_event_type = 1 [default = kRecordingPauseEventTypeResume];
inline bool RecordingPauseEventArchive::has_pause_event_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingPauseEventArchive::set_has_pause_event_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingPauseEventArchive::clear_has_pause_event_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingPauseEventArchive::clear_pause_event_type() {
  pause_event_type_ = 0;
  clear_has_pause_event_type();
}
inline ::KN::RecordingPauseEventArchive_RecordingPauseEventType RecordingPauseEventArchive::pause_event_type() const {
  return static_cast< ::KN::RecordingPauseEventArchive_RecordingPauseEventType >(pause_event_type_);
}
inline void RecordingPauseEventArchive::set_pause_event_type(::KN::RecordingPauseEventArchive_RecordingPauseEventType value) {
  assert(::KN::RecordingPauseEventArchive_RecordingPauseEventType_IsValid(value));
  set_has_pause_event_type();
  pause_event_type_ = value;
}

// -------------------------------------------------------------------

// RecordingMovieEventArchive

// optional .TSP.Reference movie_info_reference = 1;
inline bool RecordingMovieEventArchive::has_movie_info_reference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingMovieEventArchive::set_has_movie_info_reference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingMovieEventArchive::clear_has_movie_info_reference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingMovieEventArchive::clear_movie_info_reference() {
  if (movie_info_reference_ != NULL) movie_info_reference_->::TSP::Reference::Clear();
  clear_has_movie_info_reference();
}
inline const ::TSP::Reference& RecordingMovieEventArchive::movie_info_reference() const {
  return movie_info_reference_ != NULL ? *movie_info_reference_ : *default_instance_->movie_info_reference_;
}
inline ::TSP::Reference* RecordingMovieEventArchive::mutable_movie_info_reference() {
  set_has_movie_info_reference();
  if (movie_info_reference_ == NULL) movie_info_reference_ = new ::TSP::Reference;
  return movie_info_reference_;
}
inline ::TSP::Reference* RecordingMovieEventArchive::release_movie_info_reference() {
  clear_has_movie_info_reference();
  ::TSP::Reference* temp = movie_info_reference_;
  movie_info_reference_ = NULL;
  return temp;
}
inline void RecordingMovieEventArchive::set_allocated_movie_info_reference(::TSP::Reference* movie_info_reference) {
  delete movie_info_reference_;
  movie_info_reference_ = movie_info_reference;
  if (movie_info_reference) {
    set_has_movie_info_reference();
  } else {
    clear_has_movie_info_reference();
  }
}

// optional .KN.RecordingMovieEventArchive.RecordingMovieEventType movie_event_type = 2 [default = kRecordingMovieEventSeek];
inline bool RecordingMovieEventArchive::has_movie_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordingMovieEventArchive::set_has_movie_event_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordingMovieEventArchive::clear_has_movie_event_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordingMovieEventArchive::clear_movie_event_type() {
  movie_event_type_ = 1;
  clear_has_movie_event_type();
}
inline ::KN::RecordingMovieEventArchive_RecordingMovieEventType RecordingMovieEventArchive::movie_event_type() const {
  return static_cast< ::KN::RecordingMovieEventArchive_RecordingMovieEventType >(movie_event_type_);
}
inline void RecordingMovieEventArchive::set_movie_event_type(::KN::RecordingMovieEventArchive_RecordingMovieEventType value) {
  assert(::KN::RecordingMovieEventArchive_RecordingMovieEventType_IsValid(value));
  set_has_movie_event_type();
  movie_event_type_ = value;
}

// optional double movie_event_value = 3;
inline bool RecordingMovieEventArchive::has_movie_event_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordingMovieEventArchive::set_has_movie_event_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordingMovieEventArchive::clear_has_movie_event_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordingMovieEventArchive::clear_movie_event_value() {
  movie_event_value_ = 0;
  clear_has_movie_event_value();
}
inline double RecordingMovieEventArchive::movie_event_value() const {
  return movie_event_value_;
}
inline void RecordingMovieEventArchive::set_movie_event_value(double value) {
  set_has_movie_event_value();
  movie_event_value_ = value;
}

// -------------------------------------------------------------------

// RecordingMovieTrackArchive

// repeated .KN.MovieSegmentArchive movie_segments = 1;
inline int RecordingMovieTrackArchive::movie_segments_size() const {
  return movie_segments_.size();
}
inline void RecordingMovieTrackArchive::clear_movie_segments() {
  movie_segments_.Clear();
}
inline const ::KN::MovieSegmentArchive& RecordingMovieTrackArchive::movie_segments(int index) const {
  return movie_segments_.Get(index);
}
inline ::KN::MovieSegmentArchive* RecordingMovieTrackArchive::mutable_movie_segments(int index) {
  return movie_segments_.Mutable(index);
}
inline ::KN::MovieSegmentArchive* RecordingMovieTrackArchive::add_movie_segments() {
  return movie_segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::MovieSegmentArchive >&
RecordingMovieTrackArchive::movie_segments() const {
  return movie_segments_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::MovieSegmentArchive >*
RecordingMovieTrackArchive::mutable_movie_segments() {
  return &movie_segments_;
}

// -------------------------------------------------------------------

// MovieSegmentArchive

// optional .TSP.DataReference movie_data = 3;
inline bool MovieSegmentArchive::has_movie_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MovieSegmentArchive::set_has_movie_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MovieSegmentArchive::clear_has_movie_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MovieSegmentArchive::clear_movie_data() {
  if (movie_data_ != NULL) movie_data_->::TSP::DataReference::Clear();
  clear_has_movie_data();
}
inline const ::TSP::DataReference& MovieSegmentArchive::movie_data() const {
  return movie_data_ != NULL ? *movie_data_ : *default_instance_->movie_data_;
}
inline ::TSP::DataReference* MovieSegmentArchive::mutable_movie_data() {
  set_has_movie_data();
  if (movie_data_ == NULL) movie_data_ = new ::TSP::DataReference;
  return movie_data_;
}
inline ::TSP::DataReference* MovieSegmentArchive::release_movie_data() {
  clear_has_movie_data();
  ::TSP::DataReference* temp = movie_data_;
  movie_data_ = NULL;
  return temp;
}
inline void MovieSegmentArchive::set_allocated_movie_data(::TSP::DataReference* movie_data) {
  delete movie_data_;
  movie_data_ = movie_data;
  if (movie_data) {
    set_has_movie_data();
  } else {
    clear_has_movie_data();
  }
}

// optional double start_time = 2 [default = -1];
inline bool MovieSegmentArchive::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MovieSegmentArchive::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MovieSegmentArchive::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MovieSegmentArchive::clear_start_time() {
  start_time_ = -1;
  clear_has_start_time();
}
inline double MovieSegmentArchive::start_time() const {
  return start_time_;
}
inline void MovieSegmentArchive::set_start_time(double value) {
  set_has_start_time();
  start_time_ = value;
}

// optional .TSP.Reference database_movie_data = 1;
inline bool MovieSegmentArchive::has_database_movie_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MovieSegmentArchive::set_has_database_movie_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MovieSegmentArchive::clear_has_database_movie_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MovieSegmentArchive::clear_database_movie_data() {
  if (database_movie_data_ != NULL) database_movie_data_->::TSP::Reference::Clear();
  clear_has_database_movie_data();
}
inline const ::TSP::Reference& MovieSegmentArchive::database_movie_data() const {
  return database_movie_data_ != NULL ? *database_movie_data_ : *default_instance_->database_movie_data_;
}
inline ::TSP::Reference* MovieSegmentArchive::mutable_database_movie_data() {
  set_has_database_movie_data();
  if (database_movie_data_ == NULL) database_movie_data_ = new ::TSP::Reference;
  return database_movie_data_;
}
inline ::TSP::Reference* MovieSegmentArchive::release_database_movie_data() {
  clear_has_database_movie_data();
  ::TSP::Reference* temp = database_movie_data_;
  database_movie_data_ = NULL;
  return temp;
}
inline void MovieSegmentArchive::set_allocated_database_movie_data(::TSP::Reference* database_movie_data) {
  delete database_movie_data_;
  database_movie_data_ = database_movie_data;
  if (database_movie_data) {
    set_has_database_movie_data();
  } else {
    clear_has_database_movie_data();
  }
}

// -------------------------------------------------------------------

// Soundtrack

// optional double volume = 1;
inline bool Soundtrack::has_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soundtrack::set_has_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soundtrack::clear_has_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soundtrack::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double Soundtrack::volume() const {
  return volume_;
}
inline void Soundtrack::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// optional .KN.Soundtrack.SoundtrackMode mode = 2 [default = kKNSoundtrackModePlayOnce];
inline bool Soundtrack::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Soundtrack::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Soundtrack::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Soundtrack::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::KN::Soundtrack_SoundtrackMode Soundtrack::mode() const {
  return static_cast< ::KN::Soundtrack_SoundtrackMode >(mode_);
}
inline void Soundtrack::set_mode(::KN::Soundtrack_SoundtrackMode value) {
  assert(::KN::Soundtrack_SoundtrackMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .TSP.DataReference movie_media = 3;
inline int Soundtrack::movie_media_size() const {
  return movie_media_.size();
}
inline void Soundtrack::clear_movie_media() {
  movie_media_.Clear();
}
inline const ::TSP::DataReference& Soundtrack::movie_media(int index) const {
  return movie_media_.Get(index);
}
inline ::TSP::DataReference* Soundtrack::mutable_movie_media(int index) {
  return movie_media_.Mutable(index);
}
inline ::TSP::DataReference* Soundtrack::add_movie_media() {
  return movie_media_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >&
Soundtrack::movie_media() const {
  return movie_media_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::DataReference >*
Soundtrack::mutable_movie_media() {
  return &movie_media_;
}

// -------------------------------------------------------------------

// SlideNumberAttachmentArchive

// required .TSWP.TextualAttachmentArchive super = 1;
inline bool SlideNumberAttachmentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideNumberAttachmentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideNumberAttachmentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideNumberAttachmentArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextualAttachmentArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextualAttachmentArchive& SlideNumberAttachmentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextualAttachmentArchive* SlideNumberAttachmentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextualAttachmentArchive;
  return super_;
}
inline ::TSWP::TextualAttachmentArchive* SlideNumberAttachmentArchive::release_super() {
  clear_has_super();
  ::TSWP::TextualAttachmentArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void SlideNumberAttachmentArchive::set_allocated_super(::TSWP::TextualAttachmentArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// SlideCollectionSelectionArchive_OutlineSelection

// required .TSP.Reference slide_node = 1;
inline bool SlideCollectionSelectionArchive_OutlineSelection::has_slide_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::set_has_slide_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::clear_has_slide_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::clear_slide_node() {
  if (slide_node_ != NULL) slide_node_->::TSP::Reference::Clear();
  clear_has_slide_node();
}
inline const ::TSP::Reference& SlideCollectionSelectionArchive_OutlineSelection::slide_node() const {
  return slide_node_ != NULL ? *slide_node_ : *default_instance_->slide_node_;
}
inline ::TSP::Reference* SlideCollectionSelectionArchive_OutlineSelection::mutable_slide_node() {
  set_has_slide_node();
  if (slide_node_ == NULL) slide_node_ = new ::TSP::Reference;
  return slide_node_;
}
inline ::TSP::Reference* SlideCollectionSelectionArchive_OutlineSelection::release_slide_node() {
  clear_has_slide_node();
  ::TSP::Reference* temp = slide_node_;
  slide_node_ = NULL;
  return temp;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::set_allocated_slide_node(::TSP::Reference* slide_node) {
  delete slide_node_;
  slide_node_ = slide_node;
  if (slide_node) {
    set_has_slide_node();
  } else {
    clear_has_slide_node();
  }
}

// required .TSP.IndexSet selected_paragraph_indexes = 2;
inline bool SlideCollectionSelectionArchive_OutlineSelection::has_selected_paragraph_indexes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::set_has_selected_paragraph_indexes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::clear_has_selected_paragraph_indexes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::clear_selected_paragraph_indexes() {
  if (selected_paragraph_indexes_ != NULL) selected_paragraph_indexes_->::TSP::IndexSet::Clear();
  clear_has_selected_paragraph_indexes();
}
inline const ::TSP::IndexSet& SlideCollectionSelectionArchive_OutlineSelection::selected_paragraph_indexes() const {
  return selected_paragraph_indexes_ != NULL ? *selected_paragraph_indexes_ : *default_instance_->selected_paragraph_indexes_;
}
inline ::TSP::IndexSet* SlideCollectionSelectionArchive_OutlineSelection::mutable_selected_paragraph_indexes() {
  set_has_selected_paragraph_indexes();
  if (selected_paragraph_indexes_ == NULL) selected_paragraph_indexes_ = new ::TSP::IndexSet;
  return selected_paragraph_indexes_;
}
inline ::TSP::IndexSet* SlideCollectionSelectionArchive_OutlineSelection::release_selected_paragraph_indexes() {
  clear_has_selected_paragraph_indexes();
  ::TSP::IndexSet* temp = selected_paragraph_indexes_;
  selected_paragraph_indexes_ = NULL;
  return temp;
}
inline void SlideCollectionSelectionArchive_OutlineSelection::set_allocated_selected_paragraph_indexes(::TSP::IndexSet* selected_paragraph_indexes) {
  delete selected_paragraph_indexes_;
  selected_paragraph_indexes_ = selected_paragraph_indexes;
  if (selected_paragraph_indexes) {
    set_has_selected_paragraph_indexes();
  } else {
    clear_has_selected_paragraph_indexes();
  }
}

// -------------------------------------------------------------------

// SlideCollectionSelectionArchive

// repeated .TSP.Reference slide_nodes = 1;
inline int SlideCollectionSelectionArchive::slide_nodes_size() const {
  return slide_nodes_.size();
}
inline void SlideCollectionSelectionArchive::clear_slide_nodes() {
  slide_nodes_.Clear();
}
inline const ::TSP::Reference& SlideCollectionSelectionArchive::slide_nodes(int index) const {
  return slide_nodes_.Get(index);
}
inline ::TSP::Reference* SlideCollectionSelectionArchive::mutable_slide_nodes(int index) {
  return slide_nodes_.Mutable(index);
}
inline ::TSP::Reference* SlideCollectionSelectionArchive::add_slide_nodes() {
  return slide_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
SlideCollectionSelectionArchive::slide_nodes() const {
  return slide_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
SlideCollectionSelectionArchive::mutable_slide_nodes() {
  return &slide_nodes_;
}

// optional .TSP.Reference slide_node_to_edit = 2;
inline bool SlideCollectionSelectionArchive::has_slide_node_to_edit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlideCollectionSelectionArchive::set_has_slide_node_to_edit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlideCollectionSelectionArchive::clear_has_slide_node_to_edit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlideCollectionSelectionArchive::clear_slide_node_to_edit() {
  if (slide_node_to_edit_ != NULL) slide_node_to_edit_->::TSP::Reference::Clear();
  clear_has_slide_node_to_edit();
}
inline const ::TSP::Reference& SlideCollectionSelectionArchive::slide_node_to_edit() const {
  return slide_node_to_edit_ != NULL ? *slide_node_to_edit_ : *default_instance_->slide_node_to_edit_;
}
inline ::TSP::Reference* SlideCollectionSelectionArchive::mutable_slide_node_to_edit() {
  set_has_slide_node_to_edit();
  if (slide_node_to_edit_ == NULL) slide_node_to_edit_ = new ::TSP::Reference;
  return slide_node_to_edit_;
}
inline ::TSP::Reference* SlideCollectionSelectionArchive::release_slide_node_to_edit() {
  clear_has_slide_node_to_edit();
  ::TSP::Reference* temp = slide_node_to_edit_;
  slide_node_to_edit_ = NULL;
  return temp;
}
inline void SlideCollectionSelectionArchive::set_allocated_slide_node_to_edit(::TSP::Reference* slide_node_to_edit) {
  delete slide_node_to_edit_;
  slide_node_to_edit_ = slide_node_to_edit;
  if (slide_node_to_edit) {
    set_has_slide_node_to_edit();
  } else {
    clear_has_slide_node_to_edit();
  }
}

// repeated .KN.SlideCollectionSelectionArchive.OutlineSelection selected_paragraph_indexes_for_slide_nodes = 3;
inline int SlideCollectionSelectionArchive::selected_paragraph_indexes_for_slide_nodes_size() const {
  return selected_paragraph_indexes_for_slide_nodes_.size();
}
inline void SlideCollectionSelectionArchive::clear_selected_paragraph_indexes_for_slide_nodes() {
  selected_paragraph_indexes_for_slide_nodes_.Clear();
}
inline const ::KN::SlideCollectionSelectionArchive_OutlineSelection& SlideCollectionSelectionArchive::selected_paragraph_indexes_for_slide_nodes(int index) const {
  return selected_paragraph_indexes_for_slide_nodes_.Get(index);
}
inline ::KN::SlideCollectionSelectionArchive_OutlineSelection* SlideCollectionSelectionArchive::mutable_selected_paragraph_indexes_for_slide_nodes(int index) {
  return selected_paragraph_indexes_for_slide_nodes_.Mutable(index);
}
inline ::KN::SlideCollectionSelectionArchive_OutlineSelection* SlideCollectionSelectionArchive::add_selected_paragraph_indexes_for_slide_nodes() {
  return selected_paragraph_indexes_for_slide_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KN::SlideCollectionSelectionArchive_OutlineSelection >&
SlideCollectionSelectionArchive::selected_paragraph_indexes_for_slide_nodes() const {
  return selected_paragraph_indexes_for_slide_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::KN::SlideCollectionSelectionArchive_OutlineSelection >*
SlideCollectionSelectionArchive::mutable_selected_paragraph_indexes_for_slide_nodes() {
  return &selected_paragraph_indexes_for_slide_nodes_;
}

// optional .TSP.Range range_in_selected_paragraph = 4;
inline bool SlideCollectionSelectionArchive::has_range_in_selected_paragraph() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlideCollectionSelectionArchive::set_has_range_in_selected_paragraph() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlideCollectionSelectionArchive::clear_has_range_in_selected_paragraph() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlideCollectionSelectionArchive::clear_range_in_selected_paragraph() {
  if (range_in_selected_paragraph_ != NULL) range_in_selected_paragraph_->::TSP::Range::Clear();
  clear_has_range_in_selected_paragraph();
}
inline const ::TSP::Range& SlideCollectionSelectionArchive::range_in_selected_paragraph() const {
  return range_in_selected_paragraph_ != NULL ? *range_in_selected_paragraph_ : *default_instance_->range_in_selected_paragraph_;
}
inline ::TSP::Range* SlideCollectionSelectionArchive::mutable_range_in_selected_paragraph() {
  set_has_range_in_selected_paragraph();
  if (range_in_selected_paragraph_ == NULL) range_in_selected_paragraph_ = new ::TSP::Range;
  return range_in_selected_paragraph_;
}
inline ::TSP::Range* SlideCollectionSelectionArchive::release_range_in_selected_paragraph() {
  clear_has_range_in_selected_paragraph();
  ::TSP::Range* temp = range_in_selected_paragraph_;
  range_in_selected_paragraph_ = NULL;
  return temp;
}
inline void SlideCollectionSelectionArchive::set_allocated_range_in_selected_paragraph(::TSP::Range* range_in_selected_paragraph) {
  delete range_in_selected_paragraph_;
  range_in_selected_paragraph_ = range_in_selected_paragraph;
  if (range_in_selected_paragraph) {
    set_has_range_in_selected_paragraph();
  } else {
    clear_has_range_in_selected_paragraph();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KN

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType>() {
  return ::KN::TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType>() {
  return ::KN::TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::BuildAttributesArchive_BuildAttributesAcceleration>() {
  return ::KN::BuildAttributesArchive_BuildAttributesAcceleration_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::BuildAttributesArchive_BuildAttributesRotationDirection>() {
  return ::KN::BuildAttributesArchive_BuildAttributesRotationDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::BuildAttributesArchive_BuildAttributesCurveStyle>() {
  return ::KN::BuildAttributesArchive_BuildAttributesCurveStyle_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::BuildAttributesArchive_BuildAttributesTextDelivery>() {
  return ::KN::BuildAttributesArchive_BuildAttributesTextDelivery_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::BuildAttributesArchive_BuildAttributesDeliveryOption>() {
  return ::KN::BuildAttributesArchive_BuildAttributesDeliveryOption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity>() {
  return ::KN::BuildAttributesArchive_ActionBuildAttributesJiggleIntensity_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::PlaceholderArchive_Kind>() {
  return ::KN::PlaceholderArchive_Kind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::DesktopUILayoutArchive_SidebarViewMode>() {
  return ::KN::DesktopUILayoutArchive_SidebarViewMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::DesktopUILayoutArchive_InspectorPaneViewMode>() {
  return ::KN::DesktopUILayoutArchive_InspectorPaneViewMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::ShowArchive_KNShowMode>() {
  return ::KN::ShowArchive_KNShowMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::RecordingArchive_RecordingSyncState>() {
  return ::KN::RecordingArchive_RecordingSyncState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase>() {
  return ::KN::RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::RecordingPauseEventArchive_RecordingPauseEventType>() {
  return ::KN::RecordingPauseEventArchive_RecordingPauseEventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::RecordingMovieEventArchive_RecordingMovieEventType>() {
  return ::KN::RecordingMovieEventArchive_RecordingMovieEventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KN::Soundtrack_SoundtrackMode>() {
  return ::KN::Soundtrack_SoundtrackMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KNArchives_2eproto__INCLUDED
